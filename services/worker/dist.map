{
  "version": 3,
  "sources": ["src/index.ts", "src/job_processor.ts"],
  "sourcesContent": ["import '@dish/helpers/polyfill-node'\n\nimport { Server } from 'http'\n\nimport { createBullBoard } from '@bull-board/api'\nimport { BullAdapter } from '@bull-board/api/bullAdapter'\nimport { ExpressAdapter } from '@bull-board/express'\nimport { sentryException } from '@dish/common'\nimport { getBullQueue } from '@dish/worker'\nimport Bull from 'bull'\nimport express from 'express'\n\nimport { klass_map } from './job_processor'\n\nlet dashboard_server: Server\nconst queues = createQueues()\n\n// for dev it should quit background jobs better\nconst cleanExit = (e: any) => {\n  console.log('exiting cleanly...', e)\n  dashboard_server.close()\n  queues.map(({ queue }) => {\n    queue.close()\n  })\n  console.log('...exiting')\n}\nprocess.on('SIGINT', cleanExit) // catch ctrl-c\nprocess.on('SIGTERM', cleanExit) // catch kill\n\n// this is actually concurrency PER-QUEUE\n// but we have one process per queue by default\n// so its Queues (~8 right now) * Processes (1)\nconst CONCURRENCY = 1\n\ntype Queue = {\n  name: string\n  queue: Bull.Queue<any>\n}\n\nfunction clearJobs(filter?: string[]) {\n  console.log('clearing all jobs')\n  queues\n    .filter((x) => {\n      if (!filter) return true\n      return filter.includes(x.name)\n    })\n    .map((q) => {\n      q.queue.clean(10_000_000_000)\n      q.queue.removeJobs('*')\n      q.queue.empty()\n      q.queue.getActive().then((jobs) => {\n        jobs.map((job) => {\n          job.moveToFailed({ message: 'cancelled' })\n        })\n      })\n    })\n}\n\nasync function main() {\n  console.log('running worker', {\n    queues: queues.map((x) => x.name),\n    CLEAR_JOBS: process.env.CLEAR_JOBS,\n    CONCURRENCY,\n  })\n  if (process.env.CLEAR_JOBS) {\n    clearJobs()\n  }\n  await Promise.all([startDashboard(queues), startQueues(queues)])\n}\n\nfunction startDashboard(queues: Queue[]) {\n  return new Promise<void>((res) => {\n    const serverAdapter = new ExpressAdapter()\n    const bull_dashboard_app = express()\n    createBullBoard({\n      serverAdapter,\n      queues: queues.map((x) => new BullAdapter(x.queue as any)),\n    })\n\n    bull_dashboard_app.post('/clear', (req, res) => {\n      const queueHeader = `${req.headers['queues'] ?? ''}`.trim()\n      if (queueHeader === 'all') {\n        clearJobs()\n      } else {\n        clearJobs(queueHeader.split(','))\n      }\n      res.send(200)\n    })\n    bull_dashboard_app.use('/', serverAdapter.getRouter())\n    dashboard_server = bull_dashboard_app.listen(3434, () => {\n      console.log('listening on', 3434)\n      res()\n    })\n  })\n}\n\nfunction createQueues() {\n  return ['BigJobs', ...Object.keys(klass_map)].map((name) => {\n    const config = klass_map[name]?.queue_config\n    return {\n      name,\n      queue: getBullQueue(name, config),\n    }\n  })\n}\n\nasync function startQueues(queues: Queue[]) {\n  return await Promise.all(\n    queues.map(({ queue, name }) => {\n      const path = __dirname + '/job_processor.js'\n      console.log('startQueue', name, CONCURRENCY, path)\n      queue.process(name, CONCURRENCY, path)\n      console.log('Created Bull worker queue for: ' + name)\n      queue.on('failed', (job, err) => {\n        sentryException(err, {\n          data: job,\n          tags: { crawler: name },\n        })\n      })\n    })\n  )\n}\n\nmain()\n", "// All code that the workers could possibly run needs to be passed to the\n// job processor.\nimport {\n  CI,\n  DoorDash,\n  GoogleImages,\n  GooglePuppeteer,\n  GoogleReviewAPI,\n  GrubHub,\n  Infatuation,\n  Michelin,\n  Self,\n  Tripadvisor,\n  UberEats,\n  Yelp,\n} from '@dish/crawlers'\nimport { WorkerJob } from '@dish/worker'\nimport { Job } from 'bull'\n\n// Processing jobs inside a module takes advantage of sandboxing, which gives\n// the following benefits:\n//   * The process is sandboxed so if it crashes it does not affect the worker.\n//   * You can run blocking code without affecting the queue (jobs will not stall).\n//   * Much better utilization of multi-core CPUs.\n//   * Less connections to redis.\n\nconst all: typeof WorkerJob[] = [\n  UberEats,\n  DoorDash,\n  Yelp,\n  Self,\n  Infatuation,\n  Michelin,\n  Tripadvisor,\n  GooglePuppeteer,\n  GoogleReviewAPI,\n  GoogleImages,\n  GrubHub,\n]\n\nif (process.env.DISH_ENV != 'production') {\n  all.push(CI)\n}\n\nlet klass_map: { [key: string]: typeof WorkerJob } = {}\n\nfor (let klass of all) {\n  klass_map[klass.prototype.constructor.name] = klass\n}\n\nexport { klass_map }\n\nexport default async (job: Job) => {\n  const description = `${job.data.className}.${job.data.fn}(${JSON.stringify(job.data.args)})`\n  console.log(`Processing job (${job.id}, attempt: ${job.attemptsMade}): ${description}`)\n  const worker = new klass_map[job.data.className]()\n  worker.job = job\n  await worker.run(job.data.fn, job.data.args)\n}\n"],
  "mappings": "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",
  "names": []
}
