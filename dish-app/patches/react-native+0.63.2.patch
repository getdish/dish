diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
index d837754..c9045c2 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
@@ -24,21 +24,7 @@ var Scheduler = require("scheduler");
 var tracing = require("scheduler/tracing");
 
 var ReactSharedInternals =
-  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // Prevent newer renderers from RTE when used with older react package versions.
-// Current owner and dispatcher used to share the same ref,
-// but PR #14548 split them out to better support the react-debug-tools package.
-
-if (!ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher")) {
-  ReactSharedInternals.ReactCurrentDispatcher = {
-    current: null
-  };
-}
-
-if (!ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig")) {
-  ReactSharedInternals.ReactCurrentBatchConfig = {
-    suspense: null
-  };
-}
+  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
 
 // by calls to these methods by a Babel plugin.
 //
@@ -80,19 +66,12 @@ function printWarning(level, format, args) {
   // When changing this logic, you might want to also
   // update consoleWithStackDev.www.js as well.
   {
-    var hasExistingStack =
-      args.length > 0 &&
-      typeof args[args.length - 1] === "string" &&
-      args[args.length - 1].indexOf("\n    in") === 0;
+    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+    var stack = ReactDebugCurrentFrame.getStackAddendum();
 
-    if (!hasExistingStack) {
-      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
-      var stack = ReactDebugCurrentFrame.getStackAddendum();
-
-      if (stack !== "") {
-        format += "%s";
-        args = args.concat([stack]);
-      }
+    if (stack !== "") {
+      format += "%s";
+      args = args.concat([stack]);
     }
 
     var argsWithFormat = args.map(function(item) {
@@ -104,161 +83,10 @@ function printWarning(level, format, args) {
     // eslint-disable-next-line react-internal/no-production-logging
 
     Function.prototype.apply.call(console[level], console, argsWithFormat);
-
-    try {
-      // --- Welcome to debugging React ---
-      // This error was thrown as a convenience so that you can use this stack
-      // to find the callsite that caused this warning to fire.
-      var argIndex = 0;
-      var message =
-        "Warning: " +
-        format.replace(/%s/g, function() {
-          return args[argIndex++];
-        });
-      throw new Error(message);
-    } catch (x) {}
-  }
-}
-
-var FunctionComponent = 0;
-var ClassComponent = 1;
-var IndeterminateComponent = 2; // Before we know whether it is function or class
-
-var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
-
-var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
-
-var HostComponent = 5;
-var HostText = 6;
-var Fragment = 7;
-var Mode = 8;
-var ContextConsumer = 9;
-var ContextProvider = 10;
-var ForwardRef = 11;
-var Profiler = 12;
-var SuspenseComponent = 13;
-var MemoComponent = 14;
-var SimpleMemoComponent = 15;
-var LazyComponent = 16;
-var IncompleteClassComponent = 17;
-var DehydratedFragment = 18;
-var SuspenseListComponent = 19;
-var FundamentalComponent = 20;
-var ScopeComponent = 21;
-var Block = 22;
-
-function getParent(inst) {
-  do {
-    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
-    // That is depending on if we want nested subtrees (layers) to bubble
-    // events to their parent. We could also go through parentNode on the
-    // host node but that wouldn't work for React Native and doesn't let us
-    // do the portal feature.
-  } while (inst && inst.tag !== HostComponent);
-
-  if (inst) {
-    return inst;
-  }
-
-  return null;
-}
-/**
- * Return the lowest common ancestor of A and B, or null if they are in
- * different trees.
- */
-
-function getLowestCommonAncestor(instA, instB) {
-  var depthA = 0;
-
-  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
-    depthA++;
-  }
-
-  var depthB = 0;
-
-  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
-    depthB++;
-  } // If A is deeper, crawl up.
-
-  while (depthA - depthB > 0) {
-    instA = getParent(instA);
-    depthA--;
-  } // If B is deeper, crawl up.
-
-  while (depthB - depthA > 0) {
-    instB = getParent(instB);
-    depthB--;
-  } // Walk in lockstep until we find a match.
-
-  var depth = depthA;
-
-  while (depth--) {
-    if (instA === instB || instA === instB.alternate) {
-      return instA;
-    }
-
-    instA = getParent(instA);
-    instB = getParent(instB);
-  }
-
-  return null;
-}
-/**
- * Return if A is an ancestor of B.
- */
-
-function isAncestor(instA, instB) {
-  while (instB) {
-    if (instA === instB || instA === instB.alternate) {
-      return true;
-    }
-
-    instB = getParent(instB);
-  }
-
-  return false;
-}
-/**
- * Return the parent instance of the passed-in instance.
- */
-
-function getParentInstance(inst) {
-  return getParent(inst);
-}
-/**
- * Simulates the traversal of a two-phase, capture/bubble event dispatch.
- */
-
-function traverseTwoPhase(inst, fn, arg) {
-  var path = [];
-
-  while (inst) {
-    path.push(inst);
-    inst = getParent(inst);
-  }
-
-  var i;
-
-  for (i = path.length; i-- > 0; ) {
-    fn(path[i], "captured", arg);
-  }
-
-  for (i = 0; i < path.length; i++) {
-    fn(path[i], "bubbled", arg);
   }
 }
 
-var invokeGuardedCallbackImpl = function(
-  name,
-  func,
-  context,
-  a,
-  b,
-  c,
-  d,
-  e,
-  f
-) {
+function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
   var funcArgs = Array.prototype.slice.call(arguments, 3);
 
   try {
@@ -266,7 +94,9 @@ var invokeGuardedCallbackImpl = function(
   } catch (error) {
     this.onError(error);
   }
-};
+}
+
+var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
 
 {
   // In DEV mode, we swap out invokeGuardedCallback for a special version
@@ -297,7 +127,7 @@ var invokeGuardedCallbackImpl = function(
   ) {
     var fakeNode = document.createElement("react");
 
-    var invokeGuardedCallbackDev = function(
+    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(
       name,
       func,
       context,
@@ -310,7 +140,7 @@ var invokeGuardedCallbackImpl = function(
     ) {
       // If document doesn't exist we know for sure we will crash in this method
       // when we call document.createEvent(). However this can cause confusing
-      // errors: https://github.com/facebookincubator/create-react-app/issues/3482
+      // errors: https://github.com/facebook/create-react-app/issues/3482
       // So we preemptively throw with a better message instead.
       if (!(typeof document !== "undefined")) {
         throw Error(
@@ -318,7 +148,8 @@ var invokeGuardedCallbackImpl = function(
         );
       }
 
-      var evt = document.createEvent("Event"); // Keeps track of whether the user-provided callback threw an error. We
+      var evt = document.createEvent("Event");
+      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
       // set this to true at the beginning, then set it to false right after
       // calling the function. If the function errors, `didError` will never be
       // set to false. This strategy works even if the browser is flaky and
@@ -335,13 +166,9 @@ var invokeGuardedCallbackImpl = function(
       var windowEventDescriptor = Object.getOwnPropertyDescriptor(
         window,
         "event"
-      ); // Create an event handler for our fake event. We will synchronously
-      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
-      // call the user-provided callback.
-
-      var funcArgs = Array.prototype.slice.call(arguments, 3);
+      );
 
-      function callCallback() {
+      function restoreAfterDispatch() {
         // We immediately remove the callback from event listeners so that
         // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
         // nested call would trigger the fake event handlers of any call higher
@@ -357,7 +184,15 @@ var invokeGuardedCallbackImpl = function(
         ) {
           window.event = windowEvent;
         }
+      } // Create an event handler for our fake event. We will synchronously
+      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
+      // call the user-provided callback.
 
+      var funcArgs = Array.prototype.slice.call(arguments, 3);
+
+      function callCallback() {
+        didCall = true;
+        restoreAfterDispatch();
         func.apply(context, funcArgs);
         didError = false;
       } // Create a global error event handler. We use this to capture the value
@@ -412,7 +247,7 @@ var invokeGuardedCallbackImpl = function(
         Object.defineProperty(window, "event", windowEventDescriptor);
       }
 
-      if (didError) {
+      if (didCall && didError) {
         if (!didSetError) {
           // The callback errored, but the error event never fired.
           error = new Error(
@@ -429,7 +264,7 @@ var invokeGuardedCallbackImpl = function(
           error = new Error(
             "A cross-origin error was thrown. React doesn't have access to " +
               "the actual error object in development. " +
-              "See https://fb.me/react-crossorigin-error for more information."
+              "See https://reactjs.org/link/crossorigin-error for more information."
           );
         }
 
@@ -437,9 +272,16 @@ var invokeGuardedCallbackImpl = function(
       } // Remove our event listeners
 
       window.removeEventListener("error", handleWindowError);
-    };
 
-    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
+      if (!didCall) {
+        // Something went really wrong, and our event was not dispatched.
+        // https://github.com/facebook/react/issues/16734
+        // https://github.com/facebook/react/issues/16585
+        // Fall back to the production implementation.
+        restoreAfterDispatch();
+        return invokeGuardedCallbackProd.apply(this, arguments);
+      }
+    };
   }
 }
 
@@ -708,293 +550,53 @@ function hasDispatches(event) {
   return !!event._dispatchListeners;
 }
 
-function isInteractive(tag) {
-  return (
-    tag === "button" ||
-    tag === "input" ||
-    tag === "select" ||
-    tag === "textarea"
-  );
-}
-
-function shouldPreventMouseEvent(name, type, props) {
-  switch (name) {
-    case "onClick":
-    case "onClickCapture":
-    case "onDoubleClick":
-    case "onDoubleClickCapture":
-    case "onMouseDown":
-    case "onMouseDownCapture":
-    case "onMouseMove":
-    case "onMouseMoveCapture":
-    case "onMouseUp":
-    case "onMouseUpCapture":
-    case "onMouseEnter":
-      return !!(props.disabled && isInteractive(type));
-
-    default:
-      return false;
-  }
-}
+var EVENT_POOL_SIZE = 10;
 /**
- * @param {object} inst The instance, which is the source of events.
- * @param {string} registrationName Name of listener (e.g. `onClick`).
- * @return {?function} The stored callback.
+ * @interface Event
+ * @see http://www.w3.org/TR/DOM-Level-3-Events/
  */
 
-function getListener(inst, registrationName) {
-  var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
-  // live here; needs to be moved to a better place soon
-
-  var stateNode = inst.stateNode;
-
-  if (!stateNode) {
-    // Work in progress (ex: onload events in incremental mode).
-    return null;
-  }
-
-  var props = getFiberCurrentPropsFromNode(stateNode);
-
-  if (!props) {
-    // Work in progress.
-    return null;
-  }
-
-  listener = props[registrationName];
-
-  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
+var EventInterface = {
+  type: null,
+  target: null,
+  // currentTarget is set when dispatching; no use in copying it here
+  currentTarget: function() {
     return null;
-  }
-
-  if (!(!listener || typeof listener === "function")) {
-    throw Error(
-      "Expected `" +
-        registrationName +
-        "` listener to be a function, instead got a value of `" +
-        typeof listener +
-        "` type."
-    );
-  }
+  },
+  eventPhase: null,
+  bubbles: null,
+  cancelable: null,
+  timeStamp: function(event) {
+    return event.timeStamp || Date.now();
+  },
+  defaultPrevented: null,
+  isTrusted: null
+};
 
-  return listener;
+function functionThatReturnsTrue() {
+  return true;
 }
 
+function functionThatReturnsFalse() {
+  return false;
+}
 /**
- * Accumulates items that must not be null or undefined into the first one. This
- * is used to conserve memory by avoiding array allocations, and thus sacrifices
- * API cleanness. Since `current` can be null before being passed in and not
- * null after this function, make sure to assign it back to `current`:
+ * Synthetic events are dispatched by event plugins, typically in response to a
+ * top-level event delegation handler.
  *
- * `a = accumulateInto(a, b);`
+ * These systems should generally use pooling to reduce the frequency of garbage
+ * collection. The system should check `isPersistent` to determine whether the
+ * event should be released into the pool after being dispatched. Users that
+ * need a persisted event should invoke `persist`.
  *
- * This API should be sparingly used. Try `accumulate` for something cleaner.
+ * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
+ * normalizing browser quirks. Subclasses do not necessarily have to implement a
+ * DOM interface; custom application-specific events can also subclass this.
  *
- * @return {*|array<*>} An accumulation of items.
- */
-
-function accumulateInto(current, next) {
-  if (!(next != null)) {
-    throw Error(
-      "accumulateInto(...): Accumulated items must not be null or undefined."
-    );
-  }
-
-  if (current == null) {
-    return next;
-  } // Both are not empty. Warning: Never call x.concat(y) when you are not
-  // certain that x is an Array (x could be a string with concat method).
-
-  if (Array.isArray(current)) {
-    if (Array.isArray(next)) {
-      current.push.apply(current, next);
-      return current;
-    }
-
-    current.push(next);
-    return current;
-  }
-
-  if (Array.isArray(next)) {
-    // A bit too dangerous to mutate `next`.
-    return [current].concat(next);
-  }
-
-  return [current, next];
-}
-
-/**
- * @param {array} arr an "accumulation" of items which is either an Array or
- * a single item. Useful when paired with the `accumulate` module. This is a
- * simple utility that allows us to reason about a collection of items, but
- * handling the case when there is exactly one item (and we do not need to
- * allocate an array).
- * @param {function} cb Callback invoked with each element or a collection.
- * @param {?} [scope] Scope used as `this` in a callback.
- */
-function forEachAccumulated(arr, cb, scope) {
-  if (Array.isArray(arr)) {
-    arr.forEach(cb, scope);
-  } else if (arr) {
-    cb.call(scope, arr);
-  }
-}
-
-/**
- * Some event types have a notion of different registration names for different
- * "phases" of propagation. This finds listeners by a given phase.
- */
-function listenerAtPhase(inst, event, propagationPhase) {
-  var registrationName =
-    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
-  return getListener(inst, registrationName);
-}
-/**
- * A small set of propagation patterns, each of which will accept a small amount
- * of information, and generate a set of "dispatch ready event objects" - which
- * are sets of events that have already been annotated with a set of dispatched
- * listener functions/ids. The API is designed this way to discourage these
- * propagation strategies from actually executing the dispatches, since we
- * always want to collect the entire set of dispatches before executing even a
- * single one.
- */
-
-/**
- * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
- * here, allows us to not have to bind or create functions for each event.
- * Mutating the event's members allows us to not have to create a wrapping
- * "dispatch" object that pairs the event with the listener.
- */
-
-function accumulateDirectionalDispatches(inst, phase, event) {
-  {
-    if (!inst) {
-      error("Dispatching inst must not be null");
-    }
-  }
-
-  var listener = listenerAtPhase(inst, event, phase);
-
-  if (listener) {
-    event._dispatchListeners = accumulateInto(
-      event._dispatchListeners,
-      listener
-    );
-    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
-  }
-}
-/**
- * Collect dispatches (must be entirely collected before dispatching - see unit
- * tests). Lazily allocate the array to conserve memory.  We must loop through
- * each event and perform the traversal for each one. We cannot perform a
- * single traversal for the entire collection of events because each event may
- * have a different target.
- */
-
-function accumulateTwoPhaseDispatchesSingle(event) {
-  if (event && event.dispatchConfig.phasedRegistrationNames) {
-    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
-  }
-}
-/**
- * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
- */
-
-function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
-  if (event && event.dispatchConfig.phasedRegistrationNames) {
-    var targetInst = event._targetInst;
-    var parentInst = targetInst ? getParentInstance(targetInst) : null;
-    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
-  }
-}
-/**
- * Accumulates without regard to direction, does not look for phased
- * registration names. Same as `accumulateDirectDispatchesSingle` but without
- * requiring that the `dispatchMarker` be the same as the dispatched ID.
- */
-
-function accumulateDispatches(inst, ignoredDirection, event) {
-  if (inst && event && event.dispatchConfig.registrationName) {
-    var registrationName = event.dispatchConfig.registrationName;
-    var listener = getListener(inst, registrationName);
-
-    if (listener) {
-      event._dispatchListeners = accumulateInto(
-        event._dispatchListeners,
-        listener
-      );
-      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
-    }
-  }
-}
-/**
- * Accumulates dispatches on an `SyntheticEvent`, but only for the
- * `dispatchMarker`.
- * @param {SyntheticEvent} event
- */
-
-function accumulateDirectDispatchesSingle(event) {
-  if (event && event.dispatchConfig.registrationName) {
-    accumulateDispatches(event._targetInst, null, event);
-  }
-}
-
-function accumulateTwoPhaseDispatches(events) {
-  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
-}
-function accumulateTwoPhaseDispatchesSkipTarget(events) {
-  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
-}
-function accumulateDirectDispatches(events) {
-  forEachAccumulated(events, accumulateDirectDispatchesSingle);
-}
-
-var EVENT_POOL_SIZE = 10;
-/**
- * @interface Event
- * @see http://www.w3.org/TR/DOM-Level-3-Events/
- */
-
-var EventInterface = {
-  type: null,
-  target: null,
-  // currentTarget is set when dispatching; no use in copying it here
-  currentTarget: function() {
-    return null;
-  },
-  eventPhase: null,
-  bubbles: null,
-  cancelable: null,
-  timeStamp: function(event) {
-    return event.timeStamp || Date.now();
-  },
-  defaultPrevented: null,
-  isTrusted: null
-};
-
-function functionThatReturnsTrue() {
-  return true;
-}
-
-function functionThatReturnsFalse() {
-  return false;
-}
-/**
- * Synthetic events are dispatched by event plugins, typically in response to a
- * top-level event delegation handler.
- *
- * These systems should generally use pooling to reduce the frequency of garbage
- * collection. The system should check `isPersistent` to determine whether the
- * event should be released into the pool after being dispatched. Users that
- * need a persisted event should invoke `persist`.
- *
- * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
- * normalizing browser quirks. Subclasses do not necessarily have to implement a
- * DOM interface; custom application-specific events can also subclass this.
- *
- * @param {object} dispatchConfig Configuration used to dispatch this event.
- * @param {*} targetInst Marker identifying the event target.
- * @param {object} nativeEvent Native browser event.
- * @param {DOMEventTarget} nativeEventTarget Target node.
+ * @param {object} dispatchConfig Configuration used to dispatch this event.
+ * @param {*} targetInst Marker identifying the event target.
+ * @param {object} nativeEvent Native browser event.
+ * @param {DOMEventTarget} nativeEventTarget Target node.
  */
 
 function SyntheticEvent(
@@ -1015,6 +617,8 @@ function SyntheticEvent(
   this.dispatchConfig = dispatchConfig;
   this._targetInst = targetInst;
   this.nativeEvent = nativeEvent;
+  this._dispatchListeners = null;
+  this._dispatchInstances = null;
   var Interface = this.constructor.Interface;
 
   for (var propName in Interface) {
@@ -1203,13 +807,6 @@ addEventPoolingTo(SyntheticEvent);
  */
 
 function getPooledWarningPropertyDefinition(propName, getVal) {
-  var isFunction = typeof getVal === "function";
-  return {
-    configurable: true,
-    set: set,
-    get: get
-  };
-
   function set(val) {
     var action = isFunction ? "setting the method" : "setting the property";
     warn(action, "This is effectively a no-op");
@@ -1231,16 +828,28 @@ function getPooledWarningPropertyDefinition(propName, getVal) {
         "This synthetic event is reused for performance reasons. If you're seeing this, " +
           "you're %s `%s` on a released/nullified synthetic event. %s. " +
           "If you must keep the original synthetic event around, use event.persist(). " +
-          "See https://fb.me/react-event-pooling for more information.",
+          "See https://reactjs.org/link/event-pooling for more information.",
         action,
         propName,
         result
       );
     }
   }
+
+  var isFunction = typeof getVal === "function";
+  return {
+    configurable: true,
+    set: set,
+    get: get
+  };
 }
 
-function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
+function createOrGetPooledEvent(
+  dispatchConfig,
+  targetInst,
+  nativeEvent,
+  nativeInst
+) {
   var EventConstructor = this;
 
   if (EventConstructor.eventPool.length) {
@@ -1280,8 +889,8 @@ function releasePooledEvent(event) {
 }
 
 function addEventPoolingTo(EventConstructor) {
+  EventConstructor.getPooled = createOrGetPooledEvent;
   EventConstructor.eventPool = [];
-  EventConstructor.getPooled = getPooledEvent;
   EventConstructor.release = releasePooledEvent;
 }
 
@@ -1547,51 +1156,139 @@ function accumulate(current, next) {
 }
 
 /**
- * Instance of element that should respond to touch/move types of interactions,
- * as indicated explicitly by relevant callbacks.
+ * Accumulates items that must not be null or undefined into the first one. This
+ * is used to conserve memory by avoiding array allocations, and thus sacrifices
+ * API cleanness. Since `current` can be null before being passed in and not
+ * null after this function, make sure to assign it back to `current`:
+ *
+ * `a = accumulateInto(a, b);`
+ *
+ * This API should be sparingly used. Try `accumulate` for something cleaner.
+ *
+ * @return {*|array<*>} An accumulation of items.
  */
 
-var responderInst = null;
-/**
- * Count of current touches. A textInput should become responder iff the
- * selection changes while there is a touch on the screen.
- */
+function accumulateInto(current, next) {
+  if (!(next != null)) {
+    throw Error(
+      "accumulateInto(...): Accumulated items must not be null or undefined."
+    );
+  }
 
-var trackedTouchCount = 0;
+  if (current == null) {
+    return next;
+  } // Both are not empty. Warning: Never call x.concat(y) when you are not
+  // certain that x is an Array (x could be a string with concat method).
 
-var changeResponder = function(nextResponderInst, blockHostResponder) {
-  var oldResponderInst = responderInst;
-  responderInst = nextResponderInst;
+  if (Array.isArray(current)) {
+    if (Array.isArray(next)) {
+      current.push.apply(current, next);
+      return current;
+    }
 
-  if (ResponderEventPlugin.GlobalResponderHandler !== null) {
-    ResponderEventPlugin.GlobalResponderHandler.onChange(
-      oldResponderInst,
-      nextResponderInst,
-      blockHostResponder
-    );
+    current.push(next);
+    return current;
   }
-};
 
-var eventTypes = {
-  /**
-   * On a `touchStart`/`mouseDown`, is it desired that this element become the
-   * responder?
-   */
-  startShouldSetResponder: {
-    phasedRegistrationNames: {
-      bubbled: "onStartShouldSetResponder",
-      captured: "onStartShouldSetResponderCapture"
-    },
-    dependencies: startDependencies
-  },
+  if (Array.isArray(next)) {
+    // A bit too dangerous to mutate `next`.
+    return [current].concat(next);
+  }
 
-  /**
-   * On a `scroll`, is it desired that this element become the responder? This
-   * is usually not needed, but should be used to retroactively infer that a
-   * `touchStart` had occurred during momentum scroll. During a momentum scroll,
-   * a touch start will be immediately followed by a scroll event if the view is
-   * currently scrolling.
-   *
+  return [current, next];
+}
+
+/**
+ * @param {array} arr an "accumulation" of items which is either an Array or
+ * a single item. Useful when paired with the `accumulate` module. This is a
+ * simple utility that allows us to reason about a collection of items, but
+ * handling the case when there is exactly one item (and we do not need to
+ * allocate an array).
+ * @param {function} cb Callback invoked with each element or a collection.
+ * @param {?} [scope] Scope used as `this` in a callback.
+ */
+function forEachAccumulated(arr, cb, scope) {
+  if (Array.isArray(arr)) {
+    arr.forEach(cb, scope);
+  } else if (arr) {
+    cb.call(scope, arr);
+  }
+}
+
+var FunctionComponent = 0;
+var ClassComponent = 1;
+var IndeterminateComponent = 2; // Before we know whether it is function or class
+
+var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
+
+var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
+
+var HostComponent = 5;
+var HostText = 6;
+var Fragment = 7;
+var Mode = 8;
+var ContextConsumer = 9;
+var ContextProvider = 10;
+var ForwardRef = 11;
+var Profiler = 12;
+var SuspenseComponent = 13;
+var MemoComponent = 14;
+var SimpleMemoComponent = 15;
+var LazyComponent = 16;
+var IncompleteClassComponent = 17;
+var DehydratedFragment = 18;
+var SuspenseListComponent = 19;
+var FundamentalComponent = 20;
+var ScopeComponent = 21;
+var OffscreenComponent = 22;
+var LegacyHiddenComponent = 23;
+
+/**
+ * Instance of element that should respond to touch/move types of interactions,
+ * as indicated explicitly by relevant callbacks.
+ */
+
+var responderInst = null;
+/**
+ * Count of current touches. A textInput should become responder iff the
+ * selection changes while there is a touch on the screen.
+ */
+
+var trackedTouchCount = 0;
+
+var changeResponder = function(nextResponderInst, blockHostResponder) {
+  var oldResponderInst = responderInst;
+  responderInst = nextResponderInst;
+
+  if (ResponderEventPlugin.GlobalResponderHandler !== null) {
+    ResponderEventPlugin.GlobalResponderHandler.onChange(
+      oldResponderInst,
+      nextResponderInst,
+      blockHostResponder
+    );
+  }
+};
+
+var eventTypes = {
+  /**
+   * On a `touchStart`/`mouseDown`, is it desired that this element become the
+   * responder?
+   */
+  startShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onStartShouldSetResponder",
+      captured: "onStartShouldSetResponderCapture"
+    },
+    dependencies: startDependencies
+  },
+
+  /**
+   * On a `scroll`, is it desired that this element become the responder? This
+   * is usually not needed, but should be used to retroactively infer that a
+   * `touchStart` had occurred during momentum scroll. During a momentum scroll,
+   * a touch start will be immediately followed by a scroll event if the view is
+   * currently scrolling.
+   *
    * TODO: This shouldn't bubble.
    */
   scrollShouldSetResponder: {
@@ -1664,610 +1361,818 @@ var eventTypes = {
     registrationName: "onResponderTerminate",
     dependencies: []
   }
-};
+}; // Start of inline: the below functions were inlined from
+// EventPropagator.js, as they deviated from ReactDOM's newer
+// implementations.
+
+function getParent(inst) {
+  do {
+    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
+    // That is depending on if we want nested subtrees (layers) to bubble
+    // events to their parent. We could also go through parentNode on the
+    // host node but that wouldn't work for React Native and doesn't let us
+    // do the portal feature.
+  } while (inst && inst.tag !== HostComponent);
+
+  if (inst) {
+    return inst;
+  }
+
+  return null;
+}
 /**
- *
- * Responder System:
- * ----------------
- *
- * - A global, solitary "interaction lock" on a view.
- * - If a node becomes the responder, it should convey visual feedback
- *   immediately to indicate so, either by highlighting or moving accordingly.
- * - To be the responder means, that touches are exclusively important to that
- *   responder view, and no other view.
- * - While touches are still occurring, the responder lock can be transferred to
- *   a new view, but only to increasingly "higher" views (meaning ancestors of
- *   the current responder).
- *
- * Responder being granted:
- * ------------------------
- *
- * - Touch starts, moves, and scrolls can cause an ID to become the responder.
- * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to
- *   the "appropriate place".
- * - If nothing is currently the responder, the "appropriate place" is the
- *   initiating event's `targetID`.
- * - If something *is* already the responder, the "appropriate place" is the
- *   first common ancestor of the event target and the current `responderInst`.
- * - Some negotiation happens: See the timing diagram below.
- * - Scrolled views automatically become responder. The reasoning is that a
- *   platform scroll view that isn't built on top of the responder system has
- *   began scrolling, and the active responder must now be notified that the
- *   interaction is no longer locked to it - the system has taken over.
- *
- * - Responder being released:
- *   As soon as no more touches that *started* inside of descendants of the
- *   *current* responderInst, an `onResponderRelease` event is dispatched to the
- *   current responder, and the responder lock is released.
- *
- * TODO:
- * - on "end", a callback hook for `onResponderEndShouldRemainResponder` that
- *   determines if the responder lock should remain.
- * - If a view shouldn't "remain" the responder, any active touches should by
- *   default be considered "dead" and do not influence future negotiations or
- *   bubble paths. It should be as if those touches do not exist.
- * -- For multitouch: Usually a translate-z will choose to "remain" responder
- *  after one out of many touches ended. For translate-y, usually the view
- *  doesn't wish to "remain" responder after one of many touches end.
- * - Consider building this on top of a `stopPropagation` model similar to
- *   `W3C` events.
- * - Ensure that `onResponderTerminate` is called on touch cancels, whether or
- *   not `onResponderTerminationRequest` returns `true` or `false`.
- *
+ * Return the lowest common ancestor of A and B, or null if they are in
+ * different trees.
  */
 
-/*                                             Negotiation Performed
-                                             +-----------------------+
-                                            /                         \
-Process low level events to    +     Current Responder      +   wantsResponderID
-determine who to perform negot-|   (if any exists at all)   |
-iation/transition              | Otherwise just pass through|
--------------------------------+----------------------------+------------------+
-Bubble to find first ID        |                            |
-to return true:wantsResponderID|                            |
-                               |                            |
-     +-------------+           |                            |
-     | onTouchStart|           |                            |
-     +------+------+     none  |                            |
-            |            return|                            |
-+-----------v-------------+true| +------------------------+ |
-|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+
-+-----------+-------------+    | +------------------------+ |          |
-            |                  |                            | +--------+-------+
-            | returned true for|       false:REJECT +-------->|onResponderReject
-            | wantsResponderID |                    |       | +----------------+
-            | (now attempt     | +------------------+-----+ |
-            |  handoff)        | |   onResponder          | |
-            +------------------->|      TerminationRequest| |
-                               | +------------------+-----+ |
-                               |                    |       | +----------------+
-                               |         true:GRANT +-------->|onResponderGrant|
-                               |                            | +--------+-------+
-                               | +------------------------+ |          |
-                               | |   onResponderTerminate |<-----------+
-                               | +------------------+-----+ |
-                               |                    |       | +----------------+
-                               |                    +-------->|onResponderStart|
-                               |                            | +----------------+
-Bubble to find first ID        |                            |
-to return true:wantsResponderID|                            |
-                               |                            |
-     +-------------+           |                            |
-     | onTouchMove |           |                            |
-     +------+------+     none  |                            |
-            |            return|                            |
-+-----------v-------------+true| +------------------------+ |
-|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+
-+-----------+-------------+    | +------------------------+ |          |
-            |                  |                            | +--------+-------+
-            | returned true for|       false:REJECT +-------->|onResponderRejec|
-            | wantsResponderID |                    |       | +----------------+
-            | (now attempt     | +------------------+-----+ |
-            |  handoff)        | |   onResponder          | |
-            +------------------->|      TerminationRequest| |
-                               | +------------------+-----+ |
-                               |                    |       | +----------------+
-                               |         true:GRANT +-------->|onResponderGrant|
-                               |                            | +--------+-------+
-                               | +------------------------+ |          |
-                               | |   onResponderTerminate |<-----------+
-                               | +------------------+-----+ |
-                               |                    |       | +----------------+
-                               |                    +-------->|onResponderMove |
-                               |                            | +----------------+
-                               |                            |
-                               |                            |
-      Some active touch started|                            |
-      inside current responder | +------------------------+ |
-      +------------------------->|      onResponderEnd    | |
-      |                        | +------------------------+ |
-  +---+---------+              |                            |
-  | onTouchEnd  |              |                            |
-  +---+---------+              |                            |
-      |                        | +------------------------+ |
-      +------------------------->|     onResponderEnd     | |
-      No active touches started| +-----------+------------+ |
-      inside current responder |             |              |
-                               |             v              |
-                               | +------------------------+ |
-                               | |    onResponderRelease  | |
-                               | +------------------------+ |
-                               |                            |
-                               +                            + */
+function getLowestCommonAncestor(instA, instB) {
+  var depthA = 0;
 
-/**
- * A note about event ordering in the `EventPluginRegistry`.
- *
- * Suppose plugins are injected in the following order:
- *
- * `[R, S, C]`
- *
- * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for
- * `onClick` etc) and `R` is `ResponderEventPlugin`.
- *
- * "Deferred-Dispatched Events":
- *
- * - The current event plugin system will traverse the list of injected plugins,
- *   in order, and extract events by collecting the plugin's return value of
- *   `extractEvents()`.
- * - These events that are returned from `extractEvents` are "deferred
- *   dispatched events".
- * - When returned from `extractEvents`, deferred-dispatched events contain an
- *   "accumulation" of deferred dispatches.
- * - These deferred dispatches are accumulated/collected before they are
- *   returned, but processed at a later time by the `EventPluginRegistry` (hence the
- *   name deferred).
- *
- * In the process of returning their deferred-dispatched events, event plugins
- * themselves can dispatch events on-demand without returning them from
- * `extractEvents`. Plugins might want to do this, so that they can use event
- * dispatching as a tool that helps them decide which events should be extracted
- * in the first place.
- *
- * "On-Demand-Dispatched Events":
- *
- * - On-demand-dispatched events are not returned from `extractEvents`.
- * - On-demand-dispatched events are dispatched during the process of returning
- *   the deferred-dispatched events.
- * - They should not have side effects.
- * - They should be avoided, and/or eventually be replaced with another
- *   abstraction that allows event plugins to perform multiple "rounds" of event
- *   extraction.
- *
- * Therefore, the sequence of event dispatches becomes:
- *
- * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)
- * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)
- * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)
- * - `R`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
- * - `S`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
- * - `C`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
- *
- * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`
- * on-demand dispatch returns `true` (and some other details are satisfied) the
- * `onResponderGrant` deferred dispatched event is returned from
- * `extractEvents`. The sequence of dispatch executions in this case
- * will appear as follows:
- *
- * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)
- * - `touchStartCapture`       (`EventPluginRegistry` dispatches as usual)
- * - `touchStart`              (`EventPluginRegistry` dispatches as usual)
- * - `responderGrant/Reject`   (`EventPluginRegistry` dispatches as usual)
- */
-
-function setResponderAndExtractTransfer(
-  topLevelType,
-  targetInst,
-  nativeEvent,
-  nativeEventTarget
-) {
-  var shouldSetEventType = isStartish(topLevelType)
-    ? eventTypes.startShouldSetResponder
-    : isMoveish(topLevelType)
-    ? eventTypes.moveShouldSetResponder
-    : topLevelType === TOP_SELECTION_CHANGE
-    ? eventTypes.selectionChangeShouldSetResponder
-    : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.
-
-  var bubbleShouldSetFrom = !responderInst
-    ? targetInst
-    : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the "shouldSet" event, we want to skip the target
-  // (deepest ID) if it happens to be the current responder. The reasoning:
-  // It's strange to get an `onMoveShouldSetResponder` when you're *already*
-  // the responder.
-
-  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
-  var shouldSetEvent = ResponderSyntheticEvent.getPooled(
-    shouldSetEventType,
-    bubbleShouldSetFrom,
-    nativeEvent,
-    nativeEventTarget
-  );
-  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
-
-  if (skipOverBubbleShouldSetFrom) {
-    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
-  } else {
-    accumulateTwoPhaseDispatches(shouldSetEvent);
+  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
+    depthA++;
   }
 
-  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
+  var depthB = 0;
 
-  if (!shouldSetEvent.isPersistent()) {
-    shouldSetEvent.constructor.release(shouldSetEvent);
-  }
+  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
+    depthB++;
+  } // If A is deeper, crawl up.
 
-  if (!wantsResponderInst || wantsResponderInst === responderInst) {
-    return null;
-  }
+  while (depthA - depthB > 0) {
+    instA = getParent(instA);
+    depthA--;
+  } // If B is deeper, crawl up.
 
-  var extracted;
-  var grantEvent = ResponderSyntheticEvent.getPooled(
-    eventTypes.responderGrant,
-    wantsResponderInst,
-    nativeEvent,
-    nativeEventTarget
-  );
-  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
-  accumulateDirectDispatches(grantEvent);
-  var blockHostResponder = executeDirectDispatch(grantEvent) === true;
+  while (depthB - depthA > 0) {
+    instB = getParent(instB);
+    depthB--;
+  } // Walk in lockstep until we find a match.
 
-  if (responderInst) {
-    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(
-      eventTypes.responderTerminationRequest,
-      responderInst,
-      nativeEvent,
-      nativeEventTarget
-    );
-    terminationRequestEvent.touchHistory =
-      ResponderTouchHistoryStore.touchHistory;
-    accumulateDirectDispatches(terminationRequestEvent);
-    var shouldSwitch =
-      !hasDispatches(terminationRequestEvent) ||
-      executeDirectDispatch(terminationRequestEvent);
+  var depth = depthA;
 
-    if (!terminationRequestEvent.isPersistent()) {
-      terminationRequestEvent.constructor.release(terminationRequestEvent);
+  while (depth--) {
+    if (instA === instB || instA === instB.alternate) {
+      return instA;
     }
 
-    if (shouldSwitch) {
-      var terminateEvent = ResponderSyntheticEvent.getPooled(
-        eventTypes.responderTerminate,
-        responderInst,
-        nativeEvent,
-        nativeEventTarget
-      );
-      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
-      accumulateDirectDispatches(terminateEvent);
-      extracted = accumulate(extracted, [grantEvent, terminateEvent]);
-      changeResponder(wantsResponderInst, blockHostResponder);
-    } else {
-      var rejectEvent = ResponderSyntheticEvent.getPooled(
-        eventTypes.responderReject,
-        wantsResponderInst,
-        nativeEvent,
-        nativeEventTarget
-      );
-      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
-      accumulateDirectDispatches(rejectEvent);
-      extracted = accumulate(extracted, rejectEvent);
-    }
-  } else {
-    extracted = accumulate(extracted, grantEvent);
-    changeResponder(wantsResponderInst, blockHostResponder);
+    instA = getParent(instA);
+    instB = getParent(instB);
   }
 
-  return extracted;
+  return null;
 }
 /**
- * A transfer is a negotiation between a currently set responder and the next
- * element to claim responder status. Any start event could trigger a transfer
- * of responderInst. Any move event could trigger a transfer.
- *
- * @param {string} topLevelType Record from `BrowserEventConstants`.
- * @return {boolean} True if a transfer of responder could possibly occur.
+ * Return if A is an ancestor of B.
  */
 
-function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
-  return (
-    topLevelInst && // responderIgnoreScroll: We are trying to migrate away from specifically
-    // tracking native scroll events here and responderIgnoreScroll indicates we
-    // will send topTouchCancel to handle canceling touch events instead
-    ((topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll) ||
-      (trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE) ||
-      isStartish(topLevelType) ||
-      isMoveish(topLevelType))
-  );
+function isAncestor(instA, instB) {
+  while (instB) {
+    if (instA === instB || instA === instB.alternate) {
+      return true;
+    }
+
+    instB = getParent(instB);
+  }
+
+  return false;
 }
 /**
- * Returns whether or not this touch end event makes it such that there are no
- * longer any touches that started inside of the current `responderInst`.
- *
- * @param {NativeEvent} nativeEvent Native touch end event.
- * @return {boolean} Whether or not this touch end event ends the responder.
+ * Simulates the traversal of a two-phase, capture/bubble event dispatch.
  */
 
-function noResponderTouches(nativeEvent) {
-  var touches = nativeEvent.touches;
+function traverseTwoPhase(inst, fn, arg) {
+  var path = [];
 
-  if (!touches || touches.length === 0) {
-    return true;
+  while (inst) {
+    path.push(inst);
+    inst = getParent(inst);
   }
 
-  for (var i = 0; i < touches.length; i++) {
-    var activeTouch = touches[i];
-    var target = activeTouch.target;
-
-    if (target !== null && target !== undefined && target !== 0) {
-      // Is the original touch location inside of the current responder?
-      var targetInst = getInstanceFromNode(target);
+  var i;
 
-      if (isAncestor(responderInst, targetInst)) {
-        return false;
-      }
-    }
+  for (i = path.length; i-- > 0; ) {
+    fn(path[i], "captured", arg);
   }
 
-  return true;
+  for (i = 0; i < path.length; i++) {
+    fn(path[i], "bubbled", arg);
+  }
 }
 
-var ResponderEventPlugin = {
-  /* For unit testing only */
-  _getResponder: function() {
-    return responderInst;
-  },
-  eventTypes: eventTypes,
+function getListener(inst, registrationName) {
+  var stateNode = inst.stateNode;
 
-  /**
-   * We must be resilient to `targetInst` being `null` on `touchMove` or
-   * `touchEnd`. On certain platforms, this means that a native scroll has
-   * assumed control and the original touch targets are destroyed.
-   */
-  extractEvents: function(
-    topLevelType,
-    targetInst,
-    nativeEvent,
-    nativeEventTarget,
-    eventSystemFlags
-  ) {
-    if (isStartish(topLevelType)) {
-      trackedTouchCount += 1;
-    } else if (isEndish(topLevelType)) {
-      if (trackedTouchCount >= 0) {
-        trackedTouchCount -= 1;
-      } else {
-        {
-          warn(
-            "Ended a touch event which was not counted in `trackedTouchCount`."
-          );
-        }
+  if (stateNode === null) {
+    // Work in progress (ex: onload events in incremental mode).
+    return null;
+  }
 
-        return null;
-      }
-    }
+  var props = getFiberCurrentPropsFromNode(stateNode);
 
-    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);
-    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)
-      ? setResponderAndExtractTransfer(
-          topLevelType,
-          targetInst,
-          nativeEvent,
-          nativeEventTarget
-        )
-      : null; // Responder may or may not have transferred on a new touch start/move.
-    // Regardless, whoever is the responder after any potential transfer, we
-    // direct all touch start/move/ends to them in the form of
-    // `onResponderMove/Start/End`. These will be called for *every* additional
-    // finger that move/start/end, dispatched directly to whoever is the
-    // current responder at that moment, until the responder is "released".
-    //
-    // These multiple individual change touch events are are always bookended
-    // by `onResponderGrant`, and one of
-    // (`onResponderRelease/onResponderTerminate`).
+  if (props === null) {
+    // Work in progress.
+    return null;
+  }
 
-    var isResponderTouchStart = responderInst && isStartish(topLevelType);
-    var isResponderTouchMove = responderInst && isMoveish(topLevelType);
-    var isResponderTouchEnd = responderInst && isEndish(topLevelType);
-    var incrementalTouch = isResponderTouchStart
-      ? eventTypes.responderStart
-      : isResponderTouchMove
-      ? eventTypes.responderMove
-      : isResponderTouchEnd
-      ? eventTypes.responderEnd
-      : null;
+  var listener = props[registrationName];
 
-    if (incrementalTouch) {
-      var gesture = ResponderSyntheticEvent.getPooled(
-        incrementalTouch,
-        responderInst,
-        nativeEvent,
-        nativeEventTarget
-      );
-      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
-      accumulateDirectDispatches(gesture);
-      extracted = accumulate(extracted, gesture);
-    }
+  if (!(!listener || typeof listener === "function")) {
+    throw Error(
+      "Expected `" +
+        registrationName +
+        "` listener to be a function, instead got a value of `" +
+        typeof listener +
+        "` type."
+    );
+  }
 
-    var isResponderTerminate =
-      responderInst && topLevelType === TOP_TOUCH_CANCEL;
-    var isResponderRelease =
-      responderInst &&
-      !isResponderTerminate &&
-      isEndish(topLevelType) &&
-      noResponderTouches(nativeEvent);
-    var finalTouch = isResponderTerminate
-      ? eventTypes.responderTerminate
-      : isResponderRelease
-      ? eventTypes.responderRelease
-      : null;
+  return listener;
+}
 
-    if (finalTouch) {
-      var finalEvent = ResponderSyntheticEvent.getPooled(
-        finalTouch,
-        responderInst,
-        nativeEvent,
-        nativeEventTarget
-      );
-      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
-      accumulateDirectDispatches(finalEvent);
-      extracted = accumulate(extracted, finalEvent);
-      changeResponder(null);
-    }
+function listenerAtPhase(inst, event, propagationPhase) {
+  var registrationName =
+    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
+  return getListener(inst, registrationName);
+}
 
-    return extracted;
-  },
-  GlobalResponderHandler: null,
-  injection: {
-    /**
-     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler
-     * Object that handles any change in responder. Use this to inject
-     * integration with an existing touch handling system etc.
-     */
-    injectGlobalResponderHandler: function(GlobalResponderHandler) {
-      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
+function accumulateDirectionalDispatches(inst, phase, event) {
+  {
+    if (!inst) {
+      error("Dispatching inst must not be null");
     }
   }
-};
 
-/**
- * Injectable ordering of event plugins.
- */
-var eventPluginOrder = null;
-/**
- * Injectable mapping from names to event plugin modules.
- */
+  var listener = listenerAtPhase(inst, event, phase);
 
-var namesToPlugins = {};
+  if (listener) {
+    event._dispatchListeners = accumulateInto(
+      event._dispatchListeners,
+      listener
+    );
+    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
+  }
+}
 /**
- * Recomputes the plugin list using the injected plugins and plugin ordering.
- *
- * @private
+ * Accumulates without regard to direction, does not look for phased
+ * registration names. Same as `accumulateDirectDispatchesSingle` but without
+ * requiring that the `dispatchMarker` be the same as the dispatched ID.
  */
 
-function recomputePluginOrdering() {
-  if (!eventPluginOrder) {
-    // Wait until an `eventPluginOrder` is injected.
-    return;
-  }
-
-  for (var pluginName in namesToPlugins) {
-    var pluginModule = namesToPlugins[pluginName];
-    var pluginIndex = eventPluginOrder.indexOf(pluginName);
-
-    if (!(pluginIndex > -1)) {
-      throw Error(
-        "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `" +
-          pluginName +
-          "`."
-      );
-    }
-
-    if (plugins[pluginIndex]) {
-      continue;
-    }
+function accumulateDispatches(inst, ignoredDirection, event) {
+  if (inst && event && event.dispatchConfig.registrationName) {
+    var registrationName = event.dispatchConfig.registrationName;
+    var listener = getListener(inst, registrationName);
 
-    if (!pluginModule.extractEvents) {
-      throw Error(
-        "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `" +
-          pluginName +
-          "` does not."
+    if (listener) {
+      event._dispatchListeners = accumulateInto(
+        event._dispatchListeners,
+        listener
       );
-    }
-
-    plugins[pluginIndex] = pluginModule;
-    var publishedEvents = pluginModule.eventTypes;
-
-    for (var eventName in publishedEvents) {
-      if (
-        !publishEventForPlugin(
-          publishedEvents[eventName],
-          pluginModule,
-          eventName
-        )
-      ) {
-        throw Error(
-          "EventPluginRegistry: Failed to publish event `" +
-            eventName +
-            "` for plugin `" +
-            pluginName +
-            "`."
-        );
-      }
+      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
     }
   }
 }
 /**
- * Publishes an event so that it can be dispatched by the supplied plugin.
- *
- * @param {object} dispatchConfig Dispatch configuration for the event.
- * @param {object} PluginModule Plugin publishing the event.
- * @return {boolean} True if the event was successfully published.
- * @private
+ * Accumulates dispatches on an `SyntheticEvent`, but only for the
+ * `dispatchMarker`.
+ * @param {SyntheticEvent} event
  */
 
-function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
-  if (!!eventNameDispatchConfigs.hasOwnProperty(eventName)) {
-    throw Error(
-      "EventPluginRegistry: More than one plugin attempted to publish the same event name, `" +
-        eventName +
-        "`."
-    );
+function accumulateDirectDispatchesSingle(event) {
+  if (event && event.dispatchConfig.registrationName) {
+    accumulateDispatches(event._targetInst, null, event);
   }
+}
 
-  eventNameDispatchConfigs[eventName] = dispatchConfig;
-  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
-
-  if (phasedRegistrationNames) {
-    for (var phaseName in phasedRegistrationNames) {
-      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
-        var phasedRegistrationName = phasedRegistrationNames[phaseName];
-        publishRegistrationName(
-          phasedRegistrationName,
-          pluginModule,
-          eventName
-        );
-      }
-    }
+function accumulateDirectDispatches(events) {
+  forEachAccumulated(events, accumulateDirectDispatchesSingle);
+}
 
-    return true;
-  } else if (dispatchConfig.registrationName) {
-    publishRegistrationName(
-      dispatchConfig.registrationName,
-      pluginModule,
-      eventName
-    );
-    return true;
+function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    var targetInst = event._targetInst;
+    var parentInst = targetInst ? getParent(targetInst) : null;
+    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
   }
+}
 
-  return false;
+function accumulateTwoPhaseDispatchesSkipTarget(events) {
+  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
 }
-/**
- * Publishes a registration name that is used to identify dispatched events.
- *
- * @param {string} registrationName Registration name to add.
- * @param {object} PluginModule Plugin publishing the event.
- * @private
- */
 
-function publishRegistrationName(registrationName, pluginModule, eventName) {
-  if (!!registrationNameModules[registrationName]) {
-    throw Error(
-      "EventPluginRegistry: More than one plugin attempted to publish the same registration name, `" +
-        registrationName +
-        "`."
-    );
+function accumulateTwoPhaseDispatchesSingle(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
   }
+}
 
-  registrationNameModules[registrationName] = pluginModule;
-  registrationNameDependencies[registrationName] =
-    pluginModule.eventTypes[eventName].dependencies;
+function accumulateTwoPhaseDispatches(events) {
+  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
+} // End of inline
 
-  {
-    var lowerCasedName = registrationName.toLowerCase();
-  }
-}
 /**
- * Registers plugins so that they can extract and dispatch events.
+ *
+ * Responder System:
+ * ----------------
+ *
+ * - A global, solitary "interaction lock" on a view.
+ * - If a node becomes the responder, it should convey visual feedback
+ *   immediately to indicate so, either by highlighting or moving accordingly.
+ * - To be the responder means, that touches are exclusively important to that
+ *   responder view, and no other view.
+ * - While touches are still occurring, the responder lock can be transferred to
+ *   a new view, but only to increasingly "higher" views (meaning ancestors of
+ *   the current responder).
+ *
+ * Responder being granted:
+ * ------------------------
+ *
+ * - Touch starts, moves, and scrolls can cause an ID to become the responder.
+ * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to
+ *   the "appropriate place".
+ * - If nothing is currently the responder, the "appropriate place" is the
+ *   initiating event's `targetID`.
+ * - If something *is* already the responder, the "appropriate place" is the
+ *   first common ancestor of the event target and the current `responderInst`.
+ * - Some negotiation happens: See the timing diagram below.
+ * - Scrolled views automatically become responder. The reasoning is that a
+ *   platform scroll view that isn't built on top of the responder system has
+ *   began scrolling, and the active responder must now be notified that the
+ *   interaction is no longer locked to it - the system has taken over.
+ *
+ * - Responder being released:
+ *   As soon as no more touches that *started* inside of descendants of the
+ *   *current* responderInst, an `onResponderRelease` event is dispatched to the
+ *   current responder, and the responder lock is released.
+ *
+ * TODO:
+ * - on "end", a callback hook for `onResponderEndShouldRemainResponder` that
+ *   determines if the responder lock should remain.
+ * - If a view shouldn't "remain" the responder, any active touches should by
+ *   default be considered "dead" and do not influence future negotiations or
+ *   bubble paths. It should be as if those touches do not exist.
+ * -- For multitouch: Usually a translate-z will choose to "remain" responder
+ *  after one out of many touches ended. For translate-y, usually the view
+ *  doesn't wish to "remain" responder after one of many touches end.
+ * - Consider building this on top of a `stopPropagation` model similar to
+ *   `W3C` events.
+ * - Ensure that `onResponderTerminate` is called on touch cancels, whether or
+ *   not `onResponderTerminationRequest` returns `true` or `false`.
+ *
+ */
+
+/*                                             Negotiation Performed
+                                             +-----------------------+
+                                            /                         \
+Process low level events to    +     Current Responder      +   wantsResponderID
+determine who to perform negot-|   (if any exists at all)   |
+iation/transition              | Otherwise just pass through|
+-------------------------------+----------------------------+------------------+
+Bubble to find first ID        |                            |
+to return true:wantsResponderID|                            |
+                               |                            |
+     +-------------+           |                            |
+     | onTouchStart|           |                            |
+     +------+------+     none  |                            |
+            |            return|                            |
++-----------v-------------+true| +------------------------+ |
+|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+
++-----------+-------------+    | +------------------------+ |          |
+            |                  |                            | +--------+-------+
+            | returned true for|       false:REJECT +-------->|onResponderReject
+            | wantsResponderID |                    |       | +----------------+
+            | (now attempt     | +------------------+-----+ |
+            |  handoff)        | |   onResponder          | |
+            +------------------->|      TerminationRequest| |
+                               | +------------------+-----+ |
+                               |                    |       | +----------------+
+                               |         true:GRANT +-------->|onResponderGrant|
+                               |                            | +--------+-------+
+                               | +------------------------+ |          |
+                               | |   onResponderTerminate |<-----------+
+                               | +------------------+-----+ |
+                               |                    |       | +----------------+
+                               |                    +-------->|onResponderStart|
+                               |                            | +----------------+
+Bubble to find first ID        |                            |
+to return true:wantsResponderID|                            |
+                               |                            |
+     +-------------+           |                            |
+     | onTouchMove |           |                            |
+     +------+------+     none  |                            |
+            |            return|                            |
++-----------v-------------+true| +------------------------+ |
+|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+
++-----------+-------------+    | +------------------------+ |          |
+            |                  |                            | +--------+-------+
+            | returned true for|       false:REJECT +-------->|onResponderRejec|
+            | wantsResponderID |                    |       | +----------------+
+            | (now attempt     | +------------------+-----+ |
+            |  handoff)        | |   onResponder          | |
+            +------------------->|      TerminationRequest| |
+                               | +------------------+-----+ |
+                               |                    |       | +----------------+
+                               |         true:GRANT +-------->|onResponderGrant|
+                               |                            | +--------+-------+
+                               | +------------------------+ |          |
+                               | |   onResponderTerminate |<-----------+
+                               | +------------------+-----+ |
+                               |                    |       | +----------------+
+                               |                    +-------->|onResponderMove |
+                               |                            | +----------------+
+                               |                            |
+                               |                            |
+      Some active touch started|                            |
+      inside current responder | +------------------------+ |
+      +------------------------->|      onResponderEnd    | |
+      |                        | +------------------------+ |
+  +---+---------+              |                            |
+  | onTouchEnd  |              |                            |
+  +---+---------+              |                            |
+      |                        | +------------------------+ |
+      +------------------------->|     onResponderEnd     | |
+      No active touches started| +-----------+------------+ |
+      inside current responder |             |              |
+                               |             v              |
+                               | +------------------------+ |
+                               | |    onResponderRelease  | |
+                               | +------------------------+ |
+                               |                            |
+                               +                            + */
+
+/**
+ * A note about event ordering in the `EventPluginRegistry`.
+ *
+ * Suppose plugins are injected in the following order:
+ *
+ * `[R, S, C]`
+ *
+ * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for
+ * `onClick` etc) and `R` is `ResponderEventPlugin`.
+ *
+ * "Deferred-Dispatched Events":
+ *
+ * - The current event plugin system will traverse the list of injected plugins,
+ *   in order, and extract events by collecting the plugin's return value of
+ *   `extractEvents()`.
+ * - These events that are returned from `extractEvents` are "deferred
+ *   dispatched events".
+ * - When returned from `extractEvents`, deferred-dispatched events contain an
+ *   "accumulation" of deferred dispatches.
+ * - These deferred dispatches are accumulated/collected before they are
+ *   returned, but processed at a later time by the `EventPluginRegistry` (hence the
+ *   name deferred).
+ *
+ * In the process of returning their deferred-dispatched events, event plugins
+ * themselves can dispatch events on-demand without returning them from
+ * `extractEvents`. Plugins might want to do this, so that they can use event
+ * dispatching as a tool that helps them decide which events should be extracted
+ * in the first place.
+ *
+ * "On-Demand-Dispatched Events":
+ *
+ * - On-demand-dispatched events are not returned from `extractEvents`.
+ * - On-demand-dispatched events are dispatched during the process of returning
+ *   the deferred-dispatched events.
+ * - They should not have side effects.
+ * - They should be avoided, and/or eventually be replaced with another
+ *   abstraction that allows event plugins to perform multiple "rounds" of event
+ *   extraction.
+ *
+ * Therefore, the sequence of event dispatches becomes:
+ *
+ * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)
+ * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)
+ * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)
+ * - `R`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
+ * - `S`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
+ * - `C`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
+ *
+ * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`
+ * on-demand dispatch returns `true` (and some other details are satisfied) the
+ * `onResponderGrant` deferred dispatched event is returned from
+ * `extractEvents`. The sequence of dispatch executions in this case
+ * will appear as follows:
+ *
+ * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)
+ * - `touchStartCapture`       (`EventPluginRegistry` dispatches as usual)
+ * - `touchStart`              (`EventPluginRegistry` dispatches as usual)
+ * - `responderGrant/Reject`   (`EventPluginRegistry` dispatches as usual)
+ */
+
+function setResponderAndExtractTransfer(
+  topLevelType,
+  targetInst,
+  nativeEvent,
+  nativeEventTarget
+) {
+  var shouldSetEventType = isStartish(topLevelType)
+    ? eventTypes.startShouldSetResponder
+    : isMoveish(topLevelType)
+    ? eventTypes.moveShouldSetResponder
+    : topLevelType === TOP_SELECTION_CHANGE
+    ? eventTypes.selectionChangeShouldSetResponder
+    : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.
+
+  var bubbleShouldSetFrom = !responderInst
+    ? targetInst
+    : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the "shouldSet" event, we want to skip the target
+  // (deepest ID) if it happens to be the current responder. The reasoning:
+  // It's strange to get an `onMoveShouldSetResponder` when you're *already*
+  // the responder.
+
+  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
+  var shouldSetEvent = ResponderSyntheticEvent.getPooled(
+    shouldSetEventType,
+    bubbleShouldSetFrom,
+    nativeEvent,
+    nativeEventTarget
+  );
+  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+
+  if (skipOverBubbleShouldSetFrom) {
+    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
+  } else {
+    accumulateTwoPhaseDispatches(shouldSetEvent);
+  }
+
+  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
+
+  if (!shouldSetEvent.isPersistent()) {
+    shouldSetEvent.constructor.release(shouldSetEvent);
+  }
+
+  if (!wantsResponderInst || wantsResponderInst === responderInst) {
+    return null;
+  }
+
+  var extracted;
+  var grantEvent = ResponderSyntheticEvent.getPooled(
+    eventTypes.responderGrant,
+    wantsResponderInst,
+    nativeEvent,
+    nativeEventTarget
+  );
+  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+  accumulateDirectDispatches(grantEvent);
+  var blockHostResponder = executeDirectDispatch(grantEvent) === true;
+
+  if (responderInst) {
+    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(
+      eventTypes.responderTerminationRequest,
+      responderInst,
+      nativeEvent,
+      nativeEventTarget
+    );
+    terminationRequestEvent.touchHistory =
+      ResponderTouchHistoryStore.touchHistory;
+    accumulateDirectDispatches(terminationRequestEvent);
+    var shouldSwitch =
+      !hasDispatches(terminationRequestEvent) ||
+      executeDirectDispatch(terminationRequestEvent);
+
+    if (!terminationRequestEvent.isPersistent()) {
+      terminationRequestEvent.constructor.release(terminationRequestEvent);
+    }
+
+    if (shouldSwitch) {
+      var terminateEvent = ResponderSyntheticEvent.getPooled(
+        eventTypes.responderTerminate,
+        responderInst,
+        nativeEvent,
+        nativeEventTarget
+      );
+      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+      accumulateDirectDispatches(terminateEvent);
+      extracted = accumulate(extracted, [grantEvent, terminateEvent]);
+      changeResponder(wantsResponderInst, blockHostResponder);
+    } else {
+      var rejectEvent = ResponderSyntheticEvent.getPooled(
+        eventTypes.responderReject,
+        wantsResponderInst,
+        nativeEvent,
+        nativeEventTarget
+      );
+      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+      accumulateDirectDispatches(rejectEvent);
+      extracted = accumulate(extracted, rejectEvent);
+    }
+  } else {
+    extracted = accumulate(extracted, grantEvent);
+    changeResponder(wantsResponderInst, blockHostResponder);
+  }
+
+  return extracted;
+}
+/**
+ * A transfer is a negotiation between a currently set responder and the next
+ * element to claim responder status. Any start event could trigger a transfer
+ * of responderInst. Any move event could trigger a transfer.
+ *
+ * @param {string} topLevelType Record from `BrowserEventConstants`.
+ * @return {boolean} True if a transfer of responder could possibly occur.
+ */
+
+function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
+  return (
+    topLevelInst && // responderIgnoreScroll: We are trying to migrate away from specifically
+    // tracking native scroll events here and responderIgnoreScroll indicates we
+    // will send topTouchCancel to handle canceling touch events instead
+    ((topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll) ||
+      (trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE) ||
+      isStartish(topLevelType) ||
+      isMoveish(topLevelType))
+  );
+}
+/**
+ * Returns whether or not this touch end event makes it such that there are no
+ * longer any touches that started inside of the current `responderInst`.
+ *
+ * @param {NativeEvent} nativeEvent Native touch end event.
+ * @return {boolean} Whether or not this touch end event ends the responder.
+ */
+
+function noResponderTouches(nativeEvent) {
+  var touches = nativeEvent.touches;
+
+  if (!touches || touches.length === 0) {
+    return true;
+  }
+
+  for (var i = 0; i < touches.length; i++) {
+    var activeTouch = touches[i];
+    var target = activeTouch.target;
+
+    if (target !== null && target !== undefined && target !== 0) {
+      // Is the original touch location inside of the current responder?
+      var targetInst = getInstanceFromNode(target);
+
+      if (isAncestor(responderInst, targetInst)) {
+        return false;
+      }
+    }
+  }
+
+  return true;
+}
+
+var ResponderEventPlugin = {
+  /* For unit testing only */
+  _getResponder: function() {
+    return responderInst;
+  },
+  eventTypes: eventTypes,
+
+  /**
+   * We must be resilient to `targetInst` being `null` on `touchMove` or
+   * `touchEnd`. On certain platforms, this means that a native scroll has
+   * assumed control and the original touch targets are destroyed.
+   */
+  extractEvents: function(
+    topLevelType,
+    targetInst,
+    nativeEvent,
+    nativeEventTarget,
+    eventSystemFlags
+  ) {
+    if (isStartish(topLevelType)) {
+      trackedTouchCount += 1;
+    } else if (isEndish(topLevelType)) {
+      if (trackedTouchCount >= 0) {
+        trackedTouchCount -= 1;
+      } else {
+        {
+          warn(
+            "Ended a touch event which was not counted in `trackedTouchCount`."
+          );
+        }
+
+        return null;
+      }
+    }
+
+    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);
+    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)
+      ? setResponderAndExtractTransfer(
+          topLevelType,
+          targetInst,
+          nativeEvent,
+          nativeEventTarget
+        )
+      : null; // Responder may or may not have transferred on a new touch start/move.
+    // Regardless, whoever is the responder after any potential transfer, we
+    // direct all touch start/move/ends to them in the form of
+    // `onResponderMove/Start/End`. These will be called for *every* additional
+    // finger that move/start/end, dispatched directly to whoever is the
+    // current responder at that moment, until the responder is "released".
+    //
+    // These multiple individual change touch events are are always bookended
+    // by `onResponderGrant`, and one of
+    // (`onResponderRelease/onResponderTerminate`).
+
+    var isResponderTouchStart = responderInst && isStartish(topLevelType);
+    var isResponderTouchMove = responderInst && isMoveish(topLevelType);
+    var isResponderTouchEnd = responderInst && isEndish(topLevelType);
+    var incrementalTouch = isResponderTouchStart
+      ? eventTypes.responderStart
+      : isResponderTouchMove
+      ? eventTypes.responderMove
+      : isResponderTouchEnd
+      ? eventTypes.responderEnd
+      : null;
+
+    if (incrementalTouch) {
+      var gesture = ResponderSyntheticEvent.getPooled(
+        incrementalTouch,
+        responderInst,
+        nativeEvent,
+        nativeEventTarget
+      );
+      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
+      accumulateDirectDispatches(gesture);
+      extracted = accumulate(extracted, gesture);
+    }
+
+    var isResponderTerminate =
+      responderInst && topLevelType === TOP_TOUCH_CANCEL;
+    var isResponderRelease =
+      responderInst &&
+      !isResponderTerminate &&
+      isEndish(topLevelType) &&
+      noResponderTouches(nativeEvent);
+    var finalTouch = isResponderTerminate
+      ? eventTypes.responderTerminate
+      : isResponderRelease
+      ? eventTypes.responderRelease
+      : null;
+
+    if (finalTouch) {
+      var finalEvent = ResponderSyntheticEvent.getPooled(
+        finalTouch,
+        responderInst,
+        nativeEvent,
+        nativeEventTarget
+      );
+      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+      accumulateDirectDispatches(finalEvent);
+      extracted = accumulate(extracted, finalEvent);
+      changeResponder(null);
+    }
+
+    return extracted;
+  },
+  GlobalResponderHandler: null,
+  injection: {
+    /**
+     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler
+     * Object that handles any change in responder. Use this to inject
+     * integration with an existing touch handling system etc.
+     */
+    injectGlobalResponderHandler: function(GlobalResponderHandler) {
+      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
+    }
+  }
+};
+
+/**
+ * Injectable ordering of event plugins.
+ */
+var eventPluginOrder = null;
+/**
+ * Injectable mapping from names to event plugin modules.
+ */
+
+var namesToPlugins = {};
+/**
+ * Recomputes the plugin list using the injected plugins and plugin ordering.
+ *
+ * @private
+ */
+
+function recomputePluginOrdering() {
+  if (!eventPluginOrder) {
+    // Wait until an `eventPluginOrder` is injected.
+    return;
+  }
+
+  for (var pluginName in namesToPlugins) {
+    var pluginModule = namesToPlugins[pluginName];
+    var pluginIndex = eventPluginOrder.indexOf(pluginName);
+
+    if (!(pluginIndex > -1)) {
+      throw Error(
+        "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `" +
+          pluginName +
+          "`."
+      );
+    }
+
+    if (plugins[pluginIndex]) {
+      continue;
+    }
+
+    if (!pluginModule.extractEvents) {
+      throw Error(
+        "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `" +
+          pluginName +
+          "` does not."
+      );
+    }
+
+    plugins[pluginIndex] = pluginModule;
+    var publishedEvents = pluginModule.eventTypes;
+
+    for (var eventName in publishedEvents) {
+      if (
+        !publishEventForPlugin(
+          publishedEvents[eventName],
+          pluginModule,
+          eventName
+        )
+      ) {
+        throw Error(
+          "EventPluginRegistry: Failed to publish event `" +
+            eventName +
+            "` for plugin `" +
+            pluginName +
+            "`."
+        );
+      }
+    }
+  }
+}
+/**
+ * Publishes an event so that it can be dispatched by the supplied plugin.
+ *
+ * @param {object} dispatchConfig Dispatch configuration for the event.
+ * @param {object} PluginModule Plugin publishing the event.
+ * @return {boolean} True if the event was successfully published.
+ * @private
+ */
+
+function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
+  if (!!eventNameDispatchConfigs.hasOwnProperty(eventName)) {
+    throw Error(
+      "EventPluginRegistry: More than one plugin attempted to publish the same event name, `" +
+        eventName +
+        "`."
+    );
+  }
+
+  eventNameDispatchConfigs[eventName] = dispatchConfig;
+  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
+
+  if (phasedRegistrationNames) {
+    for (var phaseName in phasedRegistrationNames) {
+      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
+        var phasedRegistrationName = phasedRegistrationNames[phaseName];
+        publishRegistrationName(
+          phasedRegistrationName,
+          pluginModule,
+          eventName
+        );
+      }
+    }
+
+    return true;
+  } else if (dispatchConfig.registrationName) {
+    publishRegistrationName(
+      dispatchConfig.registrationName,
+      pluginModule,
+      eventName
+    );
+    return true;
+  }
+
+  return false;
+}
+/**
+ * Publishes a registration name that is used to identify dispatched events.
+ *
+ * @param {string} registrationName Registration name to add.
+ * @param {object} PluginModule Plugin publishing the event.
+ * @private
+ */
+
+function publishRegistrationName(registrationName, pluginModule, eventName) {
+  if (!!registrationNameModules[registrationName]) {
+    throw Error(
+      "EventPluginRegistry: More than one plugin attempted to publish the same registration name, `" +
+        registrationName +
+        "`."
+    );
+  }
+
+  registrationNameModules[registrationName] = pluginModule;
+  registrationNameDependencies[registrationName] =
+    pluginModule.eventTypes[eventName].dependencies;
+
+  {
+    var lowerCasedName = registrationName.toLowerCase();
+  }
+}
+/**
+ * Registers plugins so that they can extract and dispatch events.
  */
 
 /**
@@ -2352,20 +2257,163 @@ function injectEventPluginsByName(injectedNamesToPlugins) {
   }
 }
 
+function getListener$1(inst, registrationName) {
+  var stateNode = inst.stateNode;
+
+  if (stateNode === null) {
+    // Work in progress (ex: onload events in incremental mode).
+    return null;
+  }
+
+  var props = getFiberCurrentPropsFromNode(stateNode);
+
+  if (props === null) {
+    // Work in progress.
+    return null;
+  }
+
+  var listener = props[registrationName];
+
+  if (!(!listener || typeof listener === "function")) {
+    throw Error(
+      "Expected `" +
+        registrationName +
+        "` listener to be a function, instead got a value of `" +
+        typeof listener +
+        "` type."
+    );
+  }
+
+  return listener;
+}
+
 var customBubblingEventTypes =
     ReactNativePrivateInterface.ReactNativeViewConfigRegistry
       .customBubblingEventTypes,
   customDirectEventTypes =
     ReactNativePrivateInterface.ReactNativeViewConfigRegistry
-      .customDirectEventTypes;
+      .customDirectEventTypes; // Start of inline: the below functions were inlined from
+// EventPropagator.js, as they deviated from ReactDOM's newer
+// implementations.
+
+function listenerAtPhase$1(inst, event, propagationPhase) {
+  var registrationName =
+    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
+  return getListener$1(inst, registrationName);
+}
+
+function accumulateDirectionalDispatches$1(inst, phase, event) {
+  {
+    if (!inst) {
+      error("Dispatching inst must not be null");
+    }
+  }
+
+  var listener = listenerAtPhase$1(inst, event, phase);
+
+  if (listener) {
+    event._dispatchListeners = accumulateInto(
+      event._dispatchListeners,
+      listener
+    );
+    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
+  }
+}
+
+function getParent$1(inst) {
+  do {
+    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
+    // That is depending on if we want nested subtrees (layers) to bubble
+    // events to their parent. We could also go through parentNode on the
+    // host node but that wouldn't work for React Native and doesn't let us
+    // do the portal feature.
+  } while (inst && inst.tag !== HostComponent);
+
+  if (inst) {
+    return inst;
+  }
+
+  return null;
+}
+/**
+ * Simulates the traversal of a two-phase, capture/bubble event dispatch.
+ */
+
+function traverseTwoPhase$1(inst, fn, arg) {
+  var path = [];
+
+  while (inst) {
+    path.push(inst);
+    inst = getParent$1(inst);
+  }
+
+  var i;
+
+  for (i = path.length; i-- > 0; ) {
+    fn(path[i], "captured", arg);
+  }
+
+  for (i = 0; i < path.length; i++) {
+    fn(path[i], "bubbled", arg);
+  }
+}
+
+function accumulateTwoPhaseDispatchesSingle$1(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    traverseTwoPhase$1(
+      event._targetInst,
+      accumulateDirectionalDispatches$1,
+      event
+    );
+  }
+}
+
+function accumulateTwoPhaseDispatches$1(events) {
+  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle$1);
+}
+/**
+ * Accumulates without regard to direction, does not look for phased
+ * registration names. Same as `accumulateDirectDispatchesSingle` but without
+ * requiring that the `dispatchMarker` be the same as the dispatched ID.
+ */
+
+function accumulateDispatches$1(inst, ignoredDirection, event) {
+  if (inst && event && event.dispatchConfig.registrationName) {
+    var registrationName = event.dispatchConfig.registrationName;
+    var listener = getListener$1(inst, registrationName);
+
+    if (listener) {
+      event._dispatchListeners = accumulateInto(
+        event._dispatchListeners,
+        listener
+      );
+      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
+    }
+  }
+}
+/**
+ * Accumulates dispatches on an `SyntheticEvent`, but only for the
+ * `dispatchMarker`.
+ * @param {SyntheticEvent} event
+ */
+
+function accumulateDirectDispatchesSingle$1(event) {
+  if (event && event.dispatchConfig.registrationName) {
+    accumulateDispatches$1(event._targetInst, null, event);
+  }
+}
+
+function accumulateDirectDispatches$1(events) {
+  forEachAccumulated(events, accumulateDirectDispatchesSingle$1);
+} // End of inline
+
 var ReactNativeBridgeEventPlugin = {
   eventTypes: {},
   extractEvents: function(
     topLevelType,
     targetInst,
     nativeEvent,
-    nativeEventTarget,
-    eventSystemFlags
+    nativeEventTarget
   ) {
     if (targetInst == null) {
       // Probably a node belonging to another renderer's tree.
@@ -2389,9 +2437,9 @@ var ReactNativeBridgeEventPlugin = {
     );
 
     if (bubbleDispatchConfig) {
-      accumulateTwoPhaseDispatches(event);
+      accumulateTwoPhaseDispatches$1(event);
     } else if (directDispatchConfig) {
-      accumulateDirectDispatches(event);
+      accumulateDirectDispatches$1(event);
     } else {
       return null;
     }
@@ -2462,23 +2510,16 @@ function updateFiberProps(tag, props) {
   instanceProps.set(tag, props);
 }
 
-var PLUGIN_EVENT_SYSTEM = 1;
-
-var enableProfilerTimer = true;
-var enableFundamentalAPI = false;
-var warnAboutStringRefs = false;
-
+// Used as a way to call batchedUpdates when we don't have a reference to
 // the renderer. Such as when we're dispatching events or if third party
 // libraries need to call batchedUpdates. Eventually, this API will go away when
 // everything is batched by default. We'll then have a similar API to opt-out of
 // scheduled work and instead do synchronous work.
 // Defaults
-
 var batchedUpdatesImpl = function(fn, bookkeeping) {
   return fn(bookkeeping);
 };
 var isInsideEventHandler = false;
-
 function batchedUpdates(fn, bookkeeping) {
   if (isInsideEventHandler) {
     // If we are currently inside another batch, we need to wait until it
@@ -2636,13 +2677,7 @@ function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
   }
 
   batchedUpdates(function() {
-    runExtractedPluginEventsInBatch(
-      topLevelType,
-      inst,
-      nativeEvent,
-      target,
-      PLUGIN_EVENT_SYSTEM
-    );
+    runExtractedPluginEventsInBatch(topLevelType, inst, nativeEvent, target);
   }); // React Native doesn't use ReactControlledComponent but if it did, here's
   // where it would do it.
 }
@@ -2658,22 +2693,21 @@ function extractPluginEvents(
   topLevelType,
   targetInst,
   nativeEvent,
-  nativeEventTarget,
-  eventSystemFlags
+  nativeEventTarget
 ) {
   var events = null;
+  var legacyPlugins = plugins;
 
-  for (var i = 0; i < plugins.length; i++) {
+  for (var i = 0; i < legacyPlugins.length; i++) {
     // Not every plugin in the ordering may be loaded at runtime.
-    var possiblePlugin = plugins[i];
+    var possiblePlugin = legacyPlugins[i];
 
     if (possiblePlugin) {
       var extractedEvents = possiblePlugin.extractEvents(
         topLevelType,
         targetInst,
         nativeEvent,
-        nativeEventTarget,
-        eventSystemFlags
+        nativeEventTarget
       );
 
       if (extractedEvents) {
@@ -2689,15 +2723,13 @@ function runExtractedPluginEventsInBatch(
   topLevelType,
   targetInst,
   nativeEvent,
-  nativeEventTarget,
-  eventSystemFlags
+  nativeEventTarget
 ) {
   var events = extractPluginEvents(
     topLevelType,
     targetInst,
     nativeEvent,
-    nativeEventTarget,
-    eventSystemFlags
+    nativeEventTarget
   );
   runEventsInBatch(events);
 }
@@ -2810,37 +2842,58 @@ ResponderEventPlugin.injection.injectGlobalResponderHandler(
  * If this becomes an actual Map, that will break.
  */
 function get(key) {
-  return key._reactInternalFiber;
+  return key._reactInternals;
 }
 function set(key, value) {
-  key._reactInternalFiber = value;
+  key._reactInternals = value;
 }
 
+// ATTENTION
+// When adding new symbols to this file,
+// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
 // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
 // nor polyfill, then a plain number is used for performance.
-var hasSymbol = typeof Symbol === "function" && Symbol.for;
-var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 0xeac7;
-var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 0xeaca;
-var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 0xeacb;
-var REACT_STRICT_MODE_TYPE = hasSymbol
-  ? Symbol.for("react.strict_mode")
-  : 0xeacc;
-var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 0xead2;
-var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 0xeacd;
-var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
-var REACT_CONCURRENT_MODE_TYPE = hasSymbol
-  ? Symbol.for("react.concurrent_mode")
-  : 0xeacf;
-var REACT_FORWARD_REF_TYPE = hasSymbol
-  ? Symbol.for("react.forward_ref")
-  : 0xead0;
-var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 0xead1;
-var REACT_SUSPENSE_LIST_TYPE = hasSymbol
-  ? Symbol.for("react.suspense_list")
-  : 0xead8;
-var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
-var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;
-var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 0xead9;
+var REACT_ELEMENT_TYPE = 0xeac7;
+var REACT_PORTAL_TYPE = 0xeaca;
+var REACT_FRAGMENT_TYPE = 0xeacb;
+var REACT_STRICT_MODE_TYPE = 0xeacc;
+var REACT_PROFILER_TYPE = 0xead2;
+var REACT_PROVIDER_TYPE = 0xeacd;
+var REACT_CONTEXT_TYPE = 0xeace;
+var REACT_FORWARD_REF_TYPE = 0xead0;
+var REACT_SUSPENSE_TYPE = 0xead1;
+var REACT_SUSPENSE_LIST_TYPE = 0xead8;
+var REACT_MEMO_TYPE = 0xead3;
+var REACT_LAZY_TYPE = 0xead4;
+var REACT_FUNDAMENTAL_TYPE = 0xead5;
+var REACT_SCOPE_TYPE = 0xead7;
+var REACT_OPAQUE_ID_TYPE = 0xeae0;
+var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
+var REACT_OFFSCREEN_TYPE = 0xeae2;
+var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
+
+if (typeof Symbol === "function" && Symbol.for) {
+  var symbolFor = Symbol.for;
+  REACT_ELEMENT_TYPE = symbolFor("react.element");
+  REACT_PORTAL_TYPE = symbolFor("react.portal");
+  REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
+  REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
+  REACT_PROFILER_TYPE = symbolFor("react.profiler");
+  REACT_PROVIDER_TYPE = symbolFor("react.provider");
+  REACT_CONTEXT_TYPE = symbolFor("react.context");
+  REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
+  REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
+  REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
+  REACT_MEMO_TYPE = symbolFor("react.memo");
+  REACT_LAZY_TYPE = symbolFor("react.lazy");
+  REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
+  REACT_SCOPE_TYPE = symbolFor("react.scope");
+  REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
+  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
+  REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
+  REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
+}
+
 var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
 var FAUX_ITERATOR_SYMBOL = "@@iterator";
 function getIteratorFn(maybeIterable) {
@@ -2859,63 +2912,6 @@ function getIteratorFn(maybeIterable) {
   return null;
 }
 
-// TODO: Move this to "react" once we can import from externals.
-var Uninitialized = -1;
-var Pending = 0;
-var Resolved = 1;
-var Rejected = 2;
-
-function refineResolvedLazyComponent(lazyComponent) {
-  return lazyComponent._status === Resolved ? lazyComponent._result : null;
-}
-function initializeLazyComponentType(lazyComponent) {
-  if (lazyComponent._status === Uninitialized) {
-    var ctor = lazyComponent._result;
-
-    if (!ctor) {
-      // TODO: Remove this later. THis only exists in case you use an older "react" package.
-      ctor = lazyComponent._ctor;
-    }
-
-    var thenable = ctor(); // Transition to the next state.
-
-    var pending = lazyComponent;
-    pending._status = Pending;
-    pending._result = thenable;
-    thenable.then(
-      function(moduleObject) {
-        if (lazyComponent._status === Pending) {
-          var defaultExport = moduleObject.default;
-
-          {
-            if (defaultExport === undefined) {
-              error(
-                "lazy: Expected the result of a dynamic import() call. " +
-                "Instead received: %s\n\nYour code should look like: \n  " + // Break up imports to avoid accidentally parsing them as dependencies.
-                  "const MyComponent = lazy(() => imp" +
-                  "ort('./MyComponent'))",
-                moduleObject
-              );
-            }
-          } // Transition to the next state.
-
-          var resolved = lazyComponent;
-          resolved._status = Resolved;
-          resolved._result = defaultExport;
-        }
-      },
-      function(error) {
-        if (lazyComponent._status === Pending) {
-          // Transition to the next state.
-          var rejected = lazyComponent;
-          rejected._status = Rejected;
-          rejected._result = error;
-        }
-      }
-    );
-  }
-}
-
 function getWrappedName(outerType, innerType, wrapperName) {
   var functionName = innerType.displayName || innerType.name || "";
   return (
@@ -2987,18 +2983,16 @@ function getComponentName(type) {
       case REACT_MEMO_TYPE:
         return getComponentName(type.type);
 
-      case REACT_BLOCK_TYPE:
-        return getComponentName(type.render);
-
       case REACT_LAZY_TYPE: {
-        var thenable = type;
-        var resolvedThenable = refineResolvedLazyComponent(thenable);
+        var lazyComponent = type;
+        var payload = lazyComponent._payload;
+        var init = lazyComponent._init;
 
-        if (resolvedThenable) {
-          return getComponentName(resolvedThenable);
+        try {
+          return getComponentName(init(payload));
+        } catch (x) {
+          return null;
         }
-
-        break;
       }
     }
   }
@@ -3006,64 +3000,74 @@ function getComponentName(type) {
   return null;
 }
 
+var enableProfilerTimer = true;
+var enableFundamentalAPI = false;
+var warnAboutStringRefs = false;
+var enableNewReconciler = false;
+
 // Don't change these two values. They're used by React Dev Tools.
-var NoEffect =
-  /*              */
+var NoFlags =
+  /*                      */
   0;
 var PerformedWork =
-  /*         */
+  /*                */
   1; // You can change the rest (and add more).
 
 var Placement =
-  /*             */
+  /*                    */
   2;
 var Update =
-  /*                */
+  /*                       */
   4;
 var PlacementAndUpdate =
-  /*    */
+  /*           */
   6;
 var Deletion =
-  /*              */
+  /*                     */
   8;
 var ContentReset =
-  /*          */
+  /*                 */
   16;
 var Callback =
-  /*              */
+  /*                     */
   32;
 var DidCapture =
-  /*            */
+  /*                   */
   64;
 var Ref =
-  /*                   */
+  /*                          */
   128;
 var Snapshot =
-  /*              */
+  /*                     */
   256;
 var Passive =
-  /*               */
+  /*                      */
   512;
 var Hydrating =
-  /*             */
+  /*                    */
   1024;
 var HydratingAndUpdate =
-  /*    */
-  1028; // Passive & Update & Callback & Ref & Snapshot
-
-var LifecycleEffectMask =
-  /*   */
-  932; // Union of all host effects
+  /*           */
+  1028;
+var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot; // Union of all commit flags (flags with the lifetime of a particular commit)
 
 var HostEffectMask =
-  /*        */
-  2047;
+  /*               */
+  4095; // These are not really side effects, but we still reuse this field.
+
 var Incomplete =
-  /*            */
-  2048;
-var ShouldCapture =
-  /*         */
+  /*                   */
   4096;
+var ShouldCapture =
+  /*                */
+  8192; // TODO (effects) Remove this bit once the new reconciler is synced to the old.
+
+var PassiveUnmountPendingDev =
+  /*     */
+  16384;
+var ForceUpdateForLegacySuspense =
+  /* */
+  32768; // Static tags describe aspects of a fiber that are not specific to a render,
 
 var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 function getNearestMountedFiber(fiber) {
@@ -3078,7 +3082,7 @@ function getNearestMountedFiber(fiber) {
     do {
       node = nextNode;
 
-      if ((node.effectTag & (Placement | Hydrating)) !== NoEffect) {
+      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
         // This is an insertion or in-progress hydration. The nearest possible
         // mounted fiber is the parent but we need to continue to figure out
         // if that one is still mounted.
@@ -3338,6 +3342,20 @@ function findCurrentHostFiber(parent) {
 
   return null;
 }
+function doesFiberContain(parentFiber, childFiber) {
+  var node = childFiber;
+  var parentFiberAlternate = parentFiber.alternate;
+
+  while (node !== null) {
+    if (node === parentFiber || node === parentFiberAlternate) {
+      return true;
+    }
+
+    node = node.return;
+  }
+
+  return false;
+}
 
 // Modules provided by RN:
 var emptyObject = {};
@@ -3844,104 +3862,102 @@ function warnForStyleProps(props, validAttributes) {
   }
 }
 
-var ReactNativeFiberHostComponent =
-  /*#__PURE__*/
-  (function() {
-    function ReactNativeFiberHostComponent(
-      tag,
-      viewConfig,
-      internalInstanceHandleDEV
-    ) {
-      this._nativeTag = tag;
-      this._children = [];
-      this.viewConfig = viewConfig;
+var ReactNativeFiberHostComponent = /*#__PURE__*/ (function() {
+  function ReactNativeFiberHostComponent(
+    tag,
+    viewConfig,
+    internalInstanceHandleDEV
+  ) {
+    this._nativeTag = tag;
+    this._children = [];
+    this.viewConfig = viewConfig;
 
-      {
-        this._internalFiberInstanceHandleDEV = internalInstanceHandleDEV;
-      }
+    {
+      this._internalFiberInstanceHandleDEV = internalInstanceHandleDEV;
     }
+  }
 
-    var _proto = ReactNativeFiberHostComponent.prototype;
-
-    _proto.blur = function blur() {
-      ReactNativePrivateInterface.TextInputState.blurTextInput(this);
-    };
-
-    _proto.focus = function focus() {
-      ReactNativePrivateInterface.TextInputState.focusTextInput(this);
-    };
-
-    _proto.measure = function measure(callback) {
-      ReactNativePrivateInterface.UIManager.measure(
-        this._nativeTag,
-        mountSafeCallback_NOT_REALLY_SAFE(this, callback)
-      );
-    };
+  var _proto = ReactNativeFiberHostComponent.prototype;
 
-    _proto.measureInWindow = function measureInWindow(callback) {
-      ReactNativePrivateInterface.UIManager.measureInWindow(
-        this._nativeTag,
-        mountSafeCallback_NOT_REALLY_SAFE(this, callback)
-      );
-    };
+  _proto.blur = function blur() {
+    ReactNativePrivateInterface.TextInputState.blurTextInput(this);
+  };
 
-    _proto.measureLayout = function measureLayout(
-      relativeToNativeNode,
-      onSuccess,
-      onFail
-    ) /* currently unused */
-    {
-      var relativeNode;
+  _proto.focus = function focus() {
+    ReactNativePrivateInterface.TextInputState.focusTextInput(this);
+  };
 
-      if (typeof relativeToNativeNode === "number") {
-        // Already a node handle
-        relativeNode = relativeToNativeNode;
-      } else {
-        var nativeNode = relativeToNativeNode;
+  _proto.measure = function measure(callback) {
+    ReactNativePrivateInterface.UIManager.measure(
+      this._nativeTag,
+      mountSafeCallback_NOT_REALLY_SAFE(this, callback)
+    );
+  };
 
-        if (nativeNode._nativeTag) {
-          relativeNode = nativeNode._nativeTag;
-        }
-      }
+  _proto.measureInWindow = function measureInWindow(callback) {
+    ReactNativePrivateInterface.UIManager.measureInWindow(
+      this._nativeTag,
+      mountSafeCallback_NOT_REALLY_SAFE(this, callback)
+    );
+  };
 
-      if (relativeNode == null) {
-        {
-          error(
-            "Warning: ref.measureLayout must be called with a node handle or a ref to a native component."
-          );
-        }
+  _proto.measureLayout = function measureLayout(
+    relativeToNativeNode,
+    onSuccess,
+    onFail
+  ) /* currently unused */
+  {
+    var relativeNode;
 
-        return;
-      }
+    if (typeof relativeToNativeNode === "number") {
+      // Already a node handle
+      relativeNode = relativeToNativeNode;
+    } else {
+      var nativeNode = relativeToNativeNode;
 
-      ReactNativePrivateInterface.UIManager.measureLayout(
-        this._nativeTag,
-        relativeNode,
-        mountSafeCallback_NOT_REALLY_SAFE(this, onFail),
-        mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess)
-      );
-    };
+      if (nativeNode._nativeTag) {
+        relativeNode = nativeNode._nativeTag;
+      }
+    }
 
-    _proto.setNativeProps = function setNativeProps(nativeProps) {
+    if (relativeNode == null) {
       {
-        warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
+        error(
+          "Warning: ref.measureLayout must be called with a node handle or a ref to a native component."
+        );
       }
 
-      var updatePayload = create(nativeProps, this.viewConfig.validAttributes); // Avoid the overhead of bridge calls if there's no update.
-      // This is an expensive no-op for Android, and causes an unnecessary
-      // view invalidation for certain components (eg RCTTextInput) on iOS.
+      return;
+    }
 
-      if (updatePayload != null) {
-        ReactNativePrivateInterface.UIManager.updateView(
-          this._nativeTag,
-          this.viewConfig.uiViewClassName,
-          updatePayload
-        );
-      }
-    };
+    ReactNativePrivateInterface.UIManager.measureLayout(
+      this._nativeTag,
+      relativeNode,
+      mountSafeCallback_NOT_REALLY_SAFE(this, onFail),
+      mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess)
+    );
+  };
 
-    return ReactNativeFiberHostComponent;
-  })(); // eslint-disable-next-line no-unused-expressions
+  _proto.setNativeProps = function setNativeProps(nativeProps) {
+    {
+      warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
+    }
+
+    var updatePayload = create(nativeProps, this.viewConfig.validAttributes); // Avoid the overhead of bridge calls if there's no update.
+    // This is an expensive no-op for Android, and causes an unnecessary
+    // view invalidation for certain components (eg RCTTextInput) on iOS.
+
+    if (updatePayload != null) {
+      ReactNativePrivateInterface.UIManager.updateView(
+        this._nativeTag,
+        this.viewConfig.uiViewClassName,
+        updatePayload
+      );
+    }
+  };
+
+  return ReactNativeFiberHostComponent;
+})(); // eslint-disable-next-line no-unused-expressions
 
 // can re-export everything from this module.
 
@@ -4104,6 +4120,7 @@ function getPublicInstance(instance) {
 }
 function prepareForCommit(containerInfo) {
   // Noop
+  return null;
 }
 function prepareUpdate(
   instance,
@@ -4121,9 +4138,6 @@ function resetAfterCommit(containerInfo) {
 var scheduleTimeout = setTimeout;
 var cancelTimeout = clearTimeout;
 var noTimeout = -1;
-function shouldDeprioritizeSubtree(type, props) {
-  return false;
-}
 function shouldSetTextContent(type, props) {
   // TODO (bvaughn) Revisit this decision.
   // Always returning false simplifies the createInstance() implementation,
@@ -4306,525 +4320,239 @@ function unhideInstance(instance, props) {
     updatePayload
   );
 }
+function clearContainer(container) {
+  // TODO Implement this for React Native
+  // UIManager does not expose a "remove all" type method.
+}
 function unhideTextInstance(textInstance, text) {
   throw new Error("Not yet implemented.");
 }
+function makeClientIdInDEV(warnOnAccessInDEV) {
+  throw new Error("Not yet implemented");
+}
+function preparePortalMount(portalInstance) {
+  // noop
+}
 
-var loggedTypeFailures = {};
-function checkPropTypes(typeSpecs, values, location, componentName) {
+var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+function describeBuiltInComponentFrame(name, source, ownerFn) {
   {
-    // $FlowFixMe This is okay but Flow doesn't know it.
-    var has = Function.call.bind(Object.prototype.hasOwnProperty);
-
-    for (var typeSpecName in typeSpecs) {
-      if (has(typeSpecs, typeSpecName)) {
-        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
-        // fail the render phase where it didn't fail before. So we log it.
-        // After these have been cleaned up, we'll let them throw.
-
-        try {
-          // This is intentionally an invariant that gets caught. It's the same
-          // behavior as without this statement except with a better message.
-          if (typeof typeSpecs[typeSpecName] !== "function") {
-            var err = Error(
-              (componentName || "React class") +
-                ": " +
-                location +
-                " type `" +
-                typeSpecName +
-                "` is invalid; " +
-                "it must be a function, usually from the `prop-types` package, but received `" +
-                typeof typeSpecs[typeSpecName] +
-                "`." +
-                "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
-            );
-            err.name = "Invariant Violation";
-            throw err;
-          }
-
-          error$1 = typeSpecs[typeSpecName](
-            values,
-            typeSpecName,
-            componentName,
-            location,
-            null,
-            "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
-          );
-        } catch (ex) {
-          error$1 = ex;
-        }
-
-        if (error$1 && !(error$1 instanceof Error)) {
-          error(
-            "%s: type specification of %s" +
-              " `%s` is invalid; the type checker " +
-              "function must return `null` or an `Error` but returned a %s. " +
-              "You may have forgotten to pass an argument to the type checker " +
-              "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " +
-              "shape all require an argument).",
-            componentName || "React class",
-            location,
-            typeSpecName,
-            typeof error$1
-          );
-        }
-
-        if (
-          error$1 instanceof Error &&
-          !(error$1.message in loggedTypeFailures)
-        ) {
-          // Only monitor this failure once because there tends to be a lot of the
-          // same error.
-          loggedTypeFailures[error$1.message] = true;
+    var ownerName = null;
 
-          error("Failed %s type: %s", location, error$1.message);
-        }
-      }
+    if (ownerFn) {
+      ownerName = ownerFn.displayName || ownerFn.name || null;
     }
-  }
-}
-
-// Prefix measurements so that it's possible to filter them.
-// Longer prefixes are hard to read in DevTools.
-var reactEmoji = "\u269B";
-var warningEmoji = "\u26D4";
-var supportsUserTiming =
-  typeof performance !== "undefined" &&
-  typeof performance.mark === "function" &&
-  typeof performance.clearMarks === "function" &&
-  typeof performance.measure === "function" &&
-  typeof performance.clearMeasures === "function"; // Keep track of current fiber so that we know the path to unwind on pause.
-// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
-
-var currentFiber = null; // If we're in the middle of user code, which fiber and method is it?
-// Reusing `currentFiber` would be confusing for this because user code fiber
-// can change during commit phase too, but we don't need to unwind it (since
-// lifecycles in the commit phase don't resemble a tree).
-
-var currentPhase = null;
-var currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,
-// so we will keep track of it, and include it in the report.
-// Track commits caused by cascading updates.
-
-var isCommitting = false;
-var hasScheduledUpdateInCurrentCommit = false;
-var hasScheduledUpdateInCurrentPhase = false;
-var commitCountInCurrentWorkLoop = 0;
-var effectCountInCurrentCommit = 0;
-// to avoid stretch the commit phase with measurement overhead.
-
-var labelsInCurrentCommit = new Set();
-
-var formatMarkName = function(markName) {
-  return reactEmoji + " " + markName;
-};
-
-var formatLabel = function(label, warning) {
-  var prefix = warning ? warningEmoji + " " : reactEmoji + " ";
-  var suffix = warning ? " Warning: " + warning : "";
-  return "" + prefix + label + suffix;
-};
-
-var beginMark = function(markName) {
-  performance.mark(formatMarkName(markName));
-};
-
-var clearMark = function(markName) {
-  performance.clearMarks(formatMarkName(markName));
-};
-
-var endMark = function(label, markName, warning) {
-  var formattedMarkName = formatMarkName(markName);
-  var formattedLabel = formatLabel(label, warning);
-
-  try {
-    performance.measure(formattedLabel, formattedMarkName);
-  } catch (err) {} // If previous mark was missing for some reason, this will throw.
-  // This could only happen if React crashed in an unexpected place earlier.
-  // Don't pile on with more errors.
-  // Clear marks immediately to avoid growing buffer.
-
-  performance.clearMarks(formattedMarkName);
-  performance.clearMeasures(formattedLabel);
-};
-
-var getFiberMarkName = function(label, debugID) {
-  return label + " (#" + debugID + ")";
-};
-
-var getFiberLabel = function(componentName, isMounted, phase) {
-  if (phase === null) {
-    // These are composite component total time measurements.
-    return componentName + " [" + (isMounted ? "update" : "mount") + "]";
-  } else {
-    // Composite component methods.
-    return componentName + "." + phase;
-  }
-};
-
-var beginFiberMark = function(fiber, phase) {
-  var componentName = getComponentName(fiber.type) || "Unknown";
-  var debugID = fiber._debugID;
-  var isMounted = fiber.alternate !== null;
-  var label = getFiberLabel(componentName, isMounted, phase);
 
-  if (isCommitting && labelsInCurrentCommit.has(label)) {
-    // During the commit phase, we don't show duplicate labels because
-    // there is a fixed overhead for every measurement, and we don't
-    // want to stretch the commit phase beyond necessary.
-    return false;
+    return describeComponentFrame(name, source, ownerName);
   }
+}
+var componentFrameCache;
 
-  labelsInCurrentCommit.add(label);
-  var markName = getFiberMarkName(label, debugID);
-  beginMark(markName);
-  return true;
-};
-
-var clearFiberMark = function(fiber, phase) {
-  var componentName = getComponentName(fiber.type) || "Unknown";
-  var debugID = fiber._debugID;
-  var isMounted = fiber.alternate !== null;
-  var label = getFiberLabel(componentName, isMounted, phase);
-  var markName = getFiberMarkName(label, debugID);
-  clearMark(markName);
-};
-
-var endFiberMark = function(fiber, phase, warning) {
-  var componentName = getComponentName(fiber.type) || "Unknown";
-  var debugID = fiber._debugID;
-  var isMounted = fiber.alternate !== null;
-  var label = getFiberLabel(componentName, isMounted, phase);
-  var markName = getFiberMarkName(label, debugID);
-  endMark(label, markName, warning);
-};
-
-var shouldIgnoreFiber = function(fiber) {
-  // Host components should be skipped in the timeline.
-  // We could check typeof fiber.type, but does this work with RN?
-  switch (fiber.tag) {
-    case HostRoot:
-    case HostComponent:
-    case HostText:
-    case HostPortal:
-    case Fragment:
-    case ContextProvider:
-    case ContextConsumer:
-    case Mode:
-      return true;
+{
+  var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
+  componentFrameCache = new PossiblyWeakMap();
+}
+var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
 
-    default:
-      return false;
-  }
-};
+function describeComponentFrame(name, source, ownerName) {
+  var sourceInfo = "";
 
-var clearPendingPhaseMeasurement = function() {
-  if (currentPhase !== null && currentPhaseFiber !== null) {
-    clearFiberMark(currentPhaseFiber, currentPhase);
-  }
+  if (source) {
+    var path = source.fileName;
+    var fileName = path.replace(BEFORE_SLASH_RE, ""); // In DEV, include code for a common special case:
+    // prefer "folder/index.js" instead of just "index.js".
 
-  currentPhaseFiber = null;
-  currentPhase = null;
-  hasScheduledUpdateInCurrentPhase = false;
-};
+    if (/^index\./.test(fileName)) {
+      var match = path.match(BEFORE_SLASH_RE);
 
-var pauseTimers = function() {
-  // Stops all currently active measurements so that they can be resumed
-  // if we continue in a later deferred loop from the same unit of work.
-  var fiber = currentFiber;
+      if (match) {
+        var pathBeforeSlash = match[1];
 
-  while (fiber) {
-    if (fiber._debugIsCurrentlyTiming) {
-      endFiberMark(fiber, null, null);
+        if (pathBeforeSlash) {
+          var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
+          fileName = folderName + "/" + fileName;
+        }
+      }
     }
 
-    fiber = fiber.return;
-  }
-};
-
-var resumeTimersRecursively = function(fiber) {
-  if (fiber.return !== null) {
-    resumeTimersRecursively(fiber.return);
-  }
-
-  if (fiber._debugIsCurrentlyTiming) {
-    beginFiberMark(fiber, null);
+    sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
+  } else if (ownerName) {
+    sourceInfo = " (created by " + ownerName + ")";
   }
-};
 
-var resumeTimers = function() {
-  // Resumes all measurements that were active during the last deferred loop.
-  if (currentFiber !== null) {
-    resumeTimersRecursively(currentFiber);
-  }
-};
+  return "\n    in " + (name || "Unknown") + sourceInfo;
+}
 
-function recordEffect() {
+function describeClassComponentFrame(ctor, source, ownerFn) {
   {
-    effectCountInCurrentCommit++;
+    return describeFunctionComponentFrame(ctor, source, ownerFn);
   }
 }
-function recordScheduleUpdate() {
+function describeFunctionComponentFrame(fn, source, ownerFn) {
   {
-    if (isCommitting) {
-      hasScheduledUpdateInCurrentCommit = true;
-    }
-
-    if (
-      currentPhase !== null &&
-      currentPhase !== "componentWillMount" &&
-      currentPhase !== "componentWillReceiveProps"
-    ) {
-      hasScheduledUpdateInCurrentPhase = true;
+    if (!fn) {
+      return "";
     }
-  }
-}
-function startWorkTimer(fiber) {
-  {
-    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
-      return;
-    } // If we pause, this is the fiber to unwind from.
 
-    currentFiber = fiber;
+    var name = fn.displayName || fn.name || null;
+    var ownerName = null;
 
-    if (!beginFiberMark(fiber, null)) {
-      return;
+    if (ownerFn) {
+      ownerName = ownerFn.displayName || ownerFn.name || null;
     }
 
-    fiber._debugIsCurrentlyTiming = true;
-  }
-}
-function cancelWorkTimer(fiber) {
-  {
-    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
-      return;
-    } // Remember we shouldn't complete measurement for this fiber.
-    // Otherwise flamechart will be deep even for small updates.
-
-    fiber._debugIsCurrentlyTiming = false;
-    clearFiberMark(fiber, null);
+    return describeComponentFrame(name, source, ownerName);
   }
 }
-function stopWorkTimer(fiber) {
-  {
-    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
-      return;
-    } // If we pause, its parent is the fiber to unwind from.
-
-    currentFiber = fiber.return;
-
-    if (!fiber._debugIsCurrentlyTiming) {
-      return;
-    }
 
-    fiber._debugIsCurrentlyTiming = false;
-    endFiberMark(fiber, null, null);
+function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
+  if (type == null) {
+    return "";
   }
-}
-function stopFailedWorkTimer(fiber) {
-  {
-    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
-      return;
-    } // If we pause, its parent is the fiber to unwind from.
 
-    currentFiber = fiber.return;
-
-    if (!fiber._debugIsCurrentlyTiming) {
-      return;
+  if (typeof type === "function") {
+    {
+      return describeFunctionComponentFrame(type, source, ownerFn);
     }
-
-    fiber._debugIsCurrentlyTiming = false;
-    var warning =
-      fiber.tag === SuspenseComponent
-        ? "Rendering was suspended"
-        : "An error was thrown inside this error boundary";
-    endFiberMark(fiber, null, warning);
   }
-}
-function startPhaseTimer(fiber, phase) {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    clearPendingPhaseMeasurement();
 
-    if (!beginFiberMark(fiber, phase)) {
-      return;
-    }
-
-    currentPhaseFiber = fiber;
-    currentPhase = phase;
+  if (typeof type === "string") {
+    return describeBuiltInComponentFrame(type, source, ownerFn);
   }
-}
-function stopPhaseTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
 
-    if (currentPhase !== null && currentPhaseFiber !== null) {
-      var warning = hasScheduledUpdateInCurrentPhase
-        ? "Scheduled a cascading update"
-        : null;
-      endFiberMark(currentPhaseFiber, currentPhase, warning);
-    }
+  switch (type) {
+    case REACT_SUSPENSE_TYPE:
+      return describeBuiltInComponentFrame("Suspense", source, ownerFn);
 
-    currentPhase = null;
-    currentPhaseFiber = null;
+    case REACT_SUSPENSE_LIST_TYPE:
+      return describeBuiltInComponentFrame("SuspenseList", source, ownerFn);
   }
-}
-function startWorkLoopTimer(nextUnitOfWork) {
-  {
-    currentFiber = nextUnitOfWork;
-
-    if (!supportsUserTiming) {
-      return;
-    }
 
-    commitCountInCurrentWorkLoop = 0; // This is top level call.
-    // Any other measurements are performed within.
-
-    beginMark("(React Tree Reconciliation)"); // Resume any measurements that were in progress during the last loop.
+  if (typeof type === "object") {
+    switch (type.$$typeof) {
+      case REACT_FORWARD_REF_TYPE:
+        return describeFunctionComponentFrame(type.render, source, ownerFn);
 
-    resumeTimers();
-  }
-}
-function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
+      case REACT_MEMO_TYPE:
+        // Memo may contain any component type so we recursively resolve it.
+        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
 
-    var warning = null;
+      case REACT_LAZY_TYPE: {
+        var lazyComponent = type;
+        var payload = lazyComponent._payload;
+        var init = lazyComponent._init;
 
-    if (interruptedBy !== null) {
-      if (interruptedBy.tag === HostRoot) {
-        warning = "A top-level update interrupted the previous render";
-      } else {
-        var componentName = getComponentName(interruptedBy.type) || "Unknown";
-        warning =
-          "An update to " + componentName + " interrupted the previous render";
+        try {
+          // Lazy may contain any component type so we recursively resolve it.
+          return describeUnknownElementTypeFrameInDEV(
+            init(payload),
+            source,
+            ownerFn
+          );
+        } catch (x) {}
       }
-    } else if (commitCountInCurrentWorkLoop > 1) {
-      warning = "There were cascading updates";
     }
-
-    commitCountInCurrentWorkLoop = 0;
-    var label = didCompleteRoot
-      ? "(React Tree Reconciliation: Completed Root)"
-      : "(React Tree Reconciliation: Yielded)"; // Pause any measurements until the next loop.
-
-    pauseTimers();
-    endMark(label, "(React Tree Reconciliation)", warning);
   }
+
+  return "";
 }
-function startCommitTimer() {
+
+var loggedTypeFailures = {};
+var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+
+function setCurrentlyValidatingElement(element) {
   {
-    if (!supportsUserTiming) {
-      return;
+    if (element) {
+      var owner = element._owner;
+      var stack = describeUnknownElementTypeFrameInDEV(
+        element.type,
+        element._source,
+        owner ? owner.type : null
+      );
+      ReactDebugCurrentFrame.setExtraStackFrame(stack);
+    } else {
+      ReactDebugCurrentFrame.setExtraStackFrame(null);
     }
-
-    isCommitting = true;
-    hasScheduledUpdateInCurrentCommit = false;
-    labelsInCurrentCommit.clear();
-    beginMark("(Committing Changes)");
   }
 }
-function stopCommitTimer() {
+
+function checkPropTypes(typeSpecs, values, location, componentName, element) {
   {
-    if (!supportsUserTiming) {
-      return;
-    }
+    // $FlowFixMe This is okay but Flow doesn't know it.
+    var has = Function.call.bind(Object.prototype.hasOwnProperty);
 
-    var warning = null;
+    for (var typeSpecName in typeSpecs) {
+      if (has(typeSpecs, typeSpecName)) {
+        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
+        // fail the render phase where it didn't fail before. So we log it.
+        // After these have been cleaned up, we'll let them throw.
 
-    if (hasScheduledUpdateInCurrentCommit) {
-      warning = "Lifecycle hook scheduled a cascading update";
-    } else if (commitCountInCurrentWorkLoop > 0) {
-      warning = "Caused by a cascading update in earlier commit";
-    }
+        try {
+          // This is intentionally an invariant that gets caught. It's the same
+          // behavior as without this statement except with a better message.
+          if (typeof typeSpecs[typeSpecName] !== "function") {
+            var err = Error(
+              (componentName || "React class") +
+                ": " +
+                location +
+                " type `" +
+                typeSpecName +
+                "` is invalid; " +
+                "it must be a function, usually from the `prop-types` package, but received `" +
+                typeof typeSpecs[typeSpecName] +
+                "`." +
+                "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
+            );
+            err.name = "Invariant Violation";
+            throw err;
+          }
 
-    hasScheduledUpdateInCurrentCommit = false;
-    commitCountInCurrentWorkLoop++;
-    isCommitting = false;
-    labelsInCurrentCommit.clear();
-    endMark("(Committing Changes)", "(Committing Changes)", warning);
-  }
-}
-function startCommitSnapshotEffectsTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
+          error$1 = typeSpecs[typeSpecName](
+            values,
+            typeSpecName,
+            componentName,
+            location,
+            null,
+            "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
+          );
+        } catch (ex) {
+          error$1 = ex;
+        }
 
-    effectCountInCurrentCommit = 0;
-    beginMark("(Committing Snapshot Effects)");
-  }
-}
-function stopCommitSnapshotEffectsTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
+        if (error$1 && !(error$1 instanceof Error)) {
+          setCurrentlyValidatingElement(element);
 
-    var count = effectCountInCurrentCommit;
-    effectCountInCurrentCommit = 0;
-    endMark(
-      "(Committing Snapshot Effects: " + count + " Total)",
-      "(Committing Snapshot Effects)",
-      null
-    );
-  }
-}
-function startCommitHostEffectsTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
+          error(
+            "%s: type specification of %s" +
+              " `%s` is invalid; the type checker " +
+              "function must return `null` or an `Error` but returned a %s. " +
+              "You may have forgotten to pass an argument to the type checker " +
+              "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " +
+              "shape all require an argument).",
+            componentName || "React class",
+            location,
+            typeSpecName,
+            typeof error$1
+          );
 
-    effectCountInCurrentCommit = 0;
-    beginMark("(Committing Host Effects)");
-  }
-}
-function stopCommitHostEffectsTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
+          setCurrentlyValidatingElement(null);
+        }
 
-    var count = effectCountInCurrentCommit;
-    effectCountInCurrentCommit = 0;
-    endMark(
-      "(Committing Host Effects: " + count + " Total)",
-      "(Committing Host Effects)",
-      null
-    );
-  }
-}
-function startCommitLifeCyclesTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
+        if (
+          error$1 instanceof Error &&
+          !(error$1.message in loggedTypeFailures)
+        ) {
+          // Only monitor this failure once because there tends to be a lot of the
+          // same error.
+          loggedTypeFailures[error$1.message] = true;
+          setCurrentlyValidatingElement(element);
 
-    effectCountInCurrentCommit = 0;
-    beginMark("(Calling Lifecycle Methods)");
-  }
-}
-function stopCommitLifeCyclesTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
+          error("Failed %s type: %s", location, error$1.message);
 
-    var count = effectCountInCurrentCommit;
-    effectCountInCurrentCommit = 0;
-    endMark(
-      "(Calling Lifecycle Methods: " + count + " Total)",
-      "(Calling Lifecycle Methods)",
-      null
-    );
+          setCurrentlyValidatingElement(null);
+        }
+      }
+    }
   }
 }
 
@@ -5031,10 +4759,7 @@ function processChildContext(fiber, type, parentContext) {
       return parentContext;
     }
 
-    var childContext;
-    startPhaseTimer(fiber, "getChildContext");
-    childContext = instance.getChildContext();
-    stopPhaseTimer();
+    var childContext = instance.getChildContext();
 
     for (var contextKey in childContext) {
       if (!(contextKey in childContextTypes)) {
@@ -5052,7 +4777,7 @@ function processChildContext(fiber, type, parentContext) {
       checkPropTypes(childContextTypes, childContext, "child context", name);
     }
 
-    return Object.assign({}, parentContext, {}, childContext);
+    return Object.assign({}, parentContext, childContext);
   }
 }
 
@@ -5155,20 +4880,112 @@ var LegacyRoot = 0;
 var BlockingRoot = 1;
 var ConcurrentRoot = 2;
 
+var rendererID = null;
+var injectedHook = null;
+var hasLoggedError = false;
+var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
+function injectInternals(internals) {
+  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
+    // No DevTools
+    return false;
+  }
+
+  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+
+  if (hook.isDisabled) {
+    // This isn't a real property on the hook, but it can be set to opt out
+    // of DevTools integration and associated warnings and logs.
+    // https://github.com/facebook/react/issues/3877
+    return true;
+  }
+
+  if (!hook.supportsFiber) {
+    {
+      error(
+        "The installed version of React DevTools is too old and will not work " +
+          "with the current version of React. Please update React DevTools. " +
+          "https://reactjs.org/link/react-devtools"
+      );
+    } // DevTools exists, even though it doesn't support Fiber.
+
+    return true;
+  }
+
+  try {
+    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
+
+    injectedHook = hook;
+  } catch (err) {
+    // Catch all errors because it is unsafe to throw during initialization.
+    {
+      error("React instrumentation encountered an error: %s.", err);
+    }
+  } // DevTools exists
+
+  return true;
+}
+function onScheduleRoot(root, children) {
+  {
+    if (
+      injectedHook &&
+      typeof injectedHook.onScheduleFiberRoot === "function"
+    ) {
+      try {
+        injectedHook.onScheduleFiberRoot(rendererID, root, children);
+      } catch (err) {
+        if (!hasLoggedError) {
+          hasLoggedError = true;
+
+          error("React instrumentation encountered an error: %s", err);
+        }
+      }
+    }
+  }
+}
+function onCommitRoot(root, priorityLevel) {
+  if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
+    try {
+      var didError = (root.current.flags & DidCapture) === DidCapture;
+
+      if (enableProfilerTimer) {
+        injectedHook.onCommitFiberRoot(
+          rendererID,
+          root,
+          priorityLevel,
+          didError
+        );
+      } else {
+        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);
+      }
+    } catch (err) {
+      {
+        if (!hasLoggedError) {
+          hasLoggedError = true;
+
+          error("React instrumentation encountered an error: %s", err);
+        }
+      }
+    }
+  }
+}
+function onCommitUnmount(fiber) {
+  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, fiber);
+    } catch (err) {
+      {
+        if (!hasLoggedError) {
+          hasLoggedError = true;
+
+          error("React instrumentation encountered an error: %s", err);
+        }
+      }
+    }
+  }
+}
+
 // Intentionally not named imports because Rollup would use dynamic dispatch for
-var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
-  Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
-  Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
-  Scheduler_shouldYield = Scheduler.unstable_shouldYield,
-  Scheduler_requestPaint = Scheduler.unstable_requestPaint,
-  Scheduler_now = Scheduler.unstable_now,
-  Scheduler_getCurrentPriorityLevel =
-    Scheduler.unstable_getCurrentPriorityLevel,
-  Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
-  Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
-  Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
-  Scheduler_LowPriority = Scheduler.unstable_LowPriority,
-  Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
+var Scheduler_now = Scheduler.unstable_now;
 
 {
   // Provide explicit error message when production+profiling bundle of e.g.
@@ -5181,12 +4998,10 @@ var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
     )
   ) {
     throw Error(
-      "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling"
+      "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling"
     );
   }
 }
-
-var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use
 // ascending numbers so we can compare them like numbers. They start at 90 to
 // avoid clashing with Scheduler's priorities.
 
@@ -5197,1214 +5012,1434 @@ var LowPriority = 96;
 var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.
 
 var NoPriority = 90;
-var shouldYield = Scheduler_shouldYield;
-var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.
-  Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function() {};
-var syncQueue = null;
-var immediateQueueCallbackNode = null;
-var isFlushingSyncQueue = false;
 var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
-// This will be the case for modern browsers that support `performance.now`. In
-// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
-// timestamp. In that case, subtract the module initialization time to simulate
-// the behavior of performance.now and keep our times small enough to fit
-// within 32 bits.
-// TODO: Consider lifting this into Scheduler.
-
-var now =
-  initialTimeMs < 10000
-    ? Scheduler_now
-    : function() {
-        return Scheduler_now() - initialTimeMs;
-      };
-function getCurrentPriorityLevel() {
-  switch (Scheduler_getCurrentPriorityLevel()) {
-    case Scheduler_ImmediatePriority:
-      return ImmediatePriority;
-
-    case Scheduler_UserBlockingPriority:
-      return UserBlockingPriority;
-
-    case Scheduler_NormalPriority:
-      return NormalPriority;
-
-    case Scheduler_LowPriority:
-      return LowPriority;
-
-    case Scheduler_IdlePriority:
-      return IdlePriority;
-
-    default: {
-      throw Error("Unknown priority level.");
-    }
-  }
-}
-
-function reactPriorityToSchedulerPriority(reactPriorityLevel) {
-  switch (reactPriorityLevel) {
-    case ImmediatePriority:
-      return Scheduler_ImmediatePriority;
 
-    case UserBlockingPriority:
-      return Scheduler_UserBlockingPriority;
+var SyncLanePriority = 15;
+var SyncBatchedLanePriority = 14;
+var InputDiscreteHydrationLanePriority = 13;
+var InputDiscreteLanePriority = 12;
+var InputContinuousHydrationLanePriority = 11;
+var InputContinuousLanePriority = 10;
+var DefaultHydrationLanePriority = 9;
+var DefaultLanePriority = 8;
+var TransitionHydrationPriority = 7;
+var TransitionPriority = 6;
+var RetryLanePriority = 5;
+var SelectiveHydrationLanePriority = 4;
+var IdleHydrationLanePriority = 3;
+var IdleLanePriority = 2;
+var OffscreenLanePriority = 1;
+var NoLanePriority = 0;
+var TotalLanes = 31;
+var NoLanes =
+  /*                        */
+  0;
+var NoLane =
+  /*                          */
+  0;
+var SyncLane =
+  /*                        */
+  1;
+var SyncBatchedLane =
+  /*                 */
+  2;
+var InputDiscreteHydrationLane =
+  /*      */
+  4;
+var InputDiscreteLanes =
+  /*                    */
+  24;
+var InputContinuousHydrationLane =
+  /*           */
+  32;
+var InputContinuousLanes =
+  /*                  */
+  192;
+var DefaultHydrationLane =
+  /*            */
+  256;
+var DefaultLanes =
+  /*                   */
+  3584;
+var TransitionHydrationLane =
+  /*                */
+  4096;
+var TransitionLanes =
+  /*                       */
+  4186112;
+var RetryLanes =
+  /*                            */
+  62914560;
+var SomeRetryLane =
+  /*                  */
+  33554432;
+var SelectiveHydrationLane =
+  /*          */
+  67108864;
+var NonIdleLanes =
+  /*                                 */
+  134217727;
+var IdleHydrationLane =
+  /*               */
+  134217728;
+var IdleLanes =
+  /*                             */
+  805306368;
+var OffscreenLane =
+  /*                   */
+  1073741824;
+var NoTimestamp = -1;
+// Used by getHighestPriorityLanes and getNextLanes:
 
-    case NormalPriority:
-      return Scheduler_NormalPriority;
+var return_highestLanePriority = DefaultLanePriority;
 
-    case LowPriority:
-      return Scheduler_LowPriority;
+function getHighestPriorityLanes(lanes) {
+  if ((SyncLane & lanes) !== NoLanes) {
+    return_highestLanePriority = SyncLanePriority;
+    return SyncLane;
+  }
 
-    case IdlePriority:
-      return Scheduler_IdlePriority;
+  if ((SyncBatchedLane & lanes) !== NoLanes) {
+    return_highestLanePriority = SyncBatchedLanePriority;
+    return SyncBatchedLane;
+  }
 
-    default: {
-      throw Error("Unknown priority level.");
-    }
+  if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
+    return_highestLanePriority = InputDiscreteHydrationLanePriority;
+    return InputDiscreteHydrationLane;
   }
-}
 
-function runWithPriority(reactPriorityLevel, fn) {
-  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
-  return Scheduler_runWithPriority(priorityLevel, fn);
-}
-function scheduleCallback(reactPriorityLevel, callback, options) {
-  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
-  return Scheduler_scheduleCallback(priorityLevel, callback, options);
-}
-function scheduleSyncCallback(callback) {
-  // Push this callback into an internal queue. We'll flush these either in
-  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
-  if (syncQueue === null) {
-    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.
+  var inputDiscreteLanes = InputDiscreteLanes & lanes;
 
-    immediateQueueCallbackNode = Scheduler_scheduleCallback(
-      Scheduler_ImmediatePriority,
-      flushSyncCallbackQueueImpl
-    );
-  } else {
-    // Push onto existing queue. Don't need to schedule a callback because
-    // we already scheduled one when we created the queue.
-    syncQueue.push(callback);
+  if (inputDiscreteLanes !== NoLanes) {
+    return_highestLanePriority = InputDiscreteLanePriority;
+    return inputDiscreteLanes;
   }
 
-  return fakeCallbackNode;
-}
-function cancelCallback(callbackNode) {
-  if (callbackNode !== fakeCallbackNode) {
-    Scheduler_cancelCallback(callbackNode);
-  }
-}
-function flushSyncCallbackQueue() {
-  if (immediateQueueCallbackNode !== null) {
-    var node = immediateQueueCallbackNode;
-    immediateQueueCallbackNode = null;
-    Scheduler_cancelCallback(node);
+  if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
+    return_highestLanePriority = InputContinuousHydrationLanePriority;
+    return InputContinuousHydrationLane;
   }
 
-  flushSyncCallbackQueueImpl();
-}
-
-function flushSyncCallbackQueueImpl() {
-  if (!isFlushingSyncQueue && syncQueue !== null) {
-    // Prevent re-entrancy.
-    isFlushingSyncQueue = true;
-    var i = 0;
-
-    try {
-      var _isSync = true;
-      var queue = syncQueue;
-      runWithPriority(ImmediatePriority, function() {
-        for (; i < queue.length; i++) {
-          var callback = queue[i];
+  var inputContinuousLanes = InputContinuousLanes & lanes;
 
-          do {
-            callback = callback(_isSync);
-          } while (callback !== null);
-        }
-      });
-      syncQueue = null;
-    } catch (error) {
-      // If something throws, leave the remaining callbacks on the queue.
-      if (syncQueue !== null) {
-        syncQueue = syncQueue.slice(i + 1);
-      } // Resume flushing in the next tick
-
-      Scheduler_scheduleCallback(
-        Scheduler_ImmediatePriority,
-        flushSyncCallbackQueue
-      );
-      throw error;
-    } finally {
-      isFlushingSyncQueue = false;
-    }
+  if (inputContinuousLanes !== NoLanes) {
+    return_highestLanePriority = InputContinuousLanePriority;
+    return inputContinuousLanes;
   }
-}
 
-var NoMode = 0;
-var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
-// tag instead
+  if ((lanes & DefaultHydrationLane) !== NoLanes) {
+    return_highestLanePriority = DefaultHydrationLanePriority;
+    return DefaultHydrationLane;
+  }
 
-var BlockingMode = 2;
-var ConcurrentMode = 4;
-var ProfileMode = 8;
+  var defaultLanes = DefaultLanes & lanes;
 
-// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
-// Math.pow(2, 30) - 1
-// 0b111111111111111111111111111111
-var MAX_SIGNED_31_BIT_INT = 1073741823;
+  if (defaultLanes !== NoLanes) {
+    return_highestLanePriority = DefaultLanePriority;
+    return defaultLanes;
+  }
 
-var NoWork = 0; // TODO: Think of a better name for Never. The key difference with Idle is that
-// Never work can be committed in an inconsistent state without tearing the UI.
-// The main example is offscreen content, like a hidden subtree. So one possible
-// name is Offscreen. However, it also includes dehydrated Suspense boundaries,
-// which are inconsistent in the sense that they haven't finished yet, but
-// aren't visibly inconsistent because the server rendered HTML matches what the
-// hydrated tree would look like.
+  if ((lanes & TransitionHydrationLane) !== NoLanes) {
+    return_highestLanePriority = TransitionHydrationPriority;
+    return TransitionHydrationLane;
+  }
 
-var Never = 1; // Idle is slightly higher priority than Never. It must completely finish in
-// order to be consistent.
+  var transitionLanes = TransitionLanes & lanes;
 
-var Idle = 2; // Continuous Hydration is slightly higher than Idle and is used to increase
-var Sync = MAX_SIGNED_31_BIT_INT;
-var Batched = Sync - 1;
-var UNIT_SIZE = 10;
-var MAGIC_NUMBER_OFFSET = Batched - 1; // 1 unit of expiration time represents 10ms.
+  if (transitionLanes !== NoLanes) {
+    return_highestLanePriority = TransitionPriority;
+    return transitionLanes;
+  }
 
-function msToExpirationTime(ms) {
-  // Always subtract from the offset so that we don't clash with the magic number for NoWork.
-  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);
-}
-function expirationTimeToMs(expirationTime) {
-  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
-}
+  var retryLanes = RetryLanes & lanes;
 
-function ceiling(num, precision) {
-  return (((num / precision) | 0) + 1) * precision;
-}
+  if (retryLanes !== NoLanes) {
+    return_highestLanePriority = RetryLanePriority;
+    return retryLanes;
+  }
 
-function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
-  return (
-    MAGIC_NUMBER_OFFSET -
-    ceiling(
-      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,
-      bucketSizeMs / UNIT_SIZE
-    )
-  );
-} // TODO: This corresponds to Scheduler's NormalPriority, not LowPriority. Update
-// the names to reflect.
-
-var LOW_PRIORITY_EXPIRATION = 5000;
-var LOW_PRIORITY_BATCH_SIZE = 250;
-function computeAsyncExpiration(currentTime) {
-  return computeExpirationBucket(
-    currentTime,
-    LOW_PRIORITY_EXPIRATION,
-    LOW_PRIORITY_BATCH_SIZE
-  );
-}
-function computeSuspenseExpiration(currentTime, timeoutMs) {
-  // TODO: Should we warn if timeoutMs is lower than the normal pri expiration time?
-  return computeExpirationBucket(
-    currentTime,
-    timeoutMs,
-    LOW_PRIORITY_BATCH_SIZE
-  );
-} // We intentionally set a higher expiration time for interactive updates in
-// dev than in production.
-//
-// If the main thread is being blocked so long that you hit the expiration,
-// it's a problem that could be solved with better scheduling.
-//
-// People will be more likely to notice this and fix it with the long
-// expiration time in development.
-//
-// In production we opt for better UX at the risk of masking scheduling
-// problems, by expiring fast.
-
-var HIGH_PRIORITY_EXPIRATION = 500;
-var HIGH_PRIORITY_BATCH_SIZE = 100;
-function computeInteractiveExpiration(currentTime) {
-  return computeExpirationBucket(
-    currentTime,
-    HIGH_PRIORITY_EXPIRATION,
-    HIGH_PRIORITY_BATCH_SIZE
-  );
-}
-function inferPriorityFromExpirationTime(currentTime, expirationTime) {
-  if (expirationTime === Sync) {
-    return ImmediatePriority;
+  if (lanes & SelectiveHydrationLane) {
+    return_highestLanePriority = SelectiveHydrationLanePriority;
+    return SelectiveHydrationLane;
   }
 
-  if (expirationTime === Never || expirationTime === Idle) {
-    return IdlePriority;
+  if ((lanes & IdleHydrationLane) !== NoLanes) {
+    return_highestLanePriority = IdleHydrationLanePriority;
+    return IdleHydrationLane;
   }
 
-  var msUntil =
-    expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);
+  var idleLanes = IdleLanes & lanes;
 
-  if (msUntil <= 0) {
-    return ImmediatePriority;
+  if (idleLanes !== NoLanes) {
+    return_highestLanePriority = IdleLanePriority;
+    return idleLanes;
   }
 
-  if (msUntil <= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {
-    return UserBlockingPriority;
+  if ((OffscreenLane & lanes) !== NoLanes) {
+    return_highestLanePriority = OffscreenLanePriority;
+    return OffscreenLane;
   }
 
-  if (msUntil <= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {
-    return NormalPriority;
-  } // TODO: Handle LowPriority
-  // Assume anything lower has idle priority
+  {
+    error("Should have found matching lanes. This is a bug in React.");
+  } // This shouldn't be reachable, but as a fallback, return the entire bitmask.
 
-  return IdlePriority;
+  return_highestLanePriority = DefaultLanePriority;
+  return lanes;
 }
 
-/**
- * inlined Object.is polyfill to avoid requiring consumers ship their own
- * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
- */
-function is(x, y) {
-  return (
-    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
-  );
-}
+function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
+  switch (schedulerPriorityLevel) {
+    case ImmediatePriority:
+      return SyncLanePriority;
 
-var objectIs = typeof Object.is === "function" ? Object.is : is;
+    case UserBlockingPriority:
+      return InputContinuousLanePriority;
 
-var hasOwnProperty = Object.prototype.hasOwnProperty;
-/**
- * Performs equality by iterating through keys on an object and returning false
- * when any key has values which are not strictly equal between the arguments.
- * Returns true when the values of all keys are strictly equal.
- */
+    case NormalPriority:
+    case LowPriority:
+      // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
+      return DefaultLanePriority;
 
-function shallowEqual(objA, objB) {
-  if (objectIs(objA, objB)) {
-    return true;
-  }
+    case IdlePriority:
+      return IdleLanePriority;
 
-  if (
-    typeof objA !== "object" ||
-    objA === null ||
-    typeof objB !== "object" ||
-    objB === null
-  ) {
-    return false;
+    default:
+      return NoLanePriority;
   }
+}
+function lanePriorityToSchedulerPriority(lanePriority) {
+  switch (lanePriority) {
+    case SyncLanePriority:
+    case SyncBatchedLanePriority:
+      return ImmediatePriority;
 
-  var keysA = Object.keys(objA);
-  var keysB = Object.keys(objB);
+    case InputDiscreteHydrationLanePriority:
+    case InputDiscreteLanePriority:
+    case InputContinuousHydrationLanePriority:
+    case InputContinuousLanePriority:
+      return UserBlockingPriority;
 
-  if (keysA.length !== keysB.length) {
-    return false;
-  } // Test for A's keys different from B.
+    case DefaultHydrationLanePriority:
+    case DefaultLanePriority:
+    case TransitionHydrationPriority:
+    case TransitionPriority:
+    case SelectiveHydrationLanePriority:
+    case RetryLanePriority:
+      return NormalPriority;
 
-  for (var i = 0; i < keysA.length; i++) {
-    if (
-      !hasOwnProperty.call(objB, keysA[i]) ||
-      !objectIs(objA[keysA[i]], objB[keysA[i]])
-    ) {
-      return false;
+    case IdleHydrationLanePriority:
+    case IdleLanePriority:
+    case OffscreenLanePriority:
+      return IdlePriority;
+
+    case NoLanePriority:
+      return NoPriority;
+
+    default: {
+      throw Error(
+        "Invalid update priority: " + lanePriority + ". This is a bug in React."
+      );
     }
   }
-
-  return true;
 }
+function getNextLanes(root, wipLanes) {
+  // Early bailout if there's no pending work left.
+  var pendingLanes = root.pendingLanes;
 
-var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
-function describeComponentFrame(name, source, ownerName) {
-  var sourceInfo = "";
+  if (pendingLanes === NoLanes) {
+    return_highestLanePriority = NoLanePriority;
+    return NoLanes;
+  }
 
-  if (source) {
-    var path = source.fileName;
-    var fileName = path.replace(BEFORE_SLASH_RE, "");
+  var nextLanes = NoLanes;
+  var nextLanePriority = NoLanePriority;
+  var expiredLanes = root.expiredLanes;
+  var suspendedLanes = root.suspendedLanes;
+  var pingedLanes = root.pingedLanes; // Check if any work has expired.
 
-    {
-      // In DEV, include code for a common special case:
-      // prefer "folder/index.js" instead of just "index.js".
-      if (/^index\./.test(fileName)) {
-        var match = path.match(BEFORE_SLASH_RE);
+  if (expiredLanes !== NoLanes) {
+    nextLanes = expiredLanes;
+    nextLanePriority = return_highestLanePriority = SyncLanePriority;
+  } else {
+    // Do not work on any idle work until all the non-idle work has finished,
+    // even if the work is suspended.
+    var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
 
-        if (match) {
-          var pathBeforeSlash = match[1];
+    if (nonIdlePendingLanes !== NoLanes) {
+      var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
 
-          if (pathBeforeSlash) {
-            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
-            fileName = folderName + "/" + fileName;
-          }
+      if (nonIdleUnblockedLanes !== NoLanes) {
+        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
+        nextLanePriority = return_highestLanePriority;
+      } else {
+        var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
+
+        if (nonIdlePingedLanes !== NoLanes) {
+          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
+          nextLanePriority = return_highestLanePriority;
         }
       }
-    }
+    } else {
+      // The only remaining work is Idle.
+      var unblockedLanes = pendingLanes & ~suspendedLanes;
 
-    sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
-  } else if (ownerName) {
-    sourceInfo = " (created by " + ownerName + ")";
+      if (unblockedLanes !== NoLanes) {
+        nextLanes = getHighestPriorityLanes(unblockedLanes);
+        nextLanePriority = return_highestLanePriority;
+      } else {
+        if (pingedLanes !== NoLanes) {
+          nextLanes = getHighestPriorityLanes(pingedLanes);
+          nextLanePriority = return_highestLanePriority;
+        }
+      }
+    }
   }
 
-  return "\n    in " + (name || "Unknown") + sourceInfo;
-}
+  if (nextLanes === NoLanes) {
+    // This should only be reachable if we're suspended
+    // TODO: Consider warning in this path if a fallback timer is not scheduled.
+    return NoLanes;
+  } // If there are higher priority lanes, we'll include them even if they
+  // are suspended.
 
-var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+  nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt
+  // it and we'll lose our progress. We should only do this if the new lanes are
+  // higher priority.
 
-function describeFiber(fiber) {
-  switch (fiber.tag) {
-    case HostRoot:
-    case HostPortal:
-    case HostText:
-    case Fragment:
-    case ContextProvider:
-    case ContextConsumer:
-      return "";
+  if (
+    wipLanes !== NoLanes &&
+    wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
+    // bother waiting until the root is complete.
+    (wipLanes & suspendedLanes) === NoLanes
+  ) {
+    getHighestPriorityLanes(wipLanes);
+    var wipLanePriority = return_highestLanePriority;
 
-    default:
-      var owner = fiber._debugOwner;
-      var source = fiber._debugSource;
-      var name = getComponentName(fiber.type);
-      var ownerName = null;
+    if (nextLanePriority <= wipLanePriority) {
+      return wipLanes;
+    } else {
+      return_highestLanePriority = nextLanePriority;
+    }
+  } // Check for entangled lanes and add them to the batch.
+  //
+  // A lane is said to be entangled with another when it's not allowed to render
+  // in a batch that does not also include the other lane. Typically we do this
+  // when multiple updates have the same source, and we only want to respond to
+  // the most recent event from that source.
+  //
+  // Note that we apply entanglements *after* checking for partial work above.
+  // This means that if a lane is entangled during an interleaved event while
+  // it's already rendering, we won't interrupt it. This is intentional, since
+  // entanglement is usually "best effort": we'll try our best to render the
+  // lanes in the same batch, but it's not worth throwing out partially
+  // completed work in order to do it.
+  //
+  // For those exceptions where entanglement is semantically important, like
+  // useMutableSource, we should ensure that there is no partial work at the
+  // time we apply the entanglement.
 
-      if (owner) {
-        ownerName = getComponentName(owner.type);
-      }
+  var entangledLanes = root.entangledLanes;
 
-      return describeComponentFrame(name, source, ownerName);
+  if (entangledLanes !== NoLanes) {
+    var entanglements = root.entanglements;
+    var lanes = nextLanes & entangledLanes;
+
+    while (lanes > 0) {
+      var index = pickArbitraryLaneIndex(lanes);
+      var lane = 1 << index;
+      nextLanes |= entanglements[index];
+      lanes &= ~lane;
+    }
   }
+
+  return nextLanes;
 }
+function getMostRecentEventTime(root, lanes) {
+  var eventTimes = root.eventTimes;
+  var mostRecentEventTime = NoTimestamp;
 
-function getStackByFiberInDevAndProd(workInProgress) {
-  var info = "";
-  var node = workInProgress;
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    var eventTime = eventTimes[index];
 
-  do {
-    info += describeFiber(node);
-    node = node.return;
-  } while (node);
+    if (eventTime > mostRecentEventTime) {
+      mostRecentEventTime = eventTime;
+    }
+
+    lanes &= ~lane;
+  }
 
-  return info;
+  return mostRecentEventTime;
 }
-var current = null;
-var isRendering = false;
-function getCurrentFiberOwnerNameInDevOrNull() {
-  {
-    if (current === null) {
-      return null;
-    }
 
-    var owner = current._debugOwner;
+function computeExpirationTime(lane, currentTime) {
+  // TODO: Expiration heuristic is constant per lane, so could use a map.
+  getHighestPriorityLanes(lane);
+  var priority = return_highestLanePriority;
 
-    if (owner !== null && typeof owner !== "undefined") {
-      return getComponentName(owner.type);
+  if (priority >= InputContinuousLanePriority) {
+    // User interactions should expire slightly more quickly.
+    //
+    // NOTE: This is set to the corresponding constant as in Scheduler.js. When
+    // we made it larger, a product metric in www regressed, suggesting there's
+    // a user interaction that's being starved by a series of synchronous
+    // updates. If that theory is correct, the proper solution is to fix the
+    // starvation. However, this scenario supports the idea that expiration
+    // times are an important safeguard when starvation does happen.
+    //
+    // Also note that, in the case of user input specifically, this will soon no
+    // longer be an issue because we plan to make user input synchronous by
+    // default (until you enter `startTransition`, of course.)
+    //
+    // If weren't planning to make these updates synchronous soon anyway, I
+    // would probably make this number a configurable parameter.
+    return currentTime + 250;
+  } else if (priority >= TransitionPriority) {
+    return currentTime + 5000;
+  } else {
+    // Anything idle priority or lower should never expire.
+    return NoTimestamp;
+  }
+}
+
+function markStarvedLanesAsExpired(root, currentTime) {
+  // TODO: This gets called every time we yield. We can optimize by storing
+  // the earliest expiration time on the root. Then use that to quickly bail out
+  // of this function.
+  var pendingLanes = root.pendingLanes;
+  var suspendedLanes = root.suspendedLanes;
+  var pingedLanes = root.pingedLanes;
+  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
+  // expiration time. If so, we'll assume the update is being starved and mark
+  // it as expired to force it to finish.
+
+  var lanes = pendingLanes;
+
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    var expirationTime = expirationTimes[index];
+
+    if (expirationTime === NoTimestamp) {
+      // Found a pending lane with no expiration time. If it's not suspended, or
+      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
+      // using the current time.
+      if (
+        (lane & suspendedLanes) === NoLanes ||
+        (lane & pingedLanes) !== NoLanes
+      ) {
+        // Assumes timestamps are monotonically increasing.
+        expirationTimes[index] = computeExpirationTime(lane, currentTime);
+      }
+    } else if (expirationTime <= currentTime) {
+      // This lane expired
+      root.expiredLanes |= lane;
     }
+
+    lanes &= ~lane;
   }
+} // This returns the highest priority pending lanes regardless of whether they
+function getLanesToRetrySynchronouslyOnError(root) {
+  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
 
-  return null;
-}
-function getCurrentFiberStackInDev() {
-  {
-    if (current === null) {
-      return "";
-    } // Safe because if current fiber exists, we are reconciling,
-    // and it is guaranteed to be the work-in-progress version.
+  if (everythingButOffscreen !== NoLanes) {
+    return everythingButOffscreen;
+  }
 
-    return getStackByFiberInDevAndProd(current);
+  if (everythingButOffscreen & OffscreenLane) {
+    return OffscreenLane;
   }
+
+  return NoLanes;
 }
-function resetCurrentFiber() {
-  {
-    ReactDebugCurrentFrame.getCurrentStack = null;
-    current = null;
-    isRendering = false;
-  }
+function returnNextLanesPriority() {
+  return return_highestLanePriority;
 }
-function setCurrentFiber(fiber) {
-  {
-    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
-    current = fiber;
-    isRendering = false;
-  }
+function includesNonIdleWork(lanes) {
+  return (lanes & NonIdleLanes) !== NoLanes;
 }
-function setIsRendering(rendering) {
-  {
-    isRendering = rendering;
-  }
+function includesOnlyRetries(lanes) {
+  return (lanes & RetryLanes) === lanes;
 }
+function includesOnlyTransitions(lanes) {
+  return (lanes & TransitionLanes) === lanes;
+} // To ensure consistency across multiple updates in the same event, this should
+// be a pure function, so that it always returns the same lane for given inputs.
+
+function findUpdateLane(lanePriority, wipLanes) {
+  switch (lanePriority) {
+    case NoLanePriority:
+      break;
 
-var ReactStrictModeWarnings = {
-  recordUnsafeLifecycleWarnings: function(fiber, instance) {},
-  flushPendingUnsafeLifecycleWarnings: function() {},
-  recordLegacyContextWarning: function(fiber, instance) {},
-  flushLegacyContextWarning: function() {},
-  discardPendingWarnings: function() {}
-};
+    case SyncLanePriority:
+      return SyncLane;
 
-{
-  var findStrictRoot = function(fiber) {
-    var maybeStrictRoot = null;
-    var node = fiber;
+    case SyncBatchedLanePriority:
+      return SyncBatchedLane;
 
-    while (node !== null) {
-      if (node.mode & StrictMode) {
-        maybeStrictRoot = node;
+    case InputDiscreteLanePriority: {
+      var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
+
+      if (_lane === NoLane) {
+        // Shift to the next priority level
+        return findUpdateLane(InputContinuousLanePriority, wipLanes);
       }
 
-      node = node.return;
+      return _lane;
     }
 
-    return maybeStrictRoot;
-  };
+    case InputContinuousLanePriority: {
+      var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
 
-  var setToSortedString = function(set) {
-    var array = [];
-    set.forEach(function(value) {
-      array.push(value);
-    });
-    return array.sort().join(", ");
-  };
+      if (_lane2 === NoLane) {
+        // Shift to the next priority level
+        return findUpdateLane(DefaultLanePriority, wipLanes);
+      }
 
-  var pendingComponentWillMountWarnings = [];
-  var pendingUNSAFE_ComponentWillMountWarnings = [];
-  var pendingComponentWillReceivePropsWarnings = [];
-  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
-  var pendingComponentWillUpdateWarnings = [];
-  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.
+      return _lane2;
+    }
 
-  var didWarnAboutUnsafeLifecycles = new Set();
+    case DefaultLanePriority: {
+      var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
 
-  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(
-    fiber,
-    instance
-  ) {
-    // Dedup strategy: Warn once per component.
-    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
-      return;
-    }
+      if (_lane3 === NoLane) {
+        // If all the default lanes are already being worked on, look for a
+        // lane in the transition range.
+        _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);
 
-    if (
-      typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
-      instance.componentWillMount.__suppressDeprecationWarning !== true
-    ) {
-      pendingComponentWillMountWarnings.push(fiber);
-    }
+        if (_lane3 === NoLane) {
+          // All the transition lanes are taken, too. This should be very
+          // rare, but as a last resort, pick a default lane. This will have
+          // the effect of interrupting the current work-in-progress render.
+          _lane3 = pickArbitraryLane(DefaultLanes);
+        }
+      }
 
-    if (
-      fiber.mode & StrictMode &&
-      typeof instance.UNSAFE_componentWillMount === "function"
-    ) {
-      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
+      return _lane3;
     }
 
-    if (
-      typeof instance.componentWillReceiveProps === "function" &&
-      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
-    ) {
-      pendingComponentWillReceivePropsWarnings.push(fiber);
-    }
+    case TransitionPriority: // Should be handled by findTransitionLane instead
 
-    if (
-      fiber.mode & StrictMode &&
-      typeof instance.UNSAFE_componentWillReceiveProps === "function"
-    ) {
-      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
-    }
+    case RetryLanePriority:
+      // Should be handled by findRetryLane instead
+      break;
 
-    if (
-      typeof instance.componentWillUpdate === "function" &&
-      instance.componentWillUpdate.__suppressDeprecationWarning !== true
-    ) {
-      pendingComponentWillUpdateWarnings.push(fiber);
-    }
+    case IdleLanePriority:
+      var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
 
-    if (
-      fiber.mode & StrictMode &&
-      typeof instance.UNSAFE_componentWillUpdate === "function"
-    ) {
-      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
-    }
-  };
+      if (lane === NoLane) {
+        lane = pickArbitraryLane(IdleLanes);
+      }
 
-  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
-    // We do an initial pass to gather component names
-    var componentWillMountUniqueNames = new Set();
+      return lane;
+  }
 
-    if (pendingComponentWillMountWarnings.length > 0) {
-      pendingComponentWillMountWarnings.forEach(function(fiber) {
-        componentWillMountUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingComponentWillMountWarnings = [];
-    }
+  {
+    throw Error(
+      "Invalid update priority: " + lanePriority + ". This is a bug in React."
+    );
+  }
+} // To ensure consistency across multiple updates in the same event, this should
+// be pure function, so that it always returns the same lane for given inputs.
 
-    var UNSAFE_componentWillMountUniqueNames = new Set();
+function findTransitionLane(wipLanes, pendingLanes) {
+  // First look for lanes that are completely unclaimed, i.e. have no
+  // pending work.
+  var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
 
-    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
-      pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
-        UNSAFE_componentWillMountUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingUNSAFE_ComponentWillMountWarnings = [];
+  if (lane === NoLane) {
+    // If all lanes have pending work, look for a lane that isn't currently
+    // being worked on.
+    lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
+
+    if (lane === NoLane) {
+      // If everything is being worked on, pick any lane. This has the
+      // effect of interrupting the current work-in-progress.
+      lane = pickArbitraryLane(TransitionLanes);
     }
+  }
 
-    var componentWillReceivePropsUniqueNames = new Set();
+  return lane;
+} // To ensure consistency across multiple updates in the same event, this should
+// be pure function, so that it always returns the same lane for given inputs.
 
-    if (pendingComponentWillReceivePropsWarnings.length > 0) {
-      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
-        componentWillReceivePropsUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingComponentWillReceivePropsWarnings = [];
-    }
+function findRetryLane(wipLanes) {
+  // This is a fork of `findUpdateLane` designed specifically for Suspense
+  // "retries"  a special update that attempts to flip a Suspense boundary
+  // from its placeholder state to its primary/resolved state.
+  var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
 
-    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
+  if (lane === NoLane) {
+    lane = pickArbitraryLane(RetryLanes);
+  }
 
-    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
-      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
-        UNSAFE_componentWillReceivePropsUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
-    }
+  return lane;
+}
 
-    var componentWillUpdateUniqueNames = new Set();
+function getHighestPriorityLane(lanes) {
+  return lanes & -lanes;
+}
 
-    if (pendingComponentWillUpdateWarnings.length > 0) {
-      pendingComponentWillUpdateWarnings.forEach(function(fiber) {
-        componentWillUpdateUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingComponentWillUpdateWarnings = [];
-    }
+function getLowestPriorityLane(lanes) {
+  // This finds the most significant non-zero bit.
+  var index = 31 - clz32(lanes);
+  return index < 0 ? NoLanes : 1 << index;
+}
 
-    var UNSAFE_componentWillUpdateUniqueNames = new Set();
+function getEqualOrHigherPriorityLanes(lanes) {
+  return (getLowestPriorityLane(lanes) << 1) - 1;
+}
 
-    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
-      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
-        UNSAFE_componentWillUpdateUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingUNSAFE_ComponentWillUpdateWarnings = [];
-    } // Finally, we flush all the warnings
-    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
+function pickArbitraryLane(lanes) {
+  // This wrapper function gets inlined. Only exists so to communicate that it
+  // doesn't matter which bit is selected; you can pick any bit without
+  // affecting the algorithms where its used. Here I'm using
+  // getHighestPriorityLane because it requires the fewest operations.
+  return getHighestPriorityLane(lanes);
+}
 
-    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
-      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
+function pickArbitraryLaneIndex(lanes) {
+  return 31 - clz32(lanes);
+}
 
-      error(
-        "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
-          "\nPlease update the following components: %s",
-        sortedNames
-      );
-    }
+function laneToIndex(lane) {
+  return pickArbitraryLaneIndex(lane);
+}
 
-    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
-      var _sortedNames = setToSortedString(
-        UNSAFE_componentWillReceivePropsUniqueNames
-      );
+function includesSomeLane(a, b) {
+  return (a & b) !== NoLanes;
+}
+function isSubsetOfLanes(set, subset) {
+  return (set & subset) === subset;
+}
+function mergeLanes(a, b) {
+  return a | b;
+}
+function removeLanes(set, subset) {
+  return set & ~subset;
+} // Seems redundant, but it changes the type from a single lane (used for
+// updates) to a group of lanes (used for flushing work).
 
-      error(
-        "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended " +
-          "and may indicate bugs in your code. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move data fetching code or side effects to componentDidUpdate.\n" +
-          "* If you're updating state whenever props change, " +
-          "refactor your code to use memoization techniques or move it to " +
-          "static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames
-      );
-    }
+function laneToLanes(lane) {
+  return lane;
+}
+function createLaneMap(initial) {
+  // Intentionally pushing one by one.
+  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
+  var laneMap = [];
 
-    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
-      var _sortedNames2 = setToSortedString(
-        UNSAFE_componentWillUpdateUniqueNames
-      );
+  for (var i = 0; i < TotalLanes; i++) {
+    laneMap.push(initial);
+  }
 
-      error(
-        "Using UNSAFE_componentWillUpdate in strict mode is not recommended " +
-          "and may indicate bugs in your code. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move data fetching code or side effects to componentDidUpdate.\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames2
-      );
-    }
+  return laneMap;
+}
+function markRootUpdated(root, updateLane, eventTime) {
+  root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But
+  // it's not practical to try every single possible combination. We need a
+  // heuristic to decide which lanes to attempt to render, and in which batches.
+  // For now, we use the same heuristic as in the old ExpirationTimes model:
+  // retry any lane at equal or lower priority, but don't try updates at higher
+  // priority without also including the lower priority updates. This works well
+  // when considering updates across different priority levels, but isn't
+  // sufficient for updates within the same priority, since we want to treat
+  // those updates as parallel.
+  // Unsuspend any update at equal or lower priority.
 
-    if (componentWillMountUniqueNames.size > 0) {
-      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
+  var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111
+
+  root.suspendedLanes &= higherPriorityLanes;
+  root.pingedLanes &= higherPriorityLanes;
+  var eventTimes = root.eventTimes;
+  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
+  // recent event, and we assume time is monotonically increasing.
+
+  eventTimes[index] = eventTime;
+}
+function markRootSuspended(root, suspendedLanes) {
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.
+
+  var expirationTimes = root.expirationTimes;
+  var lanes = suspendedLanes;
+
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    expirationTimes[index] = NoTimestamp;
+    lanes &= ~lane;
+  }
+}
+function markRootPinged(root, pingedLanes, eventTime) {
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+}
+function hasDiscreteLanes(lanes) {
+  return (lanes & InputDiscreteLanes) !== NoLanes;
+}
+function markRootMutableRead(root, updateLane) {
+  root.mutableReadLanes |= updateLane & root.pendingLanes;
+}
+function markRootFinished(root, remainingLanes) {
+  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
+  root.pendingLanes = remainingLanes; // Let's try everything again
+
+  root.suspendedLanes = 0;
+  root.pingedLanes = 0;
+  root.expiredLanes &= remainingLanes;
+  root.mutableReadLanes &= remainingLanes;
+  root.entangledLanes &= remainingLanes;
+  var entanglements = root.entanglements;
+  var eventTimes = root.eventTimes;
+  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work
+
+  var lanes = noLongerPendingLanes;
+
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    entanglements[index] = NoLanes;
+    eventTimes[index] = NoTimestamp;
+    expirationTimes[index] = NoTimestamp;
+    lanes &= ~lane;
+  }
+}
+function markRootEntangled(root, entangledLanes) {
+  root.entangledLanes |= entangledLanes;
+  var entanglements = root.entanglements;
+  var lanes = entangledLanes;
+
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    entanglements[index] |= entangledLanes;
+    lanes &= ~lane;
+  }
+}
+var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.
+// Based on:
+// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
+
+var log = Math.log;
+var LN2 = Math.LN2;
+
+function clz32Fallback(lanes) {
+  if (lanes === 0) {
+    return 32;
+  }
+
+  return (31 - ((log(lanes) / LN2) | 0)) | 0;
+}
+
+// Intentionally not named imports because Rollup would use dynamic dispatch for
+var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
+  Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
+  Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
+  Scheduler_shouldYield = Scheduler.unstable_shouldYield,
+  Scheduler_requestPaint = Scheduler.unstable_requestPaint,
+  Scheduler_now$1 = Scheduler.unstable_now,
+  Scheduler_getCurrentPriorityLevel =
+    Scheduler.unstable_getCurrentPriorityLevel,
+  Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
+  Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
+  Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
+  Scheduler_LowPriority = Scheduler.unstable_LowPriority,
+  Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
+
+{
+  // Provide explicit error message when production+profiling bundle of e.g.
+  // react-dom is used with production (non-profiling) bundle of
+  // scheduler/tracing
+  if (
+    !(
+      tracing.__interactionsRef != null &&
+      tracing.__interactionsRef.current != null
+    )
+  ) {
+    throw Error(
+      "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling"
+    );
+  }
+}
+
+var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use
+// ascending numbers so we can compare them like numbers. They start at 90 to
+// avoid clashing with Scheduler's priorities.
 
-      warn(
-        "componentWillMount has been renamed, and is not recommended for use. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
-          "* Rename componentWillMount to UNSAFE_componentWillMount to suppress " +
-          "this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. " +
-          "To rename all deprecated lifecycles to their new names, you can run " +
-          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames3
-      );
-    }
+var ImmediatePriority$1 = 99;
+var UserBlockingPriority$1 = 98;
+var NormalPriority$1 = 97;
+var LowPriority$1 = 96;
+var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.
 
-    if (componentWillReceivePropsUniqueNames.size > 0) {
-      var _sortedNames4 = setToSortedString(
-        componentWillReceivePropsUniqueNames
-      );
+var NoPriority$1 = 90;
+var shouldYield = Scheduler_shouldYield;
+var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.
+  Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function() {};
+var syncQueue = null;
+var immediateQueueCallbackNode = null;
+var isFlushingSyncQueue = false;
+var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
+// This will be the case for modern browsers that support `performance.now`. In
+// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
+// timestamp. In that case, subtract the module initialization time to simulate
+// the behavior of performance.now and keep our times small enough to fit
+// within 32 bits.
+// TODO: Consider lifting this into Scheduler.
 
-      warn(
-        "componentWillReceiveProps has been renamed, and is not recommended for use. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move data fetching code or side effects to componentDidUpdate.\n" +
-          "* If you're updating state whenever props change, refactor your " +
-          "code to use memoization techniques or move it to " +
-          "static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n" +
-          "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress " +
-          "this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. " +
-          "To rename all deprecated lifecycles to their new names, you can run " +
-          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames4
-      );
-    }
+var now =
+  initialTimeMs$1 < 10000
+    ? Scheduler_now$1
+    : function() {
+        return Scheduler_now$1() - initialTimeMs$1;
+      };
+function getCurrentPriorityLevel() {
+  switch (Scheduler_getCurrentPriorityLevel()) {
+    case Scheduler_ImmediatePriority:
+      return ImmediatePriority$1;
 
-    if (componentWillUpdateUniqueNames.size > 0) {
-      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
+    case Scheduler_UserBlockingPriority:
+      return UserBlockingPriority$1;
 
-      warn(
-        "componentWillUpdate has been renamed, and is not recommended for use. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move data fetching code or side effects to componentDidUpdate.\n" +
-          "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress " +
-          "this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. " +
-          "To rename all deprecated lifecycles to their new names, you can run " +
-          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames5
-      );
-    }
-  };
+    case Scheduler_NormalPriority:
+      return NormalPriority$1;
 
-  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.
+    case Scheduler_LowPriority:
+      return LowPriority$1;
 
-  var didWarnAboutLegacyContext = new Set();
+    case Scheduler_IdlePriority:
+      return IdlePriority$1;
 
-  ReactStrictModeWarnings.recordLegacyContextWarning = function(
-    fiber,
-    instance
-  ) {
-    var strictRoot = findStrictRoot(fiber);
+    default: {
+      throw Error("Unknown priority level.");
+    }
+  }
+}
 
-    if (strictRoot === null) {
-      error(
-        "Expected to find a StrictMode component in a strict mode tree. " +
-          "This error is likely caused by a bug in React. Please file an issue."
-      );
+function reactPriorityToSchedulerPriority(reactPriorityLevel) {
+  switch (reactPriorityLevel) {
+    case ImmediatePriority$1:
+      return Scheduler_ImmediatePriority;
 
-      return;
-    } // Dedup strategy: Warn once per component.
+    case UserBlockingPriority$1:
+      return Scheduler_UserBlockingPriority;
 
-    if (didWarnAboutLegacyContext.has(fiber.type)) {
-      return;
-    }
+    case NormalPriority$1:
+      return Scheduler_NormalPriority;
 
-    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
+    case LowPriority$1:
+      return Scheduler_LowPriority;
 
-    if (
-      fiber.type.contextTypes != null ||
-      fiber.type.childContextTypes != null ||
-      (instance !== null && typeof instance.getChildContext === "function")
-    ) {
-      if (warningsForRoot === undefined) {
-        warningsForRoot = [];
-        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
-      }
+    case IdlePriority$1:
+      return Scheduler_IdlePriority;
 
-      warningsForRoot.push(fiber);
+    default: {
+      throw Error("Unknown priority level.");
     }
-  };
+  }
+}
 
-  ReactStrictModeWarnings.flushLegacyContextWarning = function() {
-    pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
-      if (fiberArray.length === 0) {
-        return;
-      }
+function runWithPriority(reactPriorityLevel, fn) {
+  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
+  return Scheduler_runWithPriority(priorityLevel, fn);
+}
+function scheduleCallback(reactPriorityLevel, callback, options) {
+  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
+  return Scheduler_scheduleCallback(priorityLevel, callback, options);
+}
+function scheduleSyncCallback(callback) {
+  // Push this callback into an internal queue. We'll flush these either in
+  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
+  if (syncQueue === null) {
+    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.
 
-      var firstFiber = fiberArray[0];
-      var uniqueNames = new Set();
-      fiberArray.forEach(function(fiber) {
-        uniqueNames.add(getComponentName(fiber.type) || "Component");
-        didWarnAboutLegacyContext.add(fiber.type);
-      });
-      var sortedNames = setToSortedString(uniqueNames);
-      var firstComponentStack = getStackByFiberInDevAndProd(firstFiber);
+    immediateQueueCallbackNode = Scheduler_scheduleCallback(
+      Scheduler_ImmediatePriority,
+      flushSyncCallbackQueueImpl
+    );
+  } else {
+    // Push onto existing queue. Don't need to schedule a callback because
+    // we already scheduled one when we created the queue.
+    syncQueue.push(callback);
+  }
 
-      error(
-        "Legacy context API has been detected within a strict-mode tree." +
-          "\n\nThe old API will be supported in all 16.x releases, but applications " +
-          "using it should migrate to the new version." +
-          "\n\nPlease update the following components: %s" +
-          "\n\nLearn more about this warning here: https://fb.me/react-legacy-context" +
-          "%s",
-        sortedNames,
-        firstComponentStack
-      );
-    });
-  };
+  return fakeCallbackNode;
+}
+function cancelCallback(callbackNode) {
+  if (callbackNode !== fakeCallbackNode) {
+    Scheduler_cancelCallback(callbackNode);
+  }
+}
+function flushSyncCallbackQueue() {
+  if (immediateQueueCallbackNode !== null) {
+    var node = immediateQueueCallbackNode;
+    immediateQueueCallbackNode = null;
+    Scheduler_cancelCallback(node);
+  }
 
-  ReactStrictModeWarnings.discardPendingWarnings = function() {
-    pendingComponentWillMountWarnings = [];
-    pendingUNSAFE_ComponentWillMountWarnings = [];
-    pendingComponentWillReceivePropsWarnings = [];
-    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
-    pendingComponentWillUpdateWarnings = [];
-    pendingUNSAFE_ComponentWillUpdateWarnings = [];
-    pendingLegacyContextWarning = new Map();
-  };
+  flushSyncCallbackQueueImpl();
 }
 
-var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.
+function flushSyncCallbackQueueImpl() {
+  if (!isFlushingSyncQueue && syncQueue !== null) {
+    // Prevent re-entrancy.
+    isFlushingSyncQueue = true;
+    var i = 0;
 
-var failedBoundaries = null;
-var setRefreshHandler = function(handler) {
-  {
-    resolveFamily = handler;
-  }
-};
-function resolveFunctionForHotReloading(type) {
-  {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return type;
+    {
+      try {
+        var _isSync2 = true;
+        var _queue = syncQueue;
+        runWithPriority(ImmediatePriority$1, function() {
+          for (; i < _queue.length; i++) {
+            var callback = _queue[i];
+
+            do {
+              callback = callback(_isSync2);
+            } while (callback !== null);
+          }
+        });
+        syncQueue = null;
+      } catch (error) {
+        // If something throws, leave the remaining callbacks on the queue.
+        if (syncQueue !== null) {
+          syncQueue = syncQueue.slice(i + 1);
+        } // Resume flushing in the next tick
+
+        Scheduler_scheduleCallback(
+          Scheduler_ImmediatePriority,
+          flushSyncCallbackQueue
+        );
+        throw error;
+      } finally {
+        isFlushingSyncQueue = false;
+      }
     }
+  }
+}
 
-    var family = resolveFamily(type);
+// TODO: this is special because it gets imported during build.
+var ReactVersion = "17.0.1-454c2211c";
 
-    if (family === undefined) {
-      return type;
-    } // Use the latest known implementation.
+var NoMode = 0;
+var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
+// tag instead
 
-    return family.current;
-  }
+var BlockingMode = 2;
+var ConcurrentMode = 4;
+var ProfileMode = 8;
+var DebugTracingMode = 16;
+
+var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
+var NoTransition = 0;
+function requestCurrentTransition() {
+  return ReactCurrentBatchConfig.transition;
 }
-function resolveClassForHotReloading(type) {
-  // No implementation differences.
-  return resolveFunctionForHotReloading(type);
+
+/**
+ * inlined Object.is polyfill to avoid requiring consumers ship their own
+ * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
+ */
+function is(x, y) {
+  return (
+    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
+  );
 }
-function resolveForwardRefForHotReloading(type) {
-  {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return type;
-    }
 
-    var family = resolveFamily(type);
+var objectIs = typeof Object.is === "function" ? Object.is : is;
 
-    if (family === undefined) {
-      // Check if we're dealing with a real forwardRef. Don't want to crash early.
-      if (
-        type !== null &&
-        type !== undefined &&
-        typeof type.render === "function"
-      ) {
-        // ForwardRef is special because its resolved .type is an object,
-        // but it's possible that we only have its inner render function in the map.
-        // If that inner render function is different, we'll build a new forwardRef type.
-        var currentRender = resolveFunctionForHotReloading(type.render);
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+/**
+ * Performs equality by iterating through keys on an object and returning false
+ * when any key has values which are not strictly equal between the arguments.
+ * Returns true when the values of all keys are strictly equal.
+ */
 
-        if (type.render !== currentRender) {
-          var syntheticType = {
-            $$typeof: REACT_FORWARD_REF_TYPE,
-            render: currentRender
-          };
+function shallowEqual(objA, objB) {
+  if (objectIs(objA, objB)) {
+    return true;
+  }
 
-          if (type.displayName !== undefined) {
-            syntheticType.displayName = type.displayName;
-          }
+  if (
+    typeof objA !== "object" ||
+    objA === null ||
+    typeof objB !== "object" ||
+    objB === null
+  ) {
+    return false;
+  }
 
-          return syntheticType;
-        }
-      }
+  var keysA = Object.keys(objA);
+  var keysB = Object.keys(objB);
 
-      return type;
-    } // Use the latest known implementation.
+  if (keysA.length !== keysB.length) {
+    return false;
+  } // Test for A's keys different from B.
 
-    return family.current;
-  }
-}
-function isCompatibleFamilyForHotReloading(fiber, element) {
-  {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
+  for (var i = 0; i < keysA.length; i++) {
+    if (
+      !hasOwnProperty.call(objB, keysA[i]) ||
+      !objectIs(objA[keysA[i]], objB[keysA[i]])
+    ) {
       return false;
     }
+  }
 
-    var prevType = fiber.elementType;
-    var nextType = element.type; // If we got here, we know types aren't === equal.
-
-    var needsCompareFamilies = false;
-    var $$typeofNextType =
-      typeof nextType === "object" && nextType !== null
-        ? nextType.$$typeof
-        : null;
+  return true;
+}
 
-    switch (fiber.tag) {
-      case ClassComponent: {
-        if (typeof nextType === "function") {
-          needsCompareFamilies = true;
-        }
+function describeFiber(fiber) {
+  var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
+  var source = fiber._debugSource;
 
-        break;
-      }
+  switch (fiber.tag) {
+    case HostComponent:
+      return describeBuiltInComponentFrame(fiber.type, source, owner);
 
-      case FunctionComponent: {
-        if (typeof nextType === "function") {
-          needsCompareFamilies = true;
-        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
-          // We don't know the inner type yet.
-          // We're going to assume that the lazy inner type is stable,
-          // and so it is sufficient to avoid reconciling it away.
-          // We're not going to unwrap or actually use the new lazy type.
-          needsCompareFamilies = true;
-        }
+    case LazyComponent:
+      return describeBuiltInComponentFrame("Lazy", source, owner);
 
-        break;
-      }
+    case SuspenseComponent:
+      return describeBuiltInComponentFrame("Suspense", source, owner);
 
-      case ForwardRef: {
-        if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
-          needsCompareFamilies = true;
-        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
-          needsCompareFamilies = true;
-        }
+    case SuspenseListComponent:
+      return describeBuiltInComponentFrame("SuspenseList", source, owner);
 
-        break;
-      }
+    case FunctionComponent:
+    case IndeterminateComponent:
+    case SimpleMemoComponent:
+      return describeFunctionComponentFrame(fiber.type, source, owner);
 
-      case MemoComponent:
-      case SimpleMemoComponent: {
-        if ($$typeofNextType === REACT_MEMO_TYPE) {
-          // TODO: if it was but can no longer be simple,
-          // we shouldn't set this.
-          needsCompareFamilies = true;
-        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
-          needsCompareFamilies = true;
-        }
+    case ForwardRef:
+      return describeFunctionComponentFrame(fiber.type.render, source, owner);
 
-        break;
-      }
+    case ClassComponent:
+      return describeClassComponentFrame(fiber.type, source, owner);
 
-      default:
-        return false;
-    } // Check if both types have a family and it's the same one.
+    default:
+      return "";
+  }
+}
 
-    if (needsCompareFamilies) {
-      // Note: memo() and forwardRef() we'll compare outer rather than inner type.
-      // This means both of them need to be registered to preserve state.
-      // If we unwrapped and compared the inner types for wrappers instead,
-      // then we would risk falsely saying two separate memo(Foo)
-      // calls are equivalent because they wrap the same Foo function.
-      var prevFamily = resolveFamily(prevType);
+function getStackByFiberInDevAndProd(workInProgress) {
+  try {
+    var info = "";
+    var node = workInProgress;
 
-      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
-        return true;
-      }
-    }
+    do {
+      info += describeFiber(node);
+      node = node.return;
+    } while (node);
 
-    return false;
+    return info;
+  } catch (x) {
+    return "\nError generating stack: " + x.message + "\n" + x.stack;
   }
 }
-function markFailedErrorBoundaryForHotReloading(fiber) {
+
+var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
+var current = null;
+var isRendering = false;
+function getCurrentFiberOwnerNameInDevOrNull() {
   {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return;
+    if (current === null) {
+      return null;
     }
 
-    if (typeof WeakSet !== "function") {
-      return;
-    }
+    var owner = current._debugOwner;
 
-    if (failedBoundaries === null) {
-      failedBoundaries = new WeakSet();
+    if (owner !== null && typeof owner !== "undefined") {
+      return getComponentName(owner.type);
     }
+  }
 
-    failedBoundaries.add(fiber);
+  return null;
+}
+
+function getCurrentFiberStackInDev() {
+  {
+    if (current === null) {
+      return "";
+    } // Safe because if current fiber exists, we are reconciling,
+    // and it is guaranteed to be the work-in-progress version.
+
+    return getStackByFiberInDevAndProd(current);
   }
 }
-var scheduleRefresh = function(root, update) {
+
+function resetCurrentFiber() {
   {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return;
+    ReactDebugCurrentFrame$1.getCurrentStack = null;
+    current = null;
+    isRendering = false;
+  }
+}
+function setCurrentFiber(fiber) {
+  {
+    ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;
+    current = fiber;
+    isRendering = false;
+  }
+}
+function setIsRendering(rendering) {
+  {
+    isRendering = rendering;
+  }
+}
+function getIsRendering() {
+  {
+    return isRendering;
+  }
+}
+
+var ReactStrictModeWarnings = {
+  recordUnsafeLifecycleWarnings: function(fiber, instance) {},
+  flushPendingUnsafeLifecycleWarnings: function() {},
+  recordLegacyContextWarning: function(fiber, instance) {},
+  flushLegacyContextWarning: function() {},
+  discardPendingWarnings: function() {}
+};
+
+{
+  var findStrictRoot = function(fiber) {
+    var maybeStrictRoot = null;
+    var node = fiber;
+
+    while (node !== null) {
+      if (node.mode & StrictMode) {
+        maybeStrictRoot = node;
+      }
+
+      node = node.return;
     }
 
-    var staleFamilies = update.staleFamilies,
-      updatedFamilies = update.updatedFamilies;
-    flushPassiveEffects();
-    flushSync(function() {
-      scheduleFibersWithFamiliesRecursively(
-        root.current,
-        updatedFamilies,
-        staleFamilies
-      );
+    return maybeStrictRoot;
+  };
+
+  var setToSortedString = function(set) {
+    var array = [];
+    set.forEach(function(value) {
+      array.push(value);
     });
-  }
-};
-var scheduleRoot = function(root, element) {
-  {
-    if (root.context !== emptyContextObject) {
-      // Super edge case: root has a legacy _renderSubtree context
-      // but we don't know the parentComponent so we can't pass it.
-      // Just ignore. We'll delete this with _renderSubtree code path later.
+    return array.sort().join(", ");
+  };
+
+  var pendingComponentWillMountWarnings = [];
+  var pendingUNSAFE_ComponentWillMountWarnings = [];
+  var pendingComponentWillReceivePropsWarnings = [];
+  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
+  var pendingComponentWillUpdateWarnings = [];
+  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.
+
+  var didWarnAboutUnsafeLifecycles = new Set();
+
+  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(
+    fiber,
+    instance
+  ) {
+    // Dedup strategy: Warn once per component.
+    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
       return;
     }
 
-    flushPassiveEffects();
-    syncUpdates(function() {
-      updateContainer(element, root, null, null);
-    });
-  }
-};
+    if (
+      typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
+      instance.componentWillMount.__suppressDeprecationWarning !== true
+    ) {
+      pendingComponentWillMountWarnings.push(fiber);
+    }
 
-function scheduleFibersWithFamiliesRecursively(
-  fiber,
-  updatedFamilies,
-  staleFamilies
-) {
-  {
-    var alternate = fiber.alternate,
-      child = fiber.child,
-      sibling = fiber.sibling,
-      tag = fiber.tag,
-      type = fiber.type;
-    var candidateType = null;
+    if (
+      fiber.mode & StrictMode &&
+      typeof instance.UNSAFE_componentWillMount === "function"
+    ) {
+      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
+    }
 
-    switch (tag) {
-      case FunctionComponent:
-      case SimpleMemoComponent:
-      case ClassComponent:
-        candidateType = type;
-        break;
+    if (
+      typeof instance.componentWillReceiveProps === "function" &&
+      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
+    ) {
+      pendingComponentWillReceivePropsWarnings.push(fiber);
+    }
 
-      case ForwardRef:
-        candidateType = type.render;
-        break;
+    if (
+      fiber.mode & StrictMode &&
+      typeof instance.UNSAFE_componentWillReceiveProps === "function"
+    ) {
+      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
     }
 
-    if (resolveFamily === null) {
-      throw new Error("Expected resolveFamily to be set during hot reload.");
+    if (
+      typeof instance.componentWillUpdate === "function" &&
+      instance.componentWillUpdate.__suppressDeprecationWarning !== true
+    ) {
+      pendingComponentWillUpdateWarnings.push(fiber);
     }
 
-    var needsRender = false;
-    var needsRemount = false;
+    if (
+      fiber.mode & StrictMode &&
+      typeof instance.UNSAFE_componentWillUpdate === "function"
+    ) {
+      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
+    }
+  };
 
-    if (candidateType !== null) {
-      var family = resolveFamily(candidateType);
+  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
+    // We do an initial pass to gather component names
+    var componentWillMountUniqueNames = new Set();
 
-      if (family !== undefined) {
-        if (staleFamilies.has(family)) {
-          needsRemount = true;
-        } else if (updatedFamilies.has(family)) {
-          if (tag === ClassComponent) {
-            needsRemount = true;
-          } else {
-            needsRender = true;
-          }
-        }
-      }
+    if (pendingComponentWillMountWarnings.length > 0) {
+      pendingComponentWillMountWarnings.forEach(function(fiber) {
+        componentWillMountUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingComponentWillMountWarnings = [];
     }
 
-    if (failedBoundaries !== null) {
-      if (
-        failedBoundaries.has(fiber) ||
-        (alternate !== null && failedBoundaries.has(alternate))
-      ) {
-        needsRemount = true;
-      }
+    var UNSAFE_componentWillMountUniqueNames = new Set();
+
+    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
+      pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
+        UNSAFE_componentWillMountUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingUNSAFE_ComponentWillMountWarnings = [];
     }
 
-    if (needsRemount) {
-      fiber._debugNeedsRemount = true;
+    var componentWillReceivePropsUniqueNames = new Set();
+
+    if (pendingComponentWillReceivePropsWarnings.length > 0) {
+      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
+        componentWillReceivePropsUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingComponentWillReceivePropsWarnings = [];
     }
 
-    if (needsRemount || needsRender) {
-      scheduleWork(fiber, Sync);
+    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
+
+    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
+      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
+        UNSAFE_componentWillReceivePropsUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
     }
 
-    if (child !== null && !needsRemount) {
-      scheduleFibersWithFamiliesRecursively(
-        child,
-        updatedFamilies,
-        staleFamilies
-      );
+    var componentWillUpdateUniqueNames = new Set();
+
+    if (pendingComponentWillUpdateWarnings.length > 0) {
+      pendingComponentWillUpdateWarnings.forEach(function(fiber) {
+        componentWillUpdateUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingComponentWillUpdateWarnings = [];
     }
 
-    if (sibling !== null) {
-      scheduleFibersWithFamiliesRecursively(
-        sibling,
-        updatedFamilies,
-        staleFamilies
+    var UNSAFE_componentWillUpdateUniqueNames = new Set();
+
+    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
+      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
+        UNSAFE_componentWillUpdateUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingUNSAFE_ComponentWillUpdateWarnings = [];
+    } // Finally, we flush all the warnings
+    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
+
+    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
+      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
+
+      error(
+        "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. " +
+          "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+          "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
+          "\nPlease update the following components: %s",
+        sortedNames
       );
     }
-  }
-}
 
-var findHostInstancesForRefresh = function(root, families) {
-  {
-    var hostInstances = new Set();
-    var types = new Set(
-      families.map(function(family) {
-        return family.current;
-      })
-    );
-    findHostInstancesForMatchingFibersRecursively(
-      root.current,
-      types,
-      hostInstances
-    );
-    return hostInstances;
-  }
-};
+    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
+      var _sortedNames = setToSortedString(
+        UNSAFE_componentWillReceivePropsUniqueNames
+      );
 
-function findHostInstancesForMatchingFibersRecursively(
-  fiber,
-  types,
-  hostInstances
-) {
-  {
-    var child = fiber.child,
-      sibling = fiber.sibling,
-      tag = fiber.tag,
-      type = fiber.type;
-    var candidateType = null;
+      error(
+        "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended " +
+          "and may indicate bugs in your code. " +
+          "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+          "* Move data fetching code or side effects to componentDidUpdate.\n" +
+          "* If you're updating state whenever props change, " +
+          "refactor your code to use memoization techniques or move it to " +
+          "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames
+      );
+    }
 
-    switch (tag) {
-      case FunctionComponent:
-      case SimpleMemoComponent:
-      case ClassComponent:
-        candidateType = type;
-        break;
+    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
+      var _sortedNames2 = setToSortedString(
+        UNSAFE_componentWillUpdateUniqueNames
+      );
 
-      case ForwardRef:
-        candidateType = type.render;
-        break;
+      error(
+        "Using UNSAFE_componentWillUpdate in strict mode is not recommended " +
+          "and may indicate bugs in your code. " +
+          "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+          "* Move data fetching code or side effects to componentDidUpdate.\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames2
+      );
     }
 
-    var didMatch = false;
+    if (componentWillMountUniqueNames.size > 0) {
+      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
 
-    if (candidateType !== null) {
-      if (types.has(candidateType)) {
-        didMatch = true;
-      }
+      warn(
+        "componentWillMount has been renamed, and is not recommended for use. " +
+          "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+          "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
+          "* Rename componentWillMount to UNSAFE_componentWillMount to suppress " +
+          "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
+          "To rename all deprecated lifecycles to their new names, you can run " +
+          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames3
+      );
     }
 
-    if (didMatch) {
-      // We have a match. This only drills down to the closest host components.
-      // There's no need to search deeper because for the purpose of giving
-      // visual feedback, "flashing" outermost parent rectangles is sufficient.
-      findHostInstancesForFiberShallowly(fiber, hostInstances);
-    } else {
-      // If there's no match, maybe there will be one further down in the child tree.
-      if (child !== null) {
-        findHostInstancesForMatchingFibersRecursively(
-          child,
-          types,
-          hostInstances
-        );
-      }
+    if (componentWillReceivePropsUniqueNames.size > 0) {
+      var _sortedNames4 = setToSortedString(
+        componentWillReceivePropsUniqueNames
+      );
+
+      warn(
+        "componentWillReceiveProps has been renamed, and is not recommended for use. " +
+          "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+          "* Move data fetching code or side effects to componentDidUpdate.\n" +
+          "* If you're updating state whenever props change, refactor your " +
+          "code to use memoization techniques or move it to " +
+          "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n" +
+          "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress " +
+          "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
+          "To rename all deprecated lifecycles to their new names, you can run " +
+          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames4
+      );
     }
 
-    if (sibling !== null) {
-      findHostInstancesForMatchingFibersRecursively(
-        sibling,
-        types,
-        hostInstances
+    if (componentWillUpdateUniqueNames.size > 0) {
+      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
+
+      warn(
+        "componentWillUpdate has been renamed, and is not recommended for use. " +
+          "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+          "* Move data fetching code or side effects to componentDidUpdate.\n" +
+          "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress " +
+          "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
+          "To rename all deprecated lifecycles to their new names, you can run " +
+          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames5
       );
     }
-  }
-}
+  };
 
-function findHostInstancesForFiberShallowly(fiber, hostInstances) {
-  {
-    var foundHostInstances = findChildHostInstancesForFiberShallowly(
-      fiber,
-      hostInstances
-    );
+  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.
 
-    if (foundHostInstances) {
-      return;
-    } // If we didn't find any host children, fallback to closest host parent.
+  var didWarnAboutLegacyContext = new Set();
 
-    var node = fiber;
+  ReactStrictModeWarnings.recordLegacyContextWarning = function(
+    fiber,
+    instance
+  ) {
+    var strictRoot = findStrictRoot(fiber);
 
-    while (true) {
-      switch (node.tag) {
-        case HostComponent:
-          hostInstances.add(node.stateNode);
-          return;
+    if (strictRoot === null) {
+      error(
+        "Expected to find a StrictMode component in a strict mode tree. " +
+          "This error is likely caused by a bug in React. Please file an issue."
+      );
 
-        case HostPortal:
-          hostInstances.add(node.stateNode.containerInfo);
-          return;
+      return;
+    } // Dedup strategy: Warn once per component.
 
-        case HostRoot:
-          hostInstances.add(node.stateNode.containerInfo);
-          return;
-      }
+    if (didWarnAboutLegacyContext.has(fiber.type)) {
+      return;
+    }
 
-      if (node.return === null) {
-        throw new Error("Expected to reach root first.");
+    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
+
+    if (
+      fiber.type.contextTypes != null ||
+      fiber.type.childContextTypes != null ||
+      (instance !== null && typeof instance.getChildContext === "function")
+    ) {
+      if (warningsForRoot === undefined) {
+        warningsForRoot = [];
+        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
       }
 
-      node = node.return;
+      warningsForRoot.push(fiber);
     }
-  }
-}
-
-function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
-  {
-    var node = fiber;
-    var foundHostInstances = false;
+  };
 
-    while (true) {
-      if (node.tag === HostComponent) {
-        // We got a match.
-        foundHostInstances = true;
-        hostInstances.add(node.stateNode); // There may still be more, so keep searching.
-      } else if (node.child !== null) {
-        node.child.return = node;
-        node = node.child;
-        continue;
+  ReactStrictModeWarnings.flushLegacyContextWarning = function() {
+    pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
+      if (fiberArray.length === 0) {
+        return;
       }
 
-      if (node === fiber) {
-        return foundHostInstances;
-      }
+      var firstFiber = fiberArray[0];
+      var uniqueNames = new Set();
+      fiberArray.forEach(function(fiber) {
+        uniqueNames.add(getComponentName(fiber.type) || "Component");
+        didWarnAboutLegacyContext.add(fiber.type);
+      });
+      var sortedNames = setToSortedString(uniqueNames);
 
-      while (node.sibling === null) {
-        if (node.return === null || node.return === fiber) {
-          return foundHostInstances;
-        }
+      try {
+        setCurrentFiber(firstFiber);
 
-        node = node.return;
+        error(
+          "Legacy context API has been detected within a strict-mode tree." +
+            "\n\nThe old API will be supported in all 16.x releases, but applications " +
+            "using it should migrate to the new version." +
+            "\n\nPlease update the following components: %s" +
+            "\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context",
+          sortedNames
+        );
+      } finally {
+        resetCurrentFiber();
       }
+    });
+  };
 
-      node.sibling.return = node.return;
-      node = node.sibling;
-    }
-  }
-
-  return false;
+  ReactStrictModeWarnings.discardPendingWarnings = function() {
+    pendingComponentWillMountWarnings = [];
+    pendingUNSAFE_ComponentWillMountWarnings = [];
+    pendingComponentWillReceivePropsWarnings = [];
+    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
+    pendingComponentWillUpdateWarnings = [];
+    pendingUNSAFE_ComponentWillUpdateWarnings = [];
+    pendingLegacyContextWarning = new Map();
+  };
 }
 
 function resolveDefaultProps(Component, baseProps) {
@@ -6424,15 +6459,11 @@ function resolveDefaultProps(Component, baseProps) {
 
   return baseProps;
 }
-function readLazyComponentType(lazyComponent) {
-  initializeLazyComponentType(lazyComponent);
-
-  if (lazyComponent._status !== Resolved) {
-    throw lazyComponent._result;
-  }
 
-  return lazyComponent._result;
-}
+// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
+// Math.pow(2, 30) - 1
+// 0b111111111111111111111111111111
+var MAX_SIGNED_31_BIT_INT = 1073741823;
 
 var valueCursor = createCursor(null);
 var rendererSigil;
@@ -6522,28 +6553,24 @@ function calculateChangedBits(context, newValue, oldValue) {
     return changedBits | 0;
   }
 }
-function scheduleWorkOnParentPath(parent, renderExpirationTime) {
-  // Update the child expiration time of all the ancestors, including
-  // the alternates.
+function scheduleWorkOnParentPath(parent, renderLanes) {
+  // Update the child lanes of all the ancestors, including the alternates.
   var node = parent;
 
   while (node !== null) {
     var alternate = node.alternate;
 
-    if (node.childExpirationTime < renderExpirationTime) {
-      node.childExpirationTime = renderExpirationTime;
+    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
+      node.childLanes = mergeLanes(node.childLanes, renderLanes);
 
-      if (
-        alternate !== null &&
-        alternate.childExpirationTime < renderExpirationTime
-      ) {
-        alternate.childExpirationTime = renderExpirationTime;
+      if (alternate !== null) {
+        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
       }
     } else if (
       alternate !== null &&
-      alternate.childExpirationTime < renderExpirationTime
+      !isSubsetOfLanes(alternate.childLanes, renderLanes)
     ) {
-      alternate.childExpirationTime = renderExpirationTime;
+      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
     } else {
       // Neither alternate was updated, which means the rest of the
       // ancestor path already has sufficient priority.
@@ -6557,7 +6584,7 @@ function propagateContextChange(
   workInProgress,
   context,
   changedBits,
-  renderExpirationTime
+  renderLanes
 ) {
   var fiber = workInProgress.child;
 
@@ -6584,7 +6611,10 @@ function propagateContextChange(
           // Match! Schedule an update on this fiber.
           if (fiber.tag === ClassComponent) {
             // Schedule a force update on the work-in-progress.
-            var update = createUpdate(renderExpirationTime, null);
+            var update = createUpdate(
+              NoTimestamp,
+              pickArbitraryLane(renderLanes)
+            );
             update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
             // update to the current fiber, too, which means it will persist even if
             // this render is thrown away. Since it's a race condition, not sure it's
@@ -6593,24 +6623,16 @@ function propagateContextChange(
             enqueueUpdate(fiber, update);
           }
 
-          if (fiber.expirationTime < renderExpirationTime) {
-            fiber.expirationTime = renderExpirationTime;
-          }
-
+          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
           var alternate = fiber.alternate;
 
-          if (
-            alternate !== null &&
-            alternate.expirationTime < renderExpirationTime
-          ) {
-            alternate.expirationTime = renderExpirationTime;
+          if (alternate !== null) {
+            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
           }
 
-          scheduleWorkOnParentPath(fiber.return, renderExpirationTime); // Mark the expiration time on the list, too.
+          scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.
 
-          if (list.expirationTime < renderExpirationTime) {
-            list.expirationTime = renderExpirationTime;
-          } // Since we already found a match, we can stop traversing the
+          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
           // dependency list.
 
           break;
@@ -6656,7 +6678,7 @@ function propagateContextChange(
     fiber = nextFiber;
   }
 }
-function prepareToReadContext(workInProgress, renderExpirationTime) {
+function prepareToReadContext(workInProgress, renderLanes) {
   currentlyRenderingFiber = workInProgress;
   lastContextDependency = null;
   lastContextWithAllBitsObserved = null;
@@ -6666,7 +6688,7 @@ function prepareToReadContext(workInProgress, renderExpirationTime) {
     var firstContext = dependencies.firstContext;
 
     if (firstContext !== null) {
-      if (dependencies.expirationTime >= renderExpirationTime) {
+      if (includesSomeLane(dependencies.lanes, renderLanes)) {
         // Context list has a pending update. Mark that this fiber performed work.
         markWorkInProgressReceivedUpdate();
       } // Reset the work-in-progress list
@@ -6720,7 +6742,7 @@ function readContext(context, observedBits) {
 
       lastContextDependency = contextItem;
       currentlyRenderingFiber.dependencies = {
-        expirationTime: NoWork,
+        lanes: NoLanes,
         firstContext: contextItem,
         responders: null
       };
@@ -6752,7 +6774,8 @@ var currentlyProcessingQueue;
 function initializeUpdateQueue(fiber) {
   var queue = {
     baseState: fiber.memoizedState,
-    baseQueue: null,
+    firstBaseUpdate: null,
+    lastBaseUpdate: null,
     shared: {
       pending: null
     },
@@ -6768,28 +6791,23 @@ function cloneUpdateQueue(current, workInProgress) {
   if (queue === currentQueue) {
     var clone = {
       baseState: currentQueue.baseState,
-      baseQueue: currentQueue.baseQueue,
+      firstBaseUpdate: currentQueue.firstBaseUpdate,
+      lastBaseUpdate: currentQueue.lastBaseUpdate,
       shared: currentQueue.shared,
       effects: currentQueue.effects
     };
     workInProgress.updateQueue = clone;
   }
 }
-function createUpdate(expirationTime, suspenseConfig) {
+function createUpdate(eventTime, lane) {
   var update = {
-    expirationTime: expirationTime,
-    suspenseConfig: suspenseConfig,
+    eventTime: eventTime,
+    lane: lane,
     tag: UpdateState,
     payload: null,
     callback: null,
     next: null
   };
-  update.next = update;
-
-  {
-    update.priority = getCurrentPriorityLevel();
-  }
-
   return update;
 }
 function enqueueUpdate(fiber, update) {
@@ -6829,25 +6847,84 @@ function enqueueUpdate(fiber, update) {
     }
   }
 }
-function enqueueCapturedUpdate(workInProgress, update) {
+function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
+  // Captured updates are updates that are thrown by a child during the render
+  // phase. They should be discarded if the render is aborted. Therefore,
+  // we should only put them on the work-in-progress queue, not the current one.
+  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.
+
   var current = workInProgress.alternate;
 
   if (current !== null) {
-    // Ensure the work-in-progress queue is a clone
-    cloneUpdateQueue(current, workInProgress);
-  } // Captured updates go only on the work-in-progress queue.
+    var currentQueue = current.updateQueue;
+
+    if (queue === currentQueue) {
+      // The work-in-progress queue is the same as current. This happens when
+      // we bail out on a parent fiber that then captures an error thrown by
+      // a child. Since we want to append the update only to the work-in
+      // -progress queue, we need to clone the updates. We usually clone during
+      // processUpdateQueue, but that didn't happen in this case because we
+      // skipped over the parent when we bailed out.
+      var newFirst = null;
+      var newLast = null;
+      var firstBaseUpdate = queue.firstBaseUpdate;
+
+      if (firstBaseUpdate !== null) {
+        // Loop through the updates and clone them.
+        var update = firstBaseUpdate;
+
+        do {
+          var clone = {
+            eventTime: update.eventTime,
+            lane: update.lane,
+            tag: update.tag,
+            payload: update.payload,
+            callback: update.callback,
+            next: null
+          };
 
-  var queue = workInProgress.updateQueue; // Append the update to the end of the list.
+          if (newLast === null) {
+            newFirst = newLast = clone;
+          } else {
+            newLast.next = clone;
+            newLast = clone;
+          }
 
-  var last = queue.baseQueue;
+          update = update.next;
+        } while (update !== null); // Append the captured update the end of the cloned list.
 
-  if (last === null) {
-    queue.baseQueue = update.next = update;
-    update.next = update;
+        if (newLast === null) {
+          newFirst = newLast = capturedUpdate;
+        } else {
+          newLast.next = capturedUpdate;
+          newLast = capturedUpdate;
+        }
+      } else {
+        // There are no base updates.
+        newFirst = newLast = capturedUpdate;
+      }
+
+      queue = {
+        baseState: currentQueue.baseState,
+        firstBaseUpdate: newFirst,
+        lastBaseUpdate: newLast,
+        shared: currentQueue.shared,
+        effects: currentQueue.effects
+      };
+      workInProgress.updateQueue = queue;
+      return;
+    }
+  } // Append the update to the end of the list.
+
+  var lastBaseUpdate = queue.lastBaseUpdate;
+
+  if (lastBaseUpdate === null) {
+    queue.firstBaseUpdate = capturedUpdate;
   } else {
-    update.next = last.next;
-    last.next = update;
+    lastBaseUpdate.next = capturedUpdate;
   }
+
+  queue.lastBaseUpdate = capturedUpdate;
 }
 
 function getStateFromUpdate(
@@ -6881,8 +6958,8 @@ function getStateFromUpdate(
     }
 
     case CaptureUpdate: {
-      workInProgress.effectTag =
-        (workInProgress.effectTag & ~ShouldCapture) | DidCapture;
+      workInProgress.flags =
+        (workInProgress.flags & ~ShouldCapture) | DidCapture;
     }
     // Intentional fallthrough
 
@@ -6923,161 +7000,163 @@ function getStateFromUpdate(
   return prevState;
 }
 
-function processUpdateQueue(
-  workInProgress,
-  props,
-  instance,
-  renderExpirationTime
-) {
+function processUpdateQueue(workInProgress, props, instance, renderLanes) {
   // This is always non-null on a ClassComponent or HostRoot
   var queue = workInProgress.updateQueue;
   hasForceUpdate = false;
 
   {
     currentlyProcessingQueue = queue.shared;
-  } // The last rebase update that is NOT part of the base state.
+  }
 
-  var baseQueue = queue.baseQueue; // The last pending update that hasn't been processed yet.
+  var firstBaseUpdate = queue.firstBaseUpdate;
+  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.
 
   var pendingQueue = queue.shared.pending;
 
   if (pendingQueue !== null) {
-    // We have new updates that haven't been processed yet.
-    // We'll add them to the base queue.
-    if (baseQueue !== null) {
-      // Merge the pending queue and the base queue.
-      var baseFirst = baseQueue.next;
-      var pendingFirst = pendingQueue.next;
-      baseQueue.next = pendingFirst;
-      pendingQueue.next = baseFirst;
+    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
+    // and last so that it's non-circular.
+
+    var lastPendingUpdate = pendingQueue;
+    var firstPendingUpdate = lastPendingUpdate.next;
+    lastPendingUpdate.next = null; // Append pending updates to base queue
+
+    if (lastBaseUpdate === null) {
+      firstBaseUpdate = firstPendingUpdate;
+    } else {
+      lastBaseUpdate.next = firstPendingUpdate;
     }
 
-    baseQueue = pendingQueue;
-    queue.shared.pending = null; // TODO: Pass `current` as argument
+    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
+    // we need to transfer the updates to that queue, too. Because the base
+    // queue is a singly-linked list with no cycles, we can append to both
+    // lists and take advantage of structural sharing.
+    // TODO: Pass `current` as argument
 
     var current = workInProgress.alternate;
 
     if (current !== null) {
+      // This is always non-null on a ClassComponent or HostRoot
       var currentQueue = current.updateQueue;
+      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
 
-      if (currentQueue !== null) {
-        currentQueue.baseQueue = pendingQueue;
+      if (currentLastBaseUpdate !== lastBaseUpdate) {
+        if (currentLastBaseUpdate === null) {
+          currentQueue.firstBaseUpdate = firstPendingUpdate;
+        } else {
+          currentLastBaseUpdate.next = firstPendingUpdate;
+        }
+
+        currentQueue.lastBaseUpdate = lastPendingUpdate;
       }
     }
   } // These values may change as we process the queue.
 
-  if (baseQueue !== null) {
-    var first = baseQueue.next; // Iterate through the list of updates to compute the result.
+  if (firstBaseUpdate !== null) {
+    // Iterate through the list of updates to compute the result.
+    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
+    // from the original lanes.
 
-    var newState = queue.baseState;
-    var newExpirationTime = NoWork;
+    var newLanes = NoLanes;
     var newBaseState = null;
-    var newBaseQueueFirst = null;
-    var newBaseQueueLast = null;
+    var newFirstBaseUpdate = null;
+    var newLastBaseUpdate = null;
+    var update = firstBaseUpdate;
+
+    do {
+      var updateLane = update.lane;
+      var updateEventTime = update.eventTime;
 
-    if (first !== null) {
-      var update = first;
+      if (!isSubsetOfLanes(renderLanes, updateLane)) {
+        // Priority is insufficient. Skip this update. If this is the first
+        // skipped update, the previous update/state is the new base
+        // update/state.
+        var clone = {
+          eventTime: updateEventTime,
+          lane: updateLane,
+          tag: update.tag,
+          payload: update.payload,
+          callback: update.callback,
+          next: null
+        };
 
-      do {
-        var updateExpirationTime = update.expirationTime;
+        if (newLastBaseUpdate === null) {
+          newFirstBaseUpdate = newLastBaseUpdate = clone;
+          newBaseState = newState;
+        } else {
+          newLastBaseUpdate = newLastBaseUpdate.next = clone;
+        } // Update the remaining priority in the queue.
 
-        if (updateExpirationTime < renderExpirationTime) {
-          // Priority is insufficient. Skip this update. If this is the first
-          // skipped update, the previous update/state is the new base
-          // update/state.
-          var clone = {
-            expirationTime: update.expirationTime,
-            suspenseConfig: update.suspenseConfig,
+        newLanes = mergeLanes(newLanes, updateLane);
+      } else {
+        // This update does have sufficient priority.
+        if (newLastBaseUpdate !== null) {
+          var _clone = {
+            eventTime: updateEventTime,
+            // This update is going to be committed so we never want uncommit
+            // it. Using NoLane works because 0 is a subset of all bitmasks, so
+            // this will never be skipped by the check above.
+            lane: NoLane,
             tag: update.tag,
             payload: update.payload,
             callback: update.callback,
             next: null
           };
+          newLastBaseUpdate = newLastBaseUpdate.next = _clone;
+        } // Process this update.
 
-          if (newBaseQueueLast === null) {
-            newBaseQueueFirst = newBaseQueueLast = clone;
-            newBaseState = newState;
-          } else {
-            newBaseQueueLast = newBaseQueueLast.next = clone;
-          } // Update the remaining priority in the queue.
-
-          if (updateExpirationTime > newExpirationTime) {
-            newExpirationTime = updateExpirationTime;
-          }
-        } else {
-          // This update does have sufficient priority.
-          if (newBaseQueueLast !== null) {
-            var _clone = {
-              expirationTime: Sync,
-              // This update is going to be committed so we never want uncommit it.
-              suspenseConfig: update.suspenseConfig,
-              tag: update.tag,
-              payload: update.payload,
-              callback: update.callback,
-              next: null
-            };
-            newBaseQueueLast = newBaseQueueLast.next = _clone;
-          } // Mark the event time of this update as relevant to this render pass.
-          // TODO: This should ideally use the true event time of this update rather than
-          // its priority which is a derived and not reverseable value.
-          // TODO: We should skip this update if it was already committed but currently
-          // we have no way of detecting the difference between a committed and suspended
-          // update here.
-
-          markRenderEventTimeAndConfig(
-            updateExpirationTime,
-            update.suspenseConfig
-          ); // Process this update.
-
-          newState = getStateFromUpdate(
-            workInProgress,
-            queue,
-            update,
-            newState,
-            props,
-            instance
-          );
-          var callback = update.callback;
+        newState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          newState,
+          props,
+          instance
+        );
+        var callback = update.callback;
 
-          if (callback !== null) {
-            workInProgress.effectTag |= Callback;
-            var effects = queue.effects;
+        if (callback !== null) {
+          workInProgress.flags |= Callback;
+          var effects = queue.effects;
 
-            if (effects === null) {
-              queue.effects = [update];
-            } else {
-              effects.push(update);
-            }
+          if (effects === null) {
+            queue.effects = [update];
+          } else {
+            effects.push(update);
           }
         }
+      }
 
-        update = update.next;
+      update = update.next;
 
-        if (update === null || update === first) {
-          pendingQueue = queue.shared.pending;
+      if (update === null) {
+        pendingQueue = queue.shared.pending;
 
-          if (pendingQueue === null) {
-            break;
-          } else {
-            // An update was scheduled from inside a reducer. Add the new
-            // pending updates to the end of the list and keep processing.
-            update = baseQueue.next = pendingQueue.next;
-            pendingQueue.next = first;
-            queue.baseQueue = baseQueue = pendingQueue;
-            queue.shared.pending = null;
-          }
+        if (pendingQueue === null) {
+          break;
+        } else {
+          // An update was scheduled from inside a reducer. Add the new
+          // pending updates to the end of the list and keep processing.
+          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
+          // unravel them when transferring them to the base queue.
+
+          var _firstPendingUpdate = _lastPendingUpdate.next;
+          _lastPendingUpdate.next = null;
+          update = _firstPendingUpdate;
+          queue.lastBaseUpdate = _lastPendingUpdate;
+          queue.shared.pending = null;
         }
-      } while (true);
-    }
+      }
+    } while (true);
 
-    if (newBaseQueueLast === null) {
+    if (newLastBaseUpdate === null) {
       newBaseState = newState;
-    } else {
-      newBaseQueueLast.next = newBaseQueueFirst;
     }
 
     queue.baseState = newBaseState;
-    queue.baseQueue = newBaseQueueLast; // Set the remaining expiration time to be whatever is remaining in the queue.
+    queue.firstBaseUpdate = newFirstBaseUpdate;
+    queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.
     // This should be fine because the only two other things that contribute to
     // expiration time are props and context. We're already in the middle of the
     // begin phase by the time we start processing the queue, so we've already
@@ -7085,8 +7164,8 @@ function processUpdateQueue(
     // shouldComponentUpdate is tricky; but we'll have to account for
     // that regardless.
 
-    markUnprocessedUpdateTime(newExpirationTime);
-    workInProgress.expirationTime = newExpirationTime;
+    markSkippedUpdateLanes(newLanes);
+    workInProgress.lanes = newLanes;
     workInProgress.memoizedState = newState;
   }
 
@@ -7130,11 +7209,6 @@ function commitUpdateQueue(finishedWork, finishedQueue, instance) {
   }
 }
 
-var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
-function requestCurrentSuspenseConfig() {
-  return ReactCurrentBatchConfig.suspense;
-}
-
 var fakeInternalInstance = {};
 var isArray = Array.isArray; // React.Component uses a shared frozen object by default.
 // We'll use it to determine whether we need to initialize legacy refs.
@@ -7235,7 +7309,7 @@ function applyDerivedStateFromProps(
   workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
   // base state.
 
-  if (workInProgress.expirationTime === NoWork) {
+  if (workInProgress.lanes === NoLanes) {
     // Queue is always non-null for classes
     var updateQueue = workInProgress.updateQueue;
     updateQueue.baseState = memoizedState;
@@ -7245,14 +7319,9 @@ var classComponentUpdater = {
   isMounted: isMounted,
   enqueueSetState: function(inst, payload, callback) {
     var fiber = get(inst);
-    var currentTime = requestCurrentTimeForUpdate();
-    var suspenseConfig = requestCurrentSuspenseConfig();
-    var expirationTime = computeExpirationForFiber(
-      currentTime,
-      fiber,
-      suspenseConfig
-    );
-    var update = createUpdate(expirationTime, suspenseConfig);
+    var eventTime = requestEventTime();
+    var lane = requestUpdateLane(fiber);
+    var update = createUpdate(eventTime, lane);
     update.payload = payload;
 
     if (callback !== undefined && callback !== null) {
@@ -7264,18 +7333,13 @@ var classComponentUpdater = {
     }
 
     enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   },
   enqueueReplaceState: function(inst, payload, callback) {
     var fiber = get(inst);
-    var currentTime = requestCurrentTimeForUpdate();
-    var suspenseConfig = requestCurrentSuspenseConfig();
-    var expirationTime = computeExpirationForFiber(
-      currentTime,
-      fiber,
-      suspenseConfig
-    );
-    var update = createUpdate(expirationTime, suspenseConfig);
+    var eventTime = requestEventTime();
+    var lane = requestUpdateLane(fiber);
+    var update = createUpdate(eventTime, lane);
     update.tag = ReplaceState;
     update.payload = payload;
 
@@ -7288,18 +7352,13 @@ var classComponentUpdater = {
     }
 
     enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   },
   enqueueForceUpdate: function(inst, callback) {
     var fiber = get(inst);
-    var currentTime = requestCurrentTimeForUpdate();
-    var suspenseConfig = requestCurrentSuspenseConfig();
-    var expirationTime = computeExpirationForFiber(
-      currentTime,
-      fiber,
-      suspenseConfig
-    );
-    var update = createUpdate(expirationTime, suspenseConfig);
+    var eventTime = requestEventTime();
+    var lane = requestUpdateLane(fiber);
+    var update = createUpdate(eventTime, lane);
     update.tag = ForceUpdate;
 
     if (callback !== undefined && callback !== null) {
@@ -7311,7 +7370,7 @@ var classComponentUpdater = {
     }
 
     enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   }
 };
 
@@ -7327,13 +7386,11 @@ function checkShouldComponentUpdate(
   var instance = workInProgress.stateNode;
 
   if (typeof instance.shouldComponentUpdate === "function") {
-    startPhaseTimer(workInProgress, "shouldComponentUpdate");
     var shouldUpdate = instance.shouldComponentUpdate(
       newProps,
       newState,
       nextContext
     );
-    stopPhaseTimer();
 
     {
       if (shouldUpdate === undefined) {
@@ -7736,7 +7793,7 @@ function constructClassInstance(workInProgress, ctor, props) {
             "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
               "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" +
               "The above lifecycles should be removed. Learn more about this warning here:\n" +
-              "https://fb.me/react-unsafe-component-lifecycles",
+              "https://reactjs.org/link/unsafe-component-lifecycles",
             _componentName,
             newApiName,
             foundWillMountName !== null ? "\n  " + foundWillMountName : "",
@@ -7759,7 +7816,6 @@ function constructClassInstance(workInProgress, ctor, props) {
 }
 
 function callComponentWillMount(workInProgress, instance) {
-  startPhaseTimer(workInProgress, "componentWillMount");
   var oldState = instance.state;
 
   if (typeof instance.componentWillMount === "function") {
@@ -7770,8 +7826,6 @@ function callComponentWillMount(workInProgress, instance) {
     instance.UNSAFE_componentWillMount();
   }
 
-  stopPhaseTimer();
-
   if (oldState !== instance.state) {
     {
       error(
@@ -7793,7 +7847,6 @@ function callComponentWillReceiveProps(
   nextContext
 ) {
   var oldState = instance.state;
-  startPhaseTimer(workInProgress, "componentWillReceiveProps");
 
   if (typeof instance.componentWillReceiveProps === "function") {
     instance.componentWillReceiveProps(newProps, nextContext);
@@ -7803,8 +7856,6 @@ function callComponentWillReceiveProps(
     instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
   }
 
-  stopPhaseTimer();
-
   if (instance.state !== oldState) {
     {
       var componentName = getComponentName(workInProgress.type) || "Component";
@@ -7825,12 +7876,7 @@ function callComponentWillReceiveProps(
   }
 } // Invokes the mount life-cycles on a previously never rendered instance.
 
-function mountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
+function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   {
     checkClassInstance(workInProgress, ctor, newProps);
   }
@@ -7880,7 +7926,7 @@ function mountClassInstance(
     }
   }
 
-  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
+  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
   instance.state = workInProgress.memoizedState;
   var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
 
@@ -7904,26 +7950,16 @@ function mountClassInstance(
     callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
     // process them now.
 
-    processUpdateQueue(
-      workInProgress,
-      newProps,
-      instance,
-      renderExpirationTime
-    );
+    processUpdateQueue(workInProgress, newProps, instance, renderLanes);
     instance.state = workInProgress.memoizedState;
   }
 
   if (typeof instance.componentDidMount === "function") {
-    workInProgress.effectTag |= Update;
+    workInProgress.flags |= Update;
   }
 }
-
-function resumeMountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
+
+function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   var instance = workInProgress.stateNode;
   var oldProps = workInProgress.memoizedProps;
   instance.props = oldProps;
@@ -7969,7 +8005,7 @@ function resumeMountClassInstance(
   resetHasForceUpdateBeforeProcessing();
   var oldState = workInProgress.memoizedState;
   var newState = (instance.state = oldState);
-  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
+  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
   newState = workInProgress.memoizedState;
 
   if (
@@ -7981,7 +8017,7 @@ function resumeMountClassInstance(
     // If an update was already in progress, we should schedule an Update
     // effect even though we're bailing out, so that cWU/cDU are called.
     if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
+      workInProgress.flags |= Update;
     }
 
     return false;
@@ -8017,8 +8053,6 @@ function resumeMountClassInstance(
       (typeof instance.UNSAFE_componentWillMount === "function" ||
         typeof instance.componentWillMount === "function")
     ) {
-      startPhaseTimer(workInProgress, "componentWillMount");
-
       if (typeof instance.componentWillMount === "function") {
         instance.componentWillMount();
       }
@@ -8026,18 +8060,16 @@ function resumeMountClassInstance(
       if (typeof instance.UNSAFE_componentWillMount === "function") {
         instance.UNSAFE_componentWillMount();
       }
-
-      stopPhaseTimer();
     }
 
     if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
+      workInProgress.flags |= Update;
     }
   } else {
     // If an update was already in progress, we should schedule an Update
     // effect even though we're bailing out, so that cWU/cDU are called.
     if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
+      workInProgress.flags |= Update;
     } // If shouldComponentUpdate returned false, we should still update the
     // memoized state to indicate that this work can be reused.
 
@@ -8057,15 +8089,17 @@ function updateClassInstance(
   workInProgress,
   ctor,
   newProps,
-  renderExpirationTime
+  renderLanes
 ) {
   var instance = workInProgress.stateNode;
   cloneUpdateQueue(current, workInProgress);
-  var oldProps = workInProgress.memoizedProps;
-  instance.props =
+  var unresolvedOldProps = workInProgress.memoizedProps;
+  var oldProps =
     workInProgress.type === workInProgress.elementType
-      ? oldProps
-      : resolveDefaultProps(workInProgress.type, oldProps);
+      ? unresolvedOldProps
+      : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
+  instance.props = oldProps;
+  var unresolvedNewProps = workInProgress.pendingProps;
   var oldContext = instance.context;
   var contextType = ctor.contextType;
   var nextContext = emptyContextObject;
@@ -8091,7 +8125,10 @@ function updateClassInstance(
     (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
       typeof instance.componentWillReceiveProps === "function")
   ) {
-    if (oldProps !== newProps || oldContext !== nextContext) {
+    if (
+      unresolvedOldProps !== unresolvedNewProps ||
+      oldContext !== nextContext
+    ) {
       callComponentWillReceiveProps(
         workInProgress,
         instance,
@@ -8104,11 +8141,11 @@ function updateClassInstance(
   resetHasForceUpdateBeforeProcessing();
   var oldState = workInProgress.memoizedState;
   var newState = (instance.state = oldState);
-  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
+  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
   newState = workInProgress.memoizedState;
 
   if (
-    oldProps === newProps &&
+    unresolvedOldProps === unresolvedNewProps &&
     oldState === newState &&
     !hasContextChanged() &&
     !checkHasForceUpdateAfterProcessing()
@@ -8117,19 +8154,19 @@ function updateClassInstance(
     // effect even though we're bailing out, so that cWU/cDU are called.
     if (typeof instance.componentDidUpdate === "function") {
       if (
-        oldProps !== current.memoizedProps ||
+        unresolvedOldProps !== current.memoizedProps ||
         oldState !== current.memoizedState
       ) {
-        workInProgress.effectTag |= Update;
+        workInProgress.flags |= Update;
       }
     }
 
     if (typeof instance.getSnapshotBeforeUpdate === "function") {
       if (
-        oldProps !== current.memoizedProps ||
+        unresolvedOldProps !== current.memoizedProps ||
         oldState !== current.memoizedState
       ) {
-        workInProgress.effectTag |= Snapshot;
+        workInProgress.flags |= Snapshot;
       }
     }
 
@@ -8166,8 +8203,6 @@ function updateClassInstance(
       (typeof instance.UNSAFE_componentWillUpdate === "function" ||
         typeof instance.componentWillUpdate === "function")
     ) {
-      startPhaseTimer(workInProgress, "componentWillUpdate");
-
       if (typeof instance.componentWillUpdate === "function") {
         instance.componentWillUpdate(newProps, newState, nextContext);
       }
@@ -8175,35 +8210,33 @@ function updateClassInstance(
       if (typeof instance.UNSAFE_componentWillUpdate === "function") {
         instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
       }
-
-      stopPhaseTimer();
     }
 
     if (typeof instance.componentDidUpdate === "function") {
-      workInProgress.effectTag |= Update;
+      workInProgress.flags |= Update;
     }
 
     if (typeof instance.getSnapshotBeforeUpdate === "function") {
-      workInProgress.effectTag |= Snapshot;
+      workInProgress.flags |= Snapshot;
     }
   } else {
     // If an update was already in progress, we should schedule an Update
     // effect even though we're bailing out, so that cWU/cDU are called.
     if (typeof instance.componentDidUpdate === "function") {
       if (
-        oldProps !== current.memoizedProps ||
+        unresolvedOldProps !== current.memoizedProps ||
         oldState !== current.memoizedState
       ) {
-        workInProgress.effectTag |= Update;
+        workInProgress.flags |= Update;
       }
     }
 
     if (typeof instance.getSnapshotBeforeUpdate === "function") {
       if (
-        oldProps !== current.memoizedProps ||
+        unresolvedOldProps !== current.memoizedProps ||
         oldState !== current.memoizedState
       ) {
-        workInProgress.effectTag |= Snapshot;
+        workInProgress.flags |= Snapshot;
       }
     } // If shouldComponentUpdate returned false, we should still update the
     // memoized props/state to indicate that this work can be reused.
@@ -8225,7 +8258,7 @@ var didWarnAboutStringRefs;
 var ownerHasKeyUseWarning;
 var ownerHasFunctionTypeWarning;
 
-var warnForMissingKey = function(child) {};
+var warnForMissingKey = function(child, returnFiber) {};
 
 {
   didWarnAboutMaps = false;
@@ -8240,7 +8273,7 @@ var warnForMissingKey = function(child) {};
   ownerHasKeyUseWarning = {};
   ownerHasFunctionTypeWarning = {};
 
-  warnForMissingKey = function(child) {
+  warnForMissingKey = function(child, returnFiber) {
     if (child === null || typeof child !== "object") {
       return;
     }
@@ -8256,21 +8289,17 @@ var warnForMissingKey = function(child) {};
     }
 
     child._store.validated = true;
-    var currentComponentErrorInfo =
-      "Each child in a list should have a unique " +
-      '"key" prop. See https://fb.me/react-warning-keys for ' +
-      "more information." +
-      getCurrentFiberStackInDev();
+    var componentName = getComponentName(returnFiber.type) || "Component";
 
-    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
+    if (ownerHasKeyUseWarning[componentName]) {
       return;
     }
 
-    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
+    ownerHasKeyUseWarning[componentName] = true;
 
     error(
       "Each child in a list should have a unique " +
-        '"key" prop. See https://fb.me/react-warning-keys for ' +
+        '"key" prop. See https://reactjs.org/link/warning-keys for ' +
         "more information."
     );
   };
@@ -8308,9 +8337,8 @@ function coerceRef(returnFiber, current, element) {
                 "String refs are a source of potential bugs and should be avoided. " +
                 "We recommend using useRef() or createRef() instead. " +
                 "Learn more about using refs safely here: " +
-                "https://fb.me/react-strict-mode-string-ref%s",
-              mixedRef,
-              getStackByFiberInDevAndProd(returnFiber)
+                "https://reactjs.org/link/strict-mode-string-ref",
+              mixedRef
             );
           }
 
@@ -8328,7 +8356,7 @@ function coerceRef(returnFiber, current, element) {
 
         if (!(ownerFiber.tag === ClassComponent)) {
           throw Error(
-            "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref"
+            "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref"
           );
         }
 
@@ -8382,7 +8410,7 @@ function coerceRef(returnFiber, current, element) {
         throw Error(
           "Element ref was specified as a string (" +
             mixedRef +
-            ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information."
+            ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information."
         );
       }
     }
@@ -8393,41 +8421,27 @@ function coerceRef(returnFiber, current, element) {
 
 function throwOnInvalidObjectType(returnFiber, newChild) {
   if (returnFiber.type !== "textarea") {
-    var addendum = "";
-
-    {
-      addendum =
-        " If you meant to render a collection of children, use an array " +
-        "instead." +
-        getCurrentFiberStackInDev();
-    }
-
     {
       throw Error(
         "Objects are not valid as a React child (found: " +
           (Object.prototype.toString.call(newChild) === "[object Object]"
             ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
             : newChild) +
-          ")." +
-          addendum
+          "). If you meant to render a collection of children, use an array instead."
       );
     }
   }
 }
 
-function warnOnFunctionType() {
+function warnOnFunctionType(returnFiber) {
   {
-    var currentComponentErrorInfo =
-      "Functions are not valid as a React child. This may happen if " +
-      "you return a Component instead of <Component /> from render. " +
-      "Or maybe you meant to call this function rather than return it." +
-      getCurrentFiberStackInDev();
+    var componentName = getComponentName(returnFiber.type) || "Component";
 
-    if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
+    if (ownerHasFunctionTypeWarning[componentName]) {
       return;
     }
 
-    ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
+    ownerHasFunctionTypeWarning[componentName] = true;
 
     error(
       "Functions are not valid as a React child. This may happen if " +
@@ -8461,7 +8475,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
 
     childToDelete.nextEffect = null;
-    childToDelete.effectTag = Deletion;
+    childToDelete.flags = Deletion;
   }
 
   function deleteRemainingChildren(returnFiber, currentFirstChild) {
@@ -8525,7 +8539,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
       if (oldIndex < lastPlacedIndex) {
         // This is a move.
-        newFiber.effectTag = Placement;
+        newFiber.flags = Placement;
         return lastPlacedIndex;
       } else {
         // This item can stay in place.
@@ -8533,7 +8547,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       }
     } else {
       // This is an insertion.
-      newFiber.effectTag = Placement;
+      newFiber.flags = Placement;
       return lastPlacedIndex;
     }
   }
@@ -8542,20 +8556,16 @@ function ChildReconciler(shouldTrackSideEffects) {
     // This is simpler for the single child case. We only need to do a
     // placement for inserting new children.
     if (shouldTrackSideEffects && newFiber.alternate === null) {
-      newFiber.effectTag = Placement;
+      newFiber.flags = Placement;
     }
 
     return newFiber;
   }
 
-  function updateTextNode(returnFiber, current, textContent, expirationTime) {
+  function updateTextNode(returnFiber, current, textContent, lanes) {
     if (current === null || current.tag !== HostText) {
       // Insert
-      var created = createFiberFromText(
-        textContent,
-        returnFiber.mode,
-        expirationTime
-      );
+      var created = createFiberFromText(textContent, returnFiber.mode, lanes);
       created.return = returnFiber;
       return created;
     } else {
@@ -8566,7 +8576,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
   }
 
-  function updateElement(returnFiber, current, element, expirationTime) {
+  function updateElement(returnFiber, current, element, lanes) {
     if (current !== null) {
       if (
         current.elementType === element.type || // Keep this check inline so it only runs on the false path:
@@ -8586,17 +8596,13 @@ function ChildReconciler(shouldTrackSideEffects) {
       }
     } // Insert
 
-    var created = createFiberFromElement(
-      element,
-      returnFiber.mode,
-      expirationTime
-    );
+    var created = createFiberFromElement(element, returnFiber.mode, lanes);
     created.ref = coerceRef(returnFiber, current, element);
     created.return = returnFiber;
     return created;
   }
 
-  function updatePortal(returnFiber, current, portal, expirationTime) {
+  function updatePortal(returnFiber, current, portal, lanes) {
     if (
       current === null ||
       current.tag !== HostPortal ||
@@ -8604,11 +8610,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       current.stateNode.implementation !== portal.implementation
     ) {
       // Insert
-      var created = createFiberFromPortal(
-        portal,
-        returnFiber.mode,
-        expirationTime
-      );
+      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
       created.return = returnFiber;
       return created;
     } else {
@@ -8619,13 +8621,13 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
   }
 
-  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
+  function updateFragment(returnFiber, current, fragment, lanes, key) {
     if (current === null || current.tag !== Fragment) {
       // Insert
       var created = createFiberFromFragment(
         fragment,
         returnFiber.mode,
-        expirationTime,
+        lanes,
         key
       );
       created.return = returnFiber;
@@ -8638,16 +8640,12 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
   }
 
-  function createChild(returnFiber, newChild, expirationTime) {
+  function createChild(returnFiber, newChild, lanes) {
     if (typeof newChild === "string" || typeof newChild === "number") {
       // Text nodes don't have keys. If the previous node is implicitly keyed
       // we can continue to replace it without aborting even if it is not a text
       // node.
-      var created = createFiberFromText(
-        "" + newChild,
-        returnFiber.mode,
-        expirationTime
-      );
+      var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
       created.return = returnFiber;
       return created;
     }
@@ -8658,7 +8656,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           var _created = createFiberFromElement(
             newChild,
             returnFiber.mode,
-            expirationTime
+            lanes
           );
 
           _created.ref = coerceRef(returnFiber, null, newChild);
@@ -8670,7 +8668,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           var _created2 = createFiberFromPortal(
             newChild,
             returnFiber.mode,
-            expirationTime
+            lanes
           );
 
           _created2.return = returnFiber;
@@ -8682,7 +8680,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         var _created3 = createFiberFromFragment(
           newChild,
           returnFiber.mode,
-          expirationTime,
+          lanes,
           null
         );
 
@@ -8695,14 +8693,14 @@ function ChildReconciler(shouldTrackSideEffects) {
 
     {
       if (typeof newChild === "function") {
-        warnOnFunctionType();
+        warnOnFunctionType(returnFiber);
       }
     }
 
     return null;
   }
 
-  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
+  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
     // Update the fiber if the keys match, otherwise return null.
     var key = oldFiber !== null ? oldFiber.key : null;
 
@@ -8714,12 +8712,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         return null;
       }
 
-      return updateTextNode(
-        returnFiber,
-        oldFiber,
-        "" + newChild,
-        expirationTime
-      );
+      return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
     }
 
     if (typeof newChild === "object" && newChild !== null) {
@@ -8731,17 +8724,12 @@ function ChildReconciler(shouldTrackSideEffects) {
                 returnFiber,
                 oldFiber,
                 newChild.props.children,
-                expirationTime,
+                lanes,
                 key
               );
             }
 
-            return updateElement(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime
-            );
+            return updateElement(returnFiber, oldFiber, newChild, lanes);
           } else {
             return null;
           }
@@ -8749,12 +8737,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
         case REACT_PORTAL_TYPE: {
           if (newChild.key === key) {
-            return updatePortal(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime
-            );
+            return updatePortal(returnFiber, oldFiber, newChild, lanes);
           } else {
             return null;
           }
@@ -8766,13 +8749,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           return null;
         }
 
-        return updateFragment(
-          returnFiber,
-          oldFiber,
-          newChild,
-          expirationTime,
-          null
-        );
+        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
       }
 
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -8780,7 +8757,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
     {
       if (typeof newChild === "function") {
-        warnOnFunctionType();
+        warnOnFunctionType(returnFiber);
       }
     }
 
@@ -8792,18 +8769,13 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     newIdx,
     newChild,
-    expirationTime
+    lanes
   ) {
     if (typeof newChild === "string" || typeof newChild === "number") {
       // Text nodes don't have keys, so we neither have to check the old nor
       // new node for the key. If both are text nodes, they match.
       var matchedFiber = existingChildren.get(newIdx) || null;
-      return updateTextNode(
-        returnFiber,
-        matchedFiber,
-        "" + newChild,
-        expirationTime
-      );
+      return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
     }
 
     if (typeof newChild === "object" && newChild !== null) {
@@ -8819,17 +8791,12 @@ function ChildReconciler(shouldTrackSideEffects) {
               returnFiber,
               _matchedFiber,
               newChild.props.children,
-              expirationTime,
+              lanes,
               newChild.key
             );
           }
 
-          return updateElement(
-            returnFiber,
-            _matchedFiber,
-            newChild,
-            expirationTime
-          );
+          return updateElement(returnFiber, _matchedFiber, newChild, lanes);
         }
 
         case REACT_PORTAL_TYPE: {
@@ -8838,12 +8805,7 @@ function ChildReconciler(shouldTrackSideEffects) {
               newChild.key === null ? newIdx : newChild.key
             ) || null;
 
-          return updatePortal(
-            returnFiber,
-            _matchedFiber2,
-            newChild,
-            expirationTime
-          );
+          return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
         }
       }
 
@@ -8854,7 +8816,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           returnFiber,
           _matchedFiber3,
           newChild,
-          expirationTime,
+          lanes,
           null
         );
       }
@@ -8864,7 +8826,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
     {
       if (typeof newChild === "function") {
-        warnOnFunctionType();
+        warnOnFunctionType(returnFiber);
       }
     }
 
@@ -8874,7 +8836,7 @@ function ChildReconciler(shouldTrackSideEffects) {
    * Warns if there is a duplicate or missing key
    */
 
-  function warnOnInvalidKey(child, knownKeys) {
+  function warnOnInvalidKey(child, knownKeys, returnFiber) {
     {
       if (typeof child !== "object" || child === null) {
         return knownKeys;
@@ -8883,7 +8845,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       switch (child.$$typeof) {
         case REACT_ELEMENT_TYPE:
         case REACT_PORTAL_TYPE:
-          warnForMissingKey(child);
+          warnForMissingKey(child, returnFiber);
           var key = child.key;
 
           if (typeof key !== "string") {
@@ -8921,7 +8883,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChildren,
-    expirationTime
+    lanes
   ) {
     // This algorithm can't optimize by searching from both ends since we
     // don't have backpointers on fibers. I'm trying to see how far we can get
@@ -8944,7 +8906,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
       for (var i = 0; i < newChildren.length; i++) {
         var child = newChildren[i];
-        knownKeys = warnOnInvalidKey(child, knownKeys);
+        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
       }
     }
 
@@ -8967,7 +8929,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         oldFiber,
         newChildren[newIdx],
-        expirationTime
+        lanes
       );
 
       if (newFiber === null) {
@@ -9017,11 +8979,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       // If we don't have any more existing children we can choose a fast path
       // since the rest will all be insertions.
       for (; newIdx < newChildren.length; newIdx++) {
-        var _newFiber = createChild(
-          returnFiber,
-          newChildren[newIdx],
-          expirationTime
-        );
+        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
 
         if (_newFiber === null) {
           continue;
@@ -9050,7 +9008,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         newIdx,
         newChildren[newIdx],
-        expirationTime
+        lanes
       );
 
       if (_newFiber2 !== null) {
@@ -9093,7 +9051,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChildrenIterable,
-    expirationTime
+    lanes
   ) {
     // This is the same implementation as reconcileChildrenArray(),
     // but using the iterator instead.
@@ -9128,9 +9086,8 @@ function ChildReconciler(shouldTrackSideEffects) {
       if (newChildrenIterable.entries === iteratorFn) {
         if (!didWarnAboutMaps) {
           error(
-            "Using Maps as children is unsupported and will likely yield " +
-              "unexpected results. Convert it to a sequence/iterable of keyed " +
-              "ReactElements instead."
+            "Using Maps as children is not supported. " +
+              "Use an array of keyed ReactElements instead."
           );
         }
 
@@ -9147,7 +9104,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
         for (; !_step.done; _step = _newChildren.next()) {
           var child = _step.value;
-          knownKeys = warnOnInvalidKey(child, knownKeys);
+          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
         }
       }
     }
@@ -9178,12 +9135,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         nextOldFiber = oldFiber.sibling;
       }
 
-      var newFiber = updateSlot(
-        returnFiber,
-        oldFiber,
-        step.value,
-        expirationTime
-      );
+      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
 
       if (newFiber === null) {
         // TODO: This breaks on empty slots like null children. That's
@@ -9232,7 +9184,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       // If we don't have any more existing children we can choose a fast path
       // since the rest will all be insertions.
       for (; !step.done; newIdx++, step = newChildren.next()) {
-        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
+        var _newFiber3 = createChild(returnFiber, step.value, lanes);
 
         if (_newFiber3 === null) {
           continue;
@@ -9261,7 +9213,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         newIdx,
         step.value,
-        expirationTime
+        lanes
       );
 
       if (_newFiber4 !== null) {
@@ -9304,7 +9256,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     textContent,
-    expirationTime
+    lanes
   ) {
     // There's no need to check for keys on text nodes since we don't have a
     // way to define them.
@@ -9319,11 +9271,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     // and delete the existing ones.
 
     deleteRemainingChildren(returnFiber, currentFirstChild);
-    var created = createFiberFromText(
-      textContent,
-      returnFiber.mode,
-      expirationTime
-    );
+    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
     created.return = returnFiber;
     return created;
   }
@@ -9332,7 +9280,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     element,
-    expirationTime
+    lanes
   ) {
     var key = element.key;
     var child = currentFirstChild;
@@ -9359,11 +9307,6 @@ function ChildReconciler(shouldTrackSideEffects) {
             break;
           }
 
-          case Block:
-
-          // We intentionally fallthrough here if enableBlocksAPI is not on.
-          // eslint-disable-next-lined no-fallthrough
-
           default: {
             if (
               child.elementType === element.type || // Keep this check inline so it only runs on the false path:
@@ -9371,17 +9314,17 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               deleteRemainingChildren(returnFiber, child.sibling);
 
-              var _existing3 = useFiber(child, element.props);
+              var _existing = useFiber(child, element.props);
 
-              _existing3.ref = coerceRef(returnFiber, child, element);
-              _existing3.return = returnFiber;
+              _existing.ref = coerceRef(returnFiber, child, element);
+              _existing.return = returnFiber;
 
               {
-                _existing3._debugSource = element._source;
-                _existing3._debugOwner = element._owner;
+                _existing._debugSource = element._source;
+                _existing._debugOwner = element._owner;
               }
 
-              return _existing3;
+              return _existing;
             }
 
             break;
@@ -9401,17 +9344,13 @@ function ChildReconciler(shouldTrackSideEffects) {
       var created = createFiberFromFragment(
         element.props.children,
         returnFiber.mode,
-        expirationTime,
+        lanes,
         element.key
       );
       created.return = returnFiber;
       return created;
     } else {
-      var _created4 = createFiberFromElement(
-        element,
-        returnFiber.mode,
-        expirationTime
-      );
+      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
 
       _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
       _created4.return = returnFiber;
@@ -9423,7 +9362,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     portal,
-    expirationTime
+    lanes
   ) {
     var key = portal.key;
     var child = currentFirstChild;
@@ -9452,11 +9391,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       child = child.sibling;
     }
 
-    var created = createFiberFromPortal(
-      portal,
-      returnFiber.mode,
-      expirationTime
-    );
+    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
     created.return = returnFiber;
     return created;
   } // This API will tag the children with the side-effect of the reconciliation
@@ -9467,7 +9402,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChild,
-    expirationTime
+    lanes
   ) {
     // This function is not recursive.
     // If the top level item is an array, we treat it as a set of children,
@@ -9496,7 +9431,7 @@ function ChildReconciler(shouldTrackSideEffects) {
               returnFiber,
               currentFirstChild,
               newChild,
-              expirationTime
+              lanes
             )
           );
 
@@ -9506,7 +9441,7 @@ function ChildReconciler(shouldTrackSideEffects) {
               returnFiber,
               currentFirstChild,
               newChild,
-              expirationTime
+              lanes
             )
           );
       }
@@ -9518,7 +9453,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           returnFiber,
           currentFirstChild,
           "" + newChild,
-          expirationTime
+          lanes
         )
       );
     }
@@ -9528,7 +9463,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         currentFirstChild,
         newChild,
-        expirationTime
+        lanes
       );
     }
 
@@ -9537,7 +9472,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         currentFirstChild,
         newChild,
-        expirationTime
+        lanes
       );
     }
 
@@ -9547,7 +9482,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
     {
       if (typeof newChild === "function") {
-        warnOnFunctionType();
+        warnOnFunctionType(returnFiber);
       }
     }
 
@@ -9570,12 +9505,12 @@ function ChildReconciler(shouldTrackSideEffects) {
         // functions and classes
         // eslint-disable-next-lined no-fallthrough
 
-        case FunctionComponent: {
-          var Component = returnFiber.type;
-
+        case FunctionComponent:
+        case ForwardRef:
+        case SimpleMemoComponent: {
           {
             throw Error(
-              (Component.displayName || Component.name || "Component") +
+              (getComponentName(returnFiber.type) || "Component") +
                 "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null."
             );
           }
@@ -9617,11 +9552,11 @@ function cloneChildFibers(current, workInProgress) {
   newChild.sibling = null;
 } // Reset a workInProgress child set to prepare it for a second pass.
 
-function resetChildFibers(workInProgress, renderExpirationTime) {
+function resetChildFibers(workInProgress, lanes) {
   var child = workInProgress.child;
 
   while (child !== null) {
-    resetWorkInProgress(child, renderExpirationTime);
+    resetWorkInProgress(child, lanes);
     child = child.sibling;
   }
 }
@@ -9793,7 +9728,7 @@ function findFirstSuspended(row) {
       // keep track of whether it suspended or not.
       node.memoizedProps.revealOrder !== undefined
     ) {
-      var didSuspend = (node.effectTag & DidCapture) !== NoEffect;
+      var didSuspend = (node.flags & DidCapture) !== NoFlags;
 
       if (didSuspend) {
         return node;
@@ -9823,18 +9758,9 @@ function findFirstSuspended(row) {
   return null;
 }
 
-function createDeprecatedResponderListener(responder, props) {
-  var eventResponderListener = {
-    responder: responder,
-    props: props
-  };
-
-  {
-    Object.freeze(eventResponderListener);
-  }
-
-  return eventResponderListener;
-}
+var NoFlags$1 =
+  /*  */
+  0; // Represents whether effect should fire.
 
 var HasEffect =
   /* */
@@ -9847,16 +9773,113 @@ var Passive$1 =
   /*   */
   4;
 
-var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
+var isHydrating = false;
+
+function enterHydrationState(fiber) {
+  {
+    return false;
+  }
+}
+
+function prepareToHydrateHostInstance(
+  fiber,
+  rootContainerInstance,
+  hostContext
+) {
+  {
+    {
+      throw Error(
+        "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
+      );
+    }
+  }
+}
+
+function prepareToHydrateHostTextInstance(fiber) {
+  {
+    {
+      throw Error(
+        "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
+      );
+    }
+  }
+  var shouldUpdate = hydrateTextInstance();
+}
+
+function popHydrationState(fiber) {
+  {
+    return false;
+  }
+}
+
+function getIsHydrating() {
+  return isHydrating;
+}
+
+// and should be reset before starting a new render.
+// This tracks which mutable sources need to be reset after a render.
+
+var workInProgressSources = [];
+var rendererSigil$1;
+
+{
+  // Used to detect multiple renderers using the same mutable source.
+  rendererSigil$1 = {};
+}
+
+function markSourceAsDirty(mutableSource) {
+  workInProgressSources.push(mutableSource);
+}
+function resetWorkInProgressVersions() {
+  for (var i = 0; i < workInProgressSources.length; i++) {
+    var mutableSource = workInProgressSources[i];
+
+    {
+      mutableSource._workInProgressVersionPrimary = null;
+    }
+  }
+
+  workInProgressSources.length = 0;
+}
+function getWorkInProgressVersion(mutableSource) {
+  {
+    return mutableSource._workInProgressVersionPrimary;
+  }
+}
+function setWorkInProgressVersion(mutableSource, version) {
+  {
+    mutableSource._workInProgressVersionPrimary = version;
+  }
+
+  workInProgressSources.push(mutableSource);
+}
+function warnAboutMultipleRenderersDEV(mutableSource) {
+  {
+    {
+      if (mutableSource._currentPrimaryRenderer == null) {
+        mutableSource._currentPrimaryRenderer = rendererSigil$1;
+      } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
+        error(
+          "Detected multiple renderers concurrently rendering the " +
+            "same mutable source. This is currently unsupported."
+        );
+      }
+    }
+  }
+} // Eager reads the version of a mutable source and stores it on the root.
+
+var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
 var didWarnAboutMismatchedHooksForComponent;
+var didWarnAboutUseOpaqueIdentifier;
 
 {
+  didWarnAboutUseOpaqueIdentifier = {};
   didWarnAboutMismatchedHooksForComponent = new Set();
 }
 
 // These are set right before calling the component.
-var renderExpirationTime = NoWork; // The work-in-progress fiber. I've named it differently to distinguish it from
+var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
 // the work-in-progress hook.
 
 var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
@@ -9870,7 +9893,12 @@ var workInProgressHook = null; // Whether an update was scheduled at any point d
 // finished evaluating this component. This is an optimization so we know
 // whether we need to clear render phase updates after a throw.
 
-var didScheduleRenderPhaseUpdate = false;
+var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
+// gets reset after each attempt.
+// TODO: Maybe there's some way to consolidate this with
+// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
+
+var didScheduleRenderPhaseUpdateDuringThisPass = false;
 var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook
 
 var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
@@ -9954,7 +9982,7 @@ function warnOnHookMismatchInDev(currentHookName) {
         error(
           "React has detected a change in the order of Hooks called by %s. " +
             "This will lead to bugs and errors if not fixed. " +
-            "For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n" +
+            "For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n" +
             "   Previous render            Next render\n" +
             "   ------------------------------------------------------\n" +
             "%s" +
@@ -9970,7 +9998,7 @@ function warnOnHookMismatchInDev(currentHookName) {
 function throwInvalidHookError() {
   {
     throw Error(
-      "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem."
+      "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
     );
   }
 }
@@ -10029,9 +10057,9 @@ function renderWithHooks(
   Component,
   props,
   secondArg,
-  nextRenderExpirationTime
+  nextRenderLanes
 ) {
-  renderExpirationTime = nextRenderExpirationTime;
+  renderLanes = nextRenderLanes;
   currentlyRenderingFiber$1 = workInProgress;
 
   {
@@ -10044,7 +10072,7 @@ function renderWithHooks(
 
   workInProgress.memoizedState = null;
   workInProgress.updateQueue = null;
-  workInProgress.expirationTime = NoWork; // The following should have already been reset
+  workInProgress.lanes = NoLanes; // The following should have already been reset
   // currentHook = null;
   // workInProgressHook = null;
   // didScheduleRenderPhaseUpdate = false;
@@ -10057,28 +10085,28 @@ function renderWithHooks(
 
   {
     if (current !== null && current.memoizedState !== null) {
-      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
     } else if (hookTypesDev !== null) {
       // This dispatcher handles an edge case where a component is updating,
       // but no stateful hooks have been used.
       // We want to match the production code behavior (which will use HooksDispatcherOnMount),
       // but with the extra DEV validation to ensure hooks ordering hasn't changed.
       // This dispatcher does that.
-      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
     } else {
-      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
     }
   }
 
   var children = Component(props, secondArg); // Check if there was a render phase update
 
-  if (workInProgress.expirationTime === renderExpirationTime) {
+  if (didScheduleRenderPhaseUpdateDuringThisPass) {
     // Keep rendering in a loop for as long as render phase updates continue to
     // be scheduled. Use a counter to prevent infinite loops.
     var numberOfReRenders = 0;
 
     do {
-      workInProgress.expirationTime = NoWork;
+      didScheduleRenderPhaseUpdateDuringThisPass = false;
 
       if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
         throw Error(
@@ -10103,13 +10131,13 @@ function renderWithHooks(
         hookTypesUpdateIndexDev = -1;
       }
 
-      ReactCurrentDispatcher.current = HooksDispatcherOnRerenderInDEV;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
       children = Component(props, secondArg);
-    } while (workInProgress.expirationTime === renderExpirationTime);
+    } while (didScheduleRenderPhaseUpdateDuringThisPass);
   } // We can assume the previous dispatcher is always this one, since we set it
   // at the beginning of the render phase and there's no re-entrancy.
 
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
 
   {
     workInProgress._debugHookTypes = hookTypesDev;
@@ -10117,7 +10145,7 @@ function renderWithHooks(
   // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
 
   var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
-  renderExpirationTime = NoWork;
+  renderLanes = NoLanes;
   currentlyRenderingFiber$1 = null;
   currentHook = null;
   workInProgressHook = null;
@@ -10138,18 +10166,15 @@ function renderWithHooks(
 
   return children;
 }
-function bailoutHooks(current, workInProgress, expirationTime) {
+function bailoutHooks(current, workInProgress, lanes) {
   workInProgress.updateQueue = current.updateQueue;
-  workInProgress.effectTag &= ~(Passive | Update);
-
-  if (current.expirationTime <= expirationTime) {
-    current.expirationTime = NoWork;
-  }
+  workInProgress.flags &= ~(Passive | Update);
+  current.lanes = removeLanes(current.lanes, lanes);
 }
 function resetHooksAfterThrow() {
   // We can assume the previous dispatcher is always this one, since we set it
   // at the beginning of the render phase and there's no re-entrancy.
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
 
   if (didScheduleRenderPhaseUpdate) {
     // There were render phase updates. These are only valid for this render
@@ -10171,9 +10196,11 @@ function resetHooksAfterThrow() {
 
       hook = hook.next;
     }
+
+    didScheduleRenderPhaseUpdate = false;
   }
 
-  renderExpirationTime = NoWork;
+  renderLanes = NoLanes;
   currentlyRenderingFiber$1 = null;
   currentHook = null;
   workInProgressHook = null;
@@ -10182,9 +10209,10 @@ function resetHooksAfterThrow() {
     hookTypesDev = null;
     hookTypesUpdateIndexDev = -1;
     currentHookNameInDev = null;
+    isUpdatingOpaqueValueInRenderPhase = false;
   }
 
-  didScheduleRenderPhaseUpdate = false;
+  didScheduleRenderPhaseUpdateDuringThisPass = false;
 }
 
 function mountWorkInProgressHook() {
@@ -10331,6 +10359,17 @@ function updateReducer(reducer, initialArg, init) {
       pendingQueue.next = baseFirst;
     }
 
+    {
+      if (current.baseQueue !== baseQueue) {
+        // Internal invariant that should never happen, but feasibly could in
+        // the future if we implement resuming, or some form of that.
+        error(
+          "Internal error: Expected work-in-progress queue to be a clone. " +
+            "This is a bug in React."
+        );
+      }
+    }
+
     current.baseQueue = baseQueue = pendingQueue;
     queue.pending = null;
   }
@@ -10345,15 +10384,14 @@ function updateReducer(reducer, initialArg, init) {
     var update = first;
 
     do {
-      var updateExpirationTime = update.expirationTime;
+      var updateLane = update.lane;
 
-      if (updateExpirationTime < renderExpirationTime) {
+      if (!isSubsetOfLanes(renderLanes, updateLane)) {
         // Priority is insufficient. Skip this update. If this is the first
         // skipped update, the previous update/state is the new base
         // update/state.
         var clone = {
-          expirationTime: update.expirationTime,
-          suspenseConfig: update.suspenseConfig,
+          lane: updateLane,
           action: update.action,
           eagerReducer: update.eagerReducer,
           eagerState: update.eagerState,
@@ -10366,35 +10404,29 @@ function updateReducer(reducer, initialArg, init) {
         } else {
           newBaseQueueLast = newBaseQueueLast.next = clone;
         } // Update the remaining priority in the queue.
+        // TODO: Don't need to accumulate this. Instead, we can remove
+        // renderLanes from the original lanes.
 
-        if (updateExpirationTime > currentlyRenderingFiber$1.expirationTime) {
-          currentlyRenderingFiber$1.expirationTime = updateExpirationTime;
-          markUnprocessedUpdateTime(updateExpirationTime);
-        }
+        currentlyRenderingFiber$1.lanes = mergeLanes(
+          currentlyRenderingFiber$1.lanes,
+          updateLane
+        );
+        markSkippedUpdateLanes(updateLane);
       } else {
         // This update does have sufficient priority.
         if (newBaseQueueLast !== null) {
           var _clone = {
-            expirationTime: Sync,
-            // This update is going to be committed so we never want uncommit it.
-            suspenseConfig: update.suspenseConfig,
+            // This update is going to be committed so we never want uncommit
+            // it. Using NoLane works because 0 is a subset of all bitmasks, so
+            // this will never be skipped by the check above.
+            lane: NoLane,
             action: update.action,
             eagerReducer: update.eagerReducer,
             eagerState: update.eagerState,
             next: null
           };
           newBaseQueueLast = newBaseQueueLast.next = _clone;
-        } // Mark the event time of this update as relevant to this render pass.
-        // TODO: This should ideally use the true event time of this update rather than
-        // its priority which is a derived and not reverseable value.
-        // TODO: We should skip this update if it was already committed but currently
-        // we have no way of detecting the difference between a committed and suspended
-        // update here.
-
-        markRenderEventTimeAndConfig(
-          updateExpirationTime,
-          update.suspenseConfig
-        ); // Process this update.
+        } // Process this update.
 
         if (update.eagerReducer === reducer) {
           // If this update was processed eagerly, and its reducer matches the
@@ -10482,6 +10514,251 @@ function rerenderReducer(reducer, initialArg, init) {
   return [newState, dispatch];
 }
 
+function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
+  {
+    warnAboutMultipleRenderersDEV(source);
+  }
+
+  var getVersion = source._getVersion;
+  var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?
+
+  var isSafeToReadFromSource = false; // Check the version first.
+  // If this render has already been started with a specific version,
+  // we can use it alone to determine if we can safely read from the source.
+
+  var currentRenderVersion = getWorkInProgressVersion(source);
+
+  if (currentRenderVersion !== null) {
+    // It's safe to read if the store hasn't been mutated since the last time
+    // we read something.
+    isSafeToReadFromSource = currentRenderVersion === version;
+  } else {
+    // If there's no version, then this is the first time we've read from the
+    // source during the current render pass, so we need to do a bit more work.
+    // What we need to determine is if there are any hooks that already
+    // subscribed to the source, and if so, whether there are any pending
+    // mutations that haven't been synchronized yet.
+    //
+    // If there are no pending mutations, then `root.mutableReadLanes` will be
+    // empty, and we know we can safely read.
+    //
+    // If there *are* pending mutations, we may still be able to safely read
+    // if the currently rendering lanes are inclusive of the pending mutation
+    // lanes, since that guarantees that the value we're about to read from
+    // the source is consistent with the values that we read during the most
+    // recent mutation.
+    isSafeToReadFromSource = isSubsetOfLanes(
+      renderLanes,
+      root.mutableReadLanes
+    );
+
+    if (isSafeToReadFromSource) {
+      // If it's safe to read from this source during the current render,
+      // store the version in case other components read from it.
+      // A changed version number will let those components know to throw and restart the render.
+      setWorkInProgressVersion(source, version);
+    }
+  }
+
+  if (isSafeToReadFromSource) {
+    var snapshot = getSnapshot(source._source);
+
+    {
+      if (typeof snapshot === "function") {
+        error(
+          "Mutable source should not return a function as the snapshot value. " +
+            "Functions may close over mutable values and cause tearing."
+        );
+      }
+    }
+
+    return snapshot;
+  } else {
+    // This handles the special case of a mutable source being shared between renderers.
+    // In that case, if the source is mutated between the first and second renderer,
+    // The second renderer don't know that it needs to reset the WIP version during unwind,
+    // (because the hook only marks sources as dirty if it's written to their WIP version).
+    // That would cause this tear check to throw again and eventually be visible to the user.
+    // We can avoid this infinite loop by explicitly marking the source as dirty.
+    //
+    // This can lead to tearing in the first renderer when it resumes,
+    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).
+    markSourceAsDirty(source);
+
+    {
+      throw Error(
+        "Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue."
+      );
+    }
+  }
+}
+
+function useMutableSource(hook, source, getSnapshot, subscribe) {
+  var root = getWorkInProgressRoot();
+
+  if (!(root !== null)) {
+    throw Error(
+      "Expected a work-in-progress root. This is a bug in React. Please file an issue."
+    );
+  }
+
+  var getVersion = source._getVersion;
+  var version = getVersion(source._source);
+  var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const
+
+  var _dispatcher$useState = dispatcher.useState(function() {
+      return readFromUnsubcribedMutableSource(root, source, getSnapshot);
+    }),
+    currentSnapshot = _dispatcher$useState[0],
+    setSnapshot = _dispatcher$useState[1];
+
+  var snapshot = currentSnapshot; // Grab a handle to the state hook as well.
+  // We use it to clear the pending update queue if we have a new source.
+
+  var stateHook = workInProgressHook;
+  var memoizedState = hook.memoizedState;
+  var refs = memoizedState.refs;
+  var prevGetSnapshot = refs.getSnapshot;
+  var prevSource = memoizedState.source;
+  var prevSubscribe = memoizedState.subscribe;
+  var fiber = currentlyRenderingFiber$1;
+  hook.memoizedState = {
+    refs: refs,
+    source: source,
+    subscribe: subscribe
+  }; // Sync the values needed by our subscription handler after each commit.
+
+  dispatcher.useEffect(
+    function() {
+      refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,
+      // but this hook recreates the queue in certain cases  to avoid updates from stale sources.
+      // handleChange() below needs to reference the dispatch function without re-subscribing,
+      // so we use a ref to ensure that it always has the latest version.
+
+      refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.
+
+      var maybeNewVersion = getVersion(source._source);
+
+      if (!objectIs(version, maybeNewVersion)) {
+        var maybeNewSnapshot = getSnapshot(source._source);
+
+        {
+          if (typeof maybeNewSnapshot === "function") {
+            error(
+              "Mutable source should not return a function as the snapshot value. " +
+                "Functions may close over mutable values and cause tearing."
+            );
+          }
+        }
+
+        if (!objectIs(snapshot, maybeNewSnapshot)) {
+          setSnapshot(maybeNewSnapshot);
+          var lane = requestUpdateLane(fiber);
+          markRootMutableRead(root, lane);
+        } // If the source mutated between render and now,
+        // there may be state updates already scheduled from the old source.
+        // Entangle the updates so that they render in the same batch.
+
+        markRootEntangled(root, root.mutableReadLanes);
+      }
+    },
+    [getSnapshot, source, subscribe]
+  ); // If we got a new source or subscribe function, re-subscribe in a passive effect.
+
+  dispatcher.useEffect(
+    function() {
+      var handleChange = function() {
+        var latestGetSnapshot = refs.getSnapshot;
+        var latestSetSnapshot = refs.setSnapshot;
+
+        try {
+          latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.
+
+          var lane = requestUpdateLane(fiber);
+          markRootMutableRead(root, lane);
+        } catch (error) {
+          // A selector might throw after a source mutation.
+          // e.g. it might try to read from a part of the store that no longer exists.
+          // In this case we should still schedule an update with React.
+          // Worst case the selector will throw again and then an error boundary will handle it.
+          latestSetSnapshot(function() {
+            throw error;
+          });
+        }
+      };
+
+      var unsubscribe = subscribe(source._source, handleChange);
+
+      {
+        if (typeof unsubscribe !== "function") {
+          error(
+            "Mutable source subscribe function must return an unsubscribe function."
+          );
+        }
+      }
+
+      return unsubscribe;
+    },
+    [source, subscribe]
+  ); // If any of the inputs to useMutableSource change, reading is potentially unsafe.
+  //
+  // If either the source or the subscription have changed we can't can't trust the update queue.
+  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.
+  //
+  // If the getSnapshot function changed, we also shouldn't rely on the update queue.
+  // It's possible that the underlying source was mutated between the when the last "change" event fired,
+  // and when the current render (with the new getSnapshot function) is processed.
+  //
+  // In both cases, we need to throw away pending updates (since they are no longer relevant)
+  // and treat reading from the source as we do in the mount case.
+
+  if (
+    !objectIs(prevGetSnapshot, getSnapshot) ||
+    !objectIs(prevSource, source) ||
+    !objectIs(prevSubscribe, subscribe)
+  ) {
+    // Create a new queue and setState method,
+    // So if there are interleaved updates, they get pushed to the older queue.
+    // When this becomes current, the previous queue and dispatch method will be discarded,
+    // including any interleaving updates that occur.
+    var newQueue = {
+      pending: null,
+      dispatch: null,
+      lastRenderedReducer: basicStateReducer,
+      lastRenderedState: snapshot
+    };
+    newQueue.dispatch = setSnapshot = dispatchAction.bind(
+      null,
+      currentlyRenderingFiber$1,
+      newQueue
+    );
+    stateHook.queue = newQueue;
+    stateHook.baseQueue = null;
+    snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot);
+    stateHook.memoizedState = stateHook.baseState = snapshot;
+  }
+
+  return snapshot;
+}
+
+function mountMutableSource(source, getSnapshot, subscribe) {
+  var hook = mountWorkInProgressHook();
+  hook.memoizedState = {
+    refs: {
+      getSnapshot: getSnapshot,
+      setSnapshot: null
+    },
+    source: source,
+    subscribe: subscribe
+  };
+  return useMutableSource(hook, source, getSnapshot, subscribe);
+}
+
+function updateMutableSource(source, getSnapshot, subscribe) {
+  var hook = updateWorkInProgressHook();
+  return useMutableSource(hook, source, getSnapshot, subscribe);
+}
+
 function mountState(initialState) {
   var hook = mountWorkInProgressHook();
 
@@ -10546,16 +10823,14 @@ function pushEffect(tag, create, destroy, deps) {
 
 function mountRef(initialValue) {
   var hook = mountWorkInProgressHook();
-  var ref = {
-    current: initialValue
-  };
 
   {
-    Object.seal(ref);
+    var _ref2 = {
+      current: initialValue
+    };
+    hook.memoizedState = _ref2;
+    return _ref2;
   }
-
-  hook.memoizedState = ref;
-  return ref;
 }
 
 function updateRef(initialValue) {
@@ -10563,19 +10838,19 @@ function updateRef(initialValue) {
   return hook.memoizedState;
 }
 
-function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
+function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
   var hook = mountWorkInProgressHook();
   var nextDeps = deps === undefined ? null : deps;
-  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  currentlyRenderingFiber$1.flags |= fiberFlags;
   hook.memoizedState = pushEffect(
-    HasEffect | hookEffectTag,
+    HasEffect | hookFlags,
     create,
     undefined,
     nextDeps
   );
 }
 
-function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
+function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
   var hook = updateWorkInProgressHook();
   var nextDeps = deps === undefined ? null : deps;
   var destroy = undefined;
@@ -10588,15 +10863,15 @@ function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
       var prevDeps = prevEffect.deps;
 
       if (areHookInputsEqual(nextDeps, prevDeps)) {
-        pushEffect(hookEffectTag, create, destroy, nextDeps);
+        pushEffect(hookFlags, create, destroy, nextDeps);
         return;
       }
     }
   }
 
-  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  currentlyRenderingFiber$1.flags |= fiberFlags;
   hook.memoizedState = pushEffect(
-    HasEffect | hookEffectTag,
+    HasEffect | hookFlags,
     create,
     destroy,
     nextDeps
@@ -10770,129 +11045,175 @@ function updateMemo(nextCreate, deps) {
   return nextValue;
 }
 
-function mountDeferredValue(value, config) {
+function mountDeferredValue(value) {
   var _mountState = mountState(value),
     prevValue = _mountState[0],
     setValue = _mountState[1];
 
   mountEffect(
     function() {
-      var previousConfig = ReactCurrentBatchConfig$1.suspense;
-      ReactCurrentBatchConfig$1.suspense = config === undefined ? null : config;
+      var prevTransition = ReactCurrentBatchConfig$1.transition;
+      ReactCurrentBatchConfig$1.transition = 1;
 
       try {
         setValue(value);
       } finally {
-        ReactCurrentBatchConfig$1.suspense = previousConfig;
+        ReactCurrentBatchConfig$1.transition = prevTransition;
       }
     },
-    [value, config]
+    [value]
   );
   return prevValue;
 }
 
-function updateDeferredValue(value, config) {
+function updateDeferredValue(value) {
   var _updateState = updateState(),
     prevValue = _updateState[0],
     setValue = _updateState[1];
 
   updateEffect(
     function() {
-      var previousConfig = ReactCurrentBatchConfig$1.suspense;
-      ReactCurrentBatchConfig$1.suspense = config === undefined ? null : config;
+      var prevTransition = ReactCurrentBatchConfig$1.transition;
+      ReactCurrentBatchConfig$1.transition = 1;
 
       try {
         setValue(value);
       } finally {
-        ReactCurrentBatchConfig$1.suspense = previousConfig;
+        ReactCurrentBatchConfig$1.transition = prevTransition;
       }
     },
-    [value, config]
+    [value]
   );
   return prevValue;
 }
 
-function rerenderDeferredValue(value, config) {
+function rerenderDeferredValue(value) {
   var _rerenderState = rerenderState(),
     prevValue = _rerenderState[0],
     setValue = _rerenderState[1];
 
   updateEffect(
     function() {
-      var previousConfig = ReactCurrentBatchConfig$1.suspense;
-      ReactCurrentBatchConfig$1.suspense = config === undefined ? null : config;
+      var prevTransition = ReactCurrentBatchConfig$1.transition;
+      ReactCurrentBatchConfig$1.transition = 1;
 
       try {
         setValue(value);
       } finally {
-        ReactCurrentBatchConfig$1.suspense = previousConfig;
+        ReactCurrentBatchConfig$1.transition = prevTransition;
       }
     },
-    [value, config]
+    [value]
   );
   return prevValue;
 }
 
-function startTransition(setPending, config, callback) {
+function startTransition(setPending, callback) {
   var priorityLevel = getCurrentPriorityLevel();
-  runWithPriority(
-    priorityLevel < UserBlockingPriority ? UserBlockingPriority : priorityLevel,
-    function() {
-      setPending(true);
-    }
-  );
-  runWithPriority(
-    priorityLevel > NormalPriority ? NormalPriority : priorityLevel,
-    function() {
-      var previousConfig = ReactCurrentBatchConfig$1.suspense;
-      ReactCurrentBatchConfig$1.suspense = config === undefined ? null : config;
 
-      try {
-        setPending(false);
-        callback();
-      } finally {
-        ReactCurrentBatchConfig$1.suspense = previousConfig;
+  {
+    runWithPriority(
+      priorityLevel < UserBlockingPriority$1
+        ? UserBlockingPriority$1
+        : priorityLevel,
+      function() {
+        setPending(true);
+      }
+    );
+    runWithPriority(
+      priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel,
+      function() {
+        var prevTransition = ReactCurrentBatchConfig$1.transition;
+        ReactCurrentBatchConfig$1.transition = 1;
+
+        try {
+          setPending(false);
+          callback();
+        } finally {
+          ReactCurrentBatchConfig$1.transition = prevTransition;
+        }
       }
-    }
-  );
+    );
+  }
 }
 
-function mountTransition(config) {
+function mountTransition() {
   var _mountState2 = mountState(false),
     isPending = _mountState2[0],
-    setPending = _mountState2[1];
+    setPending = _mountState2[1]; // The `start` method never changes.
 
-  var start = mountCallback(startTransition.bind(null, setPending, config), [
-    setPending,
-    config
-  ]);
+  var start = startTransition.bind(null, setPending);
+  var hook = mountWorkInProgressHook();
+  hook.memoizedState = start;
   return [start, isPending];
 }
 
-function updateTransition(config) {
+function updateTransition() {
   var _updateState2 = updateState(),
-    isPending = _updateState2[0],
-    setPending = _updateState2[1];
+    isPending = _updateState2[0];
 
-  var start = updateCallback(startTransition.bind(null, setPending, config), [
-    setPending,
-    config
-  ]);
+  var hook = updateWorkInProgressHook();
+  var start = hook.memoizedState;
   return [start, isPending];
 }
 
-function rerenderTransition(config) {
+function rerenderTransition() {
   var _rerenderState2 = rerenderState(),
-    isPending = _rerenderState2[0],
-    setPending = _rerenderState2[1];
+    isPending = _rerenderState2[0];
 
-  var start = updateCallback(startTransition.bind(null, setPending, config), [
-    setPending,
-    config
-  ]);
+  var hook = updateWorkInProgressHook();
+  var start = hook.memoizedState;
   return [start, isPending];
 }
 
+var isUpdatingOpaqueValueInRenderPhase = false;
+function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
+  {
+    return isUpdatingOpaqueValueInRenderPhase;
+  }
+}
+
+function warnOnOpaqueIdentifierAccessInDEV(fiber) {
+  {
+    // TODO: Should warn in effects and callbacks, too
+    var name = getComponentName(fiber.type) || "Unknown";
+
+    if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
+      error(
+        "The object passed back from useOpaqueIdentifier is meant to be " +
+          "passed through to attributes only. Do not read the " +
+          "value directly."
+      );
+
+      didWarnAboutUseOpaqueIdentifier[name] = true;
+    }
+  }
+}
+
+function mountOpaqueIdentifier() {
+  var makeId = makeClientIdInDEV.bind(
+    null,
+    warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1)
+  );
+
+  {
+    var _id = makeId();
+
+    mountState(_id);
+    return _id;
+  }
+}
+
+function updateOpaqueIdentifier() {
+  var id = updateState()[0];
+  return id;
+}
+
+function rerenderOpaqueIdentifier() {
+  var id = rerenderState()[0];
+  return id;
+}
+
 function dispatchAction(fiber, queue, action) {
   {
     if (typeof arguments[3] === "function") {
@@ -10904,25 +11225,15 @@ function dispatchAction(fiber, queue, action) {
     }
   }
 
-  var currentTime = requestCurrentTimeForUpdate();
-  var suspenseConfig = requestCurrentSuspenseConfig();
-  var expirationTime = computeExpirationForFiber(
-    currentTime,
-    fiber,
-    suspenseConfig
-  );
+  var eventTime = requestEventTime();
+  var lane = requestUpdateLane(fiber);
   var update = {
-    expirationTime: expirationTime,
-    suspenseConfig: suspenseConfig,
+    lane: lane,
     action: action,
     eagerReducer: null,
     eagerState: null,
     next: null
-  };
-
-  {
-    update.priority = getCurrentPriorityLevel();
-  } // Append the update to the end of the list.
+  }; // Append the update to the end of the list.
 
   var pending = queue.pending;
 
@@ -10944,13 +11255,11 @@ function dispatchAction(fiber, queue, action) {
     // This is a render phase update. Stash it in a lazily-created map of
     // queue -> linked list of updates. After this render pass, we'll restart
     // and apply the stashed updates on top of the work-in-progress hook.
-    didScheduleRenderPhaseUpdate = true;
-    update.expirationTime = renderExpirationTime;
-    currentlyRenderingFiber$1.expirationTime = renderExpirationTime;
+    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
   } else {
     if (
-      fiber.expirationTime === NoWork &&
-      (alternate === null || alternate.expirationTime === NoWork)
+      fiber.lanes === NoLanes &&
+      (alternate === null || alternate.lanes === NoLanes)
     ) {
       // The queue is currently empty, which means we can eagerly compute the
       // next state before entering the render phase. If the new state is the
@@ -10961,8 +11270,8 @@ function dispatchAction(fiber, queue, action) {
         var prevDispatcher;
 
         {
-          prevDispatcher = ReactCurrentDispatcher.current;
-          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+          prevDispatcher = ReactCurrentDispatcher$1.current;
+          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
         }
 
         try {
@@ -10986,7 +11295,7 @@ function dispatchAction(fiber, queue, action) {
           // Suppress the error. It will throw again in the render phase.
         } finally {
           {
-            ReactCurrentDispatcher.current = prevDispatcher;
+            ReactCurrentDispatcher$1.current = prevDispatcher;
           }
         }
       }
@@ -11000,18 +11309,10 @@ function dispatchAction(fiber, queue, action) {
       }
     }
 
-    scheduleWork(fiber, expirationTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   }
 }
 
-function mountEventListener(event) {
-  return undefined;
-}
-
-function updateEventListener(event) {
-  return undefined;
-}
-
 var ContextOnlyDispatcher = {
   readContext: readContext,
   useCallback: throwInvalidHookError,
@@ -11024,10 +11325,11 @@ var ContextOnlyDispatcher = {
   useRef: throwInvalidHookError,
   useState: throwInvalidHookError,
   useDebugValue: throwInvalidHookError,
-  useResponder: throwInvalidHookError,
   useDeferredValue: throwInvalidHookError,
   useTransition: throwInvalidHookError,
-  useEvent: throwInvalidHookError
+  useMutableSource: throwInvalidHookError,
+  useOpaqueIdentifier: throwInvalidHookError,
+  unstable_isNewReconciler: enableNewReconciler
 };
 var HooksDispatcherOnMountInDEV = null;
 var HooksDispatcherOnMountWithHookTypesInDEV = null;
@@ -11052,7 +11354,7 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. " +
         "You can only call Hooks at the top level of your React function. " +
         "For more information, see " +
-        "https://fb.me/rules-of-hooks"
+        "https://reactjs.org/link/rules-of-hooks"
     );
   };
 
@@ -11093,25 +11395,25 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useMemo";
       mountHookTypesDev();
       checkDepsAreArrayDev(deps);
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11122,13 +11424,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useState: function(initialState) {
       currentHookNameInDev = "useState";
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11136,26 +11438,27 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       mountHookTypesDev();
       return mountDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      mountHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
-    useDeferredValue: function(value, config) {
+    useDeferredValue: function(value) {
       currentHookNameInDev = "useDeferredValue";
       mountHookTypesDev();
-      return mountDeferredValue(value, config);
+      return mountDeferredValue(value);
     },
-    useTransition: function(config) {
+    useTransition: function() {
       currentHookNameInDev = "useTransition";
       mountHookTypesDev();
-      return mountTransition(config);
+      return mountTransition();
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       mountHookTypesDev();
-      return mountEventListener();
-    }
+      return mountMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      mountHookTypesDev();
+      return mountOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   HooksDispatcherOnMountWithHookTypesInDEV = {
     readContext: function(context, observedBits) {
@@ -11189,25 +11492,25 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useMemo: function(create, deps) {
       currentHookNameInDev = "useMemo";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11218,13 +11521,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useState: function(initialState) {
       currentHookNameInDev = "useState";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11232,26 +11535,27 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return mountDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
-    useDeferredValue: function(value, config) {
+    useDeferredValue: function(value) {
       currentHookNameInDev = "useDeferredValue";
       updateHookTypesDev();
-      return mountDeferredValue(value, config);
+      return mountDeferredValue(value);
     },
-    useTransition: function(config) {
+    useTransition: function() {
       currentHookNameInDev = "useTransition";
       updateHookTypesDev();
-      return mountTransition(config);
+      return mountTransition();
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       updateHookTypesDev();
-      return mountEventListener();
-    }
+      return mountMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      updateHookTypesDev();
+      return mountOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   HooksDispatcherOnUpdateInDEV = {
     readContext: function(context, observedBits) {
@@ -11285,25 +11589,25 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useMemo: function(create, deps) {
       currentHookNameInDev = "useMemo";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11314,13 +11618,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useState: function(initialState) {
       currentHookNameInDev = "useState";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11328,26 +11632,27 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
-    useDeferredValue: function(value, config) {
+    useDeferredValue: function(value) {
       currentHookNameInDev = "useDeferredValue";
       updateHookTypesDev();
-      return updateDeferredValue(value, config);
+      return updateDeferredValue(value);
     },
-    useTransition: function(config) {
+    useTransition: function() {
       currentHookNameInDev = "useTransition";
       updateHookTypesDev();
-      return updateTransition(config);
+      return updateTransition();
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       updateHookTypesDev();
-      return updateEventListener();
-    }
+      return updateMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      updateHookTypesDev();
+      return updateOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   HooksDispatcherOnRerenderInDEV = {
     readContext: function(context, observedBits) {
@@ -11381,25 +11686,25 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useMemo: function(create, deps) {
       currentHookNameInDev = "useMemo";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
 
       try {
         return updateMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
 
       try {
         return rerenderReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11410,13 +11715,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useState: function(initialState) {
       currentHookNameInDev = "useState";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
 
       try {
         return rerenderState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11424,26 +11729,27 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
-    useDeferredValue: function(value, config) {
+    useDeferredValue: function(value) {
       currentHookNameInDev = "useDeferredValue";
       updateHookTypesDev();
-      return rerenderDeferredValue(value, config);
+      return rerenderDeferredValue(value);
     },
-    useTransition: function(config) {
+    useTransition: function() {
       currentHookNameInDev = "useTransition";
       updateHookTypesDev();
-      return rerenderTransition(config);
+      return rerenderTransition();
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       updateHookTypesDev();
-      return updateEventListener();
-    }
+      return updateMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      updateHookTypesDev();
+      return rerenderOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   InvalidNestedHooksDispatcherOnMountInDEV = {
     readContext: function(context, observedBits) {
@@ -11484,26 +11790,26 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useMemo";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11516,13 +11822,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useState";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11531,30 +11837,31 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       mountHookTypesDev();
       return mountDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
+    useDeferredValue: function(value) {
+      currentHookNameInDev = "useDeferredValue";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
+      return mountDeferredValue(value);
     },
-    useDeferredValue: function(value, config) {
-      currentHookNameInDev = "useDeferredValue";
+    useTransition: function() {
+      currentHookNameInDev = "useTransition";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      return mountDeferredValue(value, config);
+      return mountTransition();
     },
-    useTransition: function(config) {
-      currentHookNameInDev = "useTransition";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      return mountTransition(config);
+      return mountMutableSource(source, getSnapshot, subscribe);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      return mountEventListener();
-    }
+      return mountOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   InvalidNestedHooksDispatcherOnUpdateInDEV = {
     readContext: function(context, observedBits) {
@@ -11595,26 +11902,26 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useMemo";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11627,13 +11934,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useState";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11642,30 +11949,31 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
+    useDeferredValue: function(value) {
+      currentHookNameInDev = "useDeferredValue";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
+      return updateDeferredValue(value);
     },
-    useDeferredValue: function(value, config) {
-      currentHookNameInDev = "useDeferredValue";
+    useTransition: function() {
+      currentHookNameInDev = "useTransition";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return updateDeferredValue(value, config);
+      return updateTransition();
     },
-    useTransition: function(config) {
-      currentHookNameInDev = "useTransition";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return updateTransition(config);
+      return updateMutableSource(source, getSnapshot, subscribe);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return updateEventListener();
-    }
+      return updateOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   InvalidNestedHooksDispatcherOnRerenderInDEV = {
     readContext: function(context, observedBits) {
@@ -11706,26 +12014,26 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useMemo";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return rerenderReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11738,13 +12046,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useState";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return rerenderState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11753,30 +12061,31 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
+    useDeferredValue: function(value) {
+      currentHookNameInDev = "useDeferredValue";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
+      return rerenderDeferredValue(value);
     },
-    useDeferredValue: function(value, config) {
-      currentHookNameInDev = "useDeferredValue";
+    useTransition: function() {
+      currentHookNameInDev = "useTransition";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return rerenderDeferredValue(value, config);
+      return rerenderTransition();
     },
-    useTransition: function(config) {
-      currentHookNameInDev = "useTransition";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return rerenderTransition(config);
+      return updateMutableSource(source, getSnapshot, subscribe);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return updateEventListener();
-    }
+      return rerenderOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
 }
 
@@ -11817,40 +12126,15 @@ function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
   }
 }
 
-function enterHydrationState(fiber) {
-  {
-    return false;
-  }
-}
-
-function prepareToHydrateHostInstance(
-  fiber,
-  rootContainerInstance,
-  hostContext
-) {
-  {
-    {
-      throw Error(
-        "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-  }
-}
-
-function prepareToHydrateHostTextInstance(fiber) {
-  {
-    {
-      throw Error(
-        "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-  }
-  var shouldUpdate = hydrateTextInstance();
-}
+function transferActualDuration(fiber) {
+  // Transfer time spent rendering these children so we don't lose it
+  // after we rerender. This is used as a helper in special cases
+  // where we should count the work of multiple passes.
+  var child = fiber.child;
 
-function popHydrationState(fiber) {
-  {
-    return false;
+  while (child) {
+    fiber.actualDuration += child.actualDuration;
+    child = child.sibling;
   }
 }
 
@@ -11876,12 +12160,7 @@ var didWarnAboutTailOptions;
   didWarnAboutTailOptions = {};
 }
 
-function reconcileChildren(
-  current,
-  workInProgress,
-  nextChildren,
-  renderExpirationTime
-) {
+function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
   if (current === null) {
     // If this is a fresh new component that hasn't been rendered yet, we
     // won't update its child set by applying minimal side-effects. Instead,
@@ -11891,7 +12170,7 @@ function reconcileChildren(
       workInProgress,
       null,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
   } else {
     // If the current child is the same as the work in progress, it means that
@@ -11903,7 +12182,7 @@ function reconcileChildren(
       workInProgress,
       current.child,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
   }
 }
@@ -11912,7 +12191,7 @@ function forceUnmountCurrentAndReconcile(
   current,
   workInProgress,
   nextChildren,
-  renderExpirationTime
+  renderLanes
 ) {
   // This function is fork of reconcileChildren. It's used in cases where we
   // want to reconcile without matching against the existing set. This has the
@@ -11926,7 +12205,7 @@ function forceUnmountCurrentAndReconcile(
     workInProgress,
     current.child,
     null,
-    renderExpirationTime
+    renderLanes
   ); // In the second pass, we mount the new children. The trick here is that we
   // pass null in place of where we usually pass the current child set. This has
   // the effect of remounting all children regardless of whether their
@@ -11936,7 +12215,7 @@ function forceUnmountCurrentAndReconcile(
     workInProgress,
     null,
     nextChildren,
-    renderExpirationTime
+    renderLanes
   );
 }
 
@@ -11945,7 +12224,7 @@ function updateForwardRef(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   // TODO: current can be non-null here even if the component
   // hasn't yet mounted. This happens after the first render suspends.
@@ -11971,7 +12250,7 @@ function updateForwardRef(
   var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent
 
   var nextChildren;
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
 
   {
     ReactCurrentOwner$1.current = workInProgress;
@@ -11982,28 +12261,19 @@ function updateForwardRef(
       render,
       nextProps,
       ref,
-      renderExpirationTime
+      renderLanes
     );
 
     setIsRendering(false);
   }
 
   if (current !== null && !didReceiveUpdate) {
-    bailoutHooks(current, workInProgress, renderExpirationTime);
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    bailoutHooks(current, workInProgress, renderLanes);
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   } // React DevTools reads this flag.
 
-  workInProgress.effectTag |= PerformedWork;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  workInProgress.flags |= PerformedWork;
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -12012,8 +12282,8 @@ function updateMemoComponent(
   workInProgress,
   Component,
   nextProps,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
   if (current === null) {
     var type = Component.type;
@@ -12043,8 +12313,8 @@ function updateMemoComponent(
         workInProgress,
         resolvedType,
         nextProps,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     }
 
@@ -12067,9 +12337,9 @@ function updateMemoComponent(
       Component.type,
       null,
       nextProps,
-      null,
+      workInProgress,
       workInProgress.mode,
-      renderExpirationTime
+      renderLanes
     );
     child.ref = workInProgress.ref;
     child.return = workInProgress;
@@ -12095,7 +12365,7 @@ function updateMemoComponent(
 
   var currentChild = current.child; // This is always exactly one child
 
-  if (updateExpirationTime < renderExpirationTime) {
+  if (!includesSomeLane(updateLanes, renderLanes)) {
     // This will be the props with resolved defaultProps,
     // unlike current.memoizedProps which will be the unresolved ones.
     var prevProps = currentChild.memoizedProps; // Default to shallow comparison
@@ -12104,15 +12374,11 @@ function updateMemoComponent(
     compare = compare !== null ? compare : shallowEqual;
 
     if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
-      return bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
     }
   } // React DevTools reads this flag.
 
-  workInProgress.effectTag |= PerformedWork;
+  workInProgress.flags |= PerformedWork;
   var newChild = createWorkInProgress(currentChild, nextProps);
   newChild.ref = workInProgress.ref;
   newChild.return = workInProgress;
@@ -12125,8 +12391,8 @@ function updateSimpleMemoComponent(
   workInProgress,
   Component,
   nextProps,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
   // TODO: current can be non-null here even if the component
   // hasn't yet mounted. This happens when the inner render suspends.
@@ -12141,19 +12407,27 @@ function updateSimpleMemoComponent(
         // We warn when you define propTypes on lazy()
         // so let's just skip over it to find memo() outer wrapper.
         // Inner props for memo are validated later.
-        outerMemoType = refineResolvedLazyComponent(outerMemoType);
-      }
+        var lazyComponent = outerMemoType;
+        var payload = lazyComponent._payload;
+        var init = lazyComponent._init;
 
-      var outerPropTypes = outerMemoType && outerMemoType.propTypes;
-
-      if (outerPropTypes) {
-        checkPropTypes(
-          outerPropTypes,
-          nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
-          "prop",
-          getComponentName(outerMemoType)
-        );
-      } // Inner propTypes will be validated in the function component path.
+        try {
+          outerMemoType = init(payload);
+        } catch (x) {
+          outerMemoType = null;
+        } // Inner propTypes will be validated in the function component path.
+
+        var outerPropTypes = outerMemoType && outerMemoType.propTypes;
+
+        if (outerPropTypes) {
+          checkPropTypes(
+            outerPropTypes,
+            nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
+            "prop",
+            getComponentName(outerMemoType)
+          );
+        }
+      }
     }
   }
 
@@ -12167,10 +12441,10 @@ function updateSimpleMemoComponent(
     ) {
       didReceiveUpdate = false;
 
-      if (updateExpirationTime < renderExpirationTime) {
-        // The pending update priority was cleared at the beginning of
-        // beginWork. We're about to bail out, but there might be additional
-        // updates at a lower priority. Usually, the priority level of the
+      if (!includesSomeLane(renderLanes, updateLanes)) {
+        // The pending lanes were cleared at the beginning of beginWork. We're
+        // about to bail out, but there might be other lanes that weren't
+        // included in the current render. Usually, the priority level of the
         // remaining updates is accumlated during the evaluation of the
         // component (i.e. when processing the update queue). But since since
         // we're bailing out early *without* evaluating the component, we need
@@ -12181,12 +12455,16 @@ function updateSimpleMemoComponent(
         // contains hooks.
         // TODO: Move the reset at in beginWork out of the common path so that
         // this is no longer necessary.
-        workInProgress.expirationTime = current.expirationTime;
+        workInProgress.lanes = current.lanes;
         return bailoutOnAlreadyFinishedWork(
           current,
           workInProgress,
-          renderExpirationTime
+          renderLanes
         );
+      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
+        // This is a special case that only exists for legacy mode.
+        // See https://github.com/facebook/react/pull/19216.
+        didReceiveUpdate = true;
       }
     }
   }
@@ -12196,35 +12474,103 @@ function updateSimpleMemoComponent(
     workInProgress,
     Component,
     nextProps,
-    renderExpirationTime
+    renderLanes
   );
 }
 
-function updateFragment(current, workInProgress, renderExpirationTime) {
+function updateOffscreenComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps;
+  var nextChildren = nextProps.children;
+  var prevState = current !== null ? current.memoizedState : null;
+
+  if (
+    nextProps.mode === "hidden" ||
+    nextProps.mode === "unstable-defer-without-hiding"
+  ) {
+    if ((workInProgress.mode & ConcurrentMode) === NoMode) {
+      // In legacy sync mode, don't defer the subtree. Render it now.
+      // TODO: Figure out what we should do in Blocking mode.
+      var nextState = {
+        baseLanes: NoLanes
+      };
+      workInProgress.memoizedState = nextState;
+      pushRenderLanes(workInProgress, renderLanes);
+    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {
+      var nextBaseLanes;
+
+      if (prevState !== null) {
+        var prevBaseLanes = prevState.baseLanes;
+        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
+      } else {
+        nextBaseLanes = renderLanes;
+      } // Schedule this fiber to re-render at offscreen priority. Then bailout.
+
+      {
+        markSpawnedWork(OffscreenLane);
+      }
+
+      workInProgress.lanes = workInProgress.childLanes = laneToLanes(
+        OffscreenLane
+      );
+      var _nextState = {
+        baseLanes: nextBaseLanes
+      };
+      workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway
+      // to avoid a push/pop misalignment.
+
+      pushRenderLanes(workInProgress, nextBaseLanes);
+      return null;
+    } else {
+      // Rendering at offscreen, so we can clear the base lanes.
+      var _nextState2 = {
+        baseLanes: NoLanes
+      };
+      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.
+
+      var subtreeRenderLanes =
+        prevState !== null ? prevState.baseLanes : renderLanes;
+      pushRenderLanes(workInProgress, subtreeRenderLanes);
+    }
+  } else {
+    var _subtreeRenderLanes;
+
+    if (prevState !== null) {
+      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes); // Since we're not hidden anymore, reset the state
+
+      workInProgress.memoizedState = null;
+    } else {
+      // We weren't previously hidden, and we still aren't, so there's nothing
+      // special to do. Need to push to the stack regardless, though, to avoid
+      // a push/pop misalignment.
+      _subtreeRenderLanes = renderLanes;
+    }
+
+    pushRenderLanes(workInProgress, _subtreeRenderLanes);
+  }
+
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+  return workInProgress.child;
+} // Note: These happen to have identical begin phases, for now. We shouldn't hold
+// ourselves to this constraint, though. If the behavior diverges, we should
+// fork the function.
+
+var updateLegacyHiddenComponent = updateOffscreenComponent;
+
+function updateFragment(current, workInProgress, renderLanes) {
   var nextChildren = workInProgress.pendingProps;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
-function updateMode(current, workInProgress, renderExpirationTime) {
+function updateMode(current, workInProgress, renderLanes) {
   var nextChildren = workInProgress.pendingProps.children;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
-function updateProfiler(current, workInProgress, renderExpirationTime) {
+function updateProfiler(current, workInProgress, renderLanes) {
   {
-    workInProgress.effectTag |= Update; // Reset effect durations for the next eventual effect phase.
+    workInProgress.flags |= Update; // Reset effect durations for the next eventual effect phase.
     // These are reset during render to allow the DevTools commit hook a chance to read them,
 
     var stateNode = workInProgress.stateNode;
@@ -12234,12 +12580,7 @@ function updateProfiler(current, workInProgress, renderExpirationTime) {
 
   var nextProps = workInProgress.pendingProps;
   var nextChildren = nextProps.children;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -12251,7 +12592,7 @@ function markRef(current, workInProgress) {
     (current !== null && current.ref !== ref)
   ) {
     // Schedule a Ref effect
-    workInProgress.effectTag |= Ref;
+    workInProgress.flags |= Ref;
   }
 }
 
@@ -12260,7 +12601,7 @@ function updateFunctionComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   {
     if (workInProgress.type !== workInProgress.elementType) {
@@ -12287,7 +12628,7 @@ function updateFunctionComponent(
   }
 
   var nextChildren;
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
 
   {
     ReactCurrentOwner$1.current = workInProgress;
@@ -12298,28 +12639,19 @@ function updateFunctionComponent(
       Component,
       nextProps,
       context,
-      renderExpirationTime
+      renderLanes
     );
 
     setIsRendering(false);
   }
 
   if (current !== null && !didReceiveUpdate) {
-    bailoutHooks(current, workInProgress, renderExpirationTime);
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    bailoutHooks(current, workInProgress, renderLanes);
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   } // React DevTools reads this flag.
 
-  workInProgress.effectTag |= PerformedWork;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  workInProgress.flags |= PerformedWork;
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -12328,7 +12660,7 @@ function updateClassComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   {
     if (workInProgress.type !== workInProgress.elementType) {
@@ -12358,7 +12690,7 @@ function updateClassComponent(
     hasContext = false;
   }
 
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   var instance = workInProgress.stateNode;
   var shouldUpdate;
 
@@ -12371,16 +12703,11 @@ function updateClassComponent(
       current.alternate = null;
       workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
 
-      workInProgress.effectTag |= Placement;
+      workInProgress.flags |= Placement;
     } // In the initial pass we might need to construct the instance.
 
     constructClassInstance(workInProgress, Component, nextProps);
-    mountClassInstance(
-      workInProgress,
-      Component,
-      nextProps,
-      renderExpirationTime
-    );
+    mountClassInstance(workInProgress, Component, nextProps, renderLanes);
     shouldUpdate = true;
   } else if (current === null) {
     // In a resume, we'll already have an instance we can reuse.
@@ -12388,7 +12715,7 @@ function updateClassComponent(
       workInProgress,
       Component,
       nextProps,
-      renderExpirationTime
+      renderLanes
     );
   } else {
     shouldUpdate = updateClassInstance(
@@ -12396,7 +12723,7 @@ function updateClassComponent(
       workInProgress,
       Component,
       nextProps,
-      renderExpirationTime
+      renderLanes
     );
   }
 
@@ -12406,13 +12733,13 @@ function updateClassComponent(
     Component,
     shouldUpdate,
     hasContext,
-    renderExpirationTime
+    renderLanes
   );
 
   {
     var inst = workInProgress.stateNode;
 
-    if (inst.props !== nextProps) {
+    if (shouldUpdate && inst.props !== nextProps) {
       if (!didWarnAboutReassigningProps) {
         error(
           "It looks like %s is reassigning its own `this.props` while rendering. " +
@@ -12434,11 +12761,11 @@ function finishClassComponent(
   Component,
   shouldUpdate,
   hasContext,
-  renderExpirationTime
+  renderLanes
 ) {
   // Refs should update even if shouldComponentUpdate returns false
   markRef(current, workInProgress);
-  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;
+  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;
 
   if (!shouldUpdate && !didCaptureError) {
     // Context providers should defer to sCU for rendering
@@ -12446,11 +12773,7 @@ function finishClassComponent(
       invalidateContextProvider(workInProgress, Component, false);
     }
 
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   }
 
   var instance = workInProgress.stateNode; // Rerender
@@ -12481,7 +12804,7 @@ function finishClassComponent(
     }
   } // React DevTools reads this flag.
 
-  workInProgress.effectTag |= PerformedWork;
+  workInProgress.flags |= PerformedWork;
 
   if (current !== null && didCaptureError) {
     // If we're recovering from an error, reconcile without reusing any of
@@ -12492,15 +12815,10 @@ function finishClassComponent(
       current,
       workInProgress,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
   } else {
-    reconcileChildren(
-      current,
-      workInProgress,
-      nextChildren,
-      renderExpirationTime
-    );
+    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   } // Memoize state using the values we just used to render.
   // TODO: Restructure so we never read values from the instance.
 
@@ -12530,7 +12848,7 @@ function pushHostRootContext(workInProgress) {
   pushHostContainer(workInProgress, root.containerInfo);
 }
 
-function updateHostRoot(current, workInProgress, renderExpirationTime) {
+function updateHostRoot(current, workInProgress, renderLanes) {
   pushHostRootContext(workInProgress);
   var updateQueue = workInProgress.updateQueue;
 
@@ -12544,32 +12862,24 @@ function updateHostRoot(current, workInProgress, renderExpirationTime) {
   var prevState = workInProgress.memoizedState;
   var prevChildren = prevState !== null ? prevState.element : null;
   cloneUpdateQueue(current, workInProgress);
-  processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);
+  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
   var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property
   // being called "element".
 
   var nextChildren = nextState.element;
 
   if (nextChildren === prevChildren) {
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   }
 
   var root = workInProgress.stateNode;
 
   if (root.hydrate && enterHydrationState()) {
-    // If we don't have any current children this might be the first pass.
-    // We always try to hydrate. If this isn't a hydration pass there won't
-    // be any children to hydrate which is effectively the same thing as
-    // not hydrating.
     var child = mountChildFibers(
       workInProgress,
       null,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
     workInProgress.child = child;
     var node = child;
@@ -12581,24 +12891,19 @@ function updateHostRoot(current, workInProgress, renderExpirationTime) {
       // Conceptually this is similar to Placement in that a new subtree is
       // inserted into the React tree here. It just happens to not need DOM
       // mutations because it already exists.
-      node.effectTag = (node.effectTag & ~Placement) | Hydrating;
+      node.flags = (node.flags & ~Placement) | Hydrating;
       node = node.sibling;
     }
   } else {
     // Otherwise reset hydration state in case we aborted and resumed another
     // root.
-    reconcileChildren(
-      current,
-      workInProgress,
-      nextChildren,
-      renderExpirationTime
-    );
+    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   }
 
   return workInProgress.child;
 }
 
-function updateHostComponent(current, workInProgress, renderExpirationTime) {
+function updateHostComponent(current, workInProgress, renderLanes) {
   pushHostContext(workInProgress);
 
   var type = workInProgress.type;
@@ -12609,30 +12914,11 @@ function updateHostComponent(current, workInProgress, renderExpirationTime) {
   if (prevProps !== null && shouldSetTextContent()) {
     // If we're switching from a direct text child to a normal child, or to
     // empty, we need to schedule the text content to be reset.
-    workInProgress.effectTag |= ContentReset;
-  }
-
-  markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.
-
-  if (
-    workInProgress.mode & ConcurrentMode &&
-    renderExpirationTime !== Never &&
-    shouldDeprioritizeSubtree()
-  ) {
-    {
-      markSpawnedWork(Never);
-    } // Schedule this fiber to re-render at offscreen priority. Then bailout.
-
-    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
-    return null;
+    workInProgress.flags |= ContentReset;
   }
 
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  markRef(current, workInProgress);
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -12646,8 +12932,8 @@ function mountLazyComponent(
   _current,
   workInProgress,
   elementType,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
   if (_current !== null) {
     // A lazy component only mounts if it suspended inside a non-
@@ -12657,18 +12943,17 @@ function mountLazyComponent(
     _current.alternate = null;
     workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
 
-    workInProgress.effectTag |= Placement;
+    workInProgress.flags |= Placement;
   }
 
-  var props = workInProgress.pendingProps; // We can't start a User Timing measurement with correct label yet.
-  // Cancel and resume right after we know the tag.
-
-  cancelWorkTimer(workInProgress);
-  var Component = readLazyComponentType(elementType); // Store the unwrapped component in the type.
+  var props = workInProgress.pendingProps;
+  var lazyComponent = elementType;
+  var payload = lazyComponent._payload;
+  var init = lazyComponent._init;
+  var Component = init(payload); // Store the unwrapped component in the type.
 
   workInProgress.type = Component;
   var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));
-  startWorkTimer(workInProgress);
   var resolvedProps = resolveDefaultProps(Component, props);
   var child;
 
@@ -12686,7 +12971,7 @@ function mountLazyComponent(
         workInProgress,
         Component,
         resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
       return child;
     }
@@ -12703,7 +12988,7 @@ function mountLazyComponent(
         workInProgress,
         Component,
         resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
       return child;
     }
@@ -12720,7 +13005,7 @@ function mountLazyComponent(
         workInProgress,
         Component,
         resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
       return child;
     }
@@ -12746,8 +13031,8 @@ function mountLazyComponent(
         workInProgress,
         Component,
         resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
       return child;
     }
@@ -12782,7 +13067,7 @@ function mountIncompleteClassComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   if (_current !== null) {
     // An incomplete component only mounts if it suspended inside a non-
@@ -12792,7 +13077,7 @@ function mountIncompleteClassComponent(
     _current.alternate = null;
     workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
 
-    workInProgress.effectTag |= Placement;
+    workInProgress.flags |= Placement;
   } // Promote the fiber to a class and try rendering again.
 
   workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`
@@ -12809,21 +13094,16 @@ function mountIncompleteClassComponent(
     hasContext = false;
   }
 
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   constructClassInstance(workInProgress, Component, nextProps);
-  mountClassInstance(
-    workInProgress,
-    Component,
-    nextProps,
-    renderExpirationTime
-  );
+  mountClassInstance(workInProgress, Component, nextProps, renderLanes);
   return finishClassComponent(
     null,
     workInProgress,
     Component,
     true,
     hasContext,
-    renderExpirationTime
+    renderLanes
   );
 }
 
@@ -12831,7 +13111,7 @@ function mountIndeterminateComponent(
   _current,
   workInProgress,
   Component,
-  renderExpirationTime
+  renderLanes
 ) {
   if (_current !== null) {
     // An indeterminate component only mounts if it suspended inside a non-
@@ -12841,7 +13121,7 @@ function mountIndeterminateComponent(
     _current.alternate = null;
     workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
 
-    workInProgress.effectTag |= Placement;
+    workInProgress.flags |= Placement;
   }
 
   var props = workInProgress.pendingProps;
@@ -12852,7 +13132,7 @@ function mountIndeterminateComponent(
     context = getMaskedContext(workInProgress, unmaskedContext);
   }
 
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   var value;
 
   {
@@ -12878,6 +13158,7 @@ function mountIndeterminateComponent(
       ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
     }
 
+    setIsRendering(true);
     ReactCurrentOwner$1.current = workInProgress;
     value = renderWithHooks(
       null,
@@ -12885,34 +13166,65 @@ function mountIndeterminateComponent(
       Component,
       props,
       context,
-      renderExpirationTime
+      renderLanes
     );
+    setIsRendering(false);
   } // React DevTools reads this flag.
 
-  workInProgress.effectTag |= PerformedWork;
+  workInProgress.flags |= PerformedWork;
+
+  {
+    // Support for module components is deprecated and is removed behind a flag.
+    // Whether or not it would crash later, we want to show a good message in DEV first.
+    if (
+      typeof value === "object" &&
+      value !== null &&
+      typeof value.render === "function" &&
+      value.$$typeof === undefined
+    ) {
+      var _componentName = getComponentName(Component) || "Unknown";
+
+      if (!didWarnAboutModulePatternComponent[_componentName]) {
+        error(
+          "The <%s /> component appears to be a function component that returns a class instance. " +
+            "Change %s to a class that extends React.Component instead. " +
+            "If you can't use a class try assigning the prototype on the function as a workaround. " +
+            "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " +
+            "cannot be called with `new` by React.",
+          _componentName,
+          _componentName,
+          _componentName
+        );
+
+        didWarnAboutModulePatternComponent[_componentName] = true;
+      }
+    }
+  }
 
   if (
+    // Run these checks in production only if the flag is off.
+    // Eventually we'll delete this branch altogether.
     typeof value === "object" &&
     value !== null &&
     typeof value.render === "function" &&
     value.$$typeof === undefined
   ) {
     {
-      var _componentName = getComponentName(Component) || "Unknown";
+      var _componentName2 = getComponentName(Component) || "Unknown";
 
-      if (!didWarnAboutModulePatternComponent[_componentName]) {
+      if (!didWarnAboutModulePatternComponent[_componentName2]) {
         error(
           "The <%s /> component appears to be a function component that returns a class instance. " +
             "Change %s to a class that extends React.Component instead. " +
             "If you can't use a class try assigning the prototype on the function as a workaround. " +
             "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " +
             "cannot be called with `new` by React.",
-          _componentName,
-          _componentName,
-          _componentName
+          _componentName2,
+          _componentName2,
+          _componentName2
         );
 
-        didWarnAboutModulePatternComponent[_componentName] = true;
+        didWarnAboutModulePatternComponent[_componentName2] = true;
       }
     } // Proceed under the assumption that this is a class instance
 
@@ -12947,20 +13259,20 @@ function mountIndeterminateComponent(
     }
 
     adoptClassInstance(workInProgress, value);
-    mountClassInstance(workInProgress, Component, props, renderExpirationTime);
+    mountClassInstance(workInProgress, Component, props, renderLanes);
     return finishClassComponent(
       null,
       workInProgress,
       Component,
       true,
       hasContext,
-      renderExpirationTime
+      renderLanes
     );
   } else {
     // Proceed under the assumption that this is a function component
     workInProgress.tag = FunctionComponent;
 
-    reconcileChildren(null, workInProgress, value, renderExpirationTime);
+    reconcileChildren(null, workInProgress, value, renderLanes);
 
     {
       validateFunctionComponentInDev(workInProgress, Component);
@@ -13009,15 +13321,15 @@ function validateFunctionComponentInDev(workInProgress, Component) {
     }
 
     if (typeof Component.getDerivedStateFromProps === "function") {
-      var _componentName2 = getComponentName(Component) || "Unknown";
+      var _componentName3 = getComponentName(Component) || "Unknown";
 
-      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {
+      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
         error(
           "%s: Function components do not support getDerivedStateFromProps.",
-          _componentName2
+          _componentName3
         );
 
-        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true;
+        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
       }
     }
 
@@ -13025,15 +13337,15 @@ function validateFunctionComponentInDev(workInProgress, Component) {
       typeof Component.contextType === "object" &&
       Component.contextType !== null
     ) {
-      var _componentName3 = getComponentName(Component) || "Unknown";
+      var _componentName4 = getComponentName(Component) || "Unknown";
 
-      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {
+      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
         error(
           "%s: Function components do not support contextType.",
-          _componentName3
+          _componentName4
         );
 
-        didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true;
+        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
       }
     }
   }
@@ -13041,41 +13353,68 @@ function validateFunctionComponentInDev(workInProgress, Component) {
 
 var SUSPENDED_MARKER = {
   dehydrated: null,
-  retryTime: NoWork
+  retryLane: NoLane
 };
 
-function shouldRemainOnFallback(suspenseContext, current, workInProgress) {
-  // If the context is telling us that we should show a fallback, and we're not
-  // already showing content, then we should show the fallback instead.
-  return (
-    hasSuspenseContext(suspenseContext, ForceSuspenseFallback) &&
-    (current === null || current.memoizedState !== null)
-  );
+function mountSuspenseOffscreenState(renderLanes) {
+  return {
+    baseLanes: renderLanes
+  };
 }
 
-function updateSuspenseComponent(
+function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
+  return {
+    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes)
+  };
+} // TODO: Probably should inline this back
+
+function shouldRemainOnFallback(
+  suspenseContext,
   current,
   workInProgress,
-  renderExpirationTime
+  renderLanes
 ) {
-  var mode = workInProgress.mode;
+  // If we're already showing a fallback, there are cases where we need to
+  // remain on that fallback regardless of whether the content has resolved.
+  // For example, SuspenseList coordinates when nested content appears.
+  if (current !== null) {
+    var suspenseState = current.memoizedState;
+
+    if (suspenseState === null) {
+      // Currently showing content. Don't hide it, even if ForceSuspenseFallack
+      // is true. More precise name might be "ForceRemainSuspenseFallback".
+      // Note: This is a factoring smell. Can't remain on a fallback if there's
+      // no fallback to remain on.
+      return false;
+    }
+  } // Not currently showing content. Consult the Suspense context.
+
+  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
+}
+
+function getRemainingWorkInPrimaryTree(current, renderLanes) {
+  // TODO: Should not remove render lanes that were pinged during this render
+  return removeLanes(current.childLanes, renderLanes);
+}
+
+function updateSuspenseComponent(current, workInProgress, renderLanes) {
   var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.
 
   {
     if (shouldSuspend(workInProgress)) {
-      workInProgress.effectTag |= DidCapture;
+      workInProgress.flags |= DidCapture;
     }
   }
 
   var suspenseContext = suspenseStackCursor.current;
-  var nextDidTimeout = false;
-  var didSuspend = (workInProgress.effectTag & DidCapture) !== NoEffect;
+  var showFallback = false;
+  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;
 
   if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
     // Something in this boundary's subtree already suspended. Switch to
     // rendering the fallback children.
-    nextDidTimeout = true;
-    workInProgress.effectTag &= ~DidCapture;
+    showFallback = true;
+    workInProgress.flags &= ~DidCapture;
   } else {
     // Attempting the main content
     if (current === null || current.memoizedState !== null) {
@@ -13097,290 +13436,411 @@ function updateSuspenseComponent(
   }
 
   suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
-  pushSuspenseContext(workInProgress, suspenseContext); // This next part is a bit confusing. If the children timeout, we switch to
-  // showing the fallback children in place of the "primary" children.
-  // However, we don't want to delete the primary children because then their
-  // state will be lost (both the React state and the host state, e.g.
-  // uncontrolled form inputs). Instead we keep them mounted and hide them.
-  // Both the fallback children AND the primary children are rendered at the
-  // same time. Once the primary children are un-suspended, we can delete
-  // the fallback children  don't need to preserve their state.
+  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
+  // boundary's children. This involves some custom reconcilation logic. Two
+  // main reasons this is so complicated.
   //
-  // The two sets of children are siblings in the host environment, but
-  // semantically, for purposes of reconciliation, they are two separate sets.
-  // So we store them using two fragment fibers.
+  // First, Legacy Mode has different semantics for backwards compatibility. The
+  // primary tree will commit in an inconsistent state, so when we do the
+  // second pass to render the fallback, we do some exceedingly, uh, clever
+  // hacks to make that not totally break. Like transferring effects and
+  // deletions from hidden tree. In Concurrent Mode, it's much simpler,
+  // because we bailout on the primary tree completely and leave it in its old
+  // state, no effects. Same as what we do for Offscreen (except that
+  // Offscreen doesn't have the first render pass).
   //
-  // However, we want to avoid allocating extra fibers for every placeholder.
-  // They're only necessary when the children time out, because that's the
-  // only time when both sets are mounted.
+  // Second is hydration. During hydration, the Suspense fiber has a slightly
+  // different layout, where the child points to a dehydrated fragment, which
+  // contains the DOM rendered by the server.
   //
-  // So, the extra fragment fibers are only used if the children time out.
-  // Otherwise, we render the primary children directly. This requires some
-  // custom reconciliation logic to preserve the state of the primary
-  // children. It's essentially a very basic form of re-parenting.
+  // Third, even if you set all that aside, Suspense is like error boundaries in
+  // that we first we try to render one tree, and if that fails, we render again
+  // and switch to a different tree. Like a try/catch block. So we have to track
+  // which branch we're currently rendering. Ideally we would model this using
+  // a stack.
 
   if (current === null) {
+    // Initial mount
     // If we're currently hydrating, try to hydrate this boundary.
     // But only if this has a fallback.
-    if (nextProps.fallback !== undefined); // This is the initial mount. This branch is pretty simple because there's
-    // no previous state that needs to be preserved.
+    if (nextProps.fallback !== undefined);
 
-    if (nextDidTimeout) {
-      // Mount separate fragments for primary and fallback children.
-      var nextFallbackChildren = nextProps.fallback;
-      var primaryChildFragment = createFiberFromFragment(
-        null,
-        mode,
-        NoWork,
-        null
-      );
-      primaryChildFragment.return = workInProgress;
-
-      if ((workInProgress.mode & BlockingMode) === NoMode) {
-        // Outside of blocking mode, we commit the effects from the
-        // partially completed, timed-out tree, too.
-        var progressedState = workInProgress.memoizedState;
-        var progressedPrimaryChild =
-          progressedState !== null
-            ? workInProgress.child.child
-            : workInProgress.child;
-        primaryChildFragment.child = progressedPrimaryChild;
-        var progressedChild = progressedPrimaryChild;
-
-        while (progressedChild !== null) {
-          progressedChild.return = primaryChildFragment;
-          progressedChild = progressedChild.sibling;
-        }
-      }
+    var nextPrimaryChildren = nextProps.children;
+    var nextFallbackChildren = nextProps.fallback;
 
-      var fallbackChildFragment = createFiberFromFragment(
+    if (showFallback) {
+      var fallbackFragment = mountSuspenseFallbackChildren(
+        workInProgress,
+        nextPrimaryChildren,
         nextFallbackChildren,
-        mode,
-        renderExpirationTime,
-        null
+        renderLanes
+      );
+      var primaryChildFragment = workInProgress.child;
+      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(
+        renderLanes
       );
-      fallbackChildFragment.return = workInProgress;
-      primaryChildFragment.sibling = fallbackChildFragment; // Skip the primary children, and continue working on the
-      // fallback children.
-
       workInProgress.memoizedState = SUSPENDED_MARKER;
-      workInProgress.child = primaryChildFragment;
-      return fallbackChildFragment;
+      return fallbackFragment;
+    } else if (typeof nextProps.unstable_expectedLoadTime === "number") {
+      // This is a CPU-bound tree. Skip this tree and show a placeholder to
+      // unblock the surrounding content. Then immediately retry after the
+      // initial commit.
+      var _fallbackFragment = mountSuspenseFallbackChildren(
+        workInProgress,
+        nextPrimaryChildren,
+        nextFallbackChildren,
+        renderLanes
+      );
+
+      var _primaryChildFragment = workInProgress.child;
+      _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(
+        renderLanes
+      );
+      workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to
+      // get it started back up to attempt the next item. While in terms of
+      // priority this work has the same priority as this current render, it's
+      // not part of the same transition once the transition has committed. If
+      // it's sync, we still want to yield so that it can be painted.
+      // Conceptually, this is really the same as pinging. We can use any
+      // RetryLane even if it's the one currently rendering since we're leaving
+      // it behind on this node.
+
+      workInProgress.lanes = SomeRetryLane;
+
+      {
+        markSpawnedWork(SomeRetryLane);
+      }
+
+      return _fallbackFragment;
     } else {
-      // Mount the primary children without an intermediate fragment fiber.
-      var nextPrimaryChildren = nextProps.children;
-      workInProgress.memoizedState = null;
-      return (workInProgress.child = mountChildFibers(
+      return mountSuspensePrimaryChildren(
         workInProgress,
-        null,
         nextPrimaryChildren,
-        renderExpirationTime
-      ));
+        renderLanes
+      );
     }
   } else {
-    // This is an update. This branch is more complicated because we need to
-    // ensure the state of the primary children is preserved.
+    // This is an update.
+    // If the current fiber has a SuspenseState, that means it's already showing
+    // a fallback.
     var prevState = current.memoizedState;
 
     if (prevState !== null) {
-      // wrapped in a fragment fiber.
-
-      var currentPrimaryChildFragment = current.child;
-      var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
-
-      if (nextDidTimeout) {
-        // Still timed out. Reuse the current primary children by cloning
-        // its fragment. We're going to skip over these entirely.
+      if (showFallback) {
         var _nextFallbackChildren2 = nextProps.fallback;
+        var _nextPrimaryChildren2 = nextProps.children;
 
-        var _primaryChildFragment2 = createWorkInProgress(
-          currentPrimaryChildFragment,
-          currentPrimaryChildFragment.pendingProps
+        var _fallbackChildFragment = updateSuspenseFallbackChildren(
+          current,
+          workInProgress,
+          _nextPrimaryChildren2,
+          _nextFallbackChildren2,
+          renderLanes
         );
 
-        _primaryChildFragment2.return = workInProgress;
-
-        if ((workInProgress.mode & BlockingMode) === NoMode) {
-          // Outside of blocking mode, we commit the effects from the
-          // partially completed, timed-out tree, too.
-          var _progressedState = workInProgress.memoizedState;
-
-          var _progressedPrimaryChild =
-            _progressedState !== null
-              ? workInProgress.child.child
-              : workInProgress.child;
-
-          if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
-            _primaryChildFragment2.child = _progressedPrimaryChild;
-            var _progressedChild2 = _progressedPrimaryChild;
-
-            while (_progressedChild2 !== null) {
-              _progressedChild2.return = _primaryChildFragment2;
-              _progressedChild2 = _progressedChild2.sibling;
-            }
-          }
-        } // Because primaryChildFragment is a new fiber that we're inserting as the
-        // parent of a new tree, we need to set its treeBaseDuration.
-
-        if (workInProgress.mode & ProfileMode) {
-          // treeBaseDuration is the sum of all the child tree base durations.
-          var _treeBaseDuration = 0;
-          var _hiddenChild = _primaryChildFragment2.child;
+        var _primaryChildFragment3 = workInProgress.child;
+        var prevOffscreenState = current.child.memoizedState;
+        _primaryChildFragment3.memoizedState =
+          prevOffscreenState === null
+            ? mountSuspenseOffscreenState(renderLanes)
+            : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
+        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(
+          current,
+          renderLanes
+        );
+        workInProgress.memoizedState = SUSPENDED_MARKER;
+        return _fallbackChildFragment;
+      } else {
+        var _nextPrimaryChildren3 = nextProps.children;
 
-          while (_hiddenChild !== null) {
-            _treeBaseDuration += _hiddenChild.treeBaseDuration;
-            _hiddenChild = _hiddenChild.sibling;
-          }
+        var _primaryChildFragment4 = updateSuspensePrimaryChildren(
+          current,
+          workInProgress,
+          _nextPrimaryChildren3,
+          renderLanes
+        );
 
-          _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
-        } // Clone the fallback child fragment, too. These we'll continue
-        // working on.
+        workInProgress.memoizedState = null;
+        return _primaryChildFragment4;
+      }
+    } else {
+      // The current tree is not already showing a fallback.
+      if (showFallback) {
+        // Timed out.
+        var _nextFallbackChildren3 = nextProps.fallback;
+        var _nextPrimaryChildren4 = nextProps.children;
 
-        var _fallbackChildFragment2 = createWorkInProgress(
-          currentFallbackChildFragment,
-          _nextFallbackChildren2
+        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(
+          current,
+          workInProgress,
+          _nextPrimaryChildren4,
+          _nextFallbackChildren3,
+          renderLanes
         );
 
-        _fallbackChildFragment2.return = workInProgress;
-        _primaryChildFragment2.sibling = _fallbackChildFragment2;
-        _primaryChildFragment2.childExpirationTime = NoWork; // Skip the primary children, and continue working on the
+        var _primaryChildFragment5 = workInProgress.child;
+        var _prevOffscreenState = current.child.memoizedState;
+        _primaryChildFragment5.memoizedState =
+          _prevOffscreenState === null
+            ? mountSuspenseOffscreenState(renderLanes)
+            : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);
+        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(
+          current,
+          renderLanes
+        ); // Skip the primary children, and continue working on the
         // fallback children.
 
         workInProgress.memoizedState = SUSPENDED_MARKER;
-        workInProgress.child = _primaryChildFragment2;
         return _fallbackChildFragment2;
       } else {
-        // No longer suspended. Switch back to showing the primary children,
-        // and remove the intermediate fragment fiber.
-        var _nextPrimaryChildren = nextProps.children;
-        var currentPrimaryChild = currentPrimaryChildFragment.child;
-        var primaryChild = reconcileChildFibers(
+        // Still haven't timed out. Continue rendering the children, like we
+        // normally do.
+        var _nextPrimaryChildren5 = nextProps.children;
+
+        var _primaryChildFragment6 = updateSuspensePrimaryChildren(
+          current,
           workInProgress,
-          currentPrimaryChild,
-          _nextPrimaryChildren,
-          renderExpirationTime
-        ); // If this render doesn't suspend, we need to delete the fallback
-        // children. Wait until the complete phase, after we've confirmed the
-        // fallback is no longer needed.
-        // TODO: Would it be better to store the fallback fragment on
-        // the stateNode?
-        // Continue rendering the children, like we normally do.
+          _nextPrimaryChildren5,
+          renderLanes
+        );
 
         workInProgress.memoizedState = null;
-        return (workInProgress.child = primaryChild);
+        return _primaryChildFragment6;
       }
-    } else {
-      // The current tree has not already timed out. That means the primary
-      // children are not wrapped in a fragment fiber.
-      var _currentPrimaryChild = current.child;
+    }
+  }
+}
 
-      if (nextDidTimeout) {
-        // Timed out. Wrap the children in a fragment fiber to keep them
-        // separate from the fallback children.
-        var _nextFallbackChildren3 = nextProps.fallback;
+function mountSuspensePrimaryChildren(
+  workInProgress,
+  primaryChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  var primaryChildProps = {
+    mode: "visible",
+    children: primaryChildren
+  };
+  var primaryChildFragment = createFiberFromOffscreen(
+    primaryChildProps,
+    mode,
+    renderLanes,
+    null
+  );
+  primaryChildFragment.return = workInProgress;
+  workInProgress.child = primaryChildFragment;
+  return primaryChildFragment;
+}
 
-        var _primaryChildFragment3 = createFiberFromFragment(
-          // It shouldn't matter what the pending props are because we aren't
-          // going to render this fragment.
-          null,
-          mode,
-          NoWork,
-          null
-        );
+function mountSuspenseFallbackChildren(
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  var progressedPrimaryFragment = workInProgress.child;
+  var primaryChildProps = {
+    mode: "hidden",
+    children: primaryChildren
+  };
+  var primaryChildFragment;
+  var fallbackChildFragment;
+
+  if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
+    // In legacy mode, we commit the primary tree as if it successfully
+    // completed, even though it's in an inconsistent state.
+    primaryChildFragment = progressedPrimaryFragment;
+    primaryChildFragment.childLanes = NoLanes;
+    primaryChildFragment.pendingProps = primaryChildProps;
+
+    if (workInProgress.mode & ProfileMode) {
+      // Reset the durations from the first pass so they aren't included in the
+      // final amounts. This seems counterintuitive, since we're intentionally
+      // not measuring part of the render phase, but this makes it match what we
+      // do in Concurrent Mode.
+      primaryChildFragment.actualDuration = 0;
+      primaryChildFragment.actualStartTime = -1;
+      primaryChildFragment.selfBaseDuration = 0;
+      primaryChildFragment.treeBaseDuration = 0;
+    }
+
+    fallbackChildFragment = createFiberFromFragment(
+      fallbackChildren,
+      mode,
+      renderLanes,
+      null
+    );
+  } else {
+    primaryChildFragment = createFiberFromOffscreen(
+      primaryChildProps,
+      mode,
+      NoLanes,
+      null
+    );
+    fallbackChildFragment = createFiberFromFragment(
+      fallbackChildren,
+      mode,
+      renderLanes,
+      null
+    );
+  }
 
-        _primaryChildFragment3.return = workInProgress;
-        _primaryChildFragment3.child = _currentPrimaryChild;
+  primaryChildFragment.return = workInProgress;
+  fallbackChildFragment.return = workInProgress;
+  primaryChildFragment.sibling = fallbackChildFragment;
+  workInProgress.child = primaryChildFragment;
+  return fallbackChildFragment;
+}
 
-        if (_currentPrimaryChild !== null) {
-          _currentPrimaryChild.return = _primaryChildFragment3;
-        } // Even though we're creating a new fiber, there are no new children,
-        // because we're reusing an already mounted tree. So we don't need to
-        // schedule a placement.
-        // primaryChildFragment.effectTag |= Placement;
+function createWorkInProgressOffscreenFiber(current, offscreenProps) {
+  // The props argument to `createWorkInProgress` is `any` typed, so we use this
+  // wrapper function to constrain it.
+  return createWorkInProgress(current, offscreenProps);
+}
 
-        if ((workInProgress.mode & BlockingMode) === NoMode) {
-          // Outside of blocking mode, we commit the effects from the
-          // partially completed, timed-out tree, too.
-          var _progressedState2 = workInProgress.memoizedState;
+function updateSuspensePrimaryChildren(
+  current,
+  workInProgress,
+  primaryChildren,
+  renderLanes
+) {
+  var currentPrimaryChildFragment = current.child;
+  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
+  var primaryChildFragment = createWorkInProgressOffscreenFiber(
+    currentPrimaryChildFragment,
+    {
+      mode: "visible",
+      children: primaryChildren
+    }
+  );
 
-          var _progressedPrimaryChild2 =
-            _progressedState2 !== null
-              ? workInProgress.child.child
-              : workInProgress.child;
+  if ((workInProgress.mode & BlockingMode) === NoMode) {
+    primaryChildFragment.lanes = renderLanes;
+  }
 
-          _primaryChildFragment3.child = _progressedPrimaryChild2;
-          var _progressedChild3 = _progressedPrimaryChild2;
+  primaryChildFragment.return = workInProgress;
+  primaryChildFragment.sibling = null;
 
-          while (_progressedChild3 !== null) {
-            _progressedChild3.return = _primaryChildFragment3;
-            _progressedChild3 = _progressedChild3.sibling;
-          }
-        } // Because primaryChildFragment is a new fiber that we're inserting as the
-        // parent of a new tree, we need to set its treeBaseDuration.
+  if (currentFallbackChildFragment !== null) {
+    // Delete the fallback child fragment
+    currentFallbackChildFragment.nextEffect = null;
+    currentFallbackChildFragment.flags = Deletion;
+    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;
+  }
 
-        if (workInProgress.mode & ProfileMode) {
-          // treeBaseDuration is the sum of all the child tree base durations.
-          var _treeBaseDuration2 = 0;
-          var _hiddenChild2 = _primaryChildFragment3.child;
+  workInProgress.child = primaryChildFragment;
+  return primaryChildFragment;
+}
 
-          while (_hiddenChild2 !== null) {
-            _treeBaseDuration2 += _hiddenChild2.treeBaseDuration;
-            _hiddenChild2 = _hiddenChild2.sibling;
-          }
+function updateSuspenseFallbackChildren(
+  current,
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  var currentPrimaryChildFragment = current.child;
+  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
+  var primaryChildProps = {
+    mode: "hidden",
+    children: primaryChildren
+  };
+  var primaryChildFragment;
 
-          _primaryChildFragment3.treeBaseDuration = _treeBaseDuration2;
-        } // Create a fragment from the fallback children, too.
+  if (
+    // In legacy mode, we commit the primary tree as if it successfully
+    // completed, even though it's in an inconsistent state.
+    (mode & BlockingMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
+    // already cloned. In legacy mode, the only case where this isn't true is
+    // when DevTools forces us to display a fallback; we skip the first render
+    // pass entirely and go straight to rendering the fallback. (In Concurrent
+    // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
+    // only codepath.)
+    workInProgress.child !== currentPrimaryChildFragment
+  ) {
+    var progressedPrimaryFragment = workInProgress.child;
+    primaryChildFragment = progressedPrimaryFragment;
+    primaryChildFragment.childLanes = NoLanes;
+    primaryChildFragment.pendingProps = primaryChildProps;
+
+    if (workInProgress.mode & ProfileMode) {
+      // Reset the durations from the first pass so they aren't included in the
+      // final amounts. This seems counterintuitive, since we're intentionally
+      // not measuring part of the render phase, but this makes it match what we
+      // do in Concurrent Mode.
+      primaryChildFragment.actualDuration = 0;
+      primaryChildFragment.actualStartTime = -1;
+      primaryChildFragment.selfBaseDuration =
+        currentPrimaryChildFragment.selfBaseDuration;
+      primaryChildFragment.treeBaseDuration =
+        currentPrimaryChildFragment.treeBaseDuration;
+    } // The fallback fiber was added as a deletion effect during the first pass.
+    // However, since we're going to remain on the fallback, we no longer want
+    // to delete it. So we need to remove it from the list. Deletions are stored
+    // on the same list as effects. We want to keep the effects from the primary
+    // tree. So we copy the primary child fragment's effect list, which does not
+    // include the fallback deletion effect.
+
+    var progressedLastEffect = primaryChildFragment.lastEffect;
+
+    if (progressedLastEffect !== null) {
+      workInProgress.firstEffect = primaryChildFragment.firstEffect;
+      workInProgress.lastEffect = progressedLastEffect;
+      progressedLastEffect.nextEffect = null;
+    } else {
+      // TODO: Reset this somewhere else? Lol legacy mode is so weird.
+      workInProgress.firstEffect = workInProgress.lastEffect = null;
+    }
+  } else {
+    primaryChildFragment = createWorkInProgressOffscreenFiber(
+      currentPrimaryChildFragment,
+      primaryChildProps
+    );
+  }
 
-        var _fallbackChildFragment3 = createFiberFromFragment(
-          _nextFallbackChildren3,
-          mode,
-          renderExpirationTime,
-          null
-        );
+  var fallbackChildFragment;
 
-        _fallbackChildFragment3.return = workInProgress;
-        _primaryChildFragment3.sibling = _fallbackChildFragment3;
-        _fallbackChildFragment3.effectTag |= Placement;
-        _primaryChildFragment3.childExpirationTime = NoWork; // Skip the primary children, and continue working on the
-        // fallback children.
+  if (currentFallbackChildFragment !== null) {
+    fallbackChildFragment = createWorkInProgress(
+      currentFallbackChildFragment,
+      fallbackChildren
+    );
+  } else {
+    fallbackChildFragment = createFiberFromFragment(
+      fallbackChildren,
+      mode,
+      renderLanes,
+      null
+    ); // Needs a placement effect because the parent (the Suspense boundary) already
+    // mounted but this is a new fiber.
 
-        workInProgress.memoizedState = SUSPENDED_MARKER;
-        workInProgress.child = _primaryChildFragment3;
-        return _fallbackChildFragment3;
-      } else {
-        // Still haven't timed out. Continue rendering the children, like we
-        // normally do.
-        workInProgress.memoizedState = null;
-        var _nextPrimaryChildren2 = nextProps.children;
-        return (workInProgress.child = reconcileChildFibers(
-          workInProgress,
-          _currentPrimaryChild,
-          _nextPrimaryChildren2,
-          renderExpirationTime
-        ));
-      }
-    }
+    fallbackChildFragment.flags |= Placement;
   }
-}
 
-function scheduleWorkOnFiber(fiber, renderExpirationTime) {
-  if (fiber.expirationTime < renderExpirationTime) {
-    fiber.expirationTime = renderExpirationTime;
-  }
+  fallbackChildFragment.return = workInProgress;
+  primaryChildFragment.return = workInProgress;
+  primaryChildFragment.sibling = fallbackChildFragment;
+  workInProgress.child = primaryChildFragment;
+  return fallbackChildFragment;
+}
 
+function scheduleWorkOnFiber(fiber, renderLanes) {
+  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
   var alternate = fiber.alternate;
 
-  if (alternate !== null && alternate.expirationTime < renderExpirationTime) {
-    alternate.expirationTime = renderExpirationTime;
+  if (alternate !== null) {
+    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
   }
 
-  scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
+  scheduleWorkOnParentPath(fiber.return, renderLanes);
 }
 
 function propagateSuspenseContextChange(
   workInProgress,
   firstChild,
-  renderExpirationTime
+  renderLanes
 ) {
   // Mark any Suspense boundaries with fallbacks as having work to do.
   // If they were previously forced into fallbacks, they may now be able
@@ -13392,7 +13852,7 @@ function propagateSuspenseContextChange(
       var state = node.memoizedState;
 
       if (state !== null) {
-        scheduleWorkOnFiber(node, renderExpirationTime);
+        scheduleWorkOnFiber(node, renderLanes);
       }
     } else if (node.tag === SuspenseListComponent) {
       // If the tail is hidden there might not be an Suspense boundaries
@@ -13400,7 +13860,7 @@ function propagateSuspenseContextChange(
       // list itself.
       // We don't have to traverse to the children of the list since
       // the list will propagate the change when it rerenders.
-      scheduleWorkOnFiber(node, renderExpirationTime);
+      scheduleWorkOnFiber(node, renderLanes);
     } else if (node.child !== null) {
       node.child.return = node;
       node = node.child;
@@ -13619,7 +14079,6 @@ function initSuspenseListRenderState(
       renderingStartTime: 0,
       last: lastContentRow,
       tail: tail,
-      tailExpiration: 0,
       tailMode: tailMode,
       lastEffect: lastEffectBeforeRendering
     };
@@ -13630,7 +14089,6 @@ function initSuspenseListRenderState(
     renderState.renderingStartTime = 0;
     renderState.last = lastContentRow;
     renderState.tail = tail;
-    renderState.tailExpiration = 0;
     renderState.tailMode = tailMode;
     renderState.lastEffect = lastEffectBeforeRendering;
   }
@@ -13642,11 +14100,7 @@ function initSuspenseListRenderState(
 // in fallback state. Then we render each row in the tail one-by-one.
 // That happens in the completeWork phase without going back to beginWork.
 
-function updateSuspenseListComponent(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
+function updateSuspenseListComponent(current, workInProgress, renderLanes) {
   var nextProps = workInProgress.pendingProps;
   var revealOrder = nextProps.revealOrder;
   var tailMode = nextProps.tail;
@@ -13654,7 +14108,7 @@ function updateSuspenseListComponent(
   validateRevealOrder(revealOrder);
   validateTailOptions(tailMode, revealOrder);
   validateSuspenseListChildren(newChildren, revealOrder);
-  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
+  reconcileChildren(current, workInProgress, newChildren, renderLanes);
   var suspenseContext = suspenseStackCursor.current;
   var shouldForceFallback = hasSuspenseContext(
     suspenseContext,
@@ -13666,10 +14120,10 @@ function updateSuspenseListComponent(
       suspenseContext,
       ForceSuspenseFallback
     );
-    workInProgress.effectTag |= DidCapture;
+    workInProgress.flags |= DidCapture;
   } else {
     var didSuspendBefore =
-      current !== null && (current.effectTag & DidCapture) !== NoEffect;
+      current !== null && (current.flags & DidCapture) !== NoFlags;
 
     if (didSuspendBefore) {
       // If we previously forced a fallback, we need to schedule work
@@ -13678,7 +14132,7 @@ function updateSuspenseListComponent(
       propagateSuspenseContextChange(
         workInProgress,
         workInProgress.child,
-        renderExpirationTime
+        renderLanes
       );
     }
 
@@ -13688,7 +14142,7 @@ function updateSuspenseListComponent(
   pushSuspenseContext(workInProgress, suspenseContext);
 
   if ((workInProgress.mode & BlockingMode) === NoMode) {
-    // Outside of blocking mode, SuspenseList doesn't work so we just
+    // In legacy mode, SuspenseList doesn't work so we just
     // use make it a noop by treating it as the default revealOrder.
     workInProgress.memoizedState = null;
   } else {
@@ -13778,7 +14232,7 @@ function updateSuspenseListComponent(
   return workInProgress.child;
 }
 
-function updatePortalComponent(current, workInProgress, renderExpirationTime) {
+function updatePortalComponent(current, workInProgress, renderLanes) {
   pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
   var nextChildren = workInProgress.pendingProps;
 
@@ -13792,21 +14246,18 @@ function updatePortalComponent(current, workInProgress, renderExpirationTime) {
       workInProgress,
       null,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
   } else {
-    reconcileChildren(
-      current,
-      workInProgress,
-      nextChildren,
-      renderExpirationTime
-    );
+    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   }
 
   return workInProgress.child;
 }
 
-function updateContextProvider(current, workInProgress, renderExpirationTime) {
+var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
+
+function updateContextProvider(current, workInProgress, renderLanes) {
   var providerType = workInProgress.type;
   var context = providerType._context;
   var newProps = workInProgress.pendingProps;
@@ -13814,6 +14265,16 @@ function updateContextProvider(current, workInProgress, renderExpirationTime) {
   var newValue = newProps.value;
 
   {
+    if (!("value" in newProps)) {
+      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
+        hasWarnedAboutUsingNoValuePropOnContextProvider = true;
+
+        error(
+          "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
+        );
+      }
+    }
+
     var providerPropTypes = workInProgress.type.propTypes;
 
     if (providerPropTypes) {
@@ -13833,29 +14294,24 @@ function updateContextProvider(current, workInProgress, renderExpirationTime) {
         return bailoutOnAlreadyFinishedWork(
           current,
           workInProgress,
-          renderExpirationTime
+          renderLanes
         );
       }
     } else {
       // The context value changed. Search for matching consumers and schedule
       // them to update.
-      propagateContextChange(
-        workInProgress,
-        context,
-        changedBits,
-        renderExpirationTime
-      );
+      propagateContextChange(workInProgress, context, changedBits, renderLanes);
     }
   }
 
   var newChildren = newProps.children;
-  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
+  reconcileChildren(current, workInProgress, newChildren, renderLanes);
   return workInProgress.child;
 }
 
 var hasWarnedAboutUsingContextAsConsumer = false;
 
-function updateContextConsumer(current, workInProgress, renderExpirationTime) {
+function updateContextConsumer(current, workInProgress, renderLanes) {
   var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
   // DEV mode, we create a separate object for Context.Consumer that acts
   // like a proxy to Context. This proxy object adds unnecessary code in PROD
@@ -13898,7 +14354,7 @@ function updateContextConsumer(current, workInProgress, renderExpirationTime) {
     }
   }
 
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   var newValue = readContext(context, newProps.unstable_observedBits);
   var newChildren;
 
@@ -13909,8 +14365,8 @@ function updateContextConsumer(current, workInProgress, renderExpirationTime) {
     setIsRendering(false);
   } // React DevTools reads this flag.
 
-  workInProgress.effectTag |= PerformedWork;
-  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
+  workInProgress.flags |= PerformedWork;
+  reconcileChildren(current, workInProgress, newChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -13918,13 +14374,7 @@ function markWorkInProgressReceivedUpdate() {
   didReceiveUpdate = true;
 }
 
-function bailoutOnAlreadyFinishedWork(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
-  cancelWorkTimer(workInProgress);
-
+function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
   if (current !== null) {
     // Reuse previous dependencies
     workInProgress.dependencies = current.dependencies;
@@ -13935,15 +14385,9 @@ function bailoutOnAlreadyFinishedWork(
     stopProfilerTimerIfRunning();
   }
 
-  var updateExpirationTime = workInProgress.expirationTime;
-
-  if (updateExpirationTime !== NoWork) {
-    markUnprocessedUpdateTime(updateExpirationTime);
-  } // Check if the children have any pending work.
+  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.
 
-  var childExpirationTime = workInProgress.childExpirationTime;
-
-  if (childExpirationTime < renderExpirationTime) {
+  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
     // The children don't have any work either. We can skip them.
     // TODO: Once we add back resuming, we should check if the children are
     // a work-in-progress set. If so, we need to transfer their effects.
@@ -14004,15 +14448,15 @@ function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
     }
 
     current.nextEffect = null;
-    current.effectTag = Deletion;
-    newWorkInProgress.effectTag |= Placement; // Restart work from the new fiber.
+    current.flags = Deletion;
+    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.
 
     return newWorkInProgress;
   }
 }
 
-function beginWork(current, workInProgress, renderExpirationTime) {
-  var updateExpirationTime = workInProgress.expirationTime;
+function beginWork(current, workInProgress, renderLanes) {
+  var updateLanes = workInProgress.lanes;
 
   {
     if (workInProgress._debugNeedsRemount && current !== null) {
@@ -14026,7 +14470,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
           workInProgress.pendingProps,
           workInProgress._debugOwner || null,
           workInProgress.mode,
-          workInProgress.expirationTime
+          workInProgress.lanes
         )
       );
     }
@@ -14044,7 +14488,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
       // If props or context changed, mark the fiber as having performed work.
       // This may be unset if the props are determined to be equal later (memo).
       didReceiveUpdate = true;
-    } else if (updateExpirationTime < renderExpirationTime) {
+    } else if (!includesSomeLane(renderLanes, updateLanes)) {
       didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
       // the begin phase. There's still some bookkeeping we that needs to be done
       // in this optimized path, mostly pushing stuff onto the stack.
@@ -14056,20 +14500,6 @@ function beginWork(current, workInProgress, renderExpirationTime) {
 
         case HostComponent:
           pushHostContext(workInProgress);
-
-          if (
-            workInProgress.mode & ConcurrentMode &&
-            renderExpirationTime !== Never &&
-            shouldDeprioritizeSubtree(workInProgress.type)
-          ) {
-            {
-              markSpawnedWork(Never);
-            } // Schedule this fiber to re-render at offscreen priority. Then bailout.
-
-            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
-            return null;
-          }
-
           break;
 
         case ClassComponent: {
@@ -14098,11 +14528,13 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         case Profiler:
           {
             // Profiler should only call onRender when one of its descendants actually rendered.
-            var hasChildWork =
-              workInProgress.childExpirationTime >= renderExpirationTime;
+            var hasChildWork = includesSomeLane(
+              renderLanes,
+              workInProgress.childLanes
+            );
 
             if (hasChildWork) {
-              workInProgress.effectTag |= Update;
+              workInProgress.flags |= Update;
             } // Reset effect durations for the next eventual effect phase.
             // These are reset during render to allow the DevTools commit hook a chance to read them,
 
@@ -14122,21 +14554,19 @@ function beginWork(current, workInProgress, renderExpirationTime) {
             // child fragment.
 
             var primaryChildFragment = workInProgress.child;
-            var primaryChildExpirationTime =
-              primaryChildFragment.childExpirationTime;
+            var primaryChildLanes = primaryChildFragment.childLanes;
 
-            if (
-              primaryChildExpirationTime !== NoWork &&
-              primaryChildExpirationTime >= renderExpirationTime
-            ) {
+            if (includesSomeLane(renderLanes, primaryChildLanes)) {
               // The primary children have pending work. Use the normal path
               // to attempt to render the primary children again.
               return updateSuspenseComponent(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
             } else {
+              // The primary child fragment does not have pending work marked
+              // on it
               pushSuspenseContext(
                 workInProgress,
                 setDefaultShallowSuspenseContext(suspenseStackCursor.current)
@@ -14146,7 +14576,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
               var child = bailoutOnAlreadyFinishedWork(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
 
               if (child !== null) {
@@ -14168,10 +14598,12 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         }
 
         case SuspenseListComponent: {
-          var didSuspendBefore = (current.effectTag & DidCapture) !== NoEffect;
+          var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;
 
-          var _hasChildWork =
-            workInProgress.childExpirationTime >= renderExpirationTime;
+          var _hasChildWork = includesSomeLane(
+            renderLanes,
+            workInProgress.childLanes
+          );
 
           if (didSuspendBefore) {
             if (_hasChildWork) {
@@ -14183,13 +14615,13 @@ function beginWork(current, workInProgress, renderExpirationTime) {
               return updateSuspenseListComponent(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
             } // If none of the children had any work, that means that none of
             // them got retried so they'll still be blocked in the same way
             // as before. We can fast bail out.
 
-            workInProgress.effectTag |= DidCapture;
+            workInProgress.flags |= DidCapture;
           } // If nothing suspended before and we're rendering the same children,
           // then the tail doesn't matter. Anything new that suspends will work
           // in the "together" mode, so we can continue from the state we had.
@@ -14201,6 +14633,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
             // update in the past but didn't complete it.
             renderState.rendering = null;
             renderState.tail = null;
+            renderState.lastEffect = null;
           }
 
           pushSuspenseContext(workInProgress, suspenseStackCursor.current);
@@ -14214,19 +14647,35 @@ function beginWork(current, workInProgress, renderExpirationTime) {
             return null;
           }
         }
+
+        case OffscreenComponent:
+        case LegacyHiddenComponent: {
+          // Need to check if the tree still needs to be deferred. This is
+          // almost identical to the logic used in the normal update path,
+          // so we'll just enter that. The only difference is we'll bail out
+          // at the next level instead of this one, because the child props
+          // have not changed. Which is fine.
+          // TODO: Probably should refactor `beginWork` to split the bailout
+          // path from the normal path. I'm tempted to do a labeled break here
+          // but I won't :)
+          workInProgress.lanes = NoLanes;
+          return updateOffscreenComponent(current, workInProgress, renderLanes);
+        }
       }
 
-      return bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
     } else {
-      // An update was scheduled on this fiber, but there are no new props
-      // nor legacy context. Set this to false. If an update queue or context
-      // consumer produces a changed value, it will set this to true. Otherwise,
-      // the component will assume the children have not changed and bail out.
-      didReceiveUpdate = false;
+      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
+        // This is a special case that only exists for legacy mode.
+        // See https://github.com/facebook/react/pull/19216.
+        didReceiveUpdate = true;
+      } else {
+        // An update was scheduled on this fiber, but there are no new props
+        // nor legacy context. Set this to false. If an update queue or context
+        // consumer produces a changed value, it will set this to true. Otherwise,
+        // the component will assume the children have not changed and bail out.
+        didReceiveUpdate = false;
+      }
     }
   } else {
     didReceiveUpdate = false;
@@ -14236,7 +14685,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
   // sometimes bails out later in the begin phase. This indicates that we should
   // move this assignment out of the common path and into each branch.
 
-  workInProgress.expirationTime = NoWork;
+  workInProgress.lanes = NoLanes;
 
   switch (workInProgress.tag) {
     case IndeterminateComponent: {
@@ -14244,7 +14693,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         current,
         workInProgress,
         workInProgress.type,
-        renderExpirationTime
+        renderLanes
       );
     }
 
@@ -14254,8 +14703,8 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         current,
         workInProgress,
         elementType,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     }
 
@@ -14271,7 +14720,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         _Component,
         resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
     }
 
@@ -14289,32 +14738,24 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         _Component2,
         _resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
     }
 
     case HostRoot:
-      return updateHostRoot(current, workInProgress, renderExpirationTime);
+      return updateHostRoot(current, workInProgress, renderLanes);
 
     case HostComponent:
-      return updateHostComponent(current, workInProgress, renderExpirationTime);
+      return updateHostComponent(current, workInProgress, renderLanes);
 
     case HostText:
       return updateHostText();
 
     case SuspenseComponent:
-      return updateSuspenseComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
 
     case HostPortal:
-      return updatePortalComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updatePortalComponent(current, workInProgress, renderLanes);
 
     case ForwardRef: {
       var type = workInProgress.type;
@@ -14330,32 +14771,24 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         type,
         _resolvedProps2,
-        renderExpirationTime
+        renderLanes
       );
     }
 
     case Fragment:
-      return updateFragment(current, workInProgress, renderExpirationTime);
+      return updateFragment(current, workInProgress, renderLanes);
 
     case Mode:
-      return updateMode(current, workInProgress, renderExpirationTime);
+      return updateMode(current, workInProgress, renderLanes);
 
     case Profiler:
-      return updateProfiler(current, workInProgress, renderExpirationTime);
+      return updateProfiler(current, workInProgress, renderLanes);
 
     case ContextProvider:
-      return updateContextProvider(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateContextProvider(current, workInProgress, renderLanes);
 
     case ContextConsumer:
-      return updateContextConsumer(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateContextConsumer(current, workInProgress, renderLanes);
 
     case MemoComponent: {
       var _type2 = workInProgress.type;
@@ -14384,8 +14817,8 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         _type2,
         _resolvedProps3,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     }
 
@@ -14395,8 +14828,8 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         workInProgress.type,
         workInProgress.pendingProps,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     }
 
@@ -14414,16 +14847,28 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         _Component3,
         _resolvedProps4,
-        renderExpirationTime
+        renderLanes
       );
     }
 
     case SuspenseListComponent: {
-      return updateSuspenseListComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+    }
+
+    case FundamentalComponent: {
+      break;
+    }
+
+    case ScopeComponent: {
+      break;
+    }
+
+    case OffscreenComponent: {
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
+    }
+
+    case LegacyHiddenComponent: {
+      return updateLegacyHiddenComponent(current, workInProgress, renderLanes);
     }
   }
 
@@ -14439,11 +14884,11 @@ function beginWork(current, workInProgress, renderExpirationTime) {
 function markUpdate(workInProgress) {
   // Tag the fiber with an update effect. This turns a Placement into
   // a PlacementAndUpdate.
-  workInProgress.effectTag |= Update;
+  workInProgress.flags |= Update;
 }
 
 function markRef$1(workInProgress) {
-  workInProgress.effectTag |= Ref;
+  workInProgress.flags |= Ref;
 }
 
 var appendAllChildren;
@@ -14607,7 +15052,7 @@ function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
   }
 }
 
-function completeWork(current, workInProgress, renderExpirationTime) {
+function completeWork(current, workInProgress, renderLanes) {
   var newProps = workInProgress.pendingProps;
 
   switch (workInProgress.tag) {
@@ -14636,6 +15081,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelContextObject(workInProgress);
+      resetWorkInProgressVersions();
       var fiberRoot = workInProgress.stateNode;
 
       if (fiberRoot.pendingContext) {
@@ -14652,6 +15098,12 @@ function completeWork(current, workInProgress, renderExpirationTime) {
           // If we hydrated, then we'll need to schedule an update for
           // the commit side-effects on the root.
           markUpdate(workInProgress);
+        } else if (!fiberRoot.hydrate) {
+          // Schedule an effect to clear this container at the start of the next commit.
+          // This handles the case of React rendering into a container with previous children.
+          // It's also safe to do for updates too, because current.child would only be null
+          // if the previous render was null (so the the container would already be empty).
+          workInProgress.flags |= Snapshot;
         }
       }
 
@@ -14710,9 +15162,8 @@ function completeWork(current, workInProgress, renderExpirationTime) {
             currentHostContext,
             workInProgress
           );
-          appendAllChildren(instance, workInProgress, false, false); // This needs to be set before we mount Flare event listeners
-
-          workInProgress.stateNode = instance;
+          appendAllChildren(instance, workInProgress, false, false);
+          workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
           // (eg DOM renderer supports auto-focus for certain elements).
           // Make sure such renderers get scheduled for later work.
 
@@ -14774,9 +15225,13 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       popSuspenseContext(workInProgress);
       var nextState = workInProgress.memoizedState;
 
-      if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
+      if ((workInProgress.flags & DidCapture) !== NoFlags) {
         // Something suspended. Re-render with the fallback children.
-        workInProgress.expirationTime = renderExpirationTime; // Do not reset the effect list.
+        workInProgress.lanes = renderLanes; // Do not reset the effect list.
+
+        if ((workInProgress.mode & ProfileMode) !== NoMode) {
+          transferActualDuration(workInProgress);
+        }
 
         return workInProgress;
       }
@@ -14789,29 +15244,6 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       } else {
         var prevState = current.memoizedState;
         prevDidTimeout = prevState !== null;
-
-        if (!nextDidTimeout && prevState !== null) {
-          // We just switched from the fallback to the normal children.
-          // Delete the fallback.
-          // TODO: Would it be better to store the fallback fragment on
-          // the stateNode during the begin phase?
-          var currentFallbackChild = current.child.sibling;
-
-          if (currentFallbackChild !== null) {
-            // Deletions go at the beginning of the return fiber's effect list
-            var first = workInProgress.firstEffect;
-
-            if (first !== null) {
-              workInProgress.firstEffect = currentFallbackChild;
-              currentFallbackChild.nextEffect = first;
-            } else {
-              workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
-              currentFallbackChild.nextEffect = null;
-            }
-
-            currentFallbackChild.effectTag = Deletion;
-          }
-        }
       }
 
       if (nextDidTimeout && !prevDidTimeout) {
@@ -14858,7 +15290,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
           // primary children. In mutation mode, we also need the flag to
           // *unhide* children that were previously hidden, so check if this
           // is currently timed out, too.
-          workInProgress.effectTag |= Update;
+          workInProgress.flags |= Update;
         }
       }
 
@@ -14868,6 +15300,11 @@ function completeWork(current, workInProgress, renderExpirationTime) {
     case HostPortal:
       popHostContainer(workInProgress);
       updateHostContainer(workInProgress);
+
+      if (current === null) {
+        preparePortalMount(workInProgress.stateNode.containerInfo);
+      }
+
       return null;
 
     case ContextProvider:
@@ -14897,8 +15334,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         return null;
       }
 
-      var didSuspendAlready =
-        (workInProgress.effectTag & DidCapture) !== NoEffect;
+      var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
       var renderedTail = renderState.rendering;
 
       if (renderedTail === null) {
@@ -14915,7 +15351,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
           // findFirstSuspended.
           var cannotBeSuspended =
             renderHasNotSuspendedYet() &&
-            (current === null || (current.effectTag & DidCapture) === NoEffect);
+            (current === null || (current.flags & DidCapture) === NoFlags);
 
           if (!cannotBeSuspended) {
             var row = workInProgress.child;
@@ -14925,7 +15361,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
               if (suspended !== null) {
                 didSuspendAlready = true;
-                workInProgress.effectTag |= DidCapture;
+                workInProgress.flags |= DidCapture;
                 cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as
                 // part of the second pass. In that case nothing will subscribe to
                 // its thennables. Instead, we'll transfer its thennables to the
@@ -14943,7 +15379,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
                 if (newThennables !== null) {
                   workInProgress.updateQueue = newThennables;
-                  workInProgress.effectTag |= Update;
+                  workInProgress.flags |= Update;
                 } // Rerender the whole list, but this time, we'll force fallbacks
                 // to stay in place.
                 // Reset the effect list before doing the second pass since that's now invalid.
@@ -14954,7 +15390,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
                 workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.
 
-                resetChildFibers(workInProgress, renderExpirationTime); // Set up the Suspense Context to force suspense and immediately
+                resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately
                 // rerender the children.
 
                 pushSuspenseContext(
@@ -14967,7 +15403,29 @@ function completeWork(current, workInProgress, renderExpirationTime) {
                 return workInProgress.child;
               }
 
-              row = row.sibling;
+              row = row.sibling;
+            }
+          }
+
+          if (renderState.tail !== null && now() > getRenderTargetTime()) {
+            // We have already passed our CPU deadline but we still have rows
+            // left in the tail. We'll just give up further attempts to render
+            // the main content and only render fallbacks.
+            workInProgress.flags |= DidCapture;
+            didSuspendAlready = true;
+            cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
+            // to get it started back up to attempt the next item. While in terms
+            // of priority this work has the same priority as this current render,
+            // it's not part of the same transition once the transition has
+            // committed. If it's sync, we still want to yield so that it can be
+            // painted. Conceptually, this is really the same as pinging.
+            // We can use any RetryLane even if it's the one currently rendering
+            // since we're leaving it behind on this node.
+
+            workInProgress.lanes = SomeRetryLane;
+
+            {
+              markSpawnedWork(SomeRetryLane);
             }
           }
         } else {
@@ -14979,7 +15437,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
           var _suspended = findFirstSuspended(renderedTail);
 
           if (_suspended !== null) {
-            workInProgress.effectTag |= DidCapture;
+            workInProgress.flags |= DidCapture;
             didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't
             // get lost if this row ends up dropped during a second pass.
 
@@ -14987,7 +15445,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
             if (_newThennables !== null) {
               workInProgress.updateQueue = _newThennables;
-              workInProgress.effectTag |= Update;
+              workInProgress.flags |= Update;
             }
 
             cutOffTailIfNeeded(renderState, true); // This might have been modified.
@@ -14995,7 +15453,8 @@ function completeWork(current, workInProgress, renderExpirationTime) {
             if (
               renderState.tail === null &&
               renderState.tailMode === "hidden" &&
-              !renderedTail.alternate
+              !renderedTail.alternate &&
+              !getIsHydrating() // We don't cut it if we're hydrating.
             ) {
               // We need to delete the row we just rendered.
               // Reset the effect list to what it was before we rendered this
@@ -15010,28 +15469,31 @@ function completeWork(current, workInProgress, renderExpirationTime) {
               return null;
             }
           } else if (
-            // The time it took to render last row is greater than time until
-            // the expiration.
+            // The time it took to render last row is greater than the remaining
+            // time we have to render. So rendering one more row would likely
+            // exceed it.
             now() * 2 - renderState.renderingStartTime >
-              renderState.tailExpiration &&
-            renderExpirationTime > Never
+              getRenderTargetTime() &&
+            renderLanes !== OffscreenLane
           ) {
             // We have now passed our CPU deadline and we'll just give up further
             // attempts to render the main content and only render fallbacks.
             // The assumption is that this is usually faster.
-            workInProgress.effectTag |= DidCapture;
+            workInProgress.flags |= DidCapture;
             didSuspendAlready = true;
             cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
-            // to get it started back up to attempt the next item. If we can show
-            // them, then they really have the same priority as this render.
-            // So we'll pick it back up the very next render pass once we've had
-            // an opportunity to yield for paint.
+            // to get it started back up to attempt the next item. While in terms
+            // of priority this work has the same priority as this current render,
+            // it's not part of the same transition once the transition has
+            // committed. If it's sync, we still want to yield so that it can be
+            // painted. Conceptually, this is really the same as pinging.
+            // We can use any RetryLane even if it's the one currently rendering
+            // since we're leaving it behind on this node.
 
-            var nextPriority = renderExpirationTime - 1;
-            workInProgress.expirationTime = workInProgress.childExpirationTime = nextPriority;
+            workInProgress.lanes = SomeRetryLane;
 
             {
-              markSpawnedWork(nextPriority);
+              markSpawnedWork(SomeRetryLane);
             }
           }
         }
@@ -15059,18 +15521,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
       if (renderState.tail !== null) {
         // We still have tail rows to render.
-        if (renderState.tailExpiration === 0) {
-          // Heuristic for how long we're willing to spend rendering rows
-          // until we just give up and show what we have so far.
-          var TAIL_EXPIRATION_TIMEOUT_MS = 500;
-          renderState.tailExpiration = now() + TAIL_EXPIRATION_TIMEOUT_MS; // TODO: This is meant to mimic the train model or JND but this
-          // is a per component value. It should really be since the start
-          // of the total render or last commit. Consider using something like
-          // globalMostRecentFallbackTime. That doesn't account for being
-          // suspended for part of the time or when it's a new render.
-          // It should probably use a global start time value instead.
-        } // Pop a row.
-
+        // Pop a row.
         var next = renderState.tail;
         renderState.rendering = next;
         renderState.tail = next.sibling;
@@ -15098,6 +15549,35 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
       return null;
     }
+
+    case FundamentalComponent: {
+      break;
+    }
+
+    case ScopeComponent: {
+      break;
+    }
+
+    case OffscreenComponent:
+    case LegacyHiddenComponent: {
+      popRenderLanes(workInProgress);
+
+      if (current !== null) {
+        var _nextState = workInProgress.memoizedState;
+        var _prevState = current.memoizedState;
+        var prevIsHidden = _prevState !== null;
+        var nextIsHidden = _nextState !== null;
+
+        if (
+          prevIsHidden !== nextIsHidden &&
+          newProps.mode !== "unstable-defer-without-hiding"
+        ) {
+          workInProgress.flags |= Update;
+        }
+      }
+
+      return null;
+    }
   }
 
   {
@@ -15109,7 +15589,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
   }
 }
 
-function unwindWork(workInProgress, renderExpirationTime) {
+function unwindWork(workInProgress, renderLanes) {
   switch (workInProgress.tag) {
     case ClassComponent: {
       var Component = workInProgress.type;
@@ -15118,211 +15598,571 @@ function unwindWork(workInProgress, renderExpirationTime) {
         popContext(workInProgress);
       }
 
-      var effectTag = workInProgress.effectTag;
+      var flags = workInProgress.flags;
+
+      if (flags & ShouldCapture) {
+        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;
+
+        if ((workInProgress.mode & ProfileMode) !== NoMode) {
+          transferActualDuration(workInProgress);
+        }
+
+        return workInProgress;
+      }
+
+      return null;
+    }
+
+    case HostRoot: {
+      popHostContainer(workInProgress);
+      popTopLevelContextObject(workInProgress);
+      resetWorkInProgressVersions();
+      var _flags = workInProgress.flags;
+
+      if (!((_flags & DidCapture) === NoFlags)) {
+        throw Error(
+          "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."
+        );
+      }
+
+      workInProgress.flags = (_flags & ~ShouldCapture) | DidCapture;
+      return workInProgress;
+    }
+
+    case HostComponent: {
+      // TODO: popHydrationState
+      popHostContext(workInProgress);
+      return null;
+    }
+
+    case SuspenseComponent: {
+      popSuspenseContext(workInProgress);
+
+      var _flags2 = workInProgress.flags;
+
+      if (_flags2 & ShouldCapture) {
+        workInProgress.flags = (_flags2 & ~ShouldCapture) | DidCapture; // Captured a suspense effect. Re-render the boundary.
+
+        if ((workInProgress.mode & ProfileMode) !== NoMode) {
+          transferActualDuration(workInProgress);
+        }
 
-      if (effectTag & ShouldCapture) {
-        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
         return workInProgress;
       }
 
-      return null;
-    }
+      return null;
+    }
+
+    case SuspenseListComponent: {
+      popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
+      // caught by a nested boundary. If not, it should bubble through.
+
+      return null;
+    }
+
+    case HostPortal:
+      popHostContainer(workInProgress);
+      return null;
+
+    case ContextProvider:
+      popProvider(workInProgress);
+      return null;
+
+    case OffscreenComponent:
+    case LegacyHiddenComponent:
+      popRenderLanes(workInProgress);
+      return null;
+
+    default:
+      return null;
+  }
+}
+
+function unwindInterruptedWork(interruptedWork) {
+  switch (interruptedWork.tag) {
+    case ClassComponent: {
+      var childContextTypes = interruptedWork.type.childContextTypes;
+
+      if (childContextTypes !== null && childContextTypes !== undefined) {
+        popContext(interruptedWork);
+      }
+
+      break;
+    }
+
+    case HostRoot: {
+      popHostContainer(interruptedWork);
+      popTopLevelContextObject(interruptedWork);
+      resetWorkInProgressVersions();
+      break;
+    }
+
+    case HostComponent: {
+      popHostContext(interruptedWork);
+      break;
+    }
+
+    case HostPortal:
+      popHostContainer(interruptedWork);
+      break;
+
+    case SuspenseComponent:
+      popSuspenseContext(interruptedWork);
+      break;
+
+    case SuspenseListComponent:
+      popSuspenseContext(interruptedWork);
+      break;
+
+    case ContextProvider:
+      popProvider(interruptedWork);
+      break;
+
+    case OffscreenComponent:
+    case LegacyHiddenComponent:
+      popRenderLanes(interruptedWork);
+      break;
+  }
+}
+
+function createCapturedValue(value, source) {
+  // If the value is an error, call this function immediately after it is thrown
+  // so the stack is accurate.
+  return {
+    value: value,
+    source: source,
+    stack: getStackByFiberInDevAndProd(source)
+  };
+}
+
+if (
+  !(
+    typeof ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog ===
+    "function"
+  )
+) {
+  throw Error(
+    "Expected ReactFiberErrorDialog.showErrorDialog to be a function."
+  );
+}
+
+function showErrorDialog(boundary, errorInfo) {
+  var capturedError = {
+    componentStack: errorInfo.stack !== null ? errorInfo.stack : "",
+    error: errorInfo.value,
+    errorBoundary:
+      boundary !== null && boundary.tag === ClassComponent
+        ? boundary.stateNode
+        : null
+  };
+  return ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog(
+    capturedError
+  );
+}
+
+function logCapturedError(boundary, errorInfo) {
+  try {
+    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
+    // This enables renderers like ReactNative to better manage redbox behavior.
+
+    if (logError === false) {
+      return;
+    }
+
+    var error = errorInfo.value;
+
+    if (true) {
+      var source = errorInfo.source;
+      var stack = errorInfo.stack;
+      var componentStack = stack !== null ? stack : ""; // Browsers support silencing uncaught errors by calling
+      // `preventDefault()` in window `error` handler.
+      // We record this information as an expando on the error.
+
+      if (error != null && error._suppressLogging) {
+        if (boundary.tag === ClassComponent) {
+          // The error is recoverable and was silenced.
+          // Ignore it and don't print the stack addendum.
+          // This is handy for testing error boundaries without noise.
+          return;
+        } // The error is fatal. Since the silencing might have
+        // been accidental, we'll surface it anyway.
+        // However, the browser would have silenced the original error
+        // so we'll print it first, and then print the stack addendum.
+
+        console["error"](error); // Don't transform to our wrapper
+        // For a more detailed description of this block, see:
+        // https://github.com/facebook/react/pull/13384
+      }
+
+      var componentName = source ? getComponentName(source.type) : null;
+      var componentNameMessage = componentName
+        ? "The above error occurred in the <" + componentName + "> component:"
+        : "The above error occurred in one of your React components:";
+      var errorBoundaryMessage;
+      var errorBoundaryName = getComponentName(boundary.type);
+
+      if (errorBoundaryName) {
+        errorBoundaryMessage =
+          "React will try to recreate this component tree from scratch " +
+          ("using the error boundary you provided, " + errorBoundaryName + ".");
+      } else {
+        errorBoundaryMessage =
+          "Consider adding an error boundary to your tree to customize error handling behavior.\n" +
+          "Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
+      }
+
+      var combinedMessage =
+        componentNameMessage +
+        "\n" +
+        componentStack +
+        "\n\n" +
+        ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
+      // We don't include the original error message and JS stack because the browser
+      // has already printed it. Even if the application swallows the error, it is still
+      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
+
+      console["error"](combinedMessage); // Don't transform to our wrapper
+    } else {
+      // In production, we print the error directly.
+      // This will include the message, the JS stack, and anything the browser wants to show.
+      // We pass the error object instead of custom message so that the browser displays the error natively.
+      console["error"](error); // Don't transform to our wrapper
+    }
+  } catch (e) {
+    // This method must not throw, or React internal state will get messed up.
+    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
+    // we want to report this error outside of the normal stack as a last resort.
+    // https://github.com/facebook/react/issues/13188
+    setTimeout(function() {
+      throw e;
+    });
+  }
+}
+
+var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
+
+function createRootErrorUpdate(fiber, errorInfo, lane) {
+  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.
+
+  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
+  // being called "element".
+
+  update.payload = {
+    element: null
+  };
+  var error = errorInfo.value;
+
+  update.callback = function() {
+    onUncaughtError(error);
+    logCapturedError(fiber, errorInfo);
+  };
+
+  return update;
+}
+
+function createClassErrorUpdate(fiber, errorInfo, lane) {
+  var update = createUpdate(NoTimestamp, lane);
+  update.tag = CaptureUpdate;
+  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+
+  if (typeof getDerivedStateFromError === "function") {
+    var error$1 = errorInfo.value;
+
+    update.payload = function() {
+      logCapturedError(fiber, errorInfo);
+      return getDerivedStateFromError(error$1);
+    };
+  }
+
+  var inst = fiber.stateNode;
+
+  if (inst !== null && typeof inst.componentDidCatch === "function") {
+    update.callback = function callback() {
+      {
+        markFailedErrorBoundaryForHotReloading(fiber);
+      }
+
+      if (typeof getDerivedStateFromError !== "function") {
+        // To preserve the preexisting retry behavior of error boundaries,
+        // we keep track of which ones already failed during this batch.
+        // This gets reset before we yield back to the browser.
+        // TODO: Warn in strict mode if getDerivedStateFromError is
+        // not defined.
+        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined
+
+        logCapturedError(fiber, errorInfo);
+      }
+
+      var error$1 = errorInfo.value;
+      var stack = errorInfo.stack;
+      this.componentDidCatch(error$1, {
+        componentStack: stack !== null ? stack : ""
+      });
+
+      {
+        if (typeof getDerivedStateFromError !== "function") {
+          // If componentDidCatch is the only error boundary method defined,
+          // then it needs to call setState to recover from errors.
+          // If no state update is scheduled then the boundary will swallow the error.
+          if (!includesSomeLane(fiber.lanes, SyncLane)) {
+            error(
+              "%s: Error boundaries should implement getDerivedStateFromError(). " +
+                "In that method, return a state update to display an error message or fallback UI.",
+              getComponentName(fiber.type) || "Unknown"
+            );
+          }
+        }
+      }
+    };
+  } else {
+    update.callback = function() {
+      markFailedErrorBoundaryForHotReloading(fiber);
+    };
+  }
+
+  return update;
+}
 
-    case HostRoot: {
-      popHostContainer(workInProgress);
-      popTopLevelContextObject(workInProgress);
-      var _effectTag = workInProgress.effectTag;
+function attachPingListener(root, wakeable, lanes) {
+  // Attach a listener to the promise to "ping" the root and retry. But only if
+  // one does not already exist for the lanes we're currently rendering (which
+  // acts like a "thread ID" here).
+  var pingCache = root.pingCache;
+  var threadIDs;
 
-      if (!((_effectTag & DidCapture) === NoEffect)) {
-        throw Error(
-          "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."
-        );
-      }
+  if (pingCache === null) {
+    pingCache = root.pingCache = new PossiblyWeakMap$1();
+    threadIDs = new Set();
+    pingCache.set(wakeable, threadIDs);
+  } else {
+    threadIDs = pingCache.get(wakeable);
 
-      workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;
-      return workInProgress;
+    if (threadIDs === undefined) {
+      threadIDs = new Set();
+      pingCache.set(wakeable, threadIDs);
     }
+  }
 
-    case HostComponent: {
-      // TODO: popHydrationState
-      popHostContext(workInProgress);
-      return null;
-    }
+  if (!threadIDs.has(lanes)) {
+    // Memoize using the thread ID to prevent redundant listeners.
+    threadIDs.add(lanes);
+    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
+    wakeable.then(ping, ping);
+  }
+}
 
-    case SuspenseComponent: {
-      popSuspenseContext(workInProgress);
+function throwException(
+  root,
+  returnFiber,
+  sourceFiber,
+  value,
+  rootRenderLanes
+) {
+  // The source fiber did not complete.
+  sourceFiber.flags |= Incomplete; // Its effect list is no longer valid.
 
-      var _effectTag2 = workInProgress.effectTag;
+  sourceFiber.firstEffect = sourceFiber.lastEffect = null;
+
+  if (
+    value !== null &&
+    typeof value === "object" &&
+    typeof value.then === "function"
+  ) {
+    // This is a wakeable.
+    var wakeable = value;
 
-      if (_effectTag2 & ShouldCapture) {
-        workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture; // Captured a suspense effect. Re-render the boundary.
+    if ((sourceFiber.mode & BlockingMode) === NoMode) {
+      // Reset the memoizedState to what it was before we attempted
+      // to render it.
+      var currentSource = sourceFiber.alternate;
 
-        return workInProgress;
+      if (currentSource) {
+        sourceFiber.updateQueue = currentSource.updateQueue;
+        sourceFiber.memoizedState = currentSource.memoizedState;
+        sourceFiber.lanes = currentSource.lanes;
+      } else {
+        sourceFiber.updateQueue = null;
+        sourceFiber.memoizedState = null;
       }
-
-      return null;
     }
 
-    case SuspenseListComponent: {
-      popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
-      // caught by a nested boundary. If not, it should bubble through.
-
-      return null;
-    }
+    var hasInvisibleParentBoundary = hasSuspenseContext(
+      suspenseStackCursor.current,
+      InvisibleParentSuspenseContext
+    ); // Schedule the nearest Suspense to re-render the timed out view.
 
-    case HostPortal:
-      popHostContainer(workInProgress);
-      return null;
+    var _workInProgress = returnFiber;
 
-    case ContextProvider:
-      popProvider(workInProgress);
-      return null;
+    do {
+      if (
+        _workInProgress.tag === SuspenseComponent &&
+        shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)
+      ) {
+        // Found the nearest boundary.
+        // Stash the promise on the boundary fiber. If the boundary times out, we'll
+        // attach another listener to flip the boundary back to its normal state.
+        var wakeables = _workInProgress.updateQueue;
 
-    default:
-      return null;
-  }
-}
+        if (wakeables === null) {
+          var updateQueue = new Set();
+          updateQueue.add(wakeable);
+          _workInProgress.updateQueue = updateQueue;
+        } else {
+          wakeables.add(wakeable);
+        } // If the boundary is outside of blocking mode, we should *not*
+        // suspend the commit. Pretend as if the suspended component rendered
+        // null and keep rendering. In the commit phase, we'll schedule a
+        // subsequent synchronous update to re-render the Suspense.
+        //
+        // Note: It doesn't matter whether the component that suspended was
+        // inside a blocking mode tree. If the Suspense is outside of it, we
+        // should *not* suspend the commit.
 
-function unwindInterruptedWork(interruptedWork) {
-  switch (interruptedWork.tag) {
-    case ClassComponent: {
-      var childContextTypes = interruptedWork.type.childContextTypes;
+        if ((_workInProgress.mode & BlockingMode) === NoMode) {
+          _workInProgress.flags |= DidCapture;
+          sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
+          // But we shouldn't call any lifecycle methods or callbacks. Remove
+          // all lifecycle effect tags.
 
-      if (childContextTypes !== null && childContextTypes !== undefined) {
-        popContext(interruptedWork);
-      }
+          sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
 
-      break;
-    }
+          if (sourceFiber.tag === ClassComponent) {
+            var currentSourceFiber = sourceFiber.alternate;
 
-    case HostRoot: {
-      popHostContainer(interruptedWork);
-      popTopLevelContextObject(interruptedWork);
-      break;
-    }
+            if (currentSourceFiber === null) {
+              // This is a new mount. Change the tag so it's not mistaken for a
+              // completed class component. For example, we should not call
+              // componentWillUnmount if it is deleted.
+              sourceFiber.tag = IncompleteClassComponent;
+            } else {
+              // When we try rendering again, we should not reuse the current fiber,
+              // since it's known to be in an inconsistent state. Use a force update to
+              // prevent a bail out.
+              var update = createUpdate(NoTimestamp, SyncLane);
+              update.tag = ForceUpdate;
+              enqueueUpdate(sourceFiber, update);
+            }
+          } // The source fiber did not complete. Mark it with Sync priority to
+          // indicate that it still has pending work.
 
-    case HostComponent: {
-      popHostContext(interruptedWork);
-      break;
-    }
+          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.
 
-    case HostPortal:
-      popHostContainer(interruptedWork);
-      break;
+          return;
+        } // Confirmed that the boundary is in a concurrent mode tree. Continue
+        // with the normal suspend path.
+        //
+        // After this we'll use a set of heuristics to determine whether this
+        // render pass will run to completion or restart or "suspend" the commit.
+        // The actual logic for this is spread out in different places.
+        //
+        // This first principle is that if we're going to suspend when we complete
+        // a root, then we should also restart if we get an update or ping that
+        // might unsuspend it, and vice versa. The only reason to suspend is
+        // because you think you might want to restart before committing. However,
+        // it doesn't make sense to restart only while in the period we're suspended.
+        //
+        // Restarting too aggressively is also not good because it starves out any
+        // intermediate loading state. So we use heuristics to determine when.
+        // Suspense Heuristics
+        //
+        // If nothing threw a Promise or all the same fallbacks are already showing,
+        // then don't suspend/restart.
+        //
+        // If this is an initial render of a new tree of Suspense boundaries and
+        // those trigger a fallback, then don't suspend/restart. We want to ensure
+        // that we can show the initial loading state as quickly as possible.
+        //
+        // If we hit a "Delayed" case, such as when we'd switch from content back into
+        // a fallback, then we should always suspend/restart. Transitions apply
+        // to this case. If none is defined, JND is used instead.
+        //
+        // If we're already showing a fallback and it gets "retried", allowing us to show
+        // another level, but there's still an inner boundary that would show a fallback,
+        // then we suspend/restart for 500ms since the last time we showed a fallback
+        // anywhere in the tree. This effectively throttles progressive loading into a
+        // consistent train of commits. This also gives us an opportunity to restart to
+        // get to the completed state slightly earlier.
+        //
+        // If there's ambiguity due to batching it's resolved in preference of:
+        // 1) "delayed", 2) "initial render", 3) "retry".
+        //
+        // We want to ensure that a "busy" state doesn't get force committed. We want to
+        // ensure that new initial loading states can commit as soon as possible.
 
-    case SuspenseComponent:
-      popSuspenseContext(interruptedWork);
-      break;
+        attachPingListener(root, wakeable, rootRenderLanes);
+        _workInProgress.flags |= ShouldCapture;
+        _workInProgress.lanes = rootRenderLanes;
+        return;
+      } // This boundary already captured during this render. Continue to the next
+      // boundary.
 
-    case SuspenseListComponent:
-      popSuspenseContext(interruptedWork);
-      break;
+      _workInProgress = _workInProgress.return;
+    } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.
+    // TODO: Use invariant so the message is stripped in prod?
 
-    case ContextProvider:
-      popProvider(interruptedWork);
-      break;
-  }
-}
+    value = new Error(
+      (getComponentName(sourceFiber.type) || "A React component") +
+        " suspended while rendering, but no fallback UI was specified.\n" +
+        "\n" +
+        "Add a <Suspense fallback=...> component higher in the tree to " +
+        "provide a loading indicator or placeholder to display."
+    );
+  } // We didn't find a boundary that could handle this type of exception. Start
+  // over and traverse parent path again, this time treating the exception
+  // as an error.
 
-function createCapturedValue(value, source) {
-  // If the value is an error, call this function immediately after it is thrown
-  // so the stack is accurate.
-  return {
-    value: value,
-    source: source,
-    stack: getStackByFiberInDevAndProd(source)
-  };
-}
+  renderDidError();
+  value = createCapturedValue(value, sourceFiber);
+  var workInProgress = returnFiber;
 
-// Module provided by RN:
+  do {
+    switch (workInProgress.tag) {
+      case HostRoot: {
+        var _errorInfo = value;
+        workInProgress.flags |= ShouldCapture;
+        var lane = pickArbitraryLane(rootRenderLanes);
+        workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);
 
-if (
-  !(
-    typeof ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog ===
-    "function"
-  )
-) {
-  throw Error(
-    "Expected ReactFiberErrorDialog.showErrorDialog to be a function."
-  );
-}
+        var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);
 
-function showErrorDialog(capturedError) {
-  return ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog(
-    capturedError
-  );
-}
+        enqueueCapturedUpdate(workInProgress, _update);
+        return;
+      }
 
-function logCapturedError(capturedError) {
-  var logError = showErrorDialog(capturedError); // Allow injected showErrorDialog() to prevent default console.error logging.
-  // This enables renderers like ReactNative to better manage redbox behavior.
+      case ClassComponent:
+        // Capture and retry
+        var errorInfo = value;
+        var ctor = workInProgress.type;
+        var instance = workInProgress.stateNode;
 
-  if (logError === false) {
-    return;
-  }
+        if (
+          (workInProgress.flags & DidCapture) === NoFlags &&
+          (typeof ctor.getDerivedStateFromError === "function" ||
+            (instance !== null &&
+              typeof instance.componentDidCatch === "function" &&
+              !isAlreadyFailedLegacyErrorBoundary(instance)))
+        ) {
+          workInProgress.flags |= ShouldCapture;
 
-  var error = capturedError.error;
+          var _lane = pickArbitraryLane(rootRenderLanes);
 
-  {
-    var componentName = capturedError.componentName,
-      componentStack = capturedError.componentStack,
-      errorBoundaryName = capturedError.errorBoundaryName,
-      errorBoundaryFound = capturedError.errorBoundaryFound,
-      willRetry = capturedError.willRetry; // Browsers support silencing uncaught errors by calling
-    // `preventDefault()` in window `error` handler.
-    // We record this information as an expando on the error.
-
-    if (error != null && error._suppressLogging) {
-      if (errorBoundaryFound && willRetry) {
-        // The error is recoverable and was silenced.
-        // Ignore it and don't print the stack addendum.
-        // This is handy for testing error boundaries without noise.
-        return;
-      } // The error is fatal. Since the silencing might have
-      // been accidental, we'll surface it anyway.
-      // However, the browser would have silenced the original error
-      // so we'll print it first, and then print the stack addendum.
+          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state
 
-      console["error"](error); // Don't transform to our wrapper
-      // For a more detailed description of this block, see:
-      // https://github.com/facebook/react/pull/13384
-    }
+          var _update2 = createClassErrorUpdate(
+            workInProgress,
+            errorInfo,
+            _lane
+          );
 
-    var componentNameMessage = componentName
-      ? "The above error occurred in the <" + componentName + "> component:"
-      : "The above error occurred in one of your React components:";
-    var errorBoundaryMessage; // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
+          enqueueCapturedUpdate(workInProgress, _update2);
+          return;
+        }
 
-    if (errorBoundaryFound && errorBoundaryName) {
-      if (willRetry) {
-        errorBoundaryMessage =
-          "React will try to recreate this component tree from scratch " +
-          ("using the error boundary you provided, " + errorBoundaryName + ".");
-      } else {
-        errorBoundaryMessage =
-          "This error was initially handled by the error boundary " +
-          errorBoundaryName +
-          ".\n" +
-          "Recreating the tree from scratch failed so React will unmount the tree.";
-      }
-    } else {
-      errorBoundaryMessage =
-        "Consider adding an error boundary to your tree to customize error handling behavior.\n" +
-        "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
+        break;
     }
 
-    var combinedMessage =
-      "" +
-      componentNameMessage +
-      componentStack +
-      "\n\n" +
-      ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
-    // We don't include the original error message and JS stack because the browser
-    // has already printed it. Even if the application swallows the error, it is still
-    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
-
-    console["error"](combinedMessage); // Don't transform to our wrapper
-  }
+    workInProgress = workInProgress.return;
+  } while (workInProgress !== null);
 }
 
 var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
@@ -15332,54 +16172,14 @@ var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
 }
 
 var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
-function logError(boundary, errorInfo) {
-  var source = errorInfo.source;
-  var stack = errorInfo.stack;
-
-  if (stack === null && source !== null) {
-    stack = getStackByFiberInDevAndProd(source);
-  }
-
-  var capturedError = {
-    componentName: source !== null ? getComponentName(source.type) : null,
-    componentStack: stack !== null ? stack : "",
-    error: errorInfo.value,
-    errorBoundary: null,
-    errorBoundaryName: null,
-    errorBoundaryFound: false,
-    willRetry: false
-  };
-
-  if (boundary !== null && boundary.tag === ClassComponent) {
-    capturedError.errorBoundary = boundary.stateNode;
-    capturedError.errorBoundaryName = getComponentName(boundary.type);
-    capturedError.errorBoundaryFound = true;
-    capturedError.willRetry = true;
-  }
-
-  try {
-    logCapturedError(capturedError);
-  } catch (e) {
-    // This method must not throw, or React internal state will get messed up.
-    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
-    // we want to report this error outside of the normal stack as a last resort.
-    // https://github.com/facebook/react/issues/13188
-    setTimeout(function() {
-      throw e;
-    });
-  }
-}
 
 var callComponentWillUnmountWithTimer = function(current, instance) {
-  startPhaseTimer(current, "componentWillUnmount");
   instance.props = current.memoizedProps;
   instance.state = current.memoizedState;
 
   {
     instance.componentWillUnmount();
   }
-
-  stopPhaseTimer();
 }; // Capture errors so they don't interrupt unmounting.
 
 function safelyCallComponentWillUnmount(current, instance) {
@@ -15405,7 +16205,9 @@ function safelyDetachRef(current) {
   if (ref !== null) {
     if (typeof ref === "function") {
       {
-        invokeGuardedCallback(null, ref, null, null);
+        {
+          invokeGuardedCallback(null, ref, null, null);
+        }
 
         if (hasCaughtError()) {
           var refError = clearCaughtError();
@@ -15433,17 +16235,15 @@ function commitBeforeMutationLifeCycles(current, finishedWork) {
   switch (finishedWork.tag) {
     case FunctionComponent:
     case ForwardRef:
-    case SimpleMemoComponent:
-    case Block: {
+    case SimpleMemoComponent: {
       return;
     }
 
     case ClassComponent: {
-      if (finishedWork.effectTag & Snapshot) {
+      if (finishedWork.flags & Snapshot) {
         if (current !== null) {
           var prevProps = current.memoizedProps;
           var prevState = current.memoizedState;
-          startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
           var instance = finishedWork.stateNode; // We could update instance props and state here,
           // but instead we rely on them being set during last render.
           // TODO: revisit this when we implement resuming.
@@ -15499,14 +16299,23 @@ function commitBeforeMutationLifeCycles(current, finishedWork) {
           }
 
           instance.__reactInternalSnapshotBeforeUpdate = snapshot;
-          stopPhaseTimer();
         }
       }
 
       return;
     }
 
-    case HostRoot:
+    case HostRoot: {
+      {
+        if (finishedWork.flags & Snapshot) {
+          var root = finishedWork.stateNode;
+          clearContainer(root.containerInfo);
+        }
+      }
+
+      return;
+    }
+
     case HostComponent:
     case HostText:
     case HostPortal:
@@ -15583,16 +16392,15 @@ function commitHookEffectListMount(tag, finishedWork) {
                 "  }\n" +
                 "  fetchData();\n" +
                 "}, [someId]); // Or [] if effect doesn't need props or state\n\n" +
-                "Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching";
+                "Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
             } else {
               addendum = " You returned: " + destroy;
             }
 
             error(
               "An effect function must not return anything besides a function, " +
-                "which is used for clean-up.%s%s",
-              addendum,
-              getStackByFiberInDevAndProd(finishedWork)
+                "which is used for clean-up.%s",
+              addendum
             );
           }
         }
@@ -15603,38 +16411,34 @@ function commitHookEffectListMount(tag, finishedWork) {
   }
 }
 
-function commitPassiveHookEffects(finishedWork) {
-  if ((finishedWork.effectTag & Passive) !== NoEffect) {
-    switch (finishedWork.tag) {
-      case FunctionComponent:
-      case ForwardRef:
-      case SimpleMemoComponent:
-      case Block: {
-        // TODO (#17945) We should call all passive destroy functions (for all fibers)
-        // before calling any create functions. The current approach only serializes
-        // these for a single fiber.
-        {
-          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork);
-          commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
-        }
+function schedulePassiveEffects(finishedWork) {
+  var updateQueue = finishedWork.updateQueue;
+  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
 
-        break;
+  if (lastEffect !== null) {
+    var firstEffect = lastEffect.next;
+    var effect = firstEffect;
+
+    do {
+      var _effect = effect,
+        next = _effect.next,
+        tag = _effect.tag;
+
+      if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
+        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
+        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
       }
-    }
+
+      effect = next;
+    } while (effect !== firstEffect);
   }
 }
 
-function commitLifeCycles(
-  finishedRoot,
-  current,
-  finishedWork,
-  committedExpirationTime
-) {
+function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
   switch (finishedWork.tag) {
     case FunctionComponent:
     case ForwardRef:
-    case SimpleMemoComponent:
-    case Block: {
+    case SimpleMemoComponent: {
       // At this point layout effects have already been destroyed (during mutation phase).
       // This is done to prevent sibling component effects from interfering with each other,
       // e.g. a destroy function in one component should never override a ref set
@@ -15643,18 +16447,18 @@ function commitLifeCycles(
         commitHookEffectListMount(Layout | HasEffect, finishedWork);
       }
 
+      schedulePassiveEffects(finishedWork);
       return;
     }
 
     case ClassComponent: {
       var instance = finishedWork.stateNode;
 
-      if (finishedWork.effectTag & Update) {
+      if (finishedWork.flags & Update) {
         if (current === null) {
-          startPhaseTimer(finishedWork, "componentDidMount"); // We could update instance props and state here,
+          // We could update instance props and state here,
           // but instead we rely on them being set during last render.
           // TODO: revisit this when we implement resuming.
-
           {
             if (
               finishedWork.type === finishedWork.elementType &&
@@ -15687,15 +16491,12 @@ function commitLifeCycles(
           {
             instance.componentDidMount();
           }
-
-          stopPhaseTimer();
         } else {
           var prevProps =
             finishedWork.elementType === finishedWork.type
               ? current.memoizedProps
               : resolveDefaultProps(finishedWork.type, current.memoizedProps);
-          var prevState = current.memoizedState;
-          startPhaseTimer(finishedWork, "componentDidUpdate"); // We could update instance props and state here,
+          var prevState = current.memoizedState; // We could update instance props and state here,
           // but instead we rely on them being set during last render.
           // TODO: revisit this when we implement resuming.
 
@@ -15735,10 +16536,9 @@ function commitLifeCycles(
               instance.__reactInternalSnapshotBeforeUpdate
             );
           }
-
-          stopPhaseTimer();
         }
-      }
+      } // TODO: I think this is now always non-null by the time it reaches the
+      // commit phase. Consider removing the type check.
 
       var updateQueue = finishedWork.updateQueue;
 
@@ -15781,6 +16581,8 @@ function commitLifeCycles(
     }
 
     case HostRoot: {
+      // TODO: I think this is now always non-null by the time it reaches the
+      // commit phase. Consider removing the type check.
       var _updateQueue = finishedWork.updateQueue;
 
       if (_updateQueue !== null) {
@@ -15810,7 +16612,7 @@ function commitLifeCycles(
       // These effects should only be committed when components are first mounted,
       // aka when there is no current/alternate.
 
-      if (current === null && finishedWork.effectTag & Update) {
+      if (current === null && finishedWork.flags & Update) {
         var type = finishedWork.type;
         var props = finishedWork.memoizedProps;
       }
@@ -15862,6 +16664,8 @@ function commitLifeCycles(
     case IncompleteClassComponent:
     case FundamentalComponent:
     case ScopeComponent:
+    case OffscreenComponent:
+    case LegacyHiddenComponent:
       return;
   }
 
@@ -15896,17 +16700,12 @@ function hideOrUnhideAllChildren(finishedWork, isHidden) {
           unhideTextInstance(_instance3, node.memoizedProps);
         }
       } else if (
-        node.tag === SuspenseComponent &&
+        (node.tag === OffscreenComponent ||
+          node.tag === LegacyHiddenComponent) &&
         node.memoizedState !== null &&
-        node.memoizedState.dehydrated === null
-      ) {
-        // Found a nested Suspense component that timed out. Skip over the
-        // primary child fragment, which should remain hidden.
-        var fallbackChildFragment = node.child.sibling;
-        fallbackChildFragment.return = node;
-        node = fallbackChildFragment;
-        continue;
-      } else if (node.child !== null) {
+        node !== finishedWork
+      );
+      else if (node.child !== null) {
         node.child.return = node;
         node = node.child;
         continue;
@@ -15947,15 +16746,16 @@ function commitAttachRef(finishedWork) {
     } // Moved outside to ensure DCE works with this flag
 
     if (typeof ref === "function") {
-      ref(instanceToUse);
+      {
+        ref(instanceToUse);
+      }
     } else {
       {
         if (!ref.hasOwnProperty("current")) {
           error(
             "Unexpected ref object provided for %s. " +
-              "Use either a ref-setter function or React.createRef().%s",
-            getComponentName(finishedWork.type),
-            getStackByFiberInDevAndProd(finishedWork)
+              "Use either a ref-setter function or React.createRef().",
+            getComponentName(finishedWork.type)
           );
         }
       }
@@ -15970,7 +16770,9 @@ function commitDetachRef(current) {
 
   if (currentRef !== null) {
     if (typeof currentRef === "function") {
-      currentRef(null);
+      {
+        currentRef(null);
+      }
     } else {
       currentRef.current = null;
     }
@@ -15986,8 +16788,7 @@ function commitUnmount(finishedRoot, current, renderPriorityLevel) {
     case FunctionComponent:
     case ForwardRef:
     case MemoComponent:
-    case SimpleMemoComponent:
-    case Block: {
+    case SimpleMemoComponent: {
       var updateQueue = current.updateQueue;
 
       if (updateQueue !== null) {
@@ -15995,42 +16796,25 @@ function commitUnmount(finishedRoot, current, renderPriorityLevel) {
 
         if (lastEffect !== null) {
           var firstEffect = lastEffect.next;
+          var effect = firstEffect;
 
-          {
-            // When the owner fiber is deleted, the destroy function of a passive
-            // effect hook is called during the synchronous commit phase. This is
-            // a concession to implementation complexity. Calling it in the
-            // passive effect phase (like they usually are, when dependencies
-            // change during an update) would require either traversing the
-            // children of the deleted fiber again, or including unmount effects
-            // as part of the fiber effect list.
-            //
-            // Because this is during the sync commit phase, we need to change
-            // the priority.
-            //
-            // TODO: Reconsider this implementation trade off.
-            var priorityLevel =
-              renderPriorityLevel > NormalPriority
-                ? NormalPriority
-                : renderPriorityLevel;
-            runWithPriority(priorityLevel, function() {
-              var effect = firstEffect;
-
-              do {
-                var _effect3 = effect,
-                  _destroy = _effect3.destroy,
-                  _tag = _effect3.tag;
-
-                if (_destroy !== undefined) {
-                  {
-                    safelyCallDestroy(current, _destroy);
-                  }
+          do {
+            var _effect2 = effect,
+              destroy = _effect2.destroy,
+              tag = _effect2.tag;
+
+            if (destroy !== undefined) {
+              if ((tag & Passive$1) !== NoFlags$1) {
+                enqueuePendingPassiveHookEffectUnmount(current, effect);
+              } else {
+                {
+                  safelyCallDestroy(current, destroy);
                 }
+              }
+            }
 
-                effect = effect.next;
-              } while (effect !== firstEffect);
-            });
-          }
+            effect = effect.next;
+          } while (effect !== firstEffect);
         }
       }
 
@@ -16058,7 +16842,7 @@ function commitUnmount(finishedRoot, current, renderPriorityLevel) {
       // We are also not using this parent because
       // the portal will get pushed immediately.
       {
-        unmountHostComponents(finishedRoot, current, renderPriorityLevel);
+        unmountHostComponents(finishedRoot, current);
       }
 
       return;
@@ -16087,7 +16871,7 @@ function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
   var node = root;
 
   while (true) {
-    commitUnmount(finishedRoot, node, renderPriorityLevel); // Visit children because they may contain more composite or host nodes.
+    commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.
     // Skip portals because commitUnmount() currently visits them recursively.
 
     if (
@@ -16117,27 +16901,33 @@ function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
   }
 }
 
-function detachFiber(current) {
-  var alternate = current.alternate; // Cut off the return pointers to disconnect it from the tree. Ideally, we
+function detachFiberMutation(fiber) {
+  // Cut off the return pointers to disconnect it from the tree. Ideally, we
   // should clear the child pointer of the parent alternate to let this
   // get GC:ed but we don't know which for sure which parent is the current
   // one so we'll settle for GC:ing the subtree of this child. This child
   // itself will be GC:ed when the parent updates the next time.
+  // Note: we cannot null out sibling here, otherwise it can cause issues
+  // with findDOMNode and how it requires the sibling field to carry out
+  // traversal in a later effect. See PR #16820. We now clear the sibling
+  // field after effects, see: detachFiberAfterEffects.
+  //
+  // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
+  // It may be required if the current component is an error boundary,
+  // and one of its descendants throws while unmounting a passive effect.
+  fiber.alternate = null;
+  fiber.child = null;
+  fiber.dependencies = null;
+  fiber.firstEffect = null;
+  fiber.lastEffect = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.return = null;
+  fiber.updateQueue = null;
 
-  current.return = null;
-  current.child = null;
-  current.memoizedState = null;
-  current.updateQueue = null;
-  current.dependencies = null;
-  current.alternate = null;
-  current.firstEffect = null;
-  current.lastEffect = null;
-  current.pendingProps = null;
-  current.memoizedProps = null;
-  current.stateNode = null;
-
-  if (alternate !== null) {
-    detachFiber(alternate);
+  {
+    fiber._debugOwner = null;
   }
 }
 
@@ -16196,7 +16986,7 @@ function getHostSibling(fiber) {
     ) {
       // If it is not host node and, we might have a host node inside it.
       // Try to search down until we find one.
-      if (node.effectTag & Placement) {
+      if (node.flags & Placement) {
         // If we don't have a child, try the siblings instead.
         continue siblings;
       } // If we don't have a child, try the siblings instead.
@@ -16210,7 +17000,7 @@ function getHostSibling(fiber) {
       }
     } // Check if this host node is stable or about to be placed.
 
-    if (!(node.effectTag & Placement)) {
+    if (!(node.flags & Placement)) {
       // Found it!
       return node.stateNode;
     }
@@ -16251,8 +17041,8 @@ function commitPlacement(finishedWork) {
     }
   }
 
-  if (parentFiber.effectTag & ContentReset) {
-    parentFiber.effectTag &= ~ContentReset;
+  if (parentFiber.flags & ContentReset) {
+    parentFiber.flags &= ~ContentReset;
   }
 
   var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its
@@ -16369,7 +17159,7 @@ function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
     }
 
     if (node.tag === HostComponent || node.tag === HostText) {
-      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel); // After all the children have unmounted, it is now safe to remove the
+      commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the
       // node from the tree.
 
       if (currentParentIsContainer) {
@@ -16389,7 +17179,7 @@ function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
         continue;
       }
     } else {
-      commitUnmount(finishedRoot, node, renderPriorityLevel); // Visit children because we may find more host components below.
+      commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.
 
       if (node.child !== null) {
         node.child.return = node;
@@ -16425,10 +17215,15 @@ function commitDeletion(finishedRoot, current, renderPriorityLevel) {
   {
     // Recursively delete all host nodes from the parent.
     // Detach refs and call componentWillUnmount() on the whole subtree.
-    unmountHostComponents(finishedRoot, current, renderPriorityLevel);
+    unmountHostComponents(finishedRoot, current);
   }
 
-  detachFiber(current);
+  var alternate = current.alternate;
+  detachFiberMutation(current);
+
+  if (alternate !== null) {
+    detachFiberMutation(alternate);
+  }
 }
 
 function commitWork(current, finishedWork) {
@@ -16436,8 +17231,7 @@ function commitWork(current, finishedWork) {
     case FunctionComponent:
     case ForwardRef:
     case MemoComponent:
-    case SimpleMemoComponent:
-    case Block: {
+    case SimpleMemoComponent: {
       // Layout effects are destroyed during the mutation phase so that all
       // destroy functions for all fibers are called before any create functions.
       // This prevents sibling component effects from interfering with each other,
@@ -16508,3118 +17302,3275 @@ function commitWork(current, finishedWork) {
       return;
     }
 
-    case SuspenseListComponent: {
-      attachSuspenseRetryListeners(finishedWork);
-      return;
-    }
+    case SuspenseListComponent: {
+      attachSuspenseRetryListeners(finishedWork);
+      return;
+    }
+
+    case IncompleteClassComponent: {
+      return;
+    }
+
+    case FundamentalComponent: {
+      break;
+    }
+
+    case ScopeComponent: {
+      break;
+    }
+
+    case OffscreenComponent:
+    case LegacyHiddenComponent: {
+      var newState = finishedWork.memoizedState;
+      var isHidden = newState !== null;
+      hideOrUnhideAllChildren(finishedWork, isHidden);
+      return;
+    }
+  }
+
+  {
+    throw Error(
+      "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+    );
+  }
+}
+
+function commitSuspenseComponent(finishedWork) {
+  var newState = finishedWork.memoizedState;
+
+  if (newState !== null) {
+    markCommitTimeOfFallback();
+
+    {
+      // Hide the Offscreen component that contains the primary children. TODO:
+      // Ideally, this effect would have been scheduled on the Offscreen fiber
+      // itself. That's how unhiding works: the Offscreen component schedules an
+      // effect on itself. However, in this case, the component didn't complete,
+      // so the fiber was never added to the effect list in the normal path. We
+      // could have appended it to the effect list in the Suspense component's
+      // second pass, but doing it this way is less complicated. This would be
+      // simpler if we got rid of the effect list and traversed the tree, like
+      // we're planning to do.
+      var primaryChildParent = finishedWork.child;
+      hideOrUnhideAllChildren(primaryChildParent, true);
+    }
+  }
+}
+
+function attachSuspenseRetryListeners(finishedWork) {
+  // If this boundary just timed out, then it will have a set of wakeables.
+  // For each wakeable, attach a listener so that when it resolves, React
+  // attempts to re-render the boundary in the primary (pre-timeout) state.
+  var wakeables = finishedWork.updateQueue;
+
+  if (wakeables !== null) {
+    finishedWork.updateQueue = null;
+    var retryCache = finishedWork.stateNode;
+
+    if (retryCache === null) {
+      retryCache = finishedWork.stateNode = new PossiblyWeakSet();
+    }
+
+    wakeables.forEach(function(wakeable) {
+      // Memoize using the boundary fiber to prevent redundant listeners.
+      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+
+      if (!retryCache.has(wakeable)) {
+        {
+          if (wakeable.__reactDoNotTraceInteractions !== true) {
+            retry = tracing.unstable_wrap(retry);
+          }
+        }
+
+        retryCache.add(wakeable);
+        wakeable.then(retry, retry);
+      }
+    });
+  }
+} // This function detects when a Suspense boundary goes from visible to hidden.
+// It returns false if the boundary is already hidden.
+// TODO: Use an effect tag.
+
+function isSuspenseBoundaryBeingHidden(current, finishedWork) {
+  if (current !== null) {
+    var oldState = current.memoizedState;
+
+    if (oldState === null || oldState.dehydrated !== null) {
+      var newState = finishedWork.memoizedState;
+      return newState !== null && newState.dehydrated === null;
+    }
+  }
+
+  return false;
+}
+
+function commitResetTextContent(current) {
+  resetTextContent(current.stateNode);
+}
+
+var COMPONENT_TYPE = 0;
+var HAS_PSEUDO_CLASS_TYPE = 1;
+var ROLE_TYPE = 2;
+var TEST_NAME_TYPE = 3;
+var TEXT_TYPE = 4;
+
+if (typeof Symbol === "function" && Symbol.for) {
+  var symbolFor$1 = Symbol.for;
+  COMPONENT_TYPE = symbolFor$1("selector.component");
+  HAS_PSEUDO_CLASS_TYPE = symbolFor$1("selector.has_pseudo_class");
+  ROLE_TYPE = symbolFor$1("selector.role");
+  TEST_NAME_TYPE = symbolFor$1("selector.test_id");
+  TEXT_TYPE = symbolFor$1("selector.text");
+}
+
+var ceil = Math.ceil;
+var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
+  ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
+  IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
+var NoContext =
+  /*             */
+  0;
+var BatchedContext =
+  /*               */
+  1;
+var DiscreteEventContext =
+  /*         */
+  4;
+var LegacyUnbatchedContext =
+  /*       */
+  8;
+var RenderContext =
+  /*                */
+  16;
+var CommitContext =
+  /*                */
+  32;
+var RetryAfterError =
+  /*       */
+  64;
+var RootIncomplete = 0;
+var RootFatalErrored = 1;
+var RootErrored = 2;
+var RootSuspended = 3;
+var RootSuspendedWithDelay = 4;
+var RootCompleted = 5; // Describes where we are in the React execution stack
+
+var executionContext = NoContext; // The root we're working on
+
+var workInProgressRoot = null; // The fiber we're working on
+
+var workInProgress = null; // The lanes we're rendering
+
+var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
+// This is a superset of the lanes we started working on at the root. The only
+// case where it's different from `workInProgressRootRenderLanes` is when we
+// enter a subtree that is hidden and needs to be unhidden: Suspense and
+// Offscreen component.
+//
+// Most things in the work loop should deal with workInProgressRootRenderLanes.
+// Most things in begin/complete phases should deal with subtreeRenderLanes.
+
+var subtreeRenderLanes = NoLanes;
+var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.
+
+var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown
+
+var workInProgressRootFatalError = null; // "Included" lanes refer to lanes that were worked on during this render. It's
+// slightly different than `renderLanes` because `renderLanes` can change as you
+// enter and exit an Offscreen tree. This value is the combination of all render
+// lanes for the entire render phase.
+
+var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only
+// includes unprocessed updates, not work in bailed out children.
+
+var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.
+
+var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.
+
+var workInProgressRootPingedLanes = NoLanes;
+var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train
+// model where we don't commit new loading states in too quick succession.
+
+var globalMostRecentFallbackTime = 0;
+var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering
+// more and prefer CPU suspense heuristics instead.
+
+var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU
+// suspense heuristics and opt out of rendering more content.
+
+var RENDER_TIMEOUT_MS = 500;
+
+function resetRenderTimer() {
+  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
+}
+
+function getRenderTargetTime() {
+  return workInProgressRootRenderTargetTime;
+}
+var nextEffect = null;
+var hasUncaughtError = false;
+var firstUncaughtError = null;
+var legacyErrorBoundariesThatAlreadyFailed = null;
+var rootDoesHavePassiveEffects = false;
+var rootWithPendingPassiveEffects = null;
+var pendingPassiveEffectsRenderPriority = NoPriority$1;
+var pendingPassiveEffectsLanes = NoLanes;
+var pendingPassiveHookEffectsMount = [];
+var pendingPassiveHookEffectsUnmount = [];
+var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates
+
+var NESTED_UPDATE_LIMIT = 50;
+var nestedUpdateCount = 0;
+var rootWithNestedUpdates = null;
+var NESTED_PASSIVE_UPDATE_LIMIT = 50;
+var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes
+// during the commit phase. This enables them to be traced across components
+// that spawn new work during render. E.g. hidden boundaries, suspended SSR
+// hydration or SuspenseList.
+// TODO: Can use a bitmask instead of an array
+
+var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their
+// event times as simultaneous, even if the actual clock time has advanced
+// between the first and second call.
 
-    case IncompleteClassComponent: {
-      return;
-    }
-  }
+var currentEventTime = NoTimestamp;
+var currentEventWipLanes = NoLanes;
+var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.
+// We warn about state updates for unmounted components differently in this case.
 
-  {
-    throw Error(
-      "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
-    );
-  }
+var isFlushingPassiveEffects = false;
+var focusedInstanceHandle = null;
+var shouldFireAfterActiveInstanceBlur = false;
+function getWorkInProgressRoot() {
+  return workInProgressRoot;
 }
+function requestEventTime() {
+  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
+    // We're inside React, so it's fine to read the actual time.
+    return now();
+  } // We're not inside React, so we may be in the middle of a browser event.
 
-function commitSuspenseComponent(finishedWork) {
-  var newState = finishedWork.memoizedState;
-  var newDidTimeout;
-  var primaryChildParent = finishedWork;
-
-  if (newState === null) {
-    newDidTimeout = false;
-  } else {
-    newDidTimeout = true;
-    primaryChildParent = finishedWork.child;
-    markCommitTimeOfFallback();
-  }
+  if (currentEventTime !== NoTimestamp) {
+    // Use the same start time for all updates until we enter React again.
+    return currentEventTime;
+  } // This is the first update since React yielded. Compute a new start time.
 
-  if (primaryChildParent !== null) {
-    hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
-  }
+  currentEventTime = now();
+  return currentEventTime;
 }
+function requestUpdateLane(fiber) {
+  // Special cases
+  var mode = fiber.mode;
 
-function attachSuspenseRetryListeners(finishedWork) {
-  // If this boundary just timed out, then it will have a set of thenables.
-  // For each thenable, attach a listener so that when it resolves, React
-  // attempts to re-render the boundary in the primary (pre-timeout) state.
-  var thenables = finishedWork.updateQueue;
+  if ((mode & BlockingMode) === NoMode) {
+    return SyncLane;
+  } else if ((mode & ConcurrentMode) === NoMode) {
+    return getCurrentPriorityLevel() === ImmediatePriority$1
+      ? SyncLane
+      : SyncBatchedLane;
+  } // The algorithm for assigning an update to a lane should be stable for all
+  // updates at the same priority within the same event. To do this, the inputs
+  // to the algorithm must be the same. For example, we use the `renderLanes`
+  // to avoid choosing a lane that is already in the middle of rendering.
+  //
+  // However, the "included" lanes could be mutated in between updates in the
+  // same event, like if you perform an update inside `flushSync`. Or any other
+  // code path that might call `prepareFreshStack`.
+  //
+  // The trick we use is to cache the first of each of these inputs within an
+  // event. Then reset the cached values once we can be sure the event is over.
+  // Our heuristic for that is whenever we enter a concurrent work loop.
+  //
+  // We'll do the same for `currentEventPendingLanes` below.
 
-  if (thenables !== null) {
-    finishedWork.updateQueue = null;
-    var retryCache = finishedWork.stateNode;
+  if (currentEventWipLanes === NoLanes) {
+    currentEventWipLanes = workInProgressRootIncludedLanes;
+  }
 
-    if (retryCache === null) {
-      retryCache = finishedWork.stateNode = new PossiblyWeakSet();
+  var isTransition = requestCurrentTransition() !== NoTransition;
+
+  if (isTransition) {
+    if (currentEventPendingLanes !== NoLanes) {
+      currentEventPendingLanes =
+        mostRecentlyUpdatedRoot !== null
+          ? mostRecentlyUpdatedRoot.pendingLanes
+          : NoLanes;
     }
 
-    thenables.forEach(function(thenable) {
-      // Memoize using the boundary fiber to prevent redundant listeners.
-      var retry = resolveRetryThenable.bind(null, finishedWork, thenable);
+    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
+  } // TODO: Remove this dependency on the Scheduler priority.
+  // To do that, we're replacing it with an update lane priority.
 
-      if (!retryCache.has(thenable)) {
-        {
-          if (thenable.__reactDoNotTraceInteractions !== true) {
-            retry = tracing.unstable_wrap(retry);
-          }
-        }
+  var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.
+  // This couples React to the Scheduler internals, so we're replacing it
+  // with the currentUpdateLanePriority above. As an example of how this
+  // could be problematic, if we're not inside `Scheduler.runWithPriority`,
+  // then we'll get the priority of the current running Scheduler task,
+  // which is probably not what we want.
 
-        retryCache.add(thenable);
-        thenable.then(retry, retry);
-      }
-    });
-  }
-}
+  var lane;
 
-function commitResetTextContent(current) {
-  resetTextContent(current.stateNode);
-}
+  if (
+    // TODO: Temporary. We're removing the concept of discrete updates.
+    (executionContext & DiscreteEventContext) !== NoContext &&
+    schedulerPriority === UserBlockingPriority$1
+  ) {
+    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
+  } else {
+    var schedulerLanePriority = schedulerPriorityToLanePriority(
+      schedulerPriority
+    );
 
-var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
+    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
+  }
 
-function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
-  var update = createUpdate(expirationTime, null); // Unmount the root by rendering null.
+  return lane;
+}
 
-  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
-  // being called "element".
+function requestRetryLane(fiber) {
+  // This is a fork of `requestUpdateLane` designed specifically for Suspense
+  // "retries"  a special update that attempts to flip a Suspense boundary
+  // from its placeholder state to its primary/resolved state.
+  // Special cases
+  var mode = fiber.mode;
 
-  update.payload = {
-    element: null
-  };
-  var error = errorInfo.value;
+  if ((mode & BlockingMode) === NoMode) {
+    return SyncLane;
+  } else if ((mode & ConcurrentMode) === NoMode) {
+    return getCurrentPriorityLevel() === ImmediatePriority$1
+      ? SyncLane
+      : SyncBatchedLane;
+  } // See `requestUpdateLane` for explanation of `currentEventWipLanes`
 
-  update.callback = function() {
-    onUncaughtError(error);
-    logError(fiber, errorInfo);
-  };
+  if (currentEventWipLanes === NoLanes) {
+    currentEventWipLanes = workInProgressRootIncludedLanes;
+  }
 
-  return update;
+  return findRetryLane(currentEventWipLanes);
 }
 
-function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
-  var update = createUpdate(expirationTime, null);
-  update.tag = CaptureUpdate;
-  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+function scheduleUpdateOnFiber(fiber, lane, eventTime) {
+  checkForNestedUpdates();
+  warnAboutRenderPhaseUpdatesInDEV(fiber);
+  var root = markUpdateLaneFromFiberToRoot(fiber, lane);
 
-  if (typeof getDerivedStateFromError === "function") {
-    var error$1 = errorInfo.value;
+  if (root === null) {
+    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
+    return null;
+  } // Mark that the root has a pending update.
 
-    update.payload = function() {
-      logError(fiber, errorInfo);
-      return getDerivedStateFromError(error$1);
-    };
-  }
+  markRootUpdated(root, lane, eventTime);
 
-  var inst = fiber.stateNode;
+  if (root === workInProgressRoot) {
+    // Received an update to a tree that's in the middle of rendering. Mark
+    // that there was an interleaved update work on this root. Unless the
+    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
+    // phase update. In that case, we don't treat render phase updates as if
+    // they were interleaved, for backwards compat reasons.
+    {
+      workInProgressRootUpdatedLanes = mergeLanes(
+        workInProgressRootUpdatedLanes,
+        lane
+      );
+    }
 
-  if (inst !== null && typeof inst.componentDidCatch === "function") {
-    update.callback = function callback() {
-      {
-        markFailedErrorBoundaryForHotReloading(fiber);
-      }
+    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
+      // The root already suspended with a delay, which means this render
+      // definitely won't finish. Since we have a new update, let's mark it as
+      // suspended now, right before marking the incoming update. This has the
+      // effect of interrupting the current render and switching to the update.
+      // TODO: Make sure this doesn't override pings that happen while we've
+      // already started rendering.
+      markRootSuspended$1(root, workInProgressRootRenderLanes);
+    }
+  } // TODO: requestUpdateLanePriority also reads the priority. Pass the
+  // priority as an argument to that function and this one.
 
-      if (typeof getDerivedStateFromError !== "function") {
-        // To preserve the preexisting retry behavior of error boundaries,
-        // we keep track of which ones already failed during this batch.
-        // This gets reset before we yield back to the browser.
-        // TODO: Warn in strict mode if getDerivedStateFromError is
-        // not defined.
-        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined
+  var priorityLevel = getCurrentPriorityLevel();
 
-        logError(fiber, errorInfo);
-      }
+  if (lane === SyncLane) {
+    if (
+      // Check if we're inside unbatchedUpdates
+      (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering
+      (executionContext & (RenderContext | CommitContext)) === NoContext
+    ) {
+      // Register pending interactions on the root to avoid losing traced interaction data.
+      schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
+      // root inside of batchedUpdates should be synchronous, but layout updates
+      // should be deferred until the end of the batch.
 
-      var error$1 = errorInfo.value;
-      var stack = errorInfo.stack;
-      this.componentDidCatch(error$1, {
-        componentStack: stack !== null ? stack : ""
-      });
+      performSyncWorkOnRoot(root);
+    } else {
+      ensureRootIsScheduled(root, eventTime);
+      schedulePendingInteractions(root, lane);
 
-      {
-        if (typeof getDerivedStateFromError !== "function") {
-          // If componentDidCatch is the only error boundary method defined,
-          // then it needs to call setState to recover from errors.
-          // If no state update is scheduled then the boundary will swallow the error.
-          if (fiber.expirationTime !== Sync) {
-            error(
-              "%s: Error boundaries should implement getDerivedStateFromError(). " +
-                "In that method, return a state update to display an error message or fallback UI.",
-              getComponentName(fiber.type) || "Unknown"
-            );
-          }
-        }
+      if (executionContext === NoContext) {
+        // Flush the synchronous work now, unless we're already working or inside
+        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
+        // scheduleCallbackForFiber to preserve the ability to schedule a callback
+        // without immediately flushing it. We only do this for user-initiated
+        // updates, to preserve historical behavior of legacy mode.
+        resetRenderTimer();
+        flushSyncCallbackQueue();
       }
-    };
+    }
   } else {
-    update.callback = function() {
-      markFailedErrorBoundaryForHotReloading(fiber);
-    };
+    // Schedule a discrete update but only if it's not Sync.
+    if (
+      (executionContext & DiscreteEventContext) !== NoContext && // Only updates at user-blocking priority or greater are considered
+      // discrete, even inside a discrete event.
+      (priorityLevel === UserBlockingPriority$1 ||
+        priorityLevel === ImmediatePriority$1)
+    ) {
+      // This is the result of a discrete event. Track the lowest priority
+      // discrete update per root so we can flush them early, if needed.
+      if (rootsWithPendingDiscreteUpdates === null) {
+        rootsWithPendingDiscreteUpdates = new Set([root]);
+      } else {
+        rootsWithPendingDiscreteUpdates.add(root);
+      }
+    } // Schedule other updates after in case the callback is sync.
+
+    ensureRootIsScheduled(root, eventTime);
+    schedulePendingInteractions(root, lane);
+  } // We use this when assigning a lane for a transition inside
+  // `requestUpdateLane`. We assume it's the same as the root being updated,
+  // since in the common case of a single root app it probably is. If it's not
+  // the same root, then it's not a huge deal, we just might batch more stuff
+  // together more than necessary.
+
+  mostRecentlyUpdatedRoot = root;
+} // This is split into a separate function so we can mark a fiber with pending
+// work without treating it as a typical update that originates from an event;
+// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
+// on a fiber.
+
+function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
+  // Update the source fiber's lanes
+  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
+  var alternate = sourceFiber.alternate;
+
+  if (alternate !== null) {
+    alternate.lanes = mergeLanes(alternate.lanes, lane);
   }
 
-  return update;
-}
+  {
+    if (
+      alternate === null &&
+      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags
+    ) {
+      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
+    }
+  } // Walk the parent path to the root and update the child expiration time.
 
-function attachPingListener(root, renderExpirationTime, thenable) {
-  // Attach a listener to the promise to "ping" the root and retry. But
-  // only if one does not already exist for the current render expiration
-  // time (which acts like a "thread ID" here).
-  var pingCache = root.pingCache;
-  var threadIDs;
+  var node = sourceFiber;
+  var parent = sourceFiber.return;
 
-  if (pingCache === null) {
-    pingCache = root.pingCache = new PossiblyWeakMap();
-    threadIDs = new Set();
-    pingCache.set(thenable, threadIDs);
-  } else {
-    threadIDs = pingCache.get(thenable);
+  while (parent !== null) {
+    parent.childLanes = mergeLanes(parent.childLanes, lane);
+    alternate = parent.alternate;
 
-    if (threadIDs === undefined) {
-      threadIDs = new Set();
-      pingCache.set(thenable, threadIDs);
+    if (alternate !== null) {
+      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
+    } else {
+      {
+        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
+          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
+        }
+      }
     }
+
+    node = parent;
+    parent = parent.return;
   }
 
-  if (!threadIDs.has(renderExpirationTime)) {
-    // Memoize using the thread ID to prevent redundant listeners.
-    threadIDs.add(renderExpirationTime);
-    var ping = pingSuspendedRoot.bind(
-      null,
-      root,
-      thenable,
-      renderExpirationTime
-    );
-    thenable.then(ping, ping);
+  if (node.tag === HostRoot) {
+    var root = node.stateNode;
+    return root;
+  } else {
+    return null;
   }
-}
+} // Use this function to schedule a task for a root. There's only one task per
+// root; if a task was already scheduled, we'll check to make sure the priority
+// of the existing task is the same as the priority of the next level that the
+// root has work on. This function is called on every update, and right before
+// exiting a task.
 
-function throwException(
-  root,
-  returnFiber,
-  sourceFiber,
-  value,
-  renderExpirationTime
-) {
-  // The source fiber did not complete.
-  sourceFiber.effectTag |= Incomplete; // Its effect list is no longer valid.
+function ensureRootIsScheduled(root, currentTime) {
+  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
+  // expired so we know to work on those next.
 
-  sourceFiber.firstEffect = sourceFiber.lastEffect = null;
+  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.
 
-  if (
-    value !== null &&
-    typeof value === "object" &&
-    typeof value.then === "function"
-  ) {
-    // This is a thenable.
-    var thenable = value;
+  var nextLanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes
+  ); // This returns the priority level computed during the `getNextLanes` call.
 
-    if ((sourceFiber.mode & BlockingMode) === NoMode) {
-      // Reset the memoizedState to what it was before we attempted
-      // to render it.
-      var currentSource = sourceFiber.alternate;
+  var newCallbackPriority = returnNextLanesPriority();
 
-      if (currentSource) {
-        sourceFiber.updateQueue = currentSource.updateQueue;
-        sourceFiber.memoizedState = currentSource.memoizedState;
-        sourceFiber.expirationTime = currentSource.expirationTime;
-      } else {
-        sourceFiber.updateQueue = null;
-        sourceFiber.memoizedState = null;
-      }
+  if (nextLanes === NoLanes) {
+    // Special case: There's nothing to work on.
+    if (existingCallbackNode !== null) {
+      cancelCallback(existingCallbackNode);
+      root.callbackNode = null;
+      root.callbackPriority = NoLanePriority;
     }
 
-    var hasInvisibleParentBoundary = hasSuspenseContext(
-      suspenseStackCursor.current,
-      InvisibleParentSuspenseContext
-    ); // Schedule the nearest Suspense to re-render the timed out view.
-
-    var _workInProgress = returnFiber;
+    return;
+  } // Check if there's an existing task. We may be able to reuse it.
 
-    do {
-      if (
-        _workInProgress.tag === SuspenseComponent &&
-        shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)
-      ) {
-        // Found the nearest boundary.
-        // Stash the promise on the boundary fiber. If the boundary times out, we'll
-        // attach another listener to flip the boundary back to its normal state.
-        var thenables = _workInProgress.updateQueue;
+  if (existingCallbackNode !== null) {
+    var existingCallbackPriority = root.callbackPriority;
 
-        if (thenables === null) {
-          var updateQueue = new Set();
-          updateQueue.add(thenable);
-          _workInProgress.updateQueue = updateQueue;
-        } else {
-          thenables.add(thenable);
-        } // If the boundary is outside of blocking mode, we should *not*
-        // suspend the commit. Pretend as if the suspended component rendered
-        // null and keep rendering. In the commit phase, we'll schedule a
-        // subsequent synchronous update to re-render the Suspense.
-        //
-        // Note: It doesn't matter whether the component that suspended was
-        // inside a blocking mode tree. If the Suspense is outside of it, we
-        // should *not* suspend the commit.
+    if (existingCallbackPriority === newCallbackPriority) {
+      // The priority hasn't changed. We can reuse the existing task. Exit.
+      return;
+    } // The priority changed. Cancel the existing callback. We'll schedule a new
+    // one below.
 
-        if ((_workInProgress.mode & BlockingMode) === NoMode) {
-          _workInProgress.effectTag |= DidCapture; // We're going to commit this fiber even though it didn't complete.
-          // But we shouldn't call any lifecycle methods or callbacks. Remove
-          // all lifecycle effect tags.
+    cancelCallback(existingCallbackNode);
+  } // Schedule a new callback.
 
-          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
+  var newCallbackNode;
 
-          if (sourceFiber.tag === ClassComponent) {
-            var currentSourceFiber = sourceFiber.alternate;
+  if (newCallbackPriority === SyncLanePriority) {
+    // Special case: Sync React callbacks are scheduled on a special
+    // internal queue
+    newCallbackNode = scheduleSyncCallback(
+      performSyncWorkOnRoot.bind(null, root)
+    );
+  } else if (newCallbackPriority === SyncBatchedLanePriority) {
+    newCallbackNode = scheduleCallback(
+      ImmediatePriority$1,
+      performSyncWorkOnRoot.bind(null, root)
+    );
+  } else {
+    var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
+      newCallbackPriority
+    );
+    newCallbackNode = scheduleCallback(
+      schedulerPriorityLevel,
+      performConcurrentWorkOnRoot.bind(null, root)
+    );
+  }
 
-            if (currentSourceFiber === null) {
-              // This is a new mount. Change the tag so it's not mistaken for a
-              // completed class component. For example, we should not call
-              // componentWillUnmount if it is deleted.
-              sourceFiber.tag = IncompleteClassComponent;
-            } else {
-              // When we try rendering again, we should not reuse the current fiber,
-              // since it's known to be in an inconsistent state. Use a force update to
-              // prevent a bail out.
-              var update = createUpdate(Sync, null);
-              update.tag = ForceUpdate;
-              enqueueUpdate(sourceFiber, update);
-            }
-          } // The source fiber did not complete. Mark it with Sync priority to
-          // indicate that it still has pending work.
+  root.callbackPriority = newCallbackPriority;
+  root.callbackNode = newCallbackNode;
+} // This is the entry point for every concurrent task, i.e. anything that
+// goes through Scheduler.
 
-          sourceFiber.expirationTime = Sync; // Exit without suspending.
+function performConcurrentWorkOnRoot(root) {
+  // Since we know we're in a React event, we can clear the current
+  // event time. The next update will compute a new event time.
+  currentEventTime = NoTimestamp;
+  currentEventWipLanes = NoLanes;
+  currentEventPendingLanes = NoLanes;
 
-          return;
-        } // Confirmed that the boundary is in a concurrent mode tree. Continue
-        // with the normal suspend path.
-        //
-        // After this we'll use a set of heuristics to determine whether this
-        // render pass will run to completion or restart or "suspend" the commit.
-        // The actual logic for this is spread out in different places.
-        //
-        // This first principle is that if we're going to suspend when we complete
-        // a root, then we should also restart if we get an update or ping that
-        // might unsuspend it, and vice versa. The only reason to suspend is
-        // because you think you might want to restart before committing. However,
-        // it doesn't make sense to restart only while in the period we're suspended.
-        //
-        // Restarting too aggressively is also not good because it starves out any
-        // intermediate loading state. So we use heuristics to determine when.
-        // Suspense Heuristics
-        //
-        // If nothing threw a Promise or all the same fallbacks are already showing,
-        // then don't suspend/restart.
-        //
-        // If this is an initial render of a new tree of Suspense boundaries and
-        // those trigger a fallback, then don't suspend/restart. We want to ensure
-        // that we can show the initial loading state as quickly as possible.
-        //
-        // If we hit a "Delayed" case, such as when we'd switch from content back into
-        // a fallback, then we should always suspend/restart. SuspenseConfig applies to
-        // this case. If none is defined, JND is used instead.
-        //
-        // If we're already showing a fallback and it gets "retried", allowing us to show
-        // another level, but there's still an inner boundary that would show a fallback,
-        // then we suspend/restart for 500ms since the last time we showed a fallback
-        // anywhere in the tree. This effectively throttles progressive loading into a
-        // consistent train of commits. This also gives us an opportunity to restart to
-        // get to the completed state slightly earlier.
-        //
-        // If there's ambiguity due to batching it's resolved in preference of:
-        // 1) "delayed", 2) "initial render", 3) "retry".
-        //
-        // We want to ensure that a "busy" state doesn't get force committed. We want to
-        // ensure that new initial loading states can commit as soon as possible.
+  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
+    throw Error("Should not already be working.");
+  } // Flush any pending passive effects before deciding which lanes to work on,
+  // in case they schedule additional work.
 
-        attachPingListener(root, renderExpirationTime, thenable);
-        _workInProgress.effectTag |= ShouldCapture;
-        _workInProgress.expirationTime = renderExpirationTime;
-        return;
-      } // This boundary already captured during this render. Continue to the next
-      // boundary.
+  var originalCallbackNode = root.callbackNode;
+  var didFlushPassiveEffects = flushPassiveEffects();
+
+  if (didFlushPassiveEffects) {
+    // Something in the passive effect phase may have canceled the current task.
+    // Check if the task node for this root was changed.
+    if (root.callbackNode !== originalCallbackNode) {
+      // The current task was canceled. Exit. We don't need to call
+      // `ensureRootIsScheduled` because the check above implies either that
+      // there's a new task, or that there's no remaining work on this root.
+      return null;
+    }
+  } // Determine the next expiration time to work on, using the fields stored
+  // on the root.
 
-      _workInProgress = _workInProgress.return;
-    } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.
-    // TODO: Use invariant so the message is stripped in prod?
+  var lanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes
+  );
 
-    value = new Error(
-      (getComponentName(sourceFiber.type) || "A React component") +
-        " suspended while rendering, but no fallback UI was specified.\n" +
-        "\n" +
-        "Add a <Suspense fallback=...> component higher in the tree to " +
-        "provide a loading indicator or placeholder to display." +
-        getStackByFiberInDevAndProd(sourceFiber)
-    );
-  } // We didn't find a boundary that could handle this type of exception. Start
-  // over and traverse parent path again, this time treating the exception
-  // as an error.
+  if (lanes === NoLanes) {
+    // Defensive coding. This is never expected to happen.
+    return null;
+  }
 
-  renderDidError();
-  value = createCapturedValue(value, sourceFiber);
-  var workInProgress = returnFiber;
+  var exitStatus = renderRootConcurrent(root, lanes);
 
-  do {
-    switch (workInProgress.tag) {
-      case HostRoot: {
-        var _errorInfo = value;
-        workInProgress.effectTag |= ShouldCapture;
-        workInProgress.expirationTime = renderExpirationTime;
+  if (
+    includesSomeLane(
+      workInProgressRootIncludedLanes,
+      workInProgressRootUpdatedLanes
+    )
+  ) {
+    // The render included lanes that were updated during the render phase.
+    // For example, when unhiding a hidden tree, we include all the lanes
+    // that were previously skipped when the tree was hidden. That set of
+    // lanes is a superset of the lanes we started rendering with.
+    //
+    // So we'll throw out the current work and restart.
+    prepareFreshStack(root, NoLanes);
+  } else if (exitStatus !== RootIncomplete) {
+    if (exitStatus === RootErrored) {
+      executionContext |= RetryAfterError; // If an error occurred during hydration,
+      // discard server response and fall back to client side render.
 
-        var _update = createRootErrorUpdate(
-          workInProgress,
-          _errorInfo,
-          renderExpirationTime
-        );
+      if (root.hydrate) {
+        root.hydrate = false;
+        clearContainer(root.containerInfo);
+      } // If something threw an error, try rendering one more time. We'll render
+      // synchronously to block concurrent data mutations, and we'll includes
+      // all pending updates are included. If it still fails after the second
+      // attempt, we'll give up and commit the resulting tree.
 
-        enqueueCapturedUpdate(workInProgress, _update);
-        return;
+      lanes = getLanesToRetrySynchronouslyOnError(root);
+
+      if (lanes !== NoLanes) {
+        exitStatus = renderRootSync(root, lanes);
       }
+    }
 
-      case ClassComponent:
-        // Capture and retry
-        var errorInfo = value;
-        var ctor = workInProgress.type;
-        var instance = workInProgress.stateNode;
+    if (exitStatus === RootFatalErrored) {
+      var fatalError = workInProgressRootFatalError;
+      prepareFreshStack(root, NoLanes);
+      markRootSuspended$1(root, lanes);
+      ensureRootIsScheduled(root, now());
+      throw fatalError;
+    } // We now have a consistent tree. The next step is either to commit it,
+    // or, if something suspended, wait to commit it after a timeout.
 
-        if (
-          (workInProgress.effectTag & DidCapture) === NoEffect &&
-          (typeof ctor.getDerivedStateFromError === "function" ||
-            (instance !== null &&
-              typeof instance.componentDidCatch === "function" &&
-              !isAlreadyFailedLegacyErrorBoundary(instance)))
-        ) {
-          workInProgress.effectTag |= ShouldCapture;
-          workInProgress.expirationTime = renderExpirationTime; // Schedule the error boundary to re-render using updated state
+    var finishedWork = root.current.alternate;
+    root.finishedWork = finishedWork;
+    root.finishedLanes = lanes;
+    finishConcurrentRender(root, exitStatus, lanes);
+  }
 
-          var _update2 = createClassErrorUpdate(
-            workInProgress,
-            errorInfo,
-            renderExpirationTime
-          );
+  ensureRootIsScheduled(root, now());
 
-          enqueueCapturedUpdate(workInProgress, _update2);
-          return;
-        }
+  if (root.callbackNode === originalCallbackNode) {
+    // The task node scheduled for this root is the same one that's
+    // currently executed. Need to return a continuation.
+    return performConcurrentWorkOnRoot.bind(null, root);
+  }
 
-        break;
+  return null;
+}
+
+function finishConcurrentRender(root, exitStatus, lanes) {
+  switch (exitStatus) {
+    case RootIncomplete:
+    case RootFatalErrored: {
+      {
+        throw Error("Root did not complete. This is a bug in React.");
+      }
     }
+    // Flow knows about invariant, so it complains if I add a break
+    // statement, but eslint doesn't know about invariant, so it complains
+    // if I do. eslint-disable-next-line no-fallthrough
 
-    workInProgress = workInProgress.return;
-  } while (workInProgress !== null);
-}
+    case RootErrored: {
+      // We should have already attempted to retry this tree. If we reached
+      // this point, it errored again. Commit it.
+      commitRoot(root);
+      break;
+    }
 
-var ceil = Math.ceil;
-var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
-  ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
-  IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
-var NoContext =
-  /*                    */
-  0;
-var BatchedContext =
-  /*               */
-  1;
-var DiscreteEventContext =
-  /*         */
-  4;
-var LegacyUnbatchedContext =
-  /*       */
-  8;
-var RenderContext =
-  /*                */
-  16;
-var CommitContext =
-  /*                */
-  32;
-var RootIncomplete = 0;
-var RootFatalErrored = 1;
-var RootErrored = 2;
-var RootSuspended = 3;
-var RootSuspendedWithDelay = 4;
-var RootCompleted = 5;
-// Describes where we are in the React execution stack
-var executionContext = NoContext; // The root we're working on
+    case RootSuspended: {
+      markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we
+      // should immediately commit it or wait a bit.
 
-var workInProgressRoot = null; // The fiber we're working on
+      if (
+        includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
+        !shouldForceFlushFallbacksInDEV()
+      ) {
+        // This render only included retries, no updates. Throttle committing
+        // retries so that we don't show too many loading states too quickly.
+        var msUntilTimeout =
+          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.
 
-var workInProgress = null; // The expiration time we're rendering
+        if (msUntilTimeout > 10) {
+          var nextLanes = getNextLanes(root, NoLanes);
 
-var renderExpirationTime$1 = NoWork; // Whether to root completed, errored, suspended, etc.
+          if (nextLanes !== NoLanes) {
+            // There's additional work on this root.
+            break;
+          }
 
-var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown
+          var suspendedLanes = root.suspendedLanes;
 
-var workInProgressRootFatalError = null; // Most recent event time among processed updates during this render.
-// This is conceptually a time stamp but expressed in terms of an ExpirationTime
-// because we deal mostly with expiration times in the hot path, so this avoids
-// the conversion happening in the hot path.
+          if (!isSubsetOfLanes(suspendedLanes, lanes)) {
+            // We should prefer to render the fallback of at the last
+            // suspended level. Ping the last suspended level to try
+            // rendering it again.
+            // FIXME: What if the suspended lanes are Idle? Should not restart.
+            var eventTime = requestEventTime();
+            markRootPinged(root, suspendedLanes);
+            break;
+          } // The render is suspended, it hasn't timed out, and there's no
+          // lower priority work to do. Instead of committing the fallback
+          // immediately, wait for more data to arrive.
 
-var workInProgressRootLatestProcessedExpirationTime = Sync;
-var workInProgressRootLatestSuspenseTimeout = Sync;
-var workInProgressRootCanSuspendUsingConfig = null; // The work left over by components that were visited during this render. Only
-// includes unprocessed updates, not work in bailed out children.
+          root.timeoutHandle = scheduleTimeout(
+            commitRoot.bind(null, root),
+            msUntilTimeout
+          );
+          break;
+        }
+      } // The work expired. Commit immediately.
 
-var workInProgressRootNextUnprocessedUpdateTime = NoWork; // If we're pinged while rendering we don't always restart immediately.
-// This flag determines if it might be worthwhile to restart if an opportunity
-// happens latere.
+      commitRoot(root);
+      break;
+    }
 
-var workInProgressRootHasPendingPing = false; // The most recent time we committed a fallback. This lets us ensure a train
-// model where we don't commit new loading states in too quick succession.
+    case RootSuspendedWithDelay: {
+      markRootSuspended$1(root, lanes);
 
-var globalMostRecentFallbackTime = 0;
-var FALLBACK_THROTTLE_MS = 500;
-var nextEffect = null;
-var hasUncaughtError = false;
-var firstUncaughtError = null;
-var legacyErrorBoundariesThatAlreadyFailed = null;
-var rootDoesHavePassiveEffects = false;
-var rootWithPendingPassiveEffects = null;
-var pendingPassiveEffectsRenderPriority = NoPriority;
-var pendingPassiveEffectsExpirationTime = NoWork;
-var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates
+      if (includesOnlyTransitions(lanes)) {
+        // This is a transition, so we should exit without committing a
+        // placeholder and without scheduling a timeout. Delay indefinitely
+        // until we receive more data.
+        break;
+      }
 
-var NESTED_UPDATE_LIMIT = 50;
-var nestedUpdateCount = 0;
-var rootWithNestedUpdates = null;
-var NESTED_PASSIVE_UPDATE_LIMIT = 50;
-var nestedPassiveUpdateCount = 0;
-var interruptedBy = null; // Marks the need to reschedule pending interactions at these expiration times
-// during the commit phase. This enables them to be traced across components
-// that spawn new work during render. E.g. hidden boundaries, suspended SSR
-// hydration or SuspenseList.
+      if (!shouldForceFlushFallbacksInDEV()) {
+        // This is not a transition, but we did trigger an avoided state.
+        // Schedule a placeholder to display after a short delay, using the Just
+        // Noticeable Difference.
+        // TODO: Is the JND optimization worth the added complexity? If this is
+        // the only reason we track the event time, then probably not.
+        // Consider removing.
+        var mostRecentEventTime = getMostRecentEventTime(root, lanes);
+        var eventTimeMs = mostRecentEventTime;
+        var timeElapsedMs = now() - eventTimeMs;
 
-var spawnedWorkDuringRender = null; // Expiration times are computed by adding to the current time (the start
-// time). However, if two updates are scheduled within the same event, we
-// should treat their start times as simultaneous, even if the actual clock
-// time has advanced between the first and second call.
-// In other words, because expiration times determine how updates are batched,
-// we want all updates of like priority that occur within the same event to
-// receive the same expiration time. Otherwise we get tearing.
+        var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.
 
-var currentEventTime = NoWork;
-function requestCurrentTimeForUpdate() {
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
-    // We're inside React, so it's fine to read the actual time.
-    return msToExpirationTime(now());
-  } // We're not inside React, so we may be in the middle of a browser event.
+        if (_msUntilTimeout > 10) {
+          // Instead of committing the fallback immediately, wait for more data
+          // to arrive.
+          root.timeoutHandle = scheduleTimeout(
+            commitRoot.bind(null, root),
+            _msUntilTimeout
+          );
+          break;
+        }
+      } // Commit the placeholder.
 
-  if (currentEventTime !== NoWork) {
-    // Use the same start time for all updates until we enter React again.
-    return currentEventTime;
-  } // This is the first update since React yielded. Compute a new start time.
+      commitRoot(root);
+      break;
+    }
 
-  currentEventTime = msToExpirationTime(now());
-  return currentEventTime;
-}
-function getCurrentTime() {
-  return msToExpirationTime(now());
-}
-function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {
-  var mode = fiber.mode;
+    case RootCompleted: {
+      // The work completed. Ready to commit.
+      commitRoot(root);
+      break;
+    }
 
-  if ((mode & BlockingMode) === NoMode) {
-    return Sync;
+    default: {
+      {
+        throw Error("Unknown root exit status.");
+      }
+    }
   }
+}
 
-  var priorityLevel = getCurrentPriorityLevel();
+function markRootSuspended$1(root, suspendedLanes) {
+  // When suspending, we should always exclude lanes that were pinged or (more
+  // rarely, since we try to avoid it) updated during the render phase.
+  // TODO: Lol maybe there's a better way to factor this besides this
+  // obnoxiously named function :)
+  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
+  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
+  markRootSuspended(root, suspendedLanes);
+} // This is the entry point for synchronous tasks that don't go
+// through Scheduler
 
-  if ((mode & ConcurrentMode) === NoMode) {
-    return priorityLevel === ImmediatePriority ? Sync : Batched;
+function performSyncWorkOnRoot(root) {
+  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
+    throw Error("Should not already be working.");
   }
 
-  if ((executionContext & RenderContext) !== NoContext) {
-    // Use whatever time we're already rendering
-    // TODO: Should there be a way to opt out, like with `runWithPriority`?
-    return renderExpirationTime$1;
-  }
+  flushPassiveEffects();
+  var lanes;
+  var exitStatus;
 
-  var expirationTime;
+  if (
+    root === workInProgressRoot &&
+    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)
+  ) {
+    // There's a partial tree, and at least one of its lanes has expired. Finish
+    // rendering it before rendering the rest of the expired work.
+    lanes = workInProgressRootRenderLanes;
+    exitStatus = renderRootSync(root, lanes);
 
-  if (suspenseConfig !== null) {
-    // Compute an expiration time based on the Suspense timeout.
-    expirationTime = computeSuspenseExpiration(
-      currentTime,
-      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION
-    );
+    if (
+      includesSomeLane(
+        workInProgressRootIncludedLanes,
+        workInProgressRootUpdatedLanes
+      )
+    ) {
+      // The render included lanes that were updated during the render phase.
+      // For example, when unhiding a hidden tree, we include all the lanes
+      // that were previously skipped when the tree was hidden. That set of
+      // lanes is a superset of the lanes we started rendering with.
+      //
+      // Note that this only happens when part of the tree is rendered
+      // concurrently. If the whole tree is rendered synchronously, then there
+      // are no interleaved events.
+      lanes = getNextLanes(root, lanes);
+      exitStatus = renderRootSync(root, lanes);
+    }
   } else {
-    // Compute an expiration time based on the Scheduler priority.
-    switch (priorityLevel) {
-      case ImmediatePriority:
-        expirationTime = Sync;
-        break;
+    lanes = getNextLanes(root, NoLanes);
+    exitStatus = renderRootSync(root, lanes);
+  }
 
-      case UserBlockingPriority:
-        // TODO: Rename this to computeUserBlockingExpiration
-        expirationTime = computeInteractiveExpiration(currentTime);
-        break;
+  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
+    executionContext |= RetryAfterError; // If an error occurred during hydration,
+    // discard server response and fall back to client side render.
 
-      case NormalPriority:
-      case LowPriority:
-        // TODO: Handle LowPriority
-        // TODO: Rename this to... something better.
-        expirationTime = computeAsyncExpiration(currentTime);
-        break;
+    if (root.hydrate) {
+      root.hydrate = false;
+      clearContainer(root.containerInfo);
+    } // If something threw an error, try rendering one more time. We'll render
+    // synchronously to block concurrent data mutations, and we'll includes
+    // all pending updates are included. If it still fails after the second
+    // attempt, we'll give up and commit the resulting tree.
 
-      case IdlePriority:
-        expirationTime = Idle;
-        break;
+    lanes = getLanesToRetrySynchronouslyOnError(root);
 
-      default: {
-        throw Error("Expected a valid priority level");
-      }
+    if (lanes !== NoLanes) {
+      exitStatus = renderRootSync(root, lanes);
     }
-  } // If we're in the middle of rendering a tree, do not update at the same
-  // expiration time that is already rendering.
-  // TODO: We shouldn't have to do this if the update is on a different root.
-  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to
-  // the root when we check for this condition.
-
-  if (
-    workInProgressRoot !== null &&
-    expirationTime === renderExpirationTime$1
-  ) {
-    // This is a trick to move this update into a separate batch
-    expirationTime -= 1;
   }
 
-  return expirationTime;
-}
-function scheduleUpdateOnFiber(fiber, expirationTime) {
-  checkForNestedUpdates();
-  warnAboutRenderPhaseUpdatesInDEV(fiber);
-  var root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
-
-  if (root === null) {
-    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
-    return;
-  }
+  if (exitStatus === RootFatalErrored) {
+    var fatalError = workInProgressRootFatalError;
+    prepareFreshStack(root, NoLanes);
+    markRootSuspended$1(root, lanes);
+    ensureRootIsScheduled(root, now());
+    throw fatalError;
+  } // We now have a consistent tree. Because this is a sync render, we
+  // will commit it even if something suspended.
 
-  checkForInterruption(fiber, expirationTime);
-  recordScheduleUpdate(); // TODO: computeExpirationForFiber also reads the priority. Pass the
-  // priority as an argument to that function and this one.
+  var finishedWork = root.current.alternate;
+  root.finishedWork = finishedWork;
+  root.finishedLanes = lanes;
+  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
+  // pending level.
 
-  var priorityLevel = getCurrentPriorityLevel();
+  ensureRootIsScheduled(root, now());
+  return null;
+}
 
-  if (expirationTime === Sync) {
-    if (
-      // Check if we're inside unbatchedUpdates
-      (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering
-      (executionContext & (RenderContext | CommitContext)) === NoContext
-    ) {
-      // Register pending interactions on the root to avoid losing traced interaction data.
-      schedulePendingInteractions(root, expirationTime); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
-      // root inside of batchedUpdates should be synchronous, but layout updates
-      // should be deferred until the end of the batch.
+function batchedUpdates$1(fn, a) {
+  var prevExecutionContext = executionContext;
+  executionContext |= BatchedContext;
 
-      performSyncWorkOnRoot(root);
-    } else {
-      ensureRootIsScheduled(root);
-      schedulePendingInteractions(root, expirationTime);
+  try {
+    return fn(a);
+  } finally {
+    executionContext = prevExecutionContext;
 
-      if (executionContext === NoContext) {
-        // Flush the synchronous work now, unless we're already working or inside
-        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
-        // scheduleCallbackForFiber to preserve the ability to schedule a callback
-        // without immediately flushing it. We only do this for user-initiated
-        // updates, to preserve historical behavior of legacy mode.
-        flushSyncCallbackQueue();
-      }
+    if (executionContext === NoContext) {
+      // Flush the immediate callbacks that were scheduled during this batch
+      resetRenderTimer();
+      flushSyncCallbackQueue();
     }
-  } else {
-    ensureRootIsScheduled(root);
-    schedulePendingInteractions(root, expirationTime);
   }
+}
+function flushSync(fn, a) {
+  var prevExecutionContext = executionContext;
 
-  if (
-    (executionContext & DiscreteEventContext) !== NoContext && // Only updates at user-blocking priority or greater are considered
-    // discrete, even inside a discrete event.
-    (priorityLevel === UserBlockingPriority ||
-      priorityLevel === ImmediatePriority)
-  ) {
-    // This is the result of a discrete event. Track the lowest priority
-    // discrete update per root so we can flush them early, if needed.
-    if (rootsWithPendingDiscreteUpdates === null) {
-      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);
-    } else {
-      var lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);
-
-      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {
-        rootsWithPendingDiscreteUpdates.set(root, expirationTime);
-      }
+  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
+    {
+      error(
+        "flushSync was called from inside a lifecycle method. React cannot " +
+          "flush when React is already rendering. Consider moving this call to " +
+          "a scheduler task or micro task."
+      );
     }
-  }
-}
-var scheduleWork = scheduleUpdateOnFiber; // This is split into a separate function so we can mark a fiber with pending
-// work without treating it as a typical update that originates from an event;
-// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
-// on a fiber.
 
-function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
-  // Update the source fiber's expiration time
-  if (fiber.expirationTime < expirationTime) {
-    fiber.expirationTime = expirationTime;
+    return fn(a);
   }
 
-  var alternate = fiber.alternate;
+  executionContext |= BatchedContext;
 
-  if (alternate !== null && alternate.expirationTime < expirationTime) {
-    alternate.expirationTime = expirationTime;
-  } // Walk the parent path to the root and update the child expiration time.
+  {
+    try {
+      if (fn) {
+        return runWithPriority(ImmediatePriority$1, fn.bind(null, a));
+      } else {
+        return undefined;
+      }
+    } finally {
+      executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
+      // Note that this will happen even if batchedUpdates is higher up
+      // the stack.
 
-  var node = fiber.return;
-  var root = null;
+      flushSyncCallbackQueue();
+    }
+  }
+}
+function pushRenderLanes(fiber, lanes) {
+  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
+  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
+  workInProgressRootIncludedLanes = mergeLanes(
+    workInProgressRootIncludedLanes,
+    lanes
+  );
+}
+function popRenderLanes(fiber) {
+  subtreeRenderLanes = subtreeRenderLanesCursor.current;
+  pop(subtreeRenderLanesCursor, fiber);
+}
 
-  if (node === null && fiber.tag === HostRoot) {
-    root = fiber.stateNode;
-  } else {
-    while (node !== null) {
-      alternate = node.alternate;
+function prepareFreshStack(root, lanes) {
+  root.finishedWork = null;
+  root.finishedLanes = NoLanes;
+  var timeoutHandle = root.timeoutHandle;
 
-      if (node.childExpirationTime < expirationTime) {
-        node.childExpirationTime = expirationTime;
+  if (timeoutHandle !== noTimeout) {
+    // The root previous suspended and scheduled a timeout to commit a fallback
+    // state. Now that we have additional work, cancel the timeout.
+    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
 
-        if (
-          alternate !== null &&
-          alternate.childExpirationTime < expirationTime
-        ) {
-          alternate.childExpirationTime = expirationTime;
-        }
-      } else if (
-        alternate !== null &&
-        alternate.childExpirationTime < expirationTime
-      ) {
-        alternate.childExpirationTime = expirationTime;
-      }
+    cancelTimeout(timeoutHandle);
+  }
 
-      if (node.return === null && node.tag === HostRoot) {
-        root = node.stateNode;
-        break;
-      }
+  if (workInProgress !== null) {
+    var interruptedWork = workInProgress.return;
 
-      node = node.return;
+    while (interruptedWork !== null) {
+      unwindInterruptedWork(interruptedWork);
+      interruptedWork = interruptedWork.return;
     }
   }
 
-  if (root !== null) {
-    if (workInProgressRoot === root) {
-      // Received an update to a tree that's in the middle of rendering. Mark
-      // that's unprocessed work on this root.
-      markUnprocessedUpdateTime(expirationTime);
-
-      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
-        // The root already suspended with a delay, which means this render
-        // definitely won't finish. Since we have a new update, let's mark it as
-        // suspended now, right before marking the incoming update. This has the
-        // effect of interrupting the current render and switching to the update.
-        // TODO: This happens to work when receiving an update during the render
-        // phase, because of the trick inside computeExpirationForFiber to
-        // subtract 1 from `renderExpirationTime` to move it into a
-        // separate bucket. But we should probably model it with an exception,
-        // using the same mechanism we use to force hydration of a subtree.
-        // TODO: This does not account for low pri updates that were already
-        // scheduled before the root started rendering. Need to track the next
-        // pending expiration time (perhaps by backtracking the return path) and
-        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.
-        markRootSuspendedAtTime(root, renderExpirationTime$1);
-      }
-    } // Mark that the root has a pending update.
-
-    markRootUpdatedAtTime(root, expirationTime);
+  workInProgressRoot = root;
+  workInProgress = createWorkInProgress(root.current, null);
+  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
+  workInProgressRootExitStatus = RootIncomplete;
+  workInProgressRootFatalError = null;
+  workInProgressRootSkippedLanes = NoLanes;
+  workInProgressRootUpdatedLanes = NoLanes;
+  workInProgressRootPingedLanes = NoLanes;
+
+  {
+    spawnedWorkDuringRender = null;
   }
 
-  return root;
+  {
+    ReactStrictModeWarnings.discardPendingWarnings();
+  }
 }
 
-function getNextRootExpirationTimeToWorkOn(root) {
-  // Determines the next expiration time that the root should render, taking
-  // into account levels that may be suspended, or levels that may have
-  // received a ping.
-  var lastExpiredTime = root.lastExpiredTime;
+function handleError(root, thrownValue) {
+  do {
+    var erroredWork = workInProgress;
 
-  if (lastExpiredTime !== NoWork) {
-    return lastExpiredTime;
-  } // "Pending" refers to any update that hasn't committed yet, including if it
-  // suspended. The "suspended" range is therefore a subset.
+    try {
+      // Reset module-level state that was set during the render phase.
+      resetContextDependencies();
+      resetHooksAfterThrow();
+      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
+      // separate issue. Write a regression test using string refs.
 
-  var firstPendingTime = root.firstPendingTime;
+      ReactCurrentOwner$2.current = null;
 
-  if (!isRootSuspendedAtTime(root, firstPendingTime)) {
-    // The highest priority pending time is not suspended. Let's work on that.
-    return firstPendingTime;
-  } // If the first pending time is suspended, check if there's a lower priority
-  // pending level that we know about. Or check if we received a ping. Work
-  // on whichever is higher priority.
+      if (erroredWork === null || erroredWork.return === null) {
+        // Expected to be working on a non-root fiber. This is a fatal error
+        // because there's no ancestor that can handle it; the root is
+        // supposed to capture all errors that weren't caught by an error
+        // boundary.
+        workInProgressRootExitStatus = RootFatalErrored;
+        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
+        // sibling, or the parent if there are no siblings. But since the root
+        // has no siblings nor a parent, we set it to null. Usually this is
+        // handled by `completeUnitOfWork` or `unwindWork`, but since we're
+        // intentionally not calling those, we need set it here.
+        // TODO: Consider calling `unwindWork` to pop the contexts.
 
-  var lastPingedTime = root.lastPingedTime;
-  var nextKnownPendingLevel = root.nextKnownPendingLevel;
-  var nextLevel =
-    lastPingedTime > nextKnownPendingLevel
-      ? lastPingedTime
-      : nextKnownPendingLevel;
+        workInProgress = null;
+        return;
+      }
 
-  if (nextLevel <= Idle && firstPendingTime !== nextLevel) {
-    // Don't work on Idle/Never priority unless everything else is committed.
-    return NoWork;
-  }
+      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
+        // Record the time spent rendering before an error was thrown. This
+        // avoids inaccurate Profiler durations in the case of a
+        // suspended render.
+        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
+      }
 
-  return nextLevel;
-} // Use this function to schedule a task for a root. There's only one task per
-// root; if a task was already scheduled, we'll check to make sure the
-// expiration time of the existing task is the same as the expiration time of
-// the next level that the root has work on. This function is called on every
-// update, and right before exiting a task.
-
-function ensureRootIsScheduled(root) {
-  var lastExpiredTime = root.lastExpiredTime;
-
-  if (lastExpiredTime !== NoWork) {
-    // Special case: Expired work should flush synchronously.
-    root.callbackExpirationTime = Sync;
-    root.callbackPriority = ImmediatePriority;
-    root.callbackNode = scheduleSyncCallback(
-      performSyncWorkOnRoot.bind(null, root)
-    );
-    return;
-  }
+      throwException(
+        root,
+        erroredWork.return,
+        erroredWork,
+        thrownValue,
+        workInProgressRootRenderLanes
+      );
+      completeUnitOfWork(erroredWork);
+    } catch (yetAnotherThrownValue) {
+      // Something in the return path also threw.
+      thrownValue = yetAnotherThrownValue;
 
-  var expirationTime = getNextRootExpirationTimeToWorkOn(root);
-  var existingCallbackNode = root.callbackNode;
+      if (workInProgress === erroredWork && erroredWork !== null) {
+        // If this boundary has already errored, then we had trouble processing
+        // the error. Bubble it to the next boundary.
+        erroredWork = erroredWork.return;
+        workInProgress = erroredWork;
+      } else {
+        erroredWork = workInProgress;
+      }
 
-  if (expirationTime === NoWork) {
-    // There's nothing to work on.
-    if (existingCallbackNode !== null) {
-      root.callbackNode = null;
-      root.callbackExpirationTime = NoWork;
-      root.callbackPriority = NoPriority;
-    }
+      continue;
+    } // Return to the normal work loop.
 
     return;
-  } // TODO: If this is an update, we already read the current time. Pass the
-  // time as an argument.
+  } while (true);
+}
 
-  var currentTime = requestCurrentTimeForUpdate();
-  var priorityLevel = inferPriorityFromExpirationTime(
-    currentTime,
-    expirationTime
-  ); // If there's an existing render task, confirm it has the correct priority and
-  // expiration time. Otherwise, we'll cancel it and schedule a new one.
+function pushDispatcher() {
+  var prevDispatcher = ReactCurrentDispatcher$2.current;
+  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
 
-  if (existingCallbackNode !== null) {
-    var existingCallbackPriority = root.callbackPriority;
-    var existingCallbackExpirationTime = root.callbackExpirationTime;
+  if (prevDispatcher === null) {
+    // The React isomorphic package does not include a default dispatcher.
+    // Instead the first renderer will lazily attach one, in order to give
+    // nicer error messages.
+    return ContextOnlyDispatcher;
+  } else {
+    return prevDispatcher;
+  }
+}
 
-    if (
-      // Callback must have the exact same expiration time.
-      existingCallbackExpirationTime === expirationTime && // Callback must have greater or equal priority.
-      existingCallbackPriority >= priorityLevel
-    ) {
-      // Existing callback is sufficient.
-      return;
-    } // Need to schedule a new task.
-    // TODO: Instead of scheduling a new task, we should be able to change the
-    // priority of the existing one.
+function popDispatcher(prevDispatcher) {
+  ReactCurrentDispatcher$2.current = prevDispatcher;
+}
 
-    cancelCallback(existingCallbackNode);
+function pushInteractions(root) {
+  {
+    var prevInteractions = tracing.__interactionsRef.current;
+    tracing.__interactionsRef.current = root.memoizedInteractions;
+    return prevInteractions;
+  }
+}
+
+function popInteractions(prevInteractions) {
+  {
+    tracing.__interactionsRef.current = prevInteractions;
+  }
+}
+
+function markCommitTimeOfFallback() {
+  globalMostRecentFallbackTime = now();
+}
+function markSkippedUpdateLanes(lane) {
+  workInProgressRootSkippedLanes = mergeLanes(
+    lane,
+    workInProgressRootSkippedLanes
+  );
+}
+function renderDidSuspend() {
+  if (workInProgressRootExitStatus === RootIncomplete) {
+    workInProgressRootExitStatus = RootSuspended;
+  }
+}
+function renderDidSuspendDelayIfPossible() {
+  if (
+    workInProgressRootExitStatus === RootIncomplete ||
+    workInProgressRootExitStatus === RootSuspended
+  ) {
+    workInProgressRootExitStatus = RootSuspendedWithDelay;
+  } // Check if there are updates that we skipped tree that might have unblocked
+  // this render.
+
+  if (
+    workInProgressRoot !== null &&
+    (includesNonIdleWork(workInProgressRootSkippedLanes) ||
+      includesNonIdleWork(workInProgressRootUpdatedLanes))
+  ) {
+    // Mark the current render as suspended so that we switch to working on
+    // the updates that were skipped. Usually we only suspend at the end of
+    // the render phase.
+    // TODO: We should probably always mark the root as suspended immediately
+    // (inside this function), since by suspending at the end of the render
+    // phase introduces a potential mistake where we suspend lanes that were
+    // pinged or updated while we were rendering.
+    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
+  }
+}
+function renderDidError() {
+  if (workInProgressRootExitStatus !== RootCompleted) {
+    workInProgressRootExitStatus = RootErrored;
   }
+} // Called during render to determine if anything has suspended.
+// Returns false if we're not sure.
+
+function renderHasNotSuspendedYet() {
+  // If something errored or completed, we can't really be sure,
+  // so those are false.
+  return workInProgressRootExitStatus === RootIncomplete;
+}
 
-  root.callbackExpirationTime = expirationTime;
-  root.callbackPriority = priorityLevel;
-  var callbackNode;
+function renderRootSync(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= RenderContext;
+  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
+  // and prepare a fresh one. Otherwise we'll continue where we left off.
 
-  if (expirationTime === Sync) {
-    // Sync React callbacks are scheduled on a special internal queue
-    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
-  } else {
-    callbackNode = scheduleCallback(
-      priorityLevel,
-      performConcurrentWorkOnRoot.bind(null, root), // Compute a task timeout based on the expiration time. This also affects
-      // ordering because tasks are processed in timeout order.
-      {
-        timeout: expirationTimeToMs(expirationTime) - now()
-      }
-    );
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
+    prepareFreshStack(root, lanes);
+    startWorkOnPendingInteractions(root, lanes);
   }
 
-  root.callbackNode = callbackNode;
-} // This is the entry point for every concurrent task, i.e. anything that
-// goes through Scheduler.
-
-function performConcurrentWorkOnRoot(root, didTimeout) {
-  // Since we know we're in a React event, we can clear the current
-  // event time. The next update will compute a new event time.
-  currentEventTime = NoWork; // Check if the render expired.
-
-  if (didTimeout) {
-    // The render task took too long to complete. Mark the current time as
-    // expired to synchronously render all expired work in a single batch.
-    var currentTime = requestCurrentTimeForUpdate();
-    markRootExpiredAtTime(root, currentTime); // This will schedule a synchronous callback.
+  var prevInteractions = pushInteractions(root);
 
-    ensureRootIsScheduled(root);
-    return null;
-  } // Determine the next expiration time to work on, using the fields stored
-  // on the root.
+  do {
+    try {
+      workLoopSync();
+      break;
+    } catch (thrownValue) {
+      handleError(root, thrownValue);
+    }
+  } while (true);
 
-  var expirationTime = getNextRootExpirationTimeToWorkOn(root);
+  resetContextDependencies();
 
-  if (expirationTime === NoWork) {
-    return null;
+  {
+    popInteractions(prevInteractions);
   }
 
-  var originalCallbackNode = root.callbackNode;
+  executionContext = prevExecutionContext;
+  popDispatcher(prevDispatcher);
 
-  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
-    throw Error("Should not already be working.");
+  if (workInProgress !== null) {
+    // This is a sync render, so we should have finished the whole tree.
+    {
+      throw Error(
+        "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
+      );
+    }
   }
 
-  flushPassiveEffects();
-  var exitStatus = renderRootConcurrent(root, expirationTime);
-
-  if (exitStatus !== RootIncomplete) {
-    if (exitStatus === RootErrored) {
-      // If something threw an error, try rendering one more time. We'll
-      // render synchronously to block concurrent data mutations, and we'll
-      // render at Idle (or lower) so that all pending updates are included.
-      // If it still fails after the second attempt, we'll give up and commit
-      // the resulting tree.
-      expirationTime = expirationTime > Idle ? Idle : expirationTime;
-      exitStatus = renderRootSync(root, expirationTime);
-    }
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = NoLanes;
+  return workInProgressRootExitStatus;
+} // The work loop is an extremely hot path. Tell Closure not to inline it.
 
-    if (exitStatus === RootFatalErrored) {
-      var fatalError = workInProgressRootFatalError;
-      prepareFreshStack(root, expirationTime);
-      markRootSuspendedAtTime(root, expirationTime);
-      ensureRootIsScheduled(root);
-      throw fatalError;
-    } // We now have a consistent tree. The next step is either to commit it,
-    // or, if something suspended, wait to commit it after a timeout.
+/** @noinline */
 
-    var finishedWork = (root.finishedWork = root.current.alternate);
-    root.finishedExpirationTime = expirationTime;
-    finishConcurrentRender(root, finishedWork, exitStatus, expirationTime);
+function workLoopSync() {
+  // Already timed out, so perform work without checking if we need to yield.
+  while (workInProgress !== null) {
+    performUnitOfWork(workInProgress);
   }
+}
 
-  ensureRootIsScheduled(root);
+function renderRootConcurrent(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= RenderContext;
+  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
+  // and prepare a fresh one. Otherwise we'll continue where we left off.
 
-  if (root.callbackNode === originalCallbackNode) {
-    // The task node scheduled for this root is the same one that's
-    // currently executed. Need to return a continuation.
-    return performConcurrentWorkOnRoot.bind(null, root);
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
+    resetRenderTimer();
+    prepareFreshStack(root, lanes);
+    startWorkOnPendingInteractions(root, lanes);
   }
 
-  return null;
-}
-
-function finishConcurrentRender(
-  root,
-  finishedWork,
-  exitStatus,
-  expirationTime
-) {
-  switch (exitStatus) {
-    case RootIncomplete:
-    case RootFatalErrored: {
-      {
-        throw Error("Root did not complete. This is a bug in React.");
-      }
-    }
-    // Flow knows about invariant, so it complains if I add a break
-    // statement, but eslint doesn't know about invariant, so it complains
-    // if I do. eslint-disable-next-line no-fallthrough
+  var prevInteractions = pushInteractions(root);
 
-    case RootErrored: {
-      // We should have already attempted to retry this tree. If we reached
-      // this point, it errored again. Commit it.
-      commitRoot(root);
+  do {
+    try {
+      workLoopConcurrent();
       break;
+    } catch (thrownValue) {
+      handleError(root, thrownValue);
     }
+  } while (true);
 
-    case RootSuspended: {
-      markRootSuspendedAtTime(root, expirationTime);
-      var lastSuspendedTime = root.lastSuspendedTime;
-
-      if (expirationTime === lastSuspendedTime) {
-        root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
-      } // We have an acceptable loading state. We need to figure out if we
-      // should immediately commit it or wait a bit.
-      // If we have processed new updates during this render, we may now
-      // have a new loading state ready. We want to ensure that we commit
-      // that as soon as possible.
-
-      var hasNotProcessedNewUpdates =
-        workInProgressRootLatestProcessedExpirationTime === Sync;
+  resetContextDependencies();
 
-      if (
-        hasNotProcessedNewUpdates && // do not delay if we're inside an act() scope
-        !IsThisRendererActing.current
-      ) {
-        // If we have not processed any new updates during this pass, then
-        // this is either a retry of an existing fallback state or a
-        // hidden tree. Hidden trees shouldn't be batched with other work
-        // and after that's fixed it can only be a retry. We're going to
-        // throttle committing retries so that we don't show too many
-        // loading states too quickly.
-        var msUntilTimeout =
-          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.
+  {
+    popInteractions(prevInteractions);
+  }
 
-        if (msUntilTimeout > 10) {
-          if (workInProgressRootHasPendingPing) {
-            var lastPingedTime = root.lastPingedTime;
-
-            if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {
-              // This render was pinged but we didn't get to restart
-              // earlier so try restarting now instead.
-              root.lastPingedTime = expirationTime;
-              prepareFreshStack(root, expirationTime);
-              break;
-            }
-          }
+  popDispatcher(prevDispatcher);
+  executionContext = prevExecutionContext;
 
-          var nextTime = getNextRootExpirationTimeToWorkOn(root);
+  if (workInProgress !== null) {
+    return RootIncomplete;
+  } else {
+    workInProgressRoot = null;
+    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.
 
-          if (nextTime !== NoWork && nextTime !== expirationTime) {
-            // There's additional work on this root.
-            break;
-          }
+    return workInProgressRootExitStatus;
+  }
+}
+/** @noinline */
 
-          if (
-            lastSuspendedTime !== NoWork &&
-            lastSuspendedTime !== expirationTime
-          ) {
-            // We should prefer to render the fallback of at the last
-            // suspended level. Ping the last suspended level to try
-            // rendering it again.
-            root.lastPingedTime = lastSuspendedTime;
-            break;
-          } // The render is suspended, it hasn't timed out, and there's no
-          // lower priority work to do. Instead of committing the fallback
-          // immediately, wait for more data to arrive.
+function workLoopConcurrent() {
+  // Perform work until Scheduler asks us to yield
+  while (workInProgress !== null && !shouldYield()) {
+    performUnitOfWork(workInProgress);
+  }
+}
 
-          root.timeoutHandle = scheduleTimeout(
-            commitRoot.bind(null, root),
-            msUntilTimeout
-          );
-          break;
-        }
-      } // The work expired. Commit immediately.
+function performUnitOfWork(unitOfWork) {
+  // The current, flushed, state of this fiber is the alternate. Ideally
+  // nothing should rely on this, but relying on it here means that we don't
+  // need an additional field on the work in progress.
+  var current = unitOfWork.alternate;
+  setCurrentFiber(unitOfWork);
+  var next;
 
-      commitRoot(root);
-      break;
-    }
+  if ((unitOfWork.mode & ProfileMode) !== NoMode) {
+    startProfilerTimer(unitOfWork);
+    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
+    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
+  } else {
+    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
+  }
 
-    case RootSuspendedWithDelay: {
-      markRootSuspendedAtTime(root, expirationTime);
-      var _lastSuspendedTime = root.lastSuspendedTime;
+  resetCurrentFiber();
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
 
-      if (expirationTime === _lastSuspendedTime) {
-        root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
-      }
+  if (next === null) {
+    // If this doesn't spawn new work, complete the current work.
+    completeUnitOfWork(unitOfWork);
+  } else {
+    workInProgress = next;
+  }
 
-      {
-        // We're suspended in a state that should be avoided. We'll try to
-        // avoid committing it for as long as the timeouts let us.
-        if (workInProgressRootHasPendingPing) {
-          var _lastPingedTime = root.lastPingedTime;
-
-          if (_lastPingedTime === NoWork || _lastPingedTime >= expirationTime) {
-            // This render was pinged but we didn't get to restart earlier
-            // so try restarting now instead.
-            root.lastPingedTime = expirationTime;
-            prepareFreshStack(root, expirationTime);
-            break;
-          }
-        }
+  ReactCurrentOwner$2.current = null;
+}
 
-        var _nextTime = getNextRootExpirationTimeToWorkOn(root);
+function completeUnitOfWork(unitOfWork) {
+  // Attempt to complete the current unit of work, then move to the next
+  // sibling. If there are no more siblings, return to the parent fiber.
+  var completedWork = unitOfWork;
 
-        if (_nextTime !== NoWork && _nextTime !== expirationTime) {
-          // There's additional work on this root.
-          break;
-        }
+  do {
+    // The current, flushed, state of this fiber is the alternate. Ideally
+    // nothing should rely on this, but relying on it here means that we don't
+    // need an additional field on the work in progress.
+    var current = completedWork.alternate;
+    var returnFiber = completedWork.return; // Check if the work completed or if something threw.
 
-        if (
-          _lastSuspendedTime !== NoWork &&
-          _lastSuspendedTime !== expirationTime
-        ) {
-          // We should prefer to render the fallback of at the last
-          // suspended level. Ping the last suspended level to try
-          // rendering it again.
-          root.lastPingedTime = _lastSuspendedTime;
-          break;
-        }
+    if ((completedWork.flags & Incomplete) === NoFlags) {
+      setCurrentFiber(completedWork);
+      var next = void 0;
 
-        var _msUntilTimeout;
-
-        if (workInProgressRootLatestSuspenseTimeout !== Sync) {
-          // We have processed a suspense config whose expiration time we
-          // can use as the timeout.
-          _msUntilTimeout =
-            expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();
-        } else if (workInProgressRootLatestProcessedExpirationTime === Sync) {
-          // This should never normally happen because only new updates
-          // cause delayed states, so we should have processed something.
-          // However, this could also happen in an offscreen tree.
-          _msUntilTimeout = 0;
-        } else {
-          // If we don't have a suspense config, we're going to use a
-          // heuristic to determine how long we can suspend.
-          var eventTimeMs = inferTimeFromExpirationTime(
-            workInProgressRootLatestProcessedExpirationTime
-          );
-          var currentTimeMs = now();
-          var timeUntilExpirationMs =
-            expirationTimeToMs(expirationTime) - currentTimeMs;
-          var timeElapsed = currentTimeMs - eventTimeMs;
-
-          if (timeElapsed < 0) {
-            // We get this wrong some time since we estimate the time.
-            timeElapsed = 0;
-          }
+      if ((completedWork.mode & ProfileMode) === NoMode) {
+        next = completeWork(current, completedWork, subtreeRenderLanes);
+      } else {
+        startProfilerTimer(completedWork);
+        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.
 
-          _msUntilTimeout = jnd(timeElapsed) - timeElapsed; // Clamp the timeout to the expiration time. TODO: Once the
-          // event time is exact instead of inferred from expiration time
-          // we don't need this.
+        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
+      }
 
-          if (timeUntilExpirationMs < _msUntilTimeout) {
-            _msUntilTimeout = timeUntilExpirationMs;
-          }
-        } // Don't bother with a very short suspense time.
+      resetCurrentFiber();
 
-        if (_msUntilTimeout > 10) {
-          // The render is suspended, it hasn't timed out, and there's no
-          // lower priority work to do. Instead of committing the fallback
-          // immediately, wait for more data to arrive.
-          root.timeoutHandle = scheduleTimeout(
-            commitRoot.bind(null, root),
-            _msUntilTimeout
-          );
-          break;
-        }
-      } // The work expired. Commit immediately.
+      if (next !== null) {
+        // Completing this fiber spawned new work. Work on that next.
+        workInProgress = next;
+        return;
+      }
 
-      commitRoot(root);
-      break;
-    }
+      resetChildLanes(completedWork);
 
-    case RootCompleted: {
-      // The work completed. Ready to commit.
       if (
-        // do not delay if we're inside an act() scope
-        workInProgressRootLatestProcessedExpirationTime !== Sync &&
-        workInProgressRootCanSuspendUsingConfig !== null
+        returnFiber !== null && // Do not append effects to parents if a sibling failed to complete
+        (returnFiber.flags & Incomplete) === NoFlags
       ) {
-        // If we have exceeded the minimum loading delay, which probably
-        // means we have shown a spinner already, we might have to suspend
-        // a bit longer to ensure that the spinner is shown for
-        // enough time.
-        var _msUntilTimeout2 = computeMsUntilSuspenseLoadingDelay(
-          workInProgressRootLatestProcessedExpirationTime,
-          expirationTime,
-          workInProgressRootCanSuspendUsingConfig
-        );
-
-        if (_msUntilTimeout2 > 10) {
-          markRootSuspendedAtTime(root, expirationTime);
-          root.timeoutHandle = scheduleTimeout(
-            commitRoot.bind(null, root),
-            _msUntilTimeout2
-          );
-          break;
+        // Append all the effects of the subtree and this fiber onto the effect
+        // list of the parent. The completion order of the children affects the
+        // side-effect order.
+        if (returnFiber.firstEffect === null) {
+          returnFiber.firstEffect = completedWork.firstEffect;
         }
-      }
 
-      commitRoot(root);
-      break;
-    }
-
-    default: {
-      {
-        throw Error("Unknown root exit status.");
-      }
-    }
-  }
-} // This is the entry point for synchronous tasks that don't go
-// through Scheduler
-
-function performSyncWorkOnRoot(root) {
-  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
-    throw Error("Should not already be working.");
-  }
-
-  flushPassiveEffects();
-  var lastExpiredTime = root.lastExpiredTime;
-  var expirationTime;
+        if (completedWork.lastEffect !== null) {
+          if (returnFiber.lastEffect !== null) {
+            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
+          }
 
-  if (lastExpiredTime !== NoWork) {
-    // There's expired work on this root. Check if we have a partial tree
-    // that we can reuse.
-    if (
-      root === workInProgressRoot &&
-      renderExpirationTime$1 >= lastExpiredTime
-    ) {
-      // There's a partial tree with equal or greater than priority than the
-      // expired level. Finish rendering it before rendering the rest of the
-      // expired work.
-      expirationTime = renderExpirationTime$1;
-    } else {
-      // Start a fresh tree.
-      expirationTime = lastExpiredTime;
-    }
-  } else {
-    // There's no expired work. This must be a new, synchronous render.
-    expirationTime = Sync;
-  }
+          returnFiber.lastEffect = completedWork.lastEffect;
+        } // If this fiber had side-effects, we append it AFTER the children's
+        // side-effects. We can perform certain side-effects earlier if needed,
+        // by doing multiple passes over the effect list. We don't want to
+        // schedule our own side-effect on our own list because if end up
+        // reusing children we'll schedule this effect onto itself since we're
+        // at the end.
 
-  var exitStatus = renderRootSync(root, expirationTime);
+        var flags = completedWork.flags; // Skip both NoWork and PerformedWork tags when creating the effect
+        // list. PerformedWork effect is read by React DevTools but shouldn't be
+        // committed.
 
-  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
-    // If something threw an error, try rendering one more time. We'll
-    // render synchronously to block concurrent data mutations, and we'll
-    // render at Idle (or lower) so that all pending updates are included.
-    // If it still fails after the second attempt, we'll give up and commit
-    // the resulting tree.
-    expirationTime = expirationTime > Idle ? Idle : expirationTime;
-    exitStatus = renderRootSync(root, expirationTime);
-  }
+        if (flags > PerformedWork) {
+          if (returnFiber.lastEffect !== null) {
+            returnFiber.lastEffect.nextEffect = completedWork;
+          } else {
+            returnFiber.firstEffect = completedWork;
+          }
 
-  if (exitStatus === RootFatalErrored) {
-    var fatalError = workInProgressRootFatalError;
-    prepareFreshStack(root, expirationTime);
-    markRootSuspendedAtTime(root, expirationTime);
-    ensureRootIsScheduled(root);
-    throw fatalError;
-  } // We now have a consistent tree. Because this is a sync render, we
-  // will commit it even if something suspended.
+          returnFiber.lastEffect = completedWork;
+        }
+      }
+    } else {
+      // This fiber did not complete because something threw. Pop values off
+      // the stack without entering the complete phase. If this is a boundary,
+      // capture values if possible.
+      var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.
 
-  root.finishedWork = root.current.alternate;
-  root.finishedExpirationTime = expirationTime;
-  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
-  // pending level.
+      if (_next !== null) {
+        // If completing this work spawned new work, do that next. We'll come
+        // back here again.
+        // Since we're restarting, remove anything that is not a host effect
+        // from the effect tag.
+        _next.flags &= HostEffectMask;
+        workInProgress = _next;
+        return;
+      }
 
-  ensureRootIsScheduled(root);
-  return null;
-}
-function syncUpdates(fn, a, b, c) {
-  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));
-}
+      if ((completedWork.mode & ProfileMode) !== NoMode) {
+        // Record the render duration for the fiber that errored.
+        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.
 
-function batchedUpdates$1(fn, a) {
-  var prevExecutionContext = executionContext;
-  executionContext |= BatchedContext;
+        var actualDuration = completedWork.actualDuration;
+        var child = completedWork.child;
 
-  try {
-    return fn(a);
-  } finally {
-    executionContext = prevExecutionContext;
+        while (child !== null) {
+          actualDuration += child.actualDuration;
+          child = child.sibling;
+        }
 
-    if (executionContext === NoContext) {
-      // Flush the immediate callbacks that were scheduled during this batch
-      flushSyncCallbackQueue();
-    }
-  }
-}
-function flushSync(fn, a) {
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
-    {
-      throw Error(
-        "flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering."
-      );
-    }
-  }
+        completedWork.actualDuration = actualDuration;
+      }
 
-  var prevExecutionContext = executionContext;
-  executionContext |= BatchedContext;
+      if (returnFiber !== null) {
+        // Mark the parent fiber as incomplete and clear its effect list.
+        returnFiber.firstEffect = returnFiber.lastEffect = null;
+        returnFiber.flags |= Incomplete;
+      }
+    }
 
-  try {
-    return runWithPriority(ImmediatePriority, fn.bind(null, a));
-  } finally {
-    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
-    // Note that this will happen even if batchedUpdates is higher up
-    // the stack.
+    var siblingFiber = completedWork.sibling;
 
-    flushSyncCallbackQueue();
-  }
-}
+    if (siblingFiber !== null) {
+      // If there is more work to do in this returnFiber, do that next.
+      workInProgress = siblingFiber;
+      return;
+    } // Otherwise, return to the parent
 
-function prepareFreshStack(root, expirationTime) {
-  root.finishedWork = null;
-  root.finishedExpirationTime = NoWork;
-  var timeoutHandle = root.timeoutHandle;
+    completedWork = returnFiber; // Update the next thing we're working on in case something throws.
 
-  if (timeoutHandle !== noTimeout) {
-    // The root previous suspended and scheduled a timeout to commit a fallback
-    // state. Now that we have additional work, cancel the timeout.
-    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
+    workInProgress = completedWork;
+  } while (completedWork !== null); // We've reached the root.
 
-    cancelTimeout(timeoutHandle);
+  if (workInProgressRootExitStatus === RootIncomplete) {
+    workInProgressRootExitStatus = RootCompleted;
   }
+}
 
-  if (workInProgress !== null) {
-    var interruptedWork = workInProgress.return;
-
-    while (interruptedWork !== null) {
-      unwindInterruptedWork(interruptedWork);
-      interruptedWork = interruptedWork.return;
-    }
+function resetChildLanes(completedWork) {
+  if (
+    // TODO: Move this check out of the hot path by moving `resetChildLanes`
+    // to switch statement in `completeWork`.
+    (completedWork.tag === LegacyHiddenComponent ||
+      completedWork.tag === OffscreenComponent) &&
+    completedWork.memoizedState !== null &&
+    !includesSomeLane(subtreeRenderLanes, OffscreenLane) &&
+    (completedWork.mode & ConcurrentMode) !== NoLanes
+  ) {
+    // The children of this component are hidden. Don't bubble their
+    // expiration times.
+    return;
   }
 
-  workInProgressRoot = root;
-  workInProgress = createWorkInProgress(root.current, null);
-  renderExpirationTime$1 = expirationTime;
-  workInProgressRootExitStatus = RootIncomplete;
-  workInProgressRootFatalError = null;
-  workInProgressRootLatestProcessedExpirationTime = Sync;
-  workInProgressRootLatestSuspenseTimeout = Sync;
-  workInProgressRootCanSuspendUsingConfig = null;
-  workInProgressRootNextUnprocessedUpdateTime = NoWork;
-  workInProgressRootHasPendingPing = false;
-
-  {
-    spawnedWorkDuringRender = null;
-  }
+  var newChildLanes = NoLanes; // Bubble up the earliest expiration time.
 
-  {
-    ReactStrictModeWarnings.discardPendingWarnings();
-  }
-}
+  if ((completedWork.mode & ProfileMode) !== NoMode) {
+    // In profiling mode, resetChildExpirationTime is also used to reset
+    // profiler durations.
+    var actualDuration = completedWork.actualDuration;
+    var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
+    // only be updated if work is done on the fiber (i.e. it doesn't bailout).
+    // When work is done, it should bubble to the parent's actualDuration. If
+    // the fiber has not been cloned though, (meaning no work was done), then
+    // this value will reflect the amount of time spent working on a previous
+    // render. In that case it should not bubble. We determine whether it was
+    // cloned by comparing the child pointer.
 
-function handleError(root, thrownValue) {
-  do {
-    try {
-      // Reset module-level state that was set during the render phase.
-      resetContextDependencies();
-      resetHooksAfterThrow();
-      resetCurrentFiber();
+    var shouldBubbleActualDurations =
+      completedWork.alternate === null ||
+      completedWork.child !== completedWork.alternate.child;
+    var child = completedWork.child;
 
-      if (workInProgress === null || workInProgress.return === null) {
-        // Expected to be working on a non-root fiber. This is a fatal error
-        // because there's no ancestor that can handle it; the root is
-        // supposed to capture all errors that weren't caught by an error
-        // boundary.
-        workInProgressRootExitStatus = RootFatalErrored;
-        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
-        // sibling, or the parent if there are no siblings. But since the root
-        // has no siblings nor a parent, we set it to null. Usually this is
-        // handled by `completeUnitOfWork` or `unwindWork`, but since we're
-        // interntionally not calling those, we need set it here.
-        // TODO: Consider calling `unwindWork` to pop the contexts.
+    while (child !== null) {
+      newChildLanes = mergeLanes(
+        newChildLanes,
+        mergeLanes(child.lanes, child.childLanes)
+      );
 
-        workInProgress = null;
-        return null;
+      if (shouldBubbleActualDurations) {
+        actualDuration += child.actualDuration;
       }
 
-      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
-        // Record the time spent rendering before an error was thrown. This
-        // avoids inaccurate Profiler durations in the case of a
-        // suspended render.
-        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
-      }
+      treeBaseDuration += child.treeBaseDuration;
+      child = child.sibling;
+    }
 
-      throwException(
-        root,
-        workInProgress.return,
-        workInProgress,
-        thrownValue,
-        renderExpirationTime$1
-      );
-      workInProgress = completeUnitOfWork(workInProgress);
-    } catch (yetAnotherThrownValue) {
-      // Something in the return path also threw.
-      thrownValue = yetAnotherThrownValue;
-      continue;
-    } // Return to the normal work loop.
+    var isTimedOutSuspense =
+      completedWork.tag === SuspenseComponent &&
+      completedWork.memoizedState !== null;
 
-    return;
-  } while (true);
-}
+    if (isTimedOutSuspense) {
+      // Don't count time spent in a timed out Suspense subtree as part of the base duration.
+      var primaryChildFragment = completedWork.child;
 
-function pushDispatcher(root) {
-  var prevDispatcher = ReactCurrentDispatcher$1.current;
-  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+      if (primaryChildFragment !== null) {
+        treeBaseDuration -= primaryChildFragment.treeBaseDuration;
+      }
+    }
 
-  if (prevDispatcher === null) {
-    // The React isomorphic package does not include a default dispatcher.
-    // Instead the first renderer will lazily attach one, in order to give
-    // nicer error messages.
-    return ContextOnlyDispatcher;
+    completedWork.actualDuration = actualDuration;
+    completedWork.treeBaseDuration = treeBaseDuration;
   } else {
-    return prevDispatcher;
+    var _child = completedWork.child;
+
+    while (_child !== null) {
+      newChildLanes = mergeLanes(
+        newChildLanes,
+        mergeLanes(_child.lanes, _child.childLanes)
+      );
+      _child = _child.sibling;
+    }
   }
-}
 
-function popDispatcher(prevDispatcher) {
-  ReactCurrentDispatcher$1.current = prevDispatcher;
+  completedWork.childLanes = newChildLanes;
 }
 
-function pushInteractions(root) {
-  {
-    var prevInteractions = tracing.__interactionsRef.current;
-    tracing.__interactionsRef.current = root.memoizedInteractions;
-    return prevInteractions;
-  }
+function commitRoot(root) {
+  var renderPriorityLevel = getCurrentPriorityLevel();
+  runWithPriority(
+    ImmediatePriority$1,
+    commitRootImpl.bind(null, root, renderPriorityLevel)
+  );
+  return null;
 }
 
-function popInteractions(prevInteractions) {
-  {
-    tracing.__interactionsRef.current = prevInteractions;
-  }
-}
+function commitRootImpl(root, renderPriorityLevel) {
+  do {
+    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
+    // means `flushPassiveEffects` will sometimes result in additional
+    // passive effects. So we need to keep flushing in a loop until there are
+    // no more pending effects.
+    // TODO: Might be better if `flushPassiveEffects` did not automatically
+    // flush synchronous work at the end, to avoid factoring hazards like this.
+    flushPassiveEffects();
+  } while (rootWithPendingPassiveEffects !== null);
 
-function markCommitTimeOfFallback() {
-  globalMostRecentFallbackTime = now();
-}
-function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {
-  if (
-    expirationTime < workInProgressRootLatestProcessedExpirationTime &&
-    expirationTime > Idle
-  ) {
-    workInProgressRootLatestProcessedExpirationTime = expirationTime;
+  flushRenderPhaseStrictModeWarningsInDEV();
+
+  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
+    throw Error("Should not already be working.");
   }
 
-  if (suspenseConfig !== null) {
-    if (
-      expirationTime < workInProgressRootLatestSuspenseTimeout &&
-      expirationTime > Idle
-    ) {
-      workInProgressRootLatestSuspenseTimeout = expirationTime; // Most of the time we only have one config and getting wrong is not bad.
+  var finishedWork = root.finishedWork;
+  var lanes = root.finishedLanes;
 
-      workInProgressRootCanSuspendUsingConfig = suspenseConfig;
-    }
-  }
-}
-function markUnprocessedUpdateTime(expirationTime) {
-  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {
-    workInProgressRootNextUnprocessedUpdateTime = expirationTime;
-  }
-}
-function renderDidSuspend() {
-  if (workInProgressRootExitStatus === RootIncomplete) {
-    workInProgressRootExitStatus = RootSuspended;
+  if (finishedWork === null) {
+    return null;
   }
-}
-function renderDidSuspendDelayIfPossible() {
-  if (
-    workInProgressRootExitStatus === RootIncomplete ||
-    workInProgressRootExitStatus === RootSuspended
-  ) {
-    workInProgressRootExitStatus = RootSuspendedWithDelay;
-  } // Check if there's a lower priority update somewhere else in the tree.
 
-  if (
-    workInProgressRootNextUnprocessedUpdateTime !== NoWork &&
-    workInProgressRoot !== null
-  ) {
-    // Mark the current render as suspended, and then mark that there's a
-    // pending update.
-    // TODO: This should immediately interrupt the current render, instead
-    // of waiting until the next time we yield.
-    markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime$1);
-    markRootUpdatedAtTime(
-      workInProgressRoot,
-      workInProgressRootNextUnprocessedUpdateTime
+  root.finishedWork = null;
+  root.finishedLanes = NoLanes;
+
+  if (!(finishedWork !== root.current)) {
+    throw Error(
+      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
     );
-  }
-}
-function renderDidError() {
-  if (workInProgressRootExitStatus !== RootCompleted) {
-    workInProgressRootExitStatus = RootErrored;
-  }
-} // Called during render to determine if anything has suspended.
-// Returns false if we're not sure.
+  } // commitRoot never returns a continuation; it always finishes synchronously.
+  // So we can clear these now to allow a new callback to be scheduled.
 
-function renderHasNotSuspendedYet() {
-  // If something errored or completed, we can't really be sure,
-  // so those are false.
-  return workInProgressRootExitStatus === RootIncomplete;
-}
+  root.callbackNode = null; // Update the first and last pending times on this root. The new first
+  // pending time is whatever is left on the root fiber.
 
-function inferTimeFromExpirationTime(expirationTime) {
-  // We don't know exactly when the update was scheduled, but we can infer an
-  // approximate start time from the expiration time.
-  var earliestExpirationTimeMs = expirationTimeToMs(expirationTime);
-  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
-}
+  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
+  markRootFinished(root, remainingLanes); // Clear already finished discrete updates in case that a later call of
+  // `flushDiscreteUpdates` starts a useless render pass which may cancels
+  // a scheduled timeout.
 
-function inferTimeFromExpirationTimeWithSuspenseConfig(
-  expirationTime,
-  suspenseConfig
-) {
-  // We don't know exactly when the update was scheduled, but we can infer an
-  // approximate start time from the expiration time by subtracting the timeout
-  // that was added to the event time.
-  var earliestExpirationTimeMs = expirationTimeToMs(expirationTime);
-  return (
-    earliestExpirationTimeMs -
-    (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION)
-  );
-}
+  if (rootsWithPendingDiscreteUpdates !== null) {
+    if (
+      !hasDiscreteLanes(remainingLanes) &&
+      rootsWithPendingDiscreteUpdates.has(root)
+    ) {
+      rootsWithPendingDiscreteUpdates.delete(root);
+    }
+  }
 
-function renderRootSync(root, expirationTime) {
-  var prevExecutionContext = executionContext;
-  executionContext |= RenderContext;
-  var prevDispatcher = pushDispatcher(); // If the root or expiration time have changed, throw out the existing stack
-  // and prepare a fresh one. Otherwise we'll continue where we left off.
+  if (root === workInProgressRoot) {
+    // We can reset these now that they are finished.
+    workInProgressRoot = null;
+    workInProgress = null;
+    workInProgressRootRenderLanes = NoLanes;
+  } // Get the list of effects.
 
-  if (
-    root !== workInProgressRoot ||
-    expirationTime !== renderExpirationTime$1
-  ) {
-    prepareFreshStack(root, expirationTime);
-    startWorkOnPendingInteractions(root, expirationTime);
+  var firstEffect;
+
+  if (finishedWork.flags > PerformedWork) {
+    // A fiber's effect list consists only of its children, not itself. So if
+    // the root has an effect, we need to add it to the end of the list. The
+    // resulting list is the set that would belong to the root's parent, if it
+    // had one; that is, all the effects in the tree including the root.
+    if (finishedWork.lastEffect !== null) {
+      finishedWork.lastEffect.nextEffect = finishedWork;
+      firstEffect = finishedWork.firstEffect;
+    } else {
+      firstEffect = finishedWork;
+    }
+  } else {
+    // There is no effect on the root.
+    firstEffect = finishedWork.firstEffect;
   }
 
-  var prevInteractions = pushInteractions(root);
-  startWorkLoopTimer(workInProgress);
+  if (firstEffect !== null) {
+    var prevExecutionContext = executionContext;
+    executionContext |= CommitContext;
+    var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles
 
-  do {
-    try {
-      workLoopSync();
-      break;
-    } catch (thrownValue) {
-      handleError(root, thrownValue);
-    }
-  } while (true);
+    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
+    // of the effect list for each phase: all mutation effects come before all
+    // layout effects, and so on.
+    // The first phase a "before mutation" phase. We use this phase to read the
+    // state of the host tree right before we mutate it. This is where
+    // getSnapshotBeforeUpdate is called.
 
-  resetContextDependencies();
+    focusedInstanceHandle = prepareForCommit(root.containerInfo);
+    shouldFireAfterActiveInstanceBlur = false;
+    nextEffect = firstEffect;
 
-  {
-    popInteractions(prevInteractions);
-  }
+    do {
+      {
+        invokeGuardedCallback(null, commitBeforeMutationEffects, null);
 
-  executionContext = prevExecutionContext;
-  popDispatcher(prevDispatcher);
+        if (hasCaughtError()) {
+          if (!(nextEffect !== null)) {
+            throw Error("Should be working on an effect.");
+          }
 
-  if (workInProgress !== null) {
-    // This is a sync render, so we should have finished the whole tree.
-    {
-      throw Error(
-        "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-  }
+          var error = clearCaughtError();
+          captureCommitPhaseError(nextEffect, error);
+          nextEffect = nextEffect.nextEffect;
+        }
+      }
+    } while (nextEffect !== null); // We no longer need to track the active instance fiber
 
-  stopFinishedWorkLoopTimer(); // Set this to null to indicate there's no in-progress render.
+    focusedInstanceHandle = null;
 
-  workInProgressRoot = null;
-  return workInProgressRootExitStatus;
-} // The work loop is an extremely hot path. Tell Closure not to inline it.
+    {
+      // Mark the current commit time to be shared by all Profilers in this
+      // batch. This enables them to be grouped later.
+      recordCommitTime();
+    } // The next phase is the mutation phase, where we mutate the host tree.
 
-/** @noinline */
+    nextEffect = firstEffect;
 
-function workLoopSync() {
-  // Already timed out, so perform work without checking if we need to yield.
-  while (workInProgress !== null) {
-    workInProgress = performUnitOfWork(workInProgress);
-  }
-}
+    do {
+      {
+        invokeGuardedCallback(
+          null,
+          commitMutationEffects,
+          null,
+          root,
+          renderPriorityLevel
+        );
 
-function renderRootConcurrent(root, expirationTime) {
-  var prevExecutionContext = executionContext;
-  executionContext |= RenderContext;
-  var prevDispatcher = pushDispatcher(); // If the root or expiration time have changed, throw out the existing stack
-  // and prepare a fresh one. Otherwise we'll continue where we left off.
+        if (hasCaughtError()) {
+          if (!(nextEffect !== null)) {
+            throw Error("Should be working on an effect.");
+          }
 
-  if (
-    root !== workInProgressRoot ||
-    expirationTime !== renderExpirationTime$1
-  ) {
-    prepareFreshStack(root, expirationTime);
-    startWorkOnPendingInteractions(root, expirationTime);
-  }
+          var _error = clearCaughtError();
 
-  var prevInteractions = pushInteractions(root);
-  startWorkLoopTimer(workInProgress);
+          captureCommitPhaseError(nextEffect, _error);
+          nextEffect = nextEffect.nextEffect;
+        }
+      }
+    } while (nextEffect !== null);
 
-  do {
-    try {
-      workLoopConcurrent();
-      break;
-    } catch (thrownValue) {
-      handleError(root, thrownValue);
-    }
-  } while (true);
+    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
+    // the mutation phase, so that the previous tree is still current during
+    // componentWillUnmount, but before the layout phase, so that the finished
+    // work is current during componentDidMount/Update.
 
-  resetContextDependencies();
+    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
+    // the host tree after it's been mutated. The idiomatic use case for this is
+    // layout, but class component lifecycles also fire here for legacy reasons.
 
-  {
-    popInteractions(prevInteractions);
-  }
+    nextEffect = firstEffect;
 
-  popDispatcher(prevDispatcher);
-  executionContext = prevExecutionContext; // Check if the tree has completed.
+    do {
+      {
+        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);
 
-  if (workInProgress !== null) {
-    // Still work remaining.
-    stopInterruptedWorkLoopTimer();
-    return RootIncomplete;
-  } else {
-    // Completed the tree.
-    stopFinishedWorkLoopTimer(); // Set this to null to indicate there's no in-progress render.
+        if (hasCaughtError()) {
+          if (!(nextEffect !== null)) {
+            throw Error("Should be working on an effect.");
+          }
 
-    workInProgressRoot = null; // Return the final exit status.
+          var _error2 = clearCaughtError();
 
-    return workInProgressRootExitStatus;
-  }
-}
-/** @noinline */
+          captureCommitPhaseError(nextEffect, _error2);
+          nextEffect = nextEffect.nextEffect;
+        }
+      }
+    } while (nextEffect !== null);
 
-function workLoopConcurrent() {
-  // Perform work until Scheduler asks us to yield
-  while (workInProgress !== null && !shouldYield()) {
-    workInProgress = performUnitOfWork(workInProgress);
-  }
-}
+    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
+    // opportunity to paint.
 
-function performUnitOfWork(unitOfWork) {
-  // The current, flushed, state of this fiber is the alternate. Ideally
-  // nothing should rely on this, but relying on it here means that we don't
-  // need an additional field on the work in progress.
-  var current = unitOfWork.alternate;
-  startWorkTimer(unitOfWork);
-  setCurrentFiber(unitOfWork);
-  var next;
+    requestPaint();
 
-  if ((unitOfWork.mode & ProfileMode) !== NoMode) {
-    startProfilerTimer(unitOfWork);
-    next = beginWork$1(current, unitOfWork, renderExpirationTime$1);
-    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
+    {
+      popInteractions(prevInteractions);
+    }
+
+    executionContext = prevExecutionContext;
   } else {
-    next = beginWork$1(current, unitOfWork, renderExpirationTime$1);
+    // No effects.
+    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
+    // no effects.
+    // TODO: Maybe there's a better way to report this.
+
+    {
+      recordCommitTime();
+    }
   }
 
-  resetCurrentFiber();
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
 
-  if (next === null) {
-    // If this doesn't spawn new work, complete the current work.
-    next = completeUnitOfWork(unitOfWork);
-  }
+  if (rootDoesHavePassiveEffects) {
+    // This commit has passive effects. Stash a reference to them. But don't
+    // schedule a callback until after flushing layout work.
+    rootDoesHavePassiveEffects = false;
+    rootWithPendingPassiveEffects = root;
+    pendingPassiveEffectsLanes = lanes;
+    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
+  } else {
+    // We are done with the effect chain at this point so let's clear the
+    // nextEffect pointers to assist with GC. If we have passive effects, we'll
+    // clear this in flushPassiveEffects.
+    nextEffect = firstEffect;
 
-  ReactCurrentOwner$2.current = null;
-  return next;
-}
+    while (nextEffect !== null) {
+      var nextNextEffect = nextEffect.nextEffect;
+      nextEffect.nextEffect = null;
 
-function completeUnitOfWork(unitOfWork) {
-  // Attempt to complete the current unit of work, then move to the next
-  // sibling. If there are no more siblings, return to the parent fiber.
-  workInProgress = unitOfWork;
+      if (nextEffect.flags & Deletion) {
+        detachFiberAfterEffects(nextEffect);
+      }
 
-  do {
-    // The current, flushed, state of this fiber is the alternate. Ideally
-    // nothing should rely on this, but relying on it here means that we don't
-    // need an additional field on the work in progress.
-    var current = workInProgress.alternate;
-    var returnFiber = workInProgress.return; // Check if the work completed or if something threw.
+      nextEffect = nextNextEffect;
+    }
+  } // Read this again, since an effect might have updated it
 
-    if ((workInProgress.effectTag & Incomplete) === NoEffect) {
-      setCurrentFiber(workInProgress);
-      var next = void 0;
+  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root
 
-      if ((workInProgress.mode & ProfileMode) === NoMode) {
-        next = completeWork(current, workInProgress, renderExpirationTime$1);
-      } else {
-        startProfilerTimer(workInProgress);
-        next = completeWork(current, workInProgress, renderExpirationTime$1); // Update render duration assuming we didn't error.
+  if (remainingLanes !== NoLanes) {
+    {
+      if (spawnedWorkDuringRender !== null) {
+        var expirationTimes = spawnedWorkDuringRender;
+        spawnedWorkDuringRender = null;
 
-        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
+        for (var i = 0; i < expirationTimes.length; i++) {
+          scheduleInteractions(
+            root,
+            expirationTimes[i],
+            root.memoizedInteractions
+          );
+        }
       }
 
-      stopWorkTimer(workInProgress);
-      resetCurrentFiber();
-      resetChildExpirationTime(workInProgress);
+      schedulePendingInteractions(root, remainingLanes);
+    }
+  } else {
+    // If there's no remaining work, we can clear the set of already failed
+    // error boundaries.
+    legacyErrorBoundariesThatAlreadyFailed = null;
+  }
+
+  {
+    if (!rootDidHavePassiveEffects) {
+      // If there are no passive effects, then we can complete the pending interactions.
+      // Otherwise, we'll wait until after the passive effects are flushed.
+      // Wait to do this until after remaining work has been scheduled,
+      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
+      finishPendingInteractions(root, lanes);
+    }
+  }
 
-      if (next !== null) {
-        // Completing this fiber spawned new work. Work on that next.
-        return next;
-      }
+  if (remainingLanes === SyncLane) {
+    // Count the number of times the root synchronously re-renders without
+    // finishing. If there are too many, it indicates an infinite update loop.
+    if (root === rootWithNestedUpdates) {
+      nestedUpdateCount++;
+    } else {
+      nestedUpdateCount = 0;
+      rootWithNestedUpdates = root;
+    }
+  } else {
+    nestedUpdateCount = 0;
+  }
 
-      if (
-        returnFiber !== null && // Do not append effects to parents if a sibling failed to complete
-        (returnFiber.effectTag & Incomplete) === NoEffect
-      ) {
-        // Append all the effects of the subtree and this fiber onto the effect
-        // list of the parent. The completion order of the children affects the
-        // side-effect order.
-        if (returnFiber.firstEffect === null) {
-          returnFiber.firstEffect = workInProgress.firstEffect;
-        }
+  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
+  // additional work on this root is scheduled.
 
-        if (workInProgress.lastEffect !== null) {
-          if (returnFiber.lastEffect !== null) {
-            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
-          }
+  ensureRootIsScheduled(root, now());
 
-          returnFiber.lastEffect = workInProgress.lastEffect;
-        } // If this fiber had side-effects, we append it AFTER the children's
-        // side-effects. We can perform certain side-effects earlier if needed,
-        // by doing multiple passes over the effect list. We don't want to
-        // schedule our own side-effect on our own list because if end up
-        // reusing children we'll schedule this effect onto itself since we're
-        // at the end.
+  if (hasUncaughtError) {
+    hasUncaughtError = false;
+    var _error3 = firstUncaughtError;
+    firstUncaughtError = null;
+    throw _error3;
+  }
 
-        var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect
-        // list. PerformedWork effect is read by React DevTools but shouldn't be
-        // committed.
+  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
+    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
+    // synchronously, but layout updates should be deferred until the end
+    // of the batch.
 
-        if (effectTag > PerformedWork) {
-          if (returnFiber.lastEffect !== null) {
-            returnFiber.lastEffect.nextEffect = workInProgress;
-          } else {
-            returnFiber.firstEffect = workInProgress;
-          }
+    return null;
+  } // If layout work was scheduled, flush it now.
 
-          returnFiber.lastEffect = workInProgress;
-        }
-      }
-    } else {
-      // This fiber did not complete because something threw. Pop values off
-      // the stack without entering the complete phase. If this is a boundary,
-      // capture values if possible.
-      var _next = unwindWork(workInProgress); // Because this fiber did not complete, don't reset its expiration time.
+  flushSyncCallbackQueue();
 
-      if ((workInProgress.mode & ProfileMode) !== NoMode) {
-        // Record the render duration for the fiber that errored.
-        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false); // Include the time spent working on failed children before continuing.
+  return null;
+}
 
-        var actualDuration = workInProgress.actualDuration;
-        var child = workInProgress.child;
+function commitBeforeMutationEffects() {
+  while (nextEffect !== null) {
+    var current = nextEffect.alternate;
 
-        while (child !== null) {
-          actualDuration += child.actualDuration;
-          child = child.sibling;
+    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
+      if ((nextEffect.flags & Deletion) !== NoFlags) {
+        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
+          shouldFireAfterActiveInstanceBlur = true;
+        }
+      } else {
+        // TODO: Move this out of the hot path using a dedicated effect tag.
+        if (
+          nextEffect.tag === SuspenseComponent &&
+          isSuspenseBoundaryBeingHidden(current, nextEffect) &&
+          doesFiberContain(nextEffect, focusedInstanceHandle)
+        ) {
+          shouldFireAfterActiveInstanceBlur = true;
         }
-
-        workInProgress.actualDuration = actualDuration;
       }
+    }
 
-      if (_next !== null) {
-        // If completing this work spawned new work, do that next. We'll come
-        // back here again.
-        // Since we're restarting, remove anything that is not a host effect
-        // from the effect tag.
-        // TODO: The name stopFailedWorkTimer is misleading because Suspense
-        // also captures and restarts.
-        stopFailedWorkTimer(workInProgress);
-        _next.effectTag &= HostEffectMask;
-        return _next;
-      }
+    var flags = nextEffect.flags;
 
-      stopWorkTimer(workInProgress);
+    if ((flags & Snapshot) !== NoFlags) {
+      setCurrentFiber(nextEffect);
+      commitBeforeMutationLifeCycles(current, nextEffect);
+      resetCurrentFiber();
+    }
 
-      if (returnFiber !== null) {
-        // Mark the parent fiber as incomplete and clear its effect list.
-        returnFiber.firstEffect = returnFiber.lastEffect = null;
-        returnFiber.effectTag |= Incomplete;
+    if ((flags & Passive) !== NoFlags) {
+      // If there are passive effects, schedule a callback to flush at
+      // the earliest opportunity.
+      if (!rootDoesHavePassiveEffects) {
+        rootDoesHavePassiveEffects = true;
+        scheduleCallback(NormalPriority$1, function() {
+          flushPassiveEffects();
+          return null;
+        });
       }
     }
 
-    var siblingFiber = workInProgress.sibling;
+    nextEffect = nextEffect.nextEffect;
+  }
+}
 
-    if (siblingFiber !== null) {
-      // If there is more work to do in this returnFiber, do that next.
-      return siblingFiber;
-    } // Otherwise, return to the parent
+function commitMutationEffects(root, renderPriorityLevel) {
+  // TODO: Should probably move the bulk of this function to commitWork.
+  while (nextEffect !== null) {
+    setCurrentFiber(nextEffect);
+    var flags = nextEffect.flags;
 
-    workInProgress = returnFiber;
-  } while (workInProgress !== null); // We've reached the root.
+    if (flags & ContentReset) {
+      commitResetTextContent(nextEffect);
+    }
 
-  if (workInProgressRootExitStatus === RootIncomplete) {
-    workInProgressRootExitStatus = RootCompleted;
-  }
+    if (flags & Ref) {
+      var current = nextEffect.alternate;
 
-  return null;
-}
+      if (current !== null) {
+        commitDetachRef(current);
+      }
+    } // The following switch statement is only concerned about placement,
+    // updates, and deletions. To avoid needing to add a case for every possible
+    // bitmap value, we remove the secondary effects from the effect tag and
+    // switch on that value.
 
-function getRemainingExpirationTime(fiber) {
-  var updateExpirationTime = fiber.expirationTime;
-  var childExpirationTime = fiber.childExpirationTime;
-  return updateExpirationTime > childExpirationTime
-    ? updateExpirationTime
-    : childExpirationTime;
-}
+    var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
 
-function resetChildExpirationTime(completedWork) {
-  if (
-    renderExpirationTime$1 !== Never &&
-    completedWork.childExpirationTime === Never
-  ) {
-    // The children of this component are hidden. Don't bubble their
-    // expiration times.
-    return;
-  }
+    switch (primaryFlags) {
+      case Placement: {
+        commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
+        // inserted, before any life-cycles like componentDidMount gets called.
+        // TODO: findDOMNode doesn't rely on this any more but isMounted does
+        // and isMounted is deprecated anyway so we should be able to kill this.
 
-  var newChildExpirationTime = NoWork; // Bubble up the earliest expiration time.
+        nextEffect.flags &= ~Placement;
+        break;
+      }
 
-  if ((completedWork.mode & ProfileMode) !== NoMode) {
-    // In profiling mode, resetChildExpirationTime is also used to reset
-    // profiler durations.
-    var actualDuration = completedWork.actualDuration;
-    var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
-    // only be updated if work is done on the fiber (i.e. it doesn't bailout).
-    // When work is done, it should bubble to the parent's actualDuration. If
-    // the fiber has not been cloned though, (meaning no work was done), then
-    // this value will reflect the amount of time spent working on a previous
-    // render. In that case it should not bubble. We determine whether it was
-    // cloned by comparing the child pointer.
+      case PlacementAndUpdate: {
+        // Placement
+        commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
+        // inserted, before any life-cycles like componentDidMount gets called.
 
-    var shouldBubbleActualDurations =
-      completedWork.alternate === null ||
-      completedWork.child !== completedWork.alternate.child;
-    var child = completedWork.child;
+        nextEffect.flags &= ~Placement; // Update
 
-    while (child !== null) {
-      var childUpdateExpirationTime = child.expirationTime;
-      var childChildExpirationTime = child.childExpirationTime;
+        var _current = nextEffect.alternate;
+        commitWork(_current, nextEffect);
+        break;
+      }
 
-      if (childUpdateExpirationTime > newChildExpirationTime) {
-        newChildExpirationTime = childUpdateExpirationTime;
+      case Hydrating: {
+        nextEffect.flags &= ~Hydrating;
+        break;
       }
 
-      if (childChildExpirationTime > newChildExpirationTime) {
-        newChildExpirationTime = childChildExpirationTime;
+      case HydratingAndUpdate: {
+        nextEffect.flags &= ~Hydrating; // Update
+
+        var _current2 = nextEffect.alternate;
+        commitWork(_current2, nextEffect);
+        break;
       }
 
-      if (shouldBubbleActualDurations) {
-        actualDuration += child.actualDuration;
+      case Update: {
+        var _current3 = nextEffect.alternate;
+        commitWork(_current3, nextEffect);
+        break;
       }
 
-      treeBaseDuration += child.treeBaseDuration;
-      child = child.sibling;
+      case Deletion: {
+        commitDeletion(root, nextEffect);
+        break;
+      }
     }
 
-    completedWork.actualDuration = actualDuration;
-    completedWork.treeBaseDuration = treeBaseDuration;
-  } else {
-    var _child = completedWork.child;
+    resetCurrentFiber();
+    nextEffect = nextEffect.nextEffect;
+  }
+}
 
-    while (_child !== null) {
-      var _childUpdateExpirationTime = _child.expirationTime;
-      var _childChildExpirationTime = _child.childExpirationTime;
+function commitLayoutEffects(root, committedLanes) {
+  while (nextEffect !== null) {
+    setCurrentFiber(nextEffect);
+    var flags = nextEffect.flags;
 
-      if (_childUpdateExpirationTime > newChildExpirationTime) {
-        newChildExpirationTime = _childUpdateExpirationTime;
-      }
+    if (flags & (Update | Callback)) {
+      var current = nextEffect.alternate;
+      commitLifeCycles(root, current, nextEffect);
+    }
 
-      if (_childChildExpirationTime > newChildExpirationTime) {
-        newChildExpirationTime = _childChildExpirationTime;
+    {
+      if (flags & Ref) {
+        commitAttachRef(nextEffect);
       }
-
-      _child = _child.sibling;
     }
-  }
-
-  completedWork.childExpirationTime = newChildExpirationTime;
-}
 
-function commitRoot(root) {
-  var renderPriorityLevel = getCurrentPriorityLevel();
-  runWithPriority(
-    ImmediatePriority,
-    commitRootImpl.bind(null, root, renderPriorityLevel)
-  );
-  return null;
+    resetCurrentFiber();
+    nextEffect = nextEffect.nextEffect;
+  }
 }
 
-function commitRootImpl(root, renderPriorityLevel) {
-  do {
-    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
-    // means `flushPassiveEffects` will sometimes result in additional
-    // passive effects. So we need to keep flushing in a loop until there are
-    // no more pending effects.
-    // TODO: Might be better if `flushPassiveEffects` did not automatically
-    // flush synchronous work at the end, to avoid factoring hazards like this.
-    flushPassiveEffects();
-  } while (rootWithPendingPassiveEffects !== null);
-
-  flushRenderPhaseStrictModeWarningsInDEV();
+function flushPassiveEffects() {
+  // Returns whether passive effects were flushed.
+  if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
+    var priorityLevel =
+      pendingPassiveEffectsRenderPriority > NormalPriority$1
+        ? NormalPriority$1
+        : pendingPassiveEffectsRenderPriority;
+    pendingPassiveEffectsRenderPriority = NoPriority$1;
 
-  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
-    throw Error("Should not already be working.");
+    {
+      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
+    }
   }
 
-  var finishedWork = root.finishedWork;
-  var expirationTime = root.finishedExpirationTime;
+  return false;
+}
+function enqueuePendingPassiveHookEffectMount(fiber, effect) {
+  pendingPassiveHookEffectsMount.push(effect, fiber);
 
-  if (finishedWork === null) {
-    return null;
+  if (!rootDoesHavePassiveEffects) {
+    rootDoesHavePassiveEffects = true;
+    scheduleCallback(NormalPriority$1, function() {
+      flushPassiveEffects();
+      return null;
+    });
   }
+}
+function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
+  pendingPassiveHookEffectsUnmount.push(effect, fiber);
 
-  root.finishedWork = null;
-  root.finishedExpirationTime = NoWork;
+  {
+    fiber.flags |= PassiveUnmountPendingDev;
+    var alternate = fiber.alternate;
 
-  if (!(finishedWork !== root.current)) {
-    throw Error(
-      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
-    );
-  } // commitRoot never returns a continuation; it always finishes synchronously.
-  // So we can clear these now to allow a new callback to be scheduled.
+    if (alternate !== null) {
+      alternate.flags |= PassiveUnmountPendingDev;
+    }
+  }
 
-  root.callbackNode = null;
-  root.callbackExpirationTime = NoWork;
-  root.callbackPriority = NoPriority;
-  root.nextKnownPendingLevel = NoWork;
-  startCommitTimer(); // Update the first and last pending times on this root. The new first
-  // pending time is whatever is left on the root fiber.
+  if (!rootDoesHavePassiveEffects) {
+    rootDoesHavePassiveEffects = true;
+    scheduleCallback(NormalPriority$1, function() {
+      flushPassiveEffects();
+      return null;
+    });
+  }
+}
 
-  var remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(
-    finishedWork
-  );
-  markRootFinishedAtTime(
-    root,
-    expirationTime,
-    remainingExpirationTimeBeforeCommit
-  );
+function invokePassiveEffectCreate(effect) {
+  var create = effect.create;
+  effect.destroy = create();
+}
 
-  if (root === workInProgressRoot) {
-    // We can reset these now that they are finished.
-    workInProgressRoot = null;
-    workInProgress = null;
-    renderExpirationTime$1 = NoWork;
-  } // This indicates that the last root we worked on is not the same one that
-  // we're committing now. This most commonly happens when a suspended root
-  // times out.
-  // Get the list of effects.
+function flushPassiveEffectsImpl() {
+  if (rootWithPendingPassiveEffects === null) {
+    return false;
+  }
 
-  var firstEffect;
+  var root = rootWithPendingPassiveEffects;
+  var lanes = pendingPassiveEffectsLanes;
+  rootWithPendingPassiveEffects = null;
+  pendingPassiveEffectsLanes = NoLanes;
 
-  if (finishedWork.effectTag > PerformedWork) {
-    // A fiber's effect list consists only of its children, not itself. So if
-    // the root has an effect, we need to add it to the end of the list. The
-    // resulting list is the set that would belong to the root's parent, if it
-    // had one; that is, all the effects in the tree including the root.
-    if (finishedWork.lastEffect !== null) {
-      finishedWork.lastEffect.nextEffect = finishedWork;
-      firstEffect = finishedWork.firstEffect;
-    } else {
-      firstEffect = finishedWork;
-    }
-  } else {
-    // There is no effect on the root.
-    firstEffect = finishedWork.firstEffect;
+  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
+    throw Error("Cannot flush passive effects while already rendering.");
   }
 
-  if (firstEffect !== null) {
-    var prevExecutionContext = executionContext;
-    executionContext |= CommitContext;
-    var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles
+  {
+    isFlushingPassiveEffects = true;
+  }
 
-    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
-    // of the effect list for each phase: all mutation effects come before all
-    // layout effects, and so on.
-    // The first phase a "before mutation" phase. We use this phase to read the
-    // state of the host tree right before we mutate it. This is where
-    // getSnapshotBeforeUpdate is called.
+  var prevExecutionContext = executionContext;
+  executionContext |= CommitContext;
+  var prevInteractions = pushInteractions(root); // It's important that ALL pending passive effect destroy functions are called
+  // before ANY passive effect create functions are called.
+  // Otherwise effects in sibling components might interfere with each other.
+  // e.g. a destroy function in one component may unintentionally override a ref
+  // value set by a create function in another component.
+  // Layout effects have the same constraint.
+  // First pass: Destroy stale passive effects.
+
+  var unmountEffects = pendingPassiveHookEffectsUnmount;
+  pendingPassiveHookEffectsUnmount = [];
+
+  for (var i = 0; i < unmountEffects.length; i += 2) {
+    var _effect = unmountEffects[i];
+    var fiber = unmountEffects[i + 1];
+    var destroy = _effect.destroy;
+    _effect.destroy = undefined;
 
-    startCommitSnapshotEffectsTimer();
-    prepareForCommit(root.containerInfo);
-    nextEffect = firstEffect;
+    {
+      fiber.flags &= ~PassiveUnmountPendingDev;
+      var alternate = fiber.alternate;
 
-    do {
+      if (alternate !== null) {
+        alternate.flags &= ~PassiveUnmountPendingDev;
+      }
+    }
+
+    if (typeof destroy === "function") {
       {
-        invokeGuardedCallback(null, commitBeforeMutationEffects, null);
+        setCurrentFiber(fiber);
+
+        {
+          invokeGuardedCallback(null, destroy, null);
+        }
 
         if (hasCaughtError()) {
-          if (!(nextEffect !== null)) {
+          if (!(fiber !== null)) {
             throw Error("Should be working on an effect.");
           }
 
           var error = clearCaughtError();
-          captureCommitPhaseError(nextEffect, error);
-          nextEffect = nextEffect.nextEffect;
+          captureCommitPhaseError(fiber, error);
         }
+
+        resetCurrentFiber();
       }
-    } while (nextEffect !== null);
+    }
+  } // Second pass: Create new passive effects.
 
-    stopCommitSnapshotEffectsTimer();
+  var mountEffects = pendingPassiveHookEffectsMount;
+  pendingPassiveHookEffectsMount = [];
 
-    {
-      // Mark the current commit time to be shared by all Profilers in this
-      // batch. This enables them to be grouped later.
-      recordCommitTime();
-    } // The next phase is the mutation phase, where we mutate the host tree.
+  for (var _i = 0; _i < mountEffects.length; _i += 2) {
+    var _effect2 = mountEffects[_i];
+    var _fiber = mountEffects[_i + 1];
 
-    startCommitHostEffectsTimer();
-    nextEffect = firstEffect;
+    {
+      setCurrentFiber(_fiber);
 
-    do {
       {
-        invokeGuardedCallback(
-          null,
-          commitMutationEffects,
-          null,
-          root,
-          renderPriorityLevel
-        );
+        invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
+      }
 
-        if (hasCaughtError()) {
-          if (!(nextEffect !== null)) {
-            throw Error("Should be working on an effect.");
-          }
+      if (hasCaughtError()) {
+        if (!(_fiber !== null)) {
+          throw Error("Should be working on an effect.");
+        }
 
-          var _error = clearCaughtError();
+        var _error4 = clearCaughtError();
 
-          captureCommitPhaseError(nextEffect, _error);
-          nextEffect = nextEffect.nextEffect;
-        }
+        captureCommitPhaseError(_fiber, _error4);
       }
-    } while (nextEffect !== null);
 
-    stopCommitHostEffectsTimer();
-    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
-    // the mutation phase, so that the previous tree is still current during
-    // componentWillUnmount, but before the layout phase, so that the finished
-    // work is current during componentDidMount/Update.
+      resetCurrentFiber();
+    }
+  } // Note: This currently assumes there are no passive effects on the root fiber
+  // because the root is not part of its own effect list.
+  // This could change in the future.
 
-    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
-    // the host tree after it's been mutated. The idiomatic use case for this is
-    // layout, but class component lifecycles also fire here for legacy reasons.
+  var effect = root.current.firstEffect;
 
-    startCommitLifeCyclesTimer();
-    nextEffect = firstEffect;
+  while (effect !== null) {
+    var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC
 
-    do {
-      {
-        invokeGuardedCallback(
-          null,
-          commitLayoutEffects,
-          null,
-          root,
-          expirationTime
-        );
+    effect.nextEffect = null;
 
-        if (hasCaughtError()) {
-          if (!(nextEffect !== null)) {
-            throw Error("Should be working on an effect.");
-          }
+    if (effect.flags & Deletion) {
+      detachFiberAfterEffects(effect);
+    }
 
-          var _error2 = clearCaughtError();
+    effect = nextNextEffect;
+  }
 
-          captureCommitPhaseError(nextEffect, _error2);
-          nextEffect = nextEffect.nextEffect;
+  {
+    popInteractions(prevInteractions);
+    finishPendingInteractions(root, lanes);
+  }
+
+  {
+    isFlushingPassiveEffects = false;
+  }
+
+  executionContext = prevExecutionContext;
+  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
+  // exceeds the limit, we'll fire a warning.
+
+  nestedPassiveUpdateCount =
+    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
+  return true;
+}
+
+function isAlreadyFailedLegacyErrorBoundary(instance) {
+  return (
+    legacyErrorBoundariesThatAlreadyFailed !== null &&
+    legacyErrorBoundariesThatAlreadyFailed.has(instance)
+  );
+}
+function markLegacyErrorBoundaryAsFailed(instance) {
+  if (legacyErrorBoundariesThatAlreadyFailed === null) {
+    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
+  } else {
+    legacyErrorBoundariesThatAlreadyFailed.add(instance);
+  }
+}
+
+function prepareToThrowUncaughtError(error) {
+  if (!hasUncaughtError) {
+    hasUncaughtError = true;
+    firstUncaughtError = error;
+  }
+}
+
+var onUncaughtError = prepareToThrowUncaughtError;
+
+function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
+  var errorInfo = createCapturedValue(error, sourceFiber);
+  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
+  enqueueUpdate(rootFiber, update);
+  var eventTime = requestEventTime();
+  var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
+
+  if (root !== null) {
+    markRootUpdated(root, SyncLane, eventTime);
+    ensureRootIsScheduled(root, eventTime);
+    schedulePendingInteractions(root, SyncLane);
+  }
+}
+
+function captureCommitPhaseError(sourceFiber, error) {
+  if (sourceFiber.tag === HostRoot) {
+    // Error was thrown at the root. There is no parent, so the root
+    // itself should capture it.
+    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
+    return;
+  }
+
+  var fiber = sourceFiber.return;
+
+  while (fiber !== null) {
+    if (fiber.tag === HostRoot) {
+      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
+      return;
+    } else if (fiber.tag === ClassComponent) {
+      var ctor = fiber.type;
+      var instance = fiber.stateNode;
+
+      if (
+        typeof ctor.getDerivedStateFromError === "function" ||
+        (typeof instance.componentDidCatch === "function" &&
+          !isAlreadyFailedLegacyErrorBoundary(instance))
+      ) {
+        var errorInfo = createCapturedValue(error, sourceFiber);
+        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
+        enqueueUpdate(fiber, update);
+        var eventTime = requestEventTime();
+        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
+
+        if (root !== null) {
+          markRootUpdated(root, SyncLane, eventTime);
+          ensureRootIsScheduled(root, eventTime);
+          schedulePendingInteractions(root, SyncLane);
+        } else {
+          // This component has already been unmounted.
+          // We can't schedule any follow up work for the root because the fiber is already unmounted,
+          // but we can still call the log-only boundary so the error isn't swallowed.
+          //
+          // TODO This is only a temporary bandaid for the old reconciler fork.
+          // We can delete this special case once the new fork is merged.
+          if (
+            typeof instance.componentDidCatch === "function" &&
+            !isAlreadyFailedLegacyErrorBoundary(instance)
+          ) {
+            try {
+              instance.componentDidCatch(error, errorInfo);
+            } catch (errorToIgnore) {
+              // TODO Ignore this error? Rethrow it?
+              // This is kind of an edge case.
+            }
+          }
         }
+
+        return;
       }
-    } while (nextEffect !== null);
+    }
 
-    stopCommitLifeCyclesTimer();
-    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
-    // opportunity to paint.
+    fiber = fiber.return;
+  }
+}
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
+  var pingCache = root.pingCache;
 
-    requestPaint();
+  if (pingCache !== null) {
+    // The wakeable resolved, so we no longer need to memoize, because it will
+    // never be thrown again.
+    pingCache.delete(wakeable);
+  }
 
-    {
-      popInteractions(prevInteractions);
+  var eventTime = requestEventTime();
+  markRootPinged(root, pingedLanes);
+
+  if (
+    workInProgressRoot === root &&
+    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)
+  ) {
+    // Received a ping at the same priority level at which we're currently
+    // rendering. We might want to restart this render. This should mirror
+    // the logic of whether or not a root suspends once it completes.
+    // TODO: If we're rendering sync either due to Sync, Batched or expired,
+    // we should probably never restart.
+    // If we're suspended with delay, or if it's a retry, we'll always suspend
+    // so we can always restart.
+    if (
+      workInProgressRootExitStatus === RootSuspendedWithDelay ||
+      (workInProgressRootExitStatus === RootSuspended &&
+        includesOnlyRetries(workInProgressRootRenderLanes) &&
+        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
+    ) {
+      // Restart from the root.
+      prepareFreshStack(root, NoLanes);
+    } else {
+      // Even though we can't restart right now, we might get an
+      // opportunity later. So we mark this render as having a ping.
+      workInProgressRootPingedLanes = mergeLanes(
+        workInProgressRootPingedLanes,
+        pingedLanes
+      );
     }
+  }
 
-    executionContext = prevExecutionContext;
-  } else {
-    // No effects.
-    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
-    // no effects.
-    // TODO: Maybe there's a better way to report this.
+  ensureRootIsScheduled(root, eventTime);
+  schedulePendingInteractions(root, pingedLanes);
+}
+
+function retryTimedOutBoundary(boundaryFiber, retryLane) {
+  // The boundary fiber (a Suspense component or SuspenseList component)
+  // previously was rendered in its fallback state. One of the promises that
+  // suspended it has resolved, which means at least part of the tree was
+  // likely unblocked. Try rendering again, at a new expiration time.
+  if (retryLane === NoLane) {
+    retryLane = requestRetryLane(boundaryFiber);
+  } // TODO: Special case idle priority?
+
+  var eventTime = requestEventTime();
+  var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
+
+  if (root !== null) {
+    markRootUpdated(root, retryLane, eventTime);
+    ensureRootIsScheduled(root, eventTime);
+    schedulePendingInteractions(root, retryLane);
+  }
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
+  var retryLane = NoLane; // Default
+
+  var retryCache;
+
+  {
+    retryCache = boundaryFiber.stateNode;
+  }
+
+  if (retryCache !== null) {
+    // The wakeable resolved, so we no longer need to memoize, because it will
+    // never be thrown again.
+    retryCache.delete(wakeable);
+  }
+
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+} // Computes the next Just Noticeable Difference (JND) boundary.
+// The theory is that a person can't tell the difference between small differences in time.
+// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
+// difference in the experience. However, waiting for longer might mean that we can avoid
+// showing an intermediate loading state. The longer we have already waited, the harder it
+// is to tell small differences in time. Therefore, the longer we've already waited,
+// the longer we can wait additionally. At some point we have to give up though.
+// We pick a train model where the next boundary commits at a consistent schedule.
+// These particular numbers are vague estimates. We expect to adjust them based on research.
 
-    startCommitSnapshotEffectsTimer();
-    stopCommitSnapshotEffectsTimer();
+function jnd(timeElapsed) {
+  return timeElapsed < 120
+    ? 120
+    : timeElapsed < 480
+    ? 480
+    : timeElapsed < 1080
+    ? 1080
+    : timeElapsed < 1920
+    ? 1920
+    : timeElapsed < 3000
+    ? 3000
+    : timeElapsed < 4320
+    ? 4320
+    : ceil(timeElapsed / 1960) * 1960;
+}
+
+function checkForNestedUpdates() {
+  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
+    nestedUpdateCount = 0;
+    rootWithNestedUpdates = null;
 
     {
-      recordCommitTime();
+      throw Error(
+        "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
+      );
     }
-
-    startCommitHostEffectsTimer();
-    stopCommitHostEffectsTimer();
-    startCommitLifeCyclesTimer();
-    stopCommitLifeCyclesTimer();
   }
 
-  stopCommitTimer();
-  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
-
-  if (rootDoesHavePassiveEffects) {
-    // This commit has passive effects. Stash a reference to them. But don't
-    // schedule a callback until after flushing layout work.
-    rootDoesHavePassiveEffects = false;
-    rootWithPendingPassiveEffects = root;
-    pendingPassiveEffectsExpirationTime = expirationTime;
-    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
-  } else {
-    // We are done with the effect chain at this point so let's clear the
-    // nextEffect pointers to assist with GC. If we have passive effects, we'll
-    // clear this in flushPassiveEffects.
-    nextEffect = firstEffect;
+  {
+    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
+      nestedPassiveUpdateCount = 0;
 
-    while (nextEffect !== null) {
-      var nextNextEffect = nextEffect.nextEffect;
-      nextEffect.nextEffect = null;
-      nextEffect = nextNextEffect;
+      error(
+        "Maximum update depth exceeded. This can happen when a component " +
+          "calls setState inside useEffect, but useEffect either doesn't " +
+          "have a dependency array, or one of the dependencies changes on " +
+          "every render."
+      );
     }
-  } // Check if there's remaining work on this root
+  }
+}
 
-  var remainingExpirationTime = root.firstPendingTime;
+function flushRenderPhaseStrictModeWarningsInDEV() {
+  {
+    ReactStrictModeWarnings.flushLegacyContextWarning();
 
-  if (remainingExpirationTime !== NoWork) {
     {
-      if (spawnedWorkDuringRender !== null) {
-        var expirationTimes = spawnedWorkDuringRender;
-        spawnedWorkDuringRender = null;
-
-        for (var i = 0; i < expirationTimes.length; i++) {
-          scheduleInteractions(
-            root,
-            expirationTimes[i],
-            root.memoizedInteractions
-          );
-        }
-      }
-
-      schedulePendingInteractions(root, remainingExpirationTime);
+      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
     }
-  } else {
-    // If there's no remaining work, we can clear the set of already failed
-    // error boundaries.
-    legacyErrorBoundariesThatAlreadyFailed = null;
   }
+}
+
+var didWarnStateUpdateForNotYetMountedComponent = null;
 
+function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
   {
-    if (!rootDidHavePassiveEffects) {
-      // If there are no passive effects, then we can complete the pending interactions.
-      // Otherwise, we'll wait until after the passive effects are flushed.
-      // Wait to do this until after remaining work has been scheduled,
-      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
-      finishPendingInteractions(root, expirationTime);
+    if ((executionContext & RenderContext) !== NoContext) {
+      // We let the other warning about render phase updates deal with this one.
+      return;
     }
-  }
 
-  if (remainingExpirationTime === Sync) {
-    // Count the number of times the root synchronously re-renders without
-    // finishing. If there are too many, it indicates an infinite update loop.
-    if (root === rootWithNestedUpdates) {
-      nestedUpdateCount++;
-    } else {
-      nestedUpdateCount = 0;
-      rootWithNestedUpdates = root;
+    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
+      return;
     }
-  } else {
-    nestedUpdateCount = 0;
-  }
 
-  onCommitRoot(finishedWork.stateNode, expirationTime); // Always call this before exiting `commitRoot`, to ensure that any
-  // additional work on this root is scheduled.
+    var tag = fiber.tag;
 
-  ensureRootIsScheduled(root);
+    if (
+      tag !== IndeterminateComponent &&
+      tag !== HostRoot &&
+      tag !== ClassComponent &&
+      tag !== FunctionComponent &&
+      tag !== ForwardRef &&
+      tag !== MemoComponent &&
+      tag !== SimpleMemoComponent
+    ) {
+      // Only warn for user-defined components, not internal ones like Suspense.
+      return;
+    } // We show the whole stack but dedupe on the top component's name because
+    // the problematic code almost always lies inside that component.
 
-  if (hasUncaughtError) {
-    hasUncaughtError = false;
-    var _error3 = firstUncaughtError;
-    firstUncaughtError = null;
-    throw _error3;
-  }
+    var componentName = getComponentName(fiber.type) || "ReactComponent";
 
-  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
-    // This is a legacy edge case. We just committed the initial mount of
-    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
-    // synchronously, but layout updates should be deferred until the end
-    // of the batch.
-    return null;
-  } // If layout work was scheduled, flush it now.
+    if (didWarnStateUpdateForNotYetMountedComponent !== null) {
+      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
+        return;
+      }
 
-  flushSyncCallbackQueue();
-  return null;
-}
+      didWarnStateUpdateForNotYetMountedComponent.add(componentName);
+    } else {
+      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
+    }
 
-function commitBeforeMutationEffects() {
-  while (nextEffect !== null) {
-    var effectTag = nextEffect.effectTag;
+    var previousFiber = current;
 
-    if ((effectTag & Snapshot) !== NoEffect) {
-      setCurrentFiber(nextEffect);
-      recordEffect();
-      var current = nextEffect.alternate;
-      commitBeforeMutationLifeCycles(current, nextEffect);
-      resetCurrentFiber();
-    }
+    try {
+      setCurrentFiber(fiber);
 
-    if ((effectTag & Passive) !== NoEffect) {
-      // If there are passive effects, schedule a callback to flush at
-      // the earliest opportunity.
-      if (!rootDoesHavePassiveEffects) {
-        rootDoesHavePassiveEffects = true;
-        scheduleCallback(NormalPriority, function() {
-          flushPassiveEffects();
-          return null;
-        });
+      error(
+        "Can't perform a React state update on a component that hasn't mounted yet. " +
+          "This indicates that you have a side-effect in your render function that " +
+          "asynchronously later calls tries to update the component. Move this work to " +
+          "useEffect instead."
+      );
+    } finally {
+      if (previousFiber) {
+        setCurrentFiber(fiber);
+      } else {
+        resetCurrentFiber();
       }
     }
-
-    nextEffect = nextEffect.nextEffect;
   }
 }
 
-function commitMutationEffects(root, renderPriorityLevel) {
-  // TODO: Should probably move the bulk of this function to commitWork.
-  while (nextEffect !== null) {
-    setCurrentFiber(nextEffect);
-    var effectTag = nextEffect.effectTag;
-
-    if (effectTag & ContentReset) {
-      commitResetTextContent(nextEffect);
-    }
+var didWarnStateUpdateForUnmountedComponent = null;
 
-    if (effectTag & Ref) {
-      var current = nextEffect.alternate;
+function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
+  {
+    var tag = fiber.tag;
 
-      if (current !== null) {
-        commitDetachRef(current);
-      }
-    } // The following switch statement is only concerned about placement,
-    // updates, and deletions. To avoid needing to add a case for every possible
-    // bitmap value, we remove the secondary effects from the effect tag and
-    // switch on that value.
+    if (
+      tag !== HostRoot &&
+      tag !== ClassComponent &&
+      tag !== FunctionComponent &&
+      tag !== ForwardRef &&
+      tag !== MemoComponent &&
+      tag !== SimpleMemoComponent
+    ) {
+      // Only warn for user-defined components, not internal ones like Suspense.
+      return;
+    } // If there are pending passive effects unmounts for this Fiber,
+    // we can assume that they would have prevented this update.
 
-    var primaryEffectTag =
-      effectTag & (Placement | Update | Deletion | Hydrating);
+    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
+      return;
+    } // We show the whole stack but dedupe on the top component's name because
+    // the problematic code almost always lies inside that component.
 
-    switch (primaryEffectTag) {
-      case Placement: {
-        commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
-        // inserted, before any life-cycles like componentDidMount gets called.
-        // TODO: findDOMNode doesn't rely on this any more but isMounted does
-        // and isMounted is deprecated anyway so we should be able to kill this.
+    var componentName = getComponentName(fiber.type) || "ReactComponent";
 
-        nextEffect.effectTag &= ~Placement;
-        break;
+    if (didWarnStateUpdateForUnmountedComponent !== null) {
+      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
+        return;
       }
 
-      case PlacementAndUpdate: {
-        // Placement
-        commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
-        // inserted, before any life-cycles like componentDidMount gets called.
+      didWarnStateUpdateForUnmountedComponent.add(componentName);
+    } else {
+      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
+    }
 
-        nextEffect.effectTag &= ~Placement; // Update
+    if (isFlushingPassiveEffects);
+    else {
+      var previousFiber = current;
 
-        var _current = nextEffect.alternate;
-        commitWork(_current, nextEffect);
-        break;
-      }
+      try {
+        setCurrentFiber(fiber);
 
-      case Hydrating: {
-        nextEffect.effectTag &= ~Hydrating;
-        break;
+        error(
+          "Can't perform a React state update on an unmounted component. This " +
+            "is a no-op, but it indicates a memory leak in your application. To " +
+            "fix, cancel all subscriptions and asynchronous tasks in %s.",
+          tag === ClassComponent
+            ? "the componentWillUnmount method"
+            : "a useEffect cleanup function"
+        );
+      } finally {
+        if (previousFiber) {
+          setCurrentFiber(fiber);
+        } else {
+          resetCurrentFiber();
+        }
       }
+    }
+  }
+}
 
-      case HydratingAndUpdate: {
-        nextEffect.effectTag &= ~Hydrating; // Update
+var beginWork$1;
 
-        var _current2 = nextEffect.alternate;
-        commitWork(_current2, nextEffect);
-        break;
-      }
+{
+  var dummyFiber = null;
 
-      case Update: {
-        var _current3 = nextEffect.alternate;
-        commitWork(_current3, nextEffect);
-        break;
-      }
+  beginWork$1 = function(current, unitOfWork, lanes) {
+    // If a component throws an error, we replay it again in a synchronously
+    // dispatched event, so that the debugger will treat it as an uncaught
+    // error See ReactErrorUtils for more information.
+    // Before entering the begin phase, copy the work-in-progress onto a dummy
+    // fiber. If beginWork throws, we'll use this to reset the state.
+    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(
+      dummyFiber,
+      unitOfWork
+    );
 
-      case Deletion: {
-        commitDeletion(root, nextEffect, renderPriorityLevel);
-        break;
-      }
-    } // TODO: Only record a mutation effect if primaryEffectTag is non-zero.
+    try {
+      return beginWork(current, unitOfWork, lanes);
+    } catch (originalError) {
+      if (
+        originalError !== null &&
+        typeof originalError === "object" &&
+        typeof originalError.then === "function"
+      ) {
+        // Don't replay promises. Treat everything else like an error.
+        throw originalError;
+      } // Keep this code in sync with handleError; any changes here must have
+      // corresponding changes there.
+
+      resetContextDependencies();
+      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
+      // same fiber again.
+      // Unwind the failed stack frame
+
+      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.
+
+      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
 
-    recordEffect();
-    resetCurrentFiber();
-    nextEffect = nextEffect.nextEffect;
-  }
-}
+      if (unitOfWork.mode & ProfileMode) {
+        // Reset the profiler timer.
+        startProfilerTimer(unitOfWork);
+      } // Run beginWork again.
 
-function commitLayoutEffects(root, committedExpirationTime) {
-  // TODO: Should probably move the bulk of this function to commitWork.
-  while (nextEffect !== null) {
-    setCurrentFiber(nextEffect);
-    var effectTag = nextEffect.effectTag;
+      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);
 
-    if (effectTag & (Update | Callback)) {
-      recordEffect();
-      var current = nextEffect.alternate;
-      commitLifeCycles(root, current, nextEffect);
-    }
+      if (hasCaughtError()) {
+        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
+        // Rethrow this error instead of the original one.
 
-    if (effectTag & Ref) {
-      recordEffect();
-      commitAttachRef(nextEffect);
+        throw replayError;
+      } else {
+        // This branch is reachable if the render phase is impure.
+        throw originalError;
+      }
     }
-
-    resetCurrentFiber();
-    nextEffect = nextEffect.nextEffect;
-  }
+  };
 }
 
-function flushPassiveEffects() {
-  if (pendingPassiveEffectsRenderPriority !== NoPriority) {
-    var priorityLevel =
-      pendingPassiveEffectsRenderPriority > NormalPriority
-        ? NormalPriority
-        : pendingPassiveEffectsRenderPriority;
-    pendingPassiveEffectsRenderPriority = NoPriority;
-    return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
-  }
+var didWarnAboutUpdateInRender = false;
+var didWarnAboutUpdateInRenderForAnotherComponent;
+
+{
+  didWarnAboutUpdateInRenderForAnotherComponent = new Set();
 }
 
-function flushPassiveEffectsImpl() {
-  if (rootWithPendingPassiveEffects === null) {
-    return false;
-  }
+function warnAboutRenderPhaseUpdatesInDEV(fiber) {
+  {
+    if (
+      isRendering &&
+      (executionContext & RenderContext) !== NoContext &&
+      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()
+    ) {
+      switch (fiber.tag) {
+        case FunctionComponent:
+        case ForwardRef:
+        case SimpleMemoComponent: {
+          var renderingComponentName =
+            (workInProgress && getComponentName(workInProgress.type)) ||
+            "Unknown"; // Dedupe by the rendering component because it's the one that needs to be fixed.
 
-  var root = rootWithPendingPassiveEffects;
-  var expirationTime = pendingPassiveEffectsExpirationTime;
-  rootWithPendingPassiveEffects = null;
-  pendingPassiveEffectsExpirationTime = NoWork;
+          var dedupeKey = renderingComponentName;
 
-  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
-    throw Error("Cannot flush passive effects while already rendering.");
-  }
+          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
+            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
+            var setStateComponentName =
+              getComponentName(fiber.type) || "Unknown";
 
-  var prevExecutionContext = executionContext;
-  executionContext |= CommitContext;
-  var prevInteractions = pushInteractions(root);
+            error(
+              "Cannot update a component (`%s`) while rendering a " +
+                "different component (`%s`). To locate the bad setState() call inside `%s`, " +
+                "follow the stack trace as described in https://reactjs.org/link/setstate-in-render",
+              setStateComponentName,
+              renderingComponentName,
+              renderingComponentName
+            );
+          }
 
-  {
-    // Note: This currently assumes there are no passive effects on the root fiber
-    // because the root is not part of its own effect list.
-    // This could change in the future.
-    var _effect2 = root.current.firstEffect;
+          break;
+        }
 
-    while (_effect2 !== null) {
-      {
-        setCurrentFiber(_effect2);
-        invokeGuardedCallback(null, commitPassiveHookEffects, null, _effect2);
+        case ClassComponent: {
+          if (!didWarnAboutUpdateInRender) {
+            error(
+              "Cannot update during an existing state transition (such as " +
+                "within `render`). Render methods should be a pure " +
+                "function of props and state."
+            );
 
-        if (hasCaughtError()) {
-          if (!(_effect2 !== null)) {
-            throw Error("Should be working on an effect.");
+            didWarnAboutUpdateInRender = true;
           }
 
-          var _error5 = clearCaughtError();
-
-          captureCommitPhaseError(_effect2, _error5);
+          break;
         }
-
-        resetCurrentFiber();
       }
-
-      var nextNextEffect = _effect2.nextEffect; // Remove nextEffect pointer to assist GC
-
-      _effect2.nextEffect = null;
-      _effect2 = nextNextEffect;
     }
   }
+} // a 'shared' variable that changes when act() opens/closes in tests.
 
+var IsThisRendererActing = {
+  current: false
+};
+function warnIfNotScopedWithMatchingAct(fiber) {
   {
-    popInteractions(prevInteractions);
-    finishPendingInteractions(root, expirationTime);
-  }
-
-  executionContext = prevExecutionContext;
-  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
-  // exceeds the limit, we'll fire a warning.
-
-  nestedPassiveUpdateCount =
-    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
-  return true;
-}
+    if (
+      IsSomeRendererActing.current === true &&
+      IsThisRendererActing.current !== true
+    ) {
+      var previousFiber = current;
 
-function isAlreadyFailedLegacyErrorBoundary(instance) {
-  return (
-    legacyErrorBoundariesThatAlreadyFailed !== null &&
-    legacyErrorBoundariesThatAlreadyFailed.has(instance)
-  );
-}
-function markLegacyErrorBoundaryAsFailed(instance) {
-  if (legacyErrorBoundariesThatAlreadyFailed === null) {
-    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
-  } else {
-    legacyErrorBoundariesThatAlreadyFailed.add(instance);
-  }
-}
+      try {
+        setCurrentFiber(fiber);
 
-function prepareToThrowUncaughtError(error) {
-  if (!hasUncaughtError) {
-    hasUncaughtError = true;
-    firstUncaughtError = error;
+        error(
+          "It looks like you're using the wrong act() around your test interactions.\n" +
+          "Be sure to use the matching version of act() corresponding to your renderer:\n\n" +
+          "// for react-dom:\n" + // Break up imports to avoid accidentally parsing them as dependencies.
+          "import {act} fr" +
+          "om 'react-dom/test-utils';\n" +
+          "// ...\n" +
+          "act(() => ...);\n\n" +
+          "// for react-test-renderer:\n" + // Break up imports to avoid accidentally parsing them as dependencies.
+            "import TestRenderer fr" +
+            "om react-test-renderer';\n" +
+            "const {act} = TestRenderer;\n" +
+            "// ...\n" +
+            "act(() => ...);"
+        );
+      } finally {
+        if (previousFiber) {
+          setCurrentFiber(fiber);
+        } else {
+          resetCurrentFiber();
+        }
+      }
+    }
   }
 }
-
-var onUncaughtError = prepareToThrowUncaughtError;
-
-function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
-  var errorInfo = createCapturedValue(error, sourceFiber);
-  var update = createRootErrorUpdate(rootFiber, errorInfo, Sync);
-  enqueueUpdate(rootFiber, update);
-  var root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);
-
-  if (root !== null) {
-    ensureRootIsScheduled(root);
-    schedulePendingInteractions(root, Sync);
+function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
+  {
+    if (
+      (fiber.mode & StrictMode) !== NoMode &&
+      IsSomeRendererActing.current === false &&
+      IsThisRendererActing.current === false
+    ) {
+      error(
+        "An update to %s ran an effect, but was not wrapped in act(...).\n\n" +
+          "When testing, code that causes React state updates should be " +
+          "wrapped into act(...):\n\n" +
+          "act(() => {\n" +
+          "  /* fire events that update state */\n" +
+          "});\n" +
+          "/* assert on the output */\n\n" +
+          "This ensures that you're testing the behavior the user would see " +
+          "in the browser." +
+          " Learn more at https://reactjs.org/link/wrap-tests-with-act",
+        getComponentName(fiber.type)
+      );
+    }
   }
 }
 
-function captureCommitPhaseError(sourceFiber, error) {
-  if (sourceFiber.tag === HostRoot) {
-    // Error was thrown at the root. There is no parent, so the root
-    // itself should capture it.
-    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
-    return;
-  }
-
-  var fiber = sourceFiber.return;
+function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
+  {
+    if (
+      executionContext === NoContext &&
+      IsSomeRendererActing.current === false &&
+      IsThisRendererActing.current === false
+    ) {
+      var previousFiber = current;
 
-  while (fiber !== null) {
-    if (fiber.tag === HostRoot) {
-      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
-      return;
-    } else if (fiber.tag === ClassComponent) {
-      var ctor = fiber.type;
-      var instance = fiber.stateNode;
+      try {
+        setCurrentFiber(fiber);
 
-      if (
-        typeof ctor.getDerivedStateFromError === "function" ||
-        (typeof instance.componentDidCatch === "function" &&
-          !isAlreadyFailedLegacyErrorBoundary(instance))
-      ) {
-        var errorInfo = createCapturedValue(error, sourceFiber);
-        var update = createClassErrorUpdate(
-          fiber,
-          errorInfo, // TODO: This is always sync
-          Sync
+        error(
+          "An update to %s inside a test was not wrapped in act(...).\n\n" +
+            "When testing, code that causes React state updates should be " +
+            "wrapped into act(...):\n\n" +
+            "act(() => {\n" +
+            "  /* fire events that update state */\n" +
+            "});\n" +
+            "/* assert on the output */\n\n" +
+            "This ensures that you're testing the behavior the user would see " +
+            "in the browser." +
+            " Learn more at https://reactjs.org/link/wrap-tests-with-act",
+          getComponentName(fiber.type)
         );
-        enqueueUpdate(fiber, update);
-        var root = markUpdateTimeFromFiberToRoot(fiber, Sync);
-
-        if (root !== null) {
-          ensureRootIsScheduled(root);
-          schedulePendingInteractions(root, Sync);
+      } finally {
+        if (previousFiber) {
+          setCurrentFiber(fiber);
+        } else {
+          resetCurrentFiber();
         }
-
-        return;
       }
     }
-
-    fiber = fiber.return;
   }
 }
-function pingSuspendedRoot(root, thenable, suspendedTime) {
-  var pingCache = root.pingCache;
 
-  if (pingCache !== null) {
-    // The thenable resolved, so we no longer need to memoize, because it will
-    // never be thrown again.
-    pingCache.delete(thenable);
-  }
+var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.
 
-  if (workInProgressRoot === root && renderExpirationTime$1 === suspendedTime) {
-    // Received a ping at the same priority level at which we're currently
-    // rendering. We might want to restart this render. This should mirror
-    // the logic of whether or not a root suspends once it completes.
-    // TODO: If we're rendering sync either due to Sync, Batched or expired,
-    // we should probably never restart.
-    // If we're suspended with delay, we'll always suspend so we can always
-    // restart. If we're suspended without any updates, it might be a retry.
-    // If it's early in the retry we can restart. We can't know for sure
-    // whether we'll eventually process an update during this render pass,
-    // but it's somewhat unlikely that we get to a ping before that, since
-    // getting to the root most update is usually very fast.
+var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
+// scheduler is the actual recommendation. The alternative could be a testing build,
+// a new lib, or whatever; we dunno just yet. This message is for early adopters
+// to get their tests right.
+
+function warnIfUnmockedScheduler(fiber) {
+  {
     if (
-      workInProgressRootExitStatus === RootSuspendedWithDelay ||
-      (workInProgressRootExitStatus === RootSuspended &&
-        workInProgressRootLatestProcessedExpirationTime === Sync &&
-        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
+      didWarnAboutUnmockedScheduler === false &&
+      Scheduler.unstable_flushAllWithoutAsserting === undefined
     ) {
-      // Restart from the root. Don't need to schedule a ping because
-      // we're already working on this tree.
-      prepareFreshStack(root, renderExpirationTime$1);
-    } else {
-      // Even though we can't restart right now, we might get an
-      // opportunity later. So we mark this render as having a ping.
-      workInProgressRootHasPendingPing = true;
-    }
+      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
+        didWarnAboutUnmockedScheduler = true;
 
-    return;
+        error(
+          'In Concurrent or Sync modes, the "scheduler" module needs to be mocked ' +
+          "to guarantee consistent behaviour across tests and browsers. " +
+          "For example, with jest: \n" + // Break up requires to avoid accidentally parsing them as dependencies.
+            "jest.mock('scheduler', () => require" +
+            "('scheduler/unstable_mock'));\n\n" +
+            "For more info, visit https://reactjs.org/link/mock-scheduler"
+        );
+      }
+    }
   }
+}
 
-  if (!isRootSuspendedAtTime(root, suspendedTime)) {
-    // The root is no longer suspended at this time.
-    return;
+function computeThreadID(root, lane) {
+  // Interaction threads are unique per root and expiration time.
+  // NOTE: Intentionally unsound cast. All that matters is that it's a number
+  // and it represents a batch of work. Could make a helper function instead,
+  // but meh this is fine for now.
+  return lane * 1000 + root.interactionThreadID;
+}
+
+function markSpawnedWork(lane) {
+  if (spawnedWorkDuringRender === null) {
+    spawnedWorkDuringRender = [lane];
+  } else {
+    spawnedWorkDuringRender.push(lane);
   }
+}
 
-  var lastPingedTime = root.lastPingedTime;
+function scheduleInteractions(root, lane, interactions) {
+  if (interactions.size > 0) {
+    var pendingInteractionMap = root.pendingInteractionMap;
+    var pendingInteractions = pendingInteractionMap.get(lane);
 
-  if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {
-    // There's already a lower priority ping scheduled.
-    return;
-  } // Mark the time at which this ping was scheduled.
+    if (pendingInteractions != null) {
+      interactions.forEach(function(interaction) {
+        if (!pendingInteractions.has(interaction)) {
+          // Update the pending async work count for previously unscheduled interaction.
+          interaction.__count++;
+        }
 
-  root.lastPingedTime = suspendedTime;
-  ensureRootIsScheduled(root);
-  schedulePendingInteractions(root, suspendedTime);
-}
+        pendingInteractions.add(interaction);
+      });
+    } else {
+      pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.
 
-function retryTimedOutBoundary(boundaryFiber, retryTime) {
-  // The boundary fiber (a Suspense component or SuspenseList component)
-  // previously was rendered in its fallback state. One of the promises that
-  // suspended it has resolved, which means at least part of the tree was
-  // likely unblocked. Try rendering again, at a new expiration time.
-  if (retryTime === NoWork) {
-    var suspenseConfig = null; // Retries don't carry over the already committed update.
-
-    var currentTime = requestCurrentTimeForUpdate();
-    retryTime = computeExpirationForFiber(
-      currentTime,
-      boundaryFiber,
-      suspenseConfig
-    );
-  } // TODO: Special case idle priority?
+      interactions.forEach(function(interaction) {
+        interaction.__count++;
+      });
+    }
 
-  var root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);
+    var subscriber = tracing.__subscriberRef.current;
 
-  if (root !== null) {
-    ensureRootIsScheduled(root);
-    schedulePendingInteractions(root, retryTime);
+    if (subscriber !== null) {
+      var threadID = computeThreadID(root, lane);
+      subscriber.onWorkScheduled(interactions, threadID);
+    }
   }
 }
-function resolveRetryThenable(boundaryFiber, thenable) {
-  var retryTime = NoWork; // Default
 
-  var retryCache;
+function schedulePendingInteractions(root, lane) {
+  scheduleInteractions(root, lane, tracing.__interactionsRef.current);
+}
 
-  {
-    retryCache = boundaryFiber.stateNode;
-  }
+function startWorkOnPendingInteractions(root, lanes) {
+  // we can accurately attribute time spent working on it, And so that cascading
+  // work triggered during the render phase will be associated with it.
 
-  if (retryCache !== null) {
-    // The thenable resolved, so we no longer need to memoize, because it will
-    // never be thrown again.
-    retryCache.delete(thenable);
-  }
+  var interactions = new Set();
+  root.pendingInteractionMap.forEach(function(
+    scheduledInteractions,
+    scheduledLane
+  ) {
+    if (includesSomeLane(lanes, scheduledLane)) {
+      scheduledInteractions.forEach(function(interaction) {
+        return interactions.add(interaction);
+      });
+    }
+  }); // Store the current set of interactions on the FiberRoot for a few reasons:
+  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
+  // without having to recalculate it. We will also use it in commitWork() to
+  // pass to any Profiler onRender() hooks. This also provides DevTools with a
+  // way to access it when the onCommitRoot() hook is called.
 
-  retryTimedOutBoundary(boundaryFiber, retryTime);
-} // Computes the next Just Noticeable Difference (JND) boundary.
-// The theory is that a person can't tell the difference between small differences in time.
-// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
-// difference in the experience. However, waiting for longer might mean that we can avoid
-// showing an intermediate loading state. The longer we have already waited, the harder it
-// is to tell small differences in time. Therefore, the longer we've already waited,
-// the longer we can wait additionally. At some point we have to give up though.
-// We pick a train model where the next boundary commits at a consistent schedule.
-// These particular numbers are vague estimates. We expect to adjust them based on research.
+  root.memoizedInteractions = interactions;
 
-function jnd(timeElapsed) {
-  return timeElapsed < 120
-    ? 120
-    : timeElapsed < 480
-    ? 480
-    : timeElapsed < 1080
-    ? 1080
-    : timeElapsed < 1920
-    ? 1920
-    : timeElapsed < 3000
-    ? 3000
-    : timeElapsed < 4320
-    ? 4320
-    : ceil(timeElapsed / 1960) * 1960;
-}
+  if (interactions.size > 0) {
+    var subscriber = tracing.__subscriberRef.current;
 
-function computeMsUntilSuspenseLoadingDelay(
-  mostRecentEventTime,
-  committedExpirationTime,
-  suspenseConfig
-) {
-  var busyMinDurationMs = suspenseConfig.busyMinDurationMs | 0;
+    if (subscriber !== null) {
+      var threadID = computeThreadID(root, lanes);
 
-  if (busyMinDurationMs <= 0) {
-    return 0;
+      try {
+        subscriber.onWorkStarted(interactions, threadID);
+      } catch (error) {
+        // If the subscriber throws, rethrow it in a separate task
+        scheduleCallback(ImmediatePriority$1, function() {
+          throw error;
+        });
+      }
+    }
   }
+}
 
-  var busyDelayMs = suspenseConfig.busyDelayMs | 0; // Compute the time until this render pass would expire.
+function finishPendingInteractions(root, committedLanes) {
+  var remainingLanesAfterCommit = root.pendingLanes;
+  var subscriber;
 
-  var currentTimeMs = now();
-  var eventTimeMs = inferTimeFromExpirationTimeWithSuspenseConfig(
-    mostRecentEventTime,
-    suspenseConfig
-  );
-  var timeElapsed = currentTimeMs - eventTimeMs;
+  try {
+    subscriber = tracing.__subscriberRef.current;
 
-  if (timeElapsed <= busyDelayMs) {
-    // If we haven't yet waited longer than the initial delay, we don't
-    // have to wait any additional time.
-    return 0;
-  }
+    if (subscriber !== null && root.memoizedInteractions.size > 0) {
+      // FIXME: More than one lane can finish in a single commit.
+      var threadID = computeThreadID(root, committedLanes);
+      subscriber.onWorkStopped(root.memoizedInteractions, threadID);
+    }
+  } catch (error) {
+    // If the subscriber throws, rethrow it in a separate task
+    scheduleCallback(ImmediatePriority$1, function() {
+      throw error;
+    });
+  } finally {
+    // Clear completed interactions from the pending Map.
+    // Unless the render was suspended or cascading work was scheduled,
+    // In which case leave pending interactions until the subsequent render.
+    var pendingInteractionMap = root.pendingInteractionMap;
+    pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
+      // Only decrement the pending interaction count if we're done.
+      // If there's still work at the current priority,
+      // That indicates that we are waiting for suspense data.
+      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
+        pendingInteractionMap.delete(lane);
+        scheduledInteractions.forEach(function(interaction) {
+          interaction.__count--;
 
-  var msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed; // This is the value that is passed to `setTimeout`.
+          if (subscriber !== null && interaction.__count === 0) {
+            try {
+              subscriber.onInteractionScheduledWorkCompleted(interaction);
+            } catch (error) {
+              // If the subscriber throws, rethrow it in a separate task
+              scheduleCallback(ImmediatePriority$1, function() {
+                throw error;
+              });
+            }
+          }
+        });
+      }
+    });
+  }
+} // `act` testing API
 
-  return msUntilTimeout;
+function shouldForceFlushFallbacksInDEV() {
+  // Never force flush in production. This function should get stripped out.
+  return actingUpdatesScopeDepth > 0;
 }
+// so we can tell if any async act() calls try to run in parallel.
 
-function checkForNestedUpdates() {
-  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
-    nestedUpdateCount = 0;
-    rootWithNestedUpdates = null;
+var actingUpdatesScopeDepth = 0;
 
-    {
-      throw Error(
-        "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
-      );
-    }
-  }
+function detachFiberAfterEffects(fiber) {
+  fiber.sibling = null;
+  fiber.stateNode = null;
+}
 
-  {
-    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
-      nestedPassiveUpdateCount = 0;
+var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.
 
-      error(
-        "Maximum update depth exceeded. This can happen when a component " +
-          "calls setState inside useEffect, but useEffect either doesn't " +
-          "have a dependency array, or one of the dependencies changes on " +
-          "every render."
-      );
-    }
+var failedBoundaries = null;
+var setRefreshHandler = function(handler) {
+  {
+    resolveFamily = handler;
   }
-}
-
-function flushRenderPhaseStrictModeWarningsInDEV() {
+};
+function resolveFunctionForHotReloading(type) {
   {
-    ReactStrictModeWarnings.flushLegacyContextWarning();
-
-    {
-      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return type;
     }
-  }
-}
 
-function stopFinishedWorkLoopTimer() {
-  var didCompleteRoot = true;
-  stopWorkLoopTimer(interruptedBy, didCompleteRoot);
-  interruptedBy = null;
-}
+    var family = resolveFamily(type);
 
-function stopInterruptedWorkLoopTimer() {
-  // TODO: Track which fiber caused the interruption.
-  var didCompleteRoot = false;
-  stopWorkLoopTimer(interruptedBy, didCompleteRoot);
-  interruptedBy = null;
-}
+    if (family === undefined) {
+      return type;
+    } // Use the latest known implementation.
 
-function checkForInterruption(fiberThatReceivedUpdate, updateExpirationTime) {
-  if (
-    workInProgressRoot !== null &&
-    updateExpirationTime > renderExpirationTime$1
-  ) {
-    interruptedBy = fiberThatReceivedUpdate;
+    return family.current;
   }
 }
+function resolveClassForHotReloading(type) {
+  // No implementation differences.
+  return resolveFunctionForHotReloading(type);
+}
+function resolveForwardRefForHotReloading(type) {
+  {
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return type;
+    }
 
-var didWarnStateUpdateForUnmountedComponent = null;
+    var family = resolveFamily(type);
 
-function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
-  {
-    var tag = fiber.tag;
+    if (family === undefined) {
+      // Check if we're dealing with a real forwardRef. Don't want to crash early.
+      if (
+        type !== null &&
+        type !== undefined &&
+        typeof type.render === "function"
+      ) {
+        // ForwardRef is special because its resolved .type is an object,
+        // but it's possible that we only have its inner render function in the map.
+        // If that inner render function is different, we'll build a new forwardRef type.
+        var currentRender = resolveFunctionForHotReloading(type.render);
 
-    if (
-      tag !== HostRoot &&
-      tag !== ClassComponent &&
-      tag !== FunctionComponent &&
-      tag !== ForwardRef &&
-      tag !== MemoComponent &&
-      tag !== SimpleMemoComponent &&
-      tag !== Block
-    ) {
-      // Only warn for user-defined components, not internal ones like Suspense.
-      return;
-    }
-    // the problematic code almost always lies inside that component.
+        if (type.render !== currentRender) {
+          var syntheticType = {
+            $$typeof: REACT_FORWARD_REF_TYPE,
+            render: currentRender
+          };
 
-    var componentName = getComponentName(fiber.type) || "ReactComponent";
+          if (type.displayName !== undefined) {
+            syntheticType.displayName = type.displayName;
+          }
 
-    if (didWarnStateUpdateForUnmountedComponent !== null) {
-      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
-        return;
+          return syntheticType;
+        }
       }
 
-      didWarnStateUpdateForUnmountedComponent.add(componentName);
-    } else {
-      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
-    }
+      return type;
+    } // Use the latest known implementation.
 
-    error(
-      "Can't perform a React state update on an unmounted component. This " +
-        "is a no-op, but it indicates a memory leak in your application. To " +
-        "fix, cancel all subscriptions and asynchronous tasks in %s.%s",
-      tag === ClassComponent
-        ? "the componentWillUnmount method"
-        : "a useEffect cleanup function",
-      getStackByFiberInDevAndProd(fiber)
-    );
+    return family.current;
   }
 }
+function isCompatibleFamilyForHotReloading(fiber, element) {
+  {
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return false;
+    }
 
-var beginWork$1;
-
-{
-  var dummyFiber = null;
-
-  beginWork$1 = function(current, unitOfWork, expirationTime) {
-    // If a component throws an error, we replay it again in a synchronously
-    // dispatched event, so that the debugger will treat it as an uncaught
-    // error See ReactErrorUtils for more information.
-    // Before entering the begin phase, copy the work-in-progress onto a dummy
-    // fiber. If beginWork throws, we'll use this to reset the state.
-    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(
-      dummyFiber,
-      unitOfWork
-    );
-
-    try {
-      return beginWork(current, unitOfWork, expirationTime);
-    } catch (originalError) {
-      if (
-        originalError !== null &&
-        typeof originalError === "object" &&
-        typeof originalError.then === "function"
-      ) {
-        // Don't replay promises. Treat everything else like an error.
-        throw originalError;
-      } // Keep this code in sync with handleError; any changes here must have
-      // corresponding changes there.
+    var prevType = fiber.elementType;
+    var nextType = element.type; // If we got here, we know types aren't === equal.
 
-      resetContextDependencies();
-      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
-      // same fiber again.
-      // Unwind the failed stack frame
+    var needsCompareFamilies = false;
+    var $$typeofNextType =
+      typeof nextType === "object" && nextType !== null
+        ? nextType.$$typeof
+        : null;
 
-      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.
+    switch (fiber.tag) {
+      case ClassComponent: {
+        if (typeof nextType === "function") {
+          needsCompareFamilies = true;
+        }
 
-      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
+        break;
+      }
 
-      if (unitOfWork.mode & ProfileMode) {
-        // Reset the profiler timer.
-        startProfilerTimer(unitOfWork);
-      } // Run beginWork again.
+      case FunctionComponent: {
+        if (typeof nextType === "function") {
+          needsCompareFamilies = true;
+        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
+          // We don't know the inner type yet.
+          // We're going to assume that the lazy inner type is stable,
+          // and so it is sufficient to avoid reconciling it away.
+          // We're not going to unwrap or actually use the new lazy type.
+          needsCompareFamilies = true;
+        }
 
-      invokeGuardedCallback(
-        null,
-        beginWork,
-        null,
-        current,
-        unitOfWork,
-        expirationTime
-      );
+        break;
+      }
 
-      if (hasCaughtError()) {
-        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
-        // Rethrow this error instead of the original one.
+      case ForwardRef: {
+        if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
+          needsCompareFamilies = true;
+        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
+          needsCompareFamilies = true;
+        }
 
-        throw replayError;
-      } else {
-        // This branch is reachable if the render phase is impure.
-        throw originalError;
+        break;
       }
-    }
-  };
-}
 
-var didWarnAboutUpdateInRender = false;
+      case MemoComponent:
+      case SimpleMemoComponent: {
+        if ($$typeofNextType === REACT_MEMO_TYPE) {
+          // TODO: if it was but can no longer be simple,
+          // we shouldn't set this.
+          needsCompareFamilies = true;
+        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
+          needsCompareFamilies = true;
+        }
 
-function warnAboutRenderPhaseUpdatesInDEV(fiber) {
-  {
-    if ((executionContext & RenderContext) !== NoContext) {
-      switch (fiber.tag) {
-        case FunctionComponent:
-        case ForwardRef:
-        case SimpleMemoComponent: {
-          error(
-            "Cannot update a component from inside the function body of a " +
-              "different component."
-          );
+        break;
+      }
 
-          break;
-        }
+      default:
+        return false;
+    } // Check if both types have a family and it's the same one.
 
-        case ClassComponent: {
-          if (isRendering && !didWarnAboutUpdateInRender) {
-            error(
-              "Cannot update during an existing state transition (such as " +
-                "within `render`). Render methods should be a pure " +
-                "function of props and state."
-            );
+    if (needsCompareFamilies) {
+      // Note: memo() and forwardRef() we'll compare outer rather than inner type.
+      // This means both of them need to be registered to preserve state.
+      // If we unwrapped and compared the inner types for wrappers instead,
+      // then we would risk falsely saying two separate memo(Foo)
+      // calls are equivalent because they wrap the same Foo function.
+      var prevFamily = resolveFamily(prevType);
 
-            didWarnAboutUpdateInRender = true;
-            break;
-          }
-        }
+      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
+        return true;
       }
     }
-  }
-} // a 'shared' variable that changes when act() opens/closes in tests.
 
-var IsThisRendererActing = {
-  current: false
-};
-function warnIfNotScopedWithMatchingAct(fiber) {
-  {
-    if (
-      IsSomeRendererActing.current === true &&
-      IsThisRendererActing.current !== true
-    ) {
-      error(
-        "It looks like you're using the wrong act() around your test interactions.\n" +
-        "Be sure to use the matching version of act() corresponding to your renderer:\n\n" +
-        "// for react-dom:\n" + // Break up imports to avoid accidentally parsing them as dependencies.
-        "import {act} fr" +
-        "om 'react-dom/test-utils';\n" +
-        "// ...\n" +
-        "act(() => ...);\n\n" +
-        "// for react-test-renderer:\n" + // Break up imports to avoid accidentally parsing them as dependencies.
-          "import TestRenderer fr" +
-          "om react-test-renderer';\n" +
-          "const {act} = TestRenderer;\n" +
-          "// ...\n" +
-          "act(() => ...);" +
-          "%s",
-        getStackByFiberInDevAndProd(fiber)
-      );
-    }
+    return false;
   }
 }
-function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
+function markFailedErrorBoundaryForHotReloading(fiber) {
   {
-    if (
-      (fiber.mode & StrictMode) !== NoMode &&
-      IsSomeRendererActing.current === false &&
-      IsThisRendererActing.current === false
-    ) {
-      error(
-        "An update to %s ran an effect, but was not wrapped in act(...).\n\n" +
-          "When testing, code that causes React state updates should be " +
-          "wrapped into act(...):\n\n" +
-          "act(() => {\n" +
-          "  /* fire events that update state */\n" +
-          "});\n" +
-          "/* assert on the output */\n\n" +
-          "This ensures that you're testing the behavior the user would see " +
-          "in the browser." +
-          " Learn more at https://fb.me/react-wrap-tests-with-act" +
-          "%s",
-        getComponentName(fiber.type),
-        getStackByFiberInDevAndProd(fiber)
-      );
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return;
     }
-  }
-}
 
-function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
-  {
-    if (
-      executionContext === NoContext &&
-      IsSomeRendererActing.current === false &&
-      IsThisRendererActing.current === false
-    ) {
-      error(
-        "An update to %s inside a test was not wrapped in act(...).\n\n" +
-          "When testing, code that causes React state updates should be " +
-          "wrapped into act(...):\n\n" +
-          "act(() => {\n" +
-          "  /* fire events that update state */\n" +
-          "});\n" +
-          "/* assert on the output */\n\n" +
-          "This ensures that you're testing the behavior the user would see " +
-          "in the browser." +
-          " Learn more at https://fb.me/react-wrap-tests-with-act" +
-          "%s",
-        getComponentName(fiber.type),
-        getStackByFiberInDevAndProd(fiber)
-      );
+    if (typeof WeakSet !== "function") {
+      return;
     }
+
+    if (failedBoundaries === null) {
+      failedBoundaries = new WeakSet();
+    }
+
+    failedBoundaries.add(fiber);
   }
 }
+var scheduleRefresh = function(root, update) {
+  {
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return;
+    }
 
-var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.
+    var staleFamilies = update.staleFamilies,
+      updatedFamilies = update.updatedFamilies;
+    flushPassiveEffects();
+    flushSync(function() {
+      scheduleFibersWithFamiliesRecursively(
+        root.current,
+        updatedFamilies,
+        staleFamilies
+      );
+    });
+  }
+};
+var scheduleRoot = function(root, element) {
+  {
+    if (root.context !== emptyContextObject) {
+      // Super edge case: root has a legacy _renderSubtree context
+      // but we don't know the parentComponent so we can't pass it.
+      // Just ignore. We'll delete this with _renderSubtree code path later.
+      return;
+    }
 
-var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
-// scheduler is the actual recommendation. The alternative could be a testing build,
-// a new lib, or whatever; we dunno just yet. This message is for early adopters
-// to get their tests right.
+    flushPassiveEffects();
+    flushSync(function() {
+      updateContainer(element, root, null, null);
+    });
+  }
+};
 
-function warnIfUnmockedScheduler(fiber) {
+function scheduleFibersWithFamiliesRecursively(
+  fiber,
+  updatedFamilies,
+  staleFamilies
+) {
   {
-    if (
-      didWarnAboutUnmockedScheduler === false &&
-      Scheduler.unstable_flushAllWithoutAsserting === undefined
-    ) {
-      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
-        didWarnAboutUnmockedScheduler = true;
+    var alternate = fiber.alternate,
+      child = fiber.child,
+      sibling = fiber.sibling,
+      tag = fiber.tag,
+      type = fiber.type;
+    var candidateType = null;
 
-        error(
-          'In Concurrent or Sync modes, the "scheduler" module needs to be mocked ' +
-          "to guarantee consistent behaviour across tests and browsers. " +
-          "For example, with jest: \n" + // Break up requires to avoid accidentally parsing them as dependencies.
-            "jest.mock('scheduler', () => require" +
-            "('scheduler/unstable_mock'));\n\n" +
-            "For more info, visit https://fb.me/react-mock-scheduler"
-        );
-      }
+    switch (tag) {
+      case FunctionComponent:
+      case SimpleMemoComponent:
+      case ClassComponent:
+        candidateType = type;
+        break;
+
+      case ForwardRef:
+        candidateType = type.render;
+        break;
     }
-  }
-}
 
-function computeThreadID(root, expirationTime) {
-  // Interaction threads are unique per root and expiration time.
-  return expirationTime * 1000 + root.interactionThreadID;
-}
+    if (resolveFamily === null) {
+      throw new Error("Expected resolveFamily to be set during hot reload.");
+    }
 
-function markSpawnedWork(expirationTime) {
-  if (spawnedWorkDuringRender === null) {
-    spawnedWorkDuringRender = [expirationTime];
-  } else {
-    spawnedWorkDuringRender.push(expirationTime);
-  }
-}
+    var needsRender = false;
+    var needsRemount = false;
 
-function scheduleInteractions(root, expirationTime, interactions) {
-  if (interactions.size > 0) {
-    var pendingInteractionMap = root.pendingInteractionMap;
-    var pendingInteractions = pendingInteractionMap.get(expirationTime);
+    if (candidateType !== null) {
+      var family = resolveFamily(candidateType);
 
-    if (pendingInteractions != null) {
-      interactions.forEach(function(interaction) {
-        if (!pendingInteractions.has(interaction)) {
-          // Update the pending async work count for previously unscheduled interaction.
-          interaction.__count++;
+      if (family !== undefined) {
+        if (staleFamilies.has(family)) {
+          needsRemount = true;
+        } else if (updatedFamilies.has(family)) {
+          if (tag === ClassComponent) {
+            needsRemount = true;
+          } else {
+            needsRender = true;
+          }
         }
+      }
+    }
 
-        pendingInteractions.add(interaction);
-      });
-    } else {
-      pendingInteractionMap.set(expirationTime, new Set(interactions)); // Update the pending async work count for the current interactions.
+    if (failedBoundaries !== null) {
+      if (
+        failedBoundaries.has(fiber) ||
+        (alternate !== null && failedBoundaries.has(alternate))
+      ) {
+        needsRemount = true;
+      }
+    }
 
-      interactions.forEach(function(interaction) {
-        interaction.__count++;
-      });
+    if (needsRemount) {
+      fiber._debugNeedsRemount = true;
     }
 
-    var subscriber = tracing.__subscriberRef.current;
+    if (needsRemount || needsRender) {
+      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
+    }
 
-    if (subscriber !== null) {
-      var threadID = computeThreadID(root, expirationTime);
-      subscriber.onWorkScheduled(interactions, threadID);
+    if (child !== null && !needsRemount) {
+      scheduleFibersWithFamiliesRecursively(
+        child,
+        updatedFamilies,
+        staleFamilies
+      );
     }
-  }
-}
 
-function schedulePendingInteractions(root, expirationTime) {
-  scheduleInteractions(root, expirationTime, tracing.__interactionsRef.current);
+    if (sibling !== null) {
+      scheduleFibersWithFamiliesRecursively(
+        sibling,
+        updatedFamilies,
+        staleFamilies
+      );
+    }
+  }
 }
 
-function startWorkOnPendingInteractions(root, expirationTime) {
-  // we can accurately attribute time spent working on it, And so that cascading
-  // work triggered during the render phase will be associated with it.
+var findHostInstancesForRefresh = function(root, families) {
+  {
+    var hostInstances = new Set();
+    var types = new Set(
+      families.map(function(family) {
+        return family.current;
+      })
+    );
+    findHostInstancesForMatchingFibersRecursively(
+      root.current,
+      types,
+      hostInstances
+    );
+    return hostInstances;
+  }
+};
 
-  var interactions = new Set();
-  root.pendingInteractionMap.forEach(function(
-    scheduledInteractions,
-    scheduledExpirationTime
-  ) {
-    if (scheduledExpirationTime >= expirationTime) {
-      scheduledInteractions.forEach(function(interaction) {
-        return interactions.add(interaction);
-      });
-    }
-  }); // Store the current set of interactions on the FiberRoot for a few reasons:
-  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
-  // without having to recalculate it. We will also use it in commitWork() to
-  // pass to any Profiler onRender() hooks. This also provides DevTools with a
-  // way to access it when the onCommitRoot() hook is called.
+function findHostInstancesForMatchingFibersRecursively(
+  fiber,
+  types,
+  hostInstances
+) {
+  {
+    var child = fiber.child,
+      sibling = fiber.sibling,
+      tag = fiber.tag,
+      type = fiber.type;
+    var candidateType = null;
 
-  root.memoizedInteractions = interactions;
+    switch (tag) {
+      case FunctionComponent:
+      case SimpleMemoComponent:
+      case ClassComponent:
+        candidateType = type;
+        break;
 
-  if (interactions.size > 0) {
-    var subscriber = tracing.__subscriberRef.current;
+      case ForwardRef:
+        candidateType = type.render;
+        break;
+    }
 
-    if (subscriber !== null) {
-      var threadID = computeThreadID(root, expirationTime);
+    var didMatch = false;
 
-      try {
-        subscriber.onWorkStarted(interactions, threadID);
-      } catch (error) {
-        // If the subscriber throws, rethrow it in a separate task
-        scheduleCallback(ImmediatePriority, function() {
-          throw error;
-        });
+    if (candidateType !== null) {
+      if (types.has(candidateType)) {
+        didMatch = true;
       }
     }
-  }
-}
-
-function finishPendingInteractions(root, committedExpirationTime) {
-  var earliestRemainingTimeAfterCommit = root.firstPendingTime;
-  var subscriber;
-
-  try {
-    subscriber = tracing.__subscriberRef.current;
 
-    if (subscriber !== null && root.memoizedInteractions.size > 0) {
-      var threadID = computeThreadID(root, committedExpirationTime);
-      subscriber.onWorkStopped(root.memoizedInteractions, threadID);
+    if (didMatch) {
+      // We have a match. This only drills down to the closest host components.
+      // There's no need to search deeper because for the purpose of giving
+      // visual feedback, "flashing" outermost parent rectangles is sufficient.
+      findHostInstancesForFiberShallowly(fiber, hostInstances);
+    } else {
+      // If there's no match, maybe there will be one further down in the child tree.
+      if (child !== null) {
+        findHostInstancesForMatchingFibersRecursively(
+          child,
+          types,
+          hostInstances
+        );
+      }
     }
-  } catch (error) {
-    // If the subscriber throws, rethrow it in a separate task
-    scheduleCallback(ImmediatePriority, function() {
-      throw error;
-    });
-  } finally {
-    // Clear completed interactions from the pending Map.
-    // Unless the render was suspended or cascading work was scheduled,
-    // In which case leave pending interactions until the subsequent render.
-    var pendingInteractionMap = root.pendingInteractionMap;
-    pendingInteractionMap.forEach(function(
-      scheduledInteractions,
-      scheduledExpirationTime
-    ) {
-      // Only decrement the pending interaction count if we're done.
-      // If there's still work at the current priority,
-      // That indicates that we are waiting for suspense data.
-      if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
-        pendingInteractionMap.delete(scheduledExpirationTime);
-        scheduledInteractions.forEach(function(interaction) {
-          interaction.__count--;
 
-          if (subscriber !== null && interaction.__count === 0) {
-            try {
-              subscriber.onInteractionScheduledWorkCompleted(interaction);
-            } catch (error) {
-              // If the subscriber throws, rethrow it in a separate task
-              scheduleCallback(ImmediatePriority, function() {
-                throw error;
-              });
-            }
-          }
-        });
-      }
-    });
+    if (sibling !== null) {
+      findHostInstancesForMatchingFibersRecursively(
+        sibling,
+        types,
+        hostInstances
+      );
+    }
   }
 }
 
-var onScheduleFiberRoot = null;
-var onCommitFiberRoot = null;
-var onCommitFiberUnmount = null;
-var hasLoggedError = false;
-var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
-function injectInternals(internals) {
-  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
-    // No DevTools
-    return false;
-  }
+function findHostInstancesForFiberShallowly(fiber, hostInstances) {
+  {
+    var foundHostInstances = findChildHostInstancesForFiberShallowly(
+      fiber,
+      hostInstances
+    );
 
-  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+    if (foundHostInstances) {
+      return;
+    } // If we didn't find any host children, fallback to closest host parent.
 
-  if (hook.isDisabled) {
-    // This isn't a real property on the hook, but it can be set to opt out
-    // of DevTools integration and associated warnings and logs.
-    // https://github.com/facebook/react/issues/3877
-    return true;
-  }
+    var node = fiber;
 
-  if (!hook.supportsFiber) {
-    {
-      error(
-        "The installed version of React DevTools is too old and will not work " +
-          "with the current version of React. Please update React DevTools. " +
-          "https://fb.me/react-devtools"
-      );
-    } // DevTools exists, even though it doesn't support Fiber.
+    while (true) {
+      switch (node.tag) {
+        case HostComponent:
+          hostInstances.add(node.stateNode);
+          return;
 
-    return true;
-  }
+        case HostPortal:
+          hostInstances.add(node.stateNode.containerInfo);
+          return;
 
-  try {
-    var rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
+        case HostRoot:
+          hostInstances.add(node.stateNode.containerInfo);
+          return;
+      }
 
-    if (true) {
-      // Only used by Fast Refresh
-      if (typeof hook.onScheduleFiberRoot === "function") {
-        onScheduleFiberRoot = function(root, children) {
-          try {
-            hook.onScheduleFiberRoot(rendererID, root, children);
-          } catch (err) {
-            if (true && !hasLoggedError) {
-              hasLoggedError = true;
-
-              error("React instrumentation encountered an error: %s", err);
-            }
-          }
-        };
+      if (node.return === null) {
+        throw new Error("Expected to reach root first.");
       }
-    }
 
-    onCommitFiberRoot = function(root, expirationTime) {
-      try {
-        var didError = (root.current.effectTag & DidCapture) === DidCapture;
+      node = node.return;
+    }
+  }
+}
 
-        if (enableProfilerTimer) {
-          var currentTime = getCurrentTime();
-          var priorityLevel = inferPriorityFromExpirationTime(
-            currentTime,
-            expirationTime
-          );
-          hook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
-        } else {
-          hook.onCommitFiberRoot(rendererID, root, undefined, didError);
-        }
-      } catch (err) {
-        if (true) {
-          if (!hasLoggedError) {
-            hasLoggedError = true;
+function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
+  {
+    var node = fiber;
+    var foundHostInstances = false;
 
-            error("React instrumentation encountered an error: %s", err);
-          }
-        }
+    while (true) {
+      if (node.tag === HostComponent) {
+        // We got a match.
+        foundHostInstances = true;
+        hostInstances.add(node.stateNode); // There may still be more, so keep searching.
+      } else if (node.child !== null) {
+        node.child.return = node;
+        node = node.child;
+        continue;
       }
-    };
 
-    onCommitFiberUnmount = function(fiber) {
-      try {
-        hook.onCommitFiberUnmount(rendererID, fiber);
-      } catch (err) {
-        if (true) {
-          if (!hasLoggedError) {
-            hasLoggedError = true;
+      if (node === fiber) {
+        return foundHostInstances;
+      }
 
-            error("React instrumentation encountered an error: %s", err);
-          }
+      while (node.sibling === null) {
+        if (node.return === null || node.return === fiber) {
+          return foundHostInstances;
         }
+
+        node = node.return;
       }
-    };
-  } catch (err) {
-    // Catch all errors because it is unsafe to throw during initialization.
-    {
-      error("React instrumentation encountered an error: %s.", err);
-    }
-  } // DevTools exists
 
-  return true;
-}
-function onScheduleRoot(root, children) {
-  if (typeof onScheduleFiberRoot === "function") {
-    onScheduleFiberRoot(root, children);
-  }
-}
-function onCommitRoot(root, expirationTime) {
-  if (typeof onCommitFiberRoot === "function") {
-    onCommitFiberRoot(root, expirationTime);
-  }
-}
-function onCommitUnmount(fiber) {
-  if (typeof onCommitFiberUnmount === "function") {
-    onCommitFiberUnmount(fiber);
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
   }
+
+  return false;
 }
 
 var hasBadMapPolyfill;
@@ -19629,13 +20580,11 @@ var hasBadMapPolyfill;
 
   try {
     var nonExtensibleObject = Object.preventExtensions({});
-    var testMap = new Map([[nonExtensibleObject, null]]);
-    var testSet = new Set([nonExtensibleObject]); // This is necessary for Rollup to not consider these unused.
-    // https://github.com/rollup/rollup/issues/1771
-    // TODO: we can remove these if Rollup fixes the bug.
+    /* eslint-disable no-new */
 
-    testMap.set(0, 0);
-    testSet.add(0);
+    new Map([[nonExtensibleObject, null]]);
+    new Set([nonExtensibleObject]);
+    /* eslint-enable no-new */
   } catch (e) {
     // TODO: Consider warning about bad polyfills
     hasBadMapPolyfill = true;
@@ -19664,12 +20613,12 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.dependencies = null;
   this.mode = mode; // Effects
 
-  this.effectTag = NoEffect;
+  this.flags = NoFlags;
   this.nextEffect = null;
   this.firstEffect = null;
   this.lastEffect = null;
-  this.expirationTime = NoWork;
-  this.childExpirationTime = NoWork;
+  this.lanes = NoLanes;
+  this.childLanes = NoLanes;
   this.alternate = null;
 
   {
@@ -19696,15 +20645,11 @@ function FiberNode(tag, pendingProps, key, mode) {
     this.actualStartTime = -1;
     this.selfBaseDuration = 0;
     this.treeBaseDuration = 0;
-  } // This is normally DEV-only except www when it adds listeners.
-  // TODO: remove the User Timing integration in favor of Root Events.
-
-  {
-    this._debugID = debugCounter++;
-    this._debugIsCurrentlyTiming = false;
   }
 
   {
+    // This isn't directly used but is handy for debugging internals:
+    this._debugID = debugCounter++;
     this._debugSource = null;
     this._debugOwner = null;
     this._debugNeedsRemount = false;
@@ -19784,10 +20729,7 @@ function createWorkInProgress(current, pendingProps) {
 
     {
       // DEV-only fields
-      {
-        workInProgress._debugID = current._debugID;
-      }
-
+      workInProgress._debugID = current._debugID;
       workInProgress._debugSource = current._debugSource;
       workInProgress._debugOwner = current._debugOwner;
       workInProgress._debugHookTypes = current._debugHookTypes;
@@ -19796,10 +20738,12 @@ function createWorkInProgress(current, pendingProps) {
     workInProgress.alternate = current;
     current.alternate = workInProgress;
   } else {
-    workInProgress.pendingProps = pendingProps; // We already have an alternate.
+    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.
+
+    workInProgress.type = current.type; // We already have an alternate.
     // Reset the effect tag.
 
-    workInProgress.effectTag = NoEffect; // The effect list is no longer valid.
+    workInProgress.flags = NoFlags; // The effect list is no longer valid.
 
     workInProgress.nextEffect = null;
     workInProgress.firstEffect = null;
@@ -19815,8 +20759,8 @@ function createWorkInProgress(current, pendingProps) {
     }
   }
 
-  workInProgress.childExpirationTime = current.childExpirationTime;
-  workInProgress.expirationTime = current.expirationTime;
+  workInProgress.childLanes = current.childLanes;
+  workInProgress.lanes = current.lanes;
   workInProgress.child = current.child;
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
@@ -19828,9 +20772,8 @@ function createWorkInProgress(current, pendingProps) {
     currentDependencies === null
       ? null
       : {
-          expirationTime: currentDependencies.expirationTime,
-          firstContext: currentDependencies.firstContext,
-          responders: currentDependencies.responders
+          lanes: currentDependencies.lanes,
+          firstContext: currentDependencies.firstContext
         }; // These will be overridden during the parent's reconciliation
 
   workInProgress.sibling = current.sibling;
@@ -19865,7 +20808,7 @@ function createWorkInProgress(current, pendingProps) {
   return workInProgress;
 } // Used to reuse a Fiber for a second pass.
 
-function resetWorkInProgress(workInProgress, renderExpirationTime) {
+function resetWorkInProgress(workInProgress, renderLanes) {
   // This resets the Fiber to what createFiber or createWorkInProgress would
   // have set the values to before during the first pass. Ideally this wouldn't
   // be necessary but unfortunately many code paths reads from the workInProgress
@@ -19874,7 +20817,7 @@ function resetWorkInProgress(workInProgress, renderExpirationTime) {
   // avoid doing another reconciliation.
   // Reset the effect tag but keep any Placement tags, since that's something
   // that child fiber is setting, not the reconciliation.
-  workInProgress.effectTag &= Placement; // The effect list is no longer valid.
+  workInProgress.flags &= Placement; // The effect list is no longer valid.
 
   workInProgress.nextEffect = null;
   workInProgress.firstEffect = null;
@@ -19883,13 +20826,14 @@ function resetWorkInProgress(workInProgress, renderExpirationTime) {
 
   if (current === null) {
     // Reset to createFiber's initial values.
-    workInProgress.childExpirationTime = NoWork;
-    workInProgress.expirationTime = renderExpirationTime;
+    workInProgress.childLanes = NoLanes;
+    workInProgress.lanes = renderLanes;
     workInProgress.child = null;
     workInProgress.memoizedProps = null;
     workInProgress.memoizedState = null;
     workInProgress.updateQueue = null;
     workInProgress.dependencies = null;
+    workInProgress.stateNode = null;
 
     {
       // Note: We don't reset the actualTime counts. It's useful to accumulate
@@ -19899,12 +20843,14 @@ function resetWorkInProgress(workInProgress, renderExpirationTime) {
     }
   } else {
     // Reset to the cloned values that createWorkInProgress would've.
-    workInProgress.childExpirationTime = current.childExpirationTime;
-    workInProgress.expirationTime = current.expirationTime;
+    workInProgress.childLanes = current.childLanes;
+    workInProgress.lanes = current.lanes;
     workInProgress.child = current.child;
     workInProgress.memoizedProps = current.memoizedProps;
     workInProgress.memoizedState = current.memoizedState;
-    workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
+    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.
+
+    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so
     // it cannot be shared with the current fiber.
 
     var currentDependencies = current.dependencies;
@@ -19912,9 +20858,8 @@ function resetWorkInProgress(workInProgress, renderExpirationTime) {
       currentDependencies === null
         ? null
         : {
-            expirationTime: currentDependencies.expirationTime,
-            firstContext: currentDependencies.firstContext,
-            responders: currentDependencies.responders
+            lanes: currentDependencies.lanes,
+            firstContext: currentDependencies.firstContext
           };
 
     {
@@ -19953,9 +20898,8 @@ function createFiberFromTypeAndProps(
   pendingProps,
   owner,
   mode,
-  expirationTime
+  lanes
 ) {
-  var fiber;
   var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
 
   var resolvedType = type;
@@ -19977,16 +20921,11 @@ function createFiberFromTypeAndProps(
   } else {
     getTag: switch (type) {
       case REACT_FRAGMENT_TYPE:
-        return createFiberFromFragment(
-          pendingProps.children,
-          mode,
-          expirationTime,
-          key
-        );
+        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
 
-      case REACT_CONCURRENT_MODE_TYPE:
+      case REACT_DEBUG_TRACING_MODE_TYPE:
         fiberTag = Mode;
-        mode |= ConcurrentMode | BlockingMode | StrictMode;
+        mode |= DebugTracingMode;
         break;
 
       case REACT_STRICT_MODE_TYPE:
@@ -19995,18 +20934,23 @@ function createFiberFromTypeAndProps(
         break;
 
       case REACT_PROFILER_TYPE:
-        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
+        return createFiberFromProfiler(pendingProps, mode, lanes, key);
 
       case REACT_SUSPENSE_TYPE:
-        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);
+        return createFiberFromSuspense(pendingProps, mode, lanes, key);
 
       case REACT_SUSPENSE_LIST_TYPE:
-        return createFiberFromSuspenseList(
-          pendingProps,
-          mode,
-          expirationTime,
-          key
-        );
+        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
+
+      case REACT_OFFSCREEN_TYPE:
+        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+
+      case REACT_LEGACY_HIDDEN_TYPE:
+        return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
+
+      case REACT_SCOPE_TYPE:
+
+      // eslint-disable-next-line no-fallthrough
 
       default: {
         if (typeof type === "object" && type !== null) {
@@ -20037,10 +20981,6 @@ function createFiberFromTypeAndProps(
               fiberTag = LazyComponent;
               resolvedType = null;
               break getTag;
-
-            case REACT_BLOCK_TYPE:
-              fiberTag = Block;
-              break getTag;
           }
         }
 
@@ -20078,13 +21018,18 @@ function createFiberFromTypeAndProps(
     }
   }
 
-  fiber = createFiber(fiberTag, pendingProps, key, mode);
+  var fiber = createFiber(fiberTag, pendingProps, key, mode);
   fiber.elementType = type;
   fiber.type = resolvedType;
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
+
+  {
+    fiber._debugOwner = owner;
+  }
+
   return fiber;
 }
-function createFiberFromElement(element, mode, expirationTime) {
+function createFiberFromElement(element, mode, lanes) {
   var owner = null;
 
   {
@@ -20100,7 +21045,7 @@ function createFiberFromElement(element, mode, expirationTime) {
     pendingProps,
     owner,
     mode,
-    expirationTime
+    lanes
   );
 
   {
@@ -20110,13 +21055,13 @@ function createFiberFromElement(element, mode, expirationTime) {
 
   return fiber;
 }
-function createFiberFromFragment(elements, mode, expirationTime, key) {
+function createFiberFromFragment(elements, mode, lanes, key) {
   var fiber = createFiber(Fragment, elements, key, mode);
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   return fiber;
 }
 
-function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
+function createFiberFromProfiler(pendingProps, mode, lanes, key) {
   {
     if (typeof pendingProps.id !== "string") {
       error('Profiler must specify an "id" as a prop');
@@ -20127,7 +21072,7 @@ function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
 
   fiber.elementType = REACT_PROFILER_TYPE;
   fiber.type = REACT_PROFILER_TYPE;
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
 
   {
     fiber.stateNode = {
@@ -20139,17 +21084,17 @@ function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
   return fiber;
 }
 
-function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
+function createFiberFromSuspense(pendingProps, mode, lanes, key) {
   var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
   // This needs to be fixed in getComponentName so that it relies on the tag
   // instead.
 
   fiber.type = REACT_SUSPENSE_TYPE;
   fiber.elementType = REACT_SUSPENSE_TYPE;
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   return fiber;
 }
-function createFiberFromSuspenseList(pendingProps, mode, expirationTime, key) {
+function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
   var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
 
   {
@@ -20160,18 +21105,44 @@ function createFiberFromSuspenseList(pendingProps, mode, expirationTime, key) {
   }
 
   fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
+  return fiber;
+}
+function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
+  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
+  // This needs to be fixed in getComponentName so that it relies on the tag
+  // instead.
+
+  {
+    fiber.type = REACT_OFFSCREEN_TYPE;
+  }
+
+  fiber.elementType = REACT_OFFSCREEN_TYPE;
+  fiber.lanes = lanes;
+  return fiber;
+}
+function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
+  var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
+  // This needs to be fixed in getComponentName so that it relies on the tag
+  // instead.
+
+  {
+    fiber.type = REACT_LEGACY_HIDDEN_TYPE;
+  }
+
+  fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
+  fiber.lanes = lanes;
   return fiber;
 }
-function createFiberFromText(content, mode, expirationTime) {
+function createFiberFromText(content, mode, lanes) {
   var fiber = createFiber(HostText, content, null, mode);
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   return fiber;
 }
-function createFiberFromPortal(portal, mode, expirationTime) {
+function createFiberFromPortal(portal, mode, lanes) {
   var pendingProps = portal.children !== null ? portal.children : [];
   var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   fiber.stateNode = {
     containerInfo: portal.containerInfo,
     pendingChildren: null,
@@ -20208,12 +21179,12 @@ function assignFiberPropertiesInDEV(target, source) {
   target.memoizedState = source.memoizedState;
   target.dependencies = source.dependencies;
   target.mode = source.mode;
-  target.effectTag = source.effectTag;
+  target.flags = source.flags;
   target.nextEffect = source.nextEffect;
   target.firstEffect = source.firstEffect;
   target.lastEffect = source.lastEffect;
-  target.expirationTime = source.expirationTime;
-  target.childExpirationTime = source.childExpirationTime;
+  target.lanes = source.lanes;
+  target.childLanes = source.childLanes;
   target.alternate = source.alternate;
 
   {
@@ -20223,11 +21194,7 @@ function assignFiberPropertiesInDEV(target, source) {
     target.treeBaseDuration = source.treeBaseDuration;
   }
 
-  {
-    target._debugID = source._debugID;
-    target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
-  }
-
+  target._debugID = source._debugID;
   target._debugSource = source._debugSource;
   target._debugOwner = source._debugOwner;
   target._debugNeedsRemount = source._debugNeedsRemount;
@@ -20237,30 +21204,49 @@ function assignFiberPropertiesInDEV(target, source) {
 
 function FiberRootNode(containerInfo, tag, hydrate) {
   this.tag = tag;
-  this.current = null;
   this.containerInfo = containerInfo;
   this.pendingChildren = null;
+  this.current = null;
   this.pingCache = null;
-  this.finishedExpirationTime = NoWork;
   this.finishedWork = null;
   this.timeoutHandle = noTimeout;
   this.context = null;
   this.pendingContext = null;
   this.hydrate = hydrate;
   this.callbackNode = null;
-  this.callbackPriority = NoPriority;
-  this.firstPendingTime = NoWork;
-  this.firstSuspendedTime = NoWork;
-  this.lastSuspendedTime = NoWork;
-  this.nextKnownPendingLevel = NoWork;
-  this.lastPingedTime = NoWork;
-  this.lastExpiredTime = NoWork;
+  this.callbackPriority = NoLanePriority;
+  this.eventTimes = createLaneMap(NoLanes);
+  this.expirationTimes = createLaneMap(NoTimestamp);
+  this.pendingLanes = NoLanes;
+  this.suspendedLanes = NoLanes;
+  this.pingedLanes = NoLanes;
+  this.expiredLanes = NoLanes;
+  this.mutableReadLanes = NoLanes;
+  this.finishedLanes = NoLanes;
+  this.entangledLanes = NoLanes;
+  this.entanglements = createLaneMap(NoLanes);
 
   {
     this.interactionThreadID = tracing.unstable_getThreadID();
     this.memoizedInteractions = new Set();
     this.pendingInteractionMap = new Map();
   }
+
+  {
+    switch (tag) {
+      case BlockingRoot:
+        this._debugRootType = "createBlockingRoot()";
+        break;
+
+      case ConcurrentRoot:
+        this._debugRootType = "createRoot()";
+        break;
+
+      case LegacyRoot:
+        this._debugRootType = "createLegacyRoot()";
+        break;
+    }
+  }
 }
 
 function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
@@ -20273,95 +21259,22 @@ function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
   initializeUpdateQueue(uninitializedFiber);
   return root;
 }
-function isRootSuspendedAtTime(root, expirationTime) {
-  var firstSuspendedTime = root.firstSuspendedTime;
-  var lastSuspendedTime = root.lastSuspendedTime;
-  return (
-    firstSuspendedTime !== NoWork &&
-    firstSuspendedTime >= expirationTime &&
-    lastSuspendedTime <= expirationTime
-  );
-}
-function markRootSuspendedAtTime(root, expirationTime) {
-  var firstSuspendedTime = root.firstSuspendedTime;
-  var lastSuspendedTime = root.lastSuspendedTime;
-
-  if (firstSuspendedTime < expirationTime) {
-    root.firstSuspendedTime = expirationTime;
-  }
-
-  if (lastSuspendedTime > expirationTime || firstSuspendedTime === NoWork) {
-    root.lastSuspendedTime = expirationTime;
-  }
-
-  if (expirationTime <= root.lastPingedTime) {
-    root.lastPingedTime = NoWork;
-  }
-
-  if (expirationTime <= root.lastExpiredTime) {
-    root.lastExpiredTime = NoWork;
-  }
-}
-function markRootUpdatedAtTime(root, expirationTime) {
-  // Update the range of pending times
-  var firstPendingTime = root.firstPendingTime;
-
-  if (expirationTime > firstPendingTime) {
-    root.firstPendingTime = expirationTime;
-  } // Update the range of suspended times. Treat everything lower priority or
-  // equal to this update as unsuspended.
 
-  var firstSuspendedTime = root.firstSuspendedTime;
-
-  if (firstSuspendedTime !== NoWork) {
-    if (expirationTime >= firstSuspendedTime) {
-      // The entire suspended range is now unsuspended.
-      root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;
-    } else if (expirationTime >= root.lastSuspendedTime) {
-      root.lastSuspendedTime = expirationTime + 1;
-    } // This is a pending level. Check if it's higher priority than the next
-    // known pending level.
-
-    if (expirationTime > root.nextKnownPendingLevel) {
-      root.nextKnownPendingLevel = expirationTime;
-    }
-  }
-}
-function markRootFinishedAtTime(
-  root,
-  finishedExpirationTime,
-  remainingExpirationTime
+function createPortal(
+  children,
+  containerInfo, // TODO: figure out the API for cross-renderer implementation.
+  implementation
 ) {
-  // Update the range of pending times
-  root.firstPendingTime = remainingExpirationTime; // Update the range of suspended times. Treat everything higher priority or
-  // equal to this update as unsuspended.
-
-  if (finishedExpirationTime <= root.lastSuspendedTime) {
-    // The entire suspended range is now unsuspended.
-    root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;
-  } else if (finishedExpirationTime <= root.firstSuspendedTime) {
-    // Part of the suspended range is now unsuspended. Narrow the range to
-    // include everything between the unsuspended time (non-inclusive) and the
-    // last suspended time.
-    root.firstSuspendedTime = finishedExpirationTime - 1;
-  }
-
-  if (finishedExpirationTime <= root.lastPingedTime) {
-    // Clear the pinged time
-    root.lastPingedTime = NoWork;
-  }
-
-  if (finishedExpirationTime <= root.lastExpiredTime) {
-    // Clear the expired time
-    root.lastExpiredTime = NoWork;
-  }
-}
-function markRootExpiredAtTime(root, expirationTime) {
-  var lastExpiredTime = root.lastExpiredTime;
-
-  if (lastExpiredTime === NoWork || lastExpiredTime > expirationTime) {
-    root.lastExpiredTime = expirationTime;
-  }
+  var key =
+    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
+  return {
+    // This tag allow us to uniquely identify this as a React Portal
+    $$typeof: REACT_PORTAL_TYPE,
+    key: key == null ? null : "" + key,
+    children: children,
+    containerInfo: containerInfo,
+    implementation: implementation
+  };
 }
 
 var didWarnAboutNestedUpdates;
@@ -20421,31 +21334,42 @@ function findHostInstanceWithWarning(component, methodName) {
 
       if (!didWarnAboutFindNodeInStrictMode[componentName]) {
         didWarnAboutFindNodeInStrictMode[componentName] = true;
+        var previousFiber = current;
 
-        if (fiber.mode & StrictMode) {
-          error(
-            "%s is deprecated in StrictMode. " +
-              "%s was passed an instance of %s which is inside StrictMode. " +
-              "Instead, add a ref directly to the element you want to reference. " +
-              "Learn more about using refs safely here: " +
-              "https://fb.me/react-strict-mode-find-node%s",
-            methodName,
-            methodName,
-            componentName,
-            getStackByFiberInDevAndProd(hostFiber)
-          );
-        } else {
-          error(
-            "%s is deprecated in StrictMode. " +
-              "%s was passed an instance of %s which renders StrictMode children. " +
-              "Instead, add a ref directly to the element you want to reference. " +
-              "Learn more about using refs safely here: " +
-              "https://fb.me/react-strict-mode-find-node%s",
-            methodName,
-            methodName,
-            componentName,
-            getStackByFiberInDevAndProd(hostFiber)
-          );
+        try {
+          setCurrentFiber(hostFiber);
+
+          if (fiber.mode & StrictMode) {
+            error(
+              "%s is deprecated in StrictMode. " +
+                "%s was passed an instance of %s which is inside StrictMode. " +
+                "Instead, add a ref directly to the element you want to reference. " +
+                "Learn more about using refs safely here: " +
+                "https://reactjs.org/link/strict-mode-find-node",
+              methodName,
+              methodName,
+              componentName
+            );
+          } else {
+            error(
+              "%s is deprecated in StrictMode. " +
+                "%s was passed an instance of %s which renders StrictMode children. " +
+                "Instead, add a ref directly to the element you want to reference. " +
+                "Learn more about using refs safely here: " +
+                "https://reactjs.org/link/strict-mode-find-node",
+              methodName,
+              methodName,
+              componentName
+            );
+          }
+        } finally {
+          // Ideally this should reset to previous but this shouldn't be called in
+          // render and there's another warning for that anyway.
+          if (previousFiber) {
+            setCurrentFiber(previousFiber);
+          } else {
+            resetCurrentFiber();
+          }
         }
       }
     }
@@ -20463,7 +21387,7 @@ function updateContainer(element, container, parentComponent, callback) {
   }
 
   var current$1 = container.current;
-  var currentTime = requestCurrentTimeForUpdate();
+  var eventTime = requestEventTime();
 
   {
     // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
@@ -20473,12 +21397,8 @@ function updateContainer(element, container, parentComponent, callback) {
     }
   }
 
-  var suspenseConfig = requestCurrentSuspenseConfig();
-  var expirationTime = computeExpirationForFiber(
-    currentTime,
-    current$1,
-    suspenseConfig
-  );
+  var lane = requestUpdateLane(current$1);
+
   var context = getContextForSubtree(parentComponent);
 
   if (container.context === null) {
@@ -20501,7 +21421,7 @@ function updateContainer(element, container, parentComponent, callback) {
     }
   }
 
-  var update = createUpdate(expirationTime, suspenseConfig); // Caution: React DevTools currently depends on this property
+  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
   // being called "element".
 
   update.payload = {
@@ -20524,8 +21444,8 @@ function updateContainer(element, container, parentComponent, callback) {
   }
 
   enqueueUpdate(current$1, update);
-  scheduleWork(current$1, expirationTime);
-  return expirationTime;
+  scheduleUpdateOnFiber(current$1, lane, eventTime);
+  return lane;
 }
 function getPublicRootInstance(container) {
   var containerFiber = container.current;
@@ -20551,28 +21471,102 @@ function shouldSuspend(fiber) {
   return shouldSuspendImpl(fiber);
 }
 var overrideHookState = null;
+var overrideHookStateDeletePath = null;
+var overrideHookStateRenamePath = null;
 var overrideProps = null;
+var overridePropsDeletePath = null;
+var overridePropsRenamePath = null;
 var scheduleUpdate = null;
 var setSuspenseHandler = null;
 
 {
-  var copyWithSetImpl = function(obj, path, idx, value) {
-    if (idx >= path.length) {
+  var copyWithDeleteImpl = function(obj, path, index) {
+    var key = path[index];
+    var updated = Array.isArray(obj) ? obj.slice() : Object.assign({}, obj);
+
+    if (index + 1 === path.length) {
+      if (Array.isArray(updated)) {
+        updated.splice(key, 1);
+      } else {
+        delete updated[key];
+      }
+
+      return updated;
+    } // $FlowFixMe number or string is fine here
+
+    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
+    return updated;
+  };
+
+  var copyWithDelete = function(obj, path) {
+    return copyWithDeleteImpl(obj, path, 0);
+  };
+
+  var copyWithRenameImpl = function(obj, oldPath, newPath, index) {
+    var oldKey = oldPath[index];
+    var updated = Array.isArray(obj) ? obj.slice() : Object.assign({}, obj);
+
+    if (index + 1 === oldPath.length) {
+      var newKey = newPath[index]; // $FlowFixMe number or string is fine here
+
+      updated[newKey] = updated[oldKey];
+
+      if (Array.isArray(updated)) {
+        updated.splice(oldKey, 1);
+      } else {
+        delete updated[oldKey];
+      }
+    } else {
+      // $FlowFixMe number or string is fine here
+      updated[oldKey] = copyWithRenameImpl(
+        // $FlowFixMe number or string is fine here
+        obj[oldKey],
+        oldPath,
+        newPath,
+        index + 1
+      );
+    }
+
+    return updated;
+  };
+
+  var copyWithRename = function(obj, oldPath, newPath) {
+    if (oldPath.length !== newPath.length) {
+      warn("copyWithRename() expects paths of the same length");
+
+      return;
+    } else {
+      for (var i = 0; i < newPath.length - 1; i++) {
+        if (oldPath[i] !== newPath[i]) {
+          warn(
+            "copyWithRename() expects paths to be the same except for the deepest key"
+          );
+
+          return;
+        }
+      }
+    }
+
+    return copyWithRenameImpl(obj, oldPath, newPath, 0);
+  };
+
+  var copyWithSetImpl = function(obj, path, index, value) {
+    if (index >= path.length) {
       return value;
     }
 
-    var key = path[idx];
+    var key = path[index];
     var updated = Array.isArray(obj) ? obj.slice() : Object.assign({}, obj); // $FlowFixMe number or string is fine here
 
-    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
+    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
     return updated;
   };
 
   var copyWithSet = function(obj, path, value) {
     return copyWithSetImpl(obj, path, 0, value);
-  }; // Support DevTools editable values for useState and useReducer.
+  };
 
-  overrideHookState = function(fiber, id, path, value) {
+  var findHook = function(fiber, id) {
     // For now, the "id" of stateful hooks is just the stateful hook index.
     // This may change in the future with e.g. nested hooks.
     var currentHook = fiber.memoizedState;
@@ -20582,17 +21576,57 @@ var setSuspenseHandler = null;
       id--;
     }
 
-    if (currentHook !== null) {
-      var newState = copyWithSet(currentHook.memoizedState, path, value);
-      currentHook.memoizedState = newState;
-      currentHook.baseState = newState; // We aren't actually adding an update to the queue,
+    return currentHook;
+  }; // Support DevTools editable values for useState and useReducer.
+
+  overrideHookState = function(fiber, id, path, value) {
+    var hook = findHook(fiber, id);
+
+    if (hook !== null) {
+      var newState = copyWithSet(hook.memoizedState, path, value);
+      hook.memoizedState = newState;
+      hook.baseState = newState; // We aren't actually adding an update to the queue,
+      // because there is no update we can add for useReducer hooks that won't trigger an error.
+      // (There's no appropriate action type for DevTools overrides.)
+      // As a result though, React will see the scheduled update as a noop and bailout.
+      // Shallow cloning props works as a workaround for now to bypass the bailout check.
+
+      fiber.memoizedProps = Object.assign({}, fiber.memoizedProps);
+      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
+    }
+  };
+
+  overrideHookStateDeletePath = function(fiber, id, path) {
+    var hook = findHook(fiber, id);
+
+    if (hook !== null) {
+      var newState = copyWithDelete(hook.memoizedState, path);
+      hook.memoizedState = newState;
+      hook.baseState = newState; // We aren't actually adding an update to the queue,
+      // because there is no update we can add for useReducer hooks that won't trigger an error.
+      // (There's no appropriate action type for DevTools overrides.)
+      // As a result though, React will see the scheduled update as a noop and bailout.
+      // Shallow cloning props works as a workaround for now to bypass the bailout check.
+
+      fiber.memoizedProps = Object.assign({}, fiber.memoizedProps);
+      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
+    }
+  };
+
+  overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
+    var hook = findHook(fiber, id);
+
+    if (hook !== null) {
+      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
+      hook.memoizedState = newState;
+      hook.baseState = newState; // We aren't actually adding an update to the queue,
       // because there is no update we can add for useReducer hooks that won't trigger an error.
       // (There's no appropriate action type for DevTools overrides.)
       // As a result though, React will see the scheduled update as a noop and bailout.
       // Shallow cloning props works as a workaround for now to bypass the bailout check.
 
       fiber.memoizedProps = Object.assign({}, fiber.memoizedProps);
-      scheduleWork(fiber, Sync);
+      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
     }
   }; // Support DevTools props for function components, forwardRef, memo, host components, etc.
 
@@ -20603,11 +21637,31 @@ var setSuspenseHandler = null;
       fiber.alternate.pendingProps = fiber.pendingProps;
     }
 
-    scheduleWork(fiber, Sync);
+    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
+  };
+
+  overridePropsDeletePath = function(fiber, path) {
+    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
+
+    if (fiber.alternate) {
+      fiber.alternate.pendingProps = fiber.pendingProps;
+    }
+
+    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
+  };
+
+  overridePropsRenamePath = function(fiber, oldPath, newPath) {
+    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
+
+    if (fiber.alternate) {
+      fiber.alternate.pendingProps = fiber.pendingProps;
+    }
+
+    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
   };
 
   scheduleUpdate = function(fiber) {
-    scheduleWork(fiber, Sync);
+    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
   };
 
   setSuspenseHandler = function(newShouldSuspendImpl) {
@@ -20615,6 +21669,24 @@ var setSuspenseHandler = null;
   };
 }
 
+function findHostInstanceByFiber(fiber) {
+  var hostFiber = findCurrentHostFiber(fiber);
+
+  if (hostFiber === null) {
+    return null;
+  }
+
+  return hostFiber.stateNode;
+}
+
+function emptyFindFiberByHostInstance(instance) {
+  return null;
+}
+
+function getCurrentFiberForDevTools() {
+  return current;
+}
+
 function injectIntoDevTools(devToolsConfig) {
   var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
   var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
@@ -20624,59 +21696,26 @@ function injectIntoDevTools(devToolsConfig) {
     rendererPackageName: devToolsConfig.rendererPackageName,
     rendererConfig: devToolsConfig.rendererConfig,
     overrideHookState: overrideHookState,
+    overrideHookStateDeletePath: overrideHookStateDeletePath,
+    overrideHookStateRenamePath: overrideHookStateRenamePath,
     overrideProps: overrideProps,
+    overridePropsDeletePath: overridePropsDeletePath,
+    overridePropsRenamePath: overridePropsRenamePath,
     setSuspenseHandler: setSuspenseHandler,
     scheduleUpdate: scheduleUpdate,
     currentDispatcherRef: ReactCurrentDispatcher,
-    findHostInstanceByFiber: function(fiber) {
-      var hostFiber = findCurrentHostFiber(fiber);
-
-      if (hostFiber === null) {
-        return null;
-      }
-
-      return hostFiber.stateNode;
-    },
-    findFiberByHostInstance: function(instance) {
-      if (!findFiberByHostInstance) {
-        // Might not be implemented by the renderer.
-        return null;
-      }
-
-      return findFiberByHostInstance(instance);
-    },
+    findHostInstanceByFiber: findHostInstanceByFiber,
+    findFiberByHostInstance:
+      findFiberByHostInstance || emptyFindFiberByHostInstance,
     // React Refresh
     findHostInstancesForRefresh: findHostInstancesForRefresh,
     scheduleRefresh: scheduleRefresh,
     scheduleRoot: scheduleRoot,
     setRefreshHandler: setRefreshHandler,
     // Enables DevTools to append owner stacks to error messages in DEV mode.
-    getCurrentFiber: function() {
-      return current;
-    }
+    getCurrentFiber: getCurrentFiberForDevTools
   });
 }
-var IsSomeRendererActing$1 = ReactSharedInternals.IsSomeRendererActing;
-
-function createPortal(
-  children,
-  containerInfo, // TODO: figure out the API for cross-renderer implementation.
-  implementation
-) {
-  var key =
-    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
-  return {
-    // This tag allow us to uniquely identify this as a React Portal
-    $$typeof: REACT_PORTAL_TYPE,
-    key: key == null ? null : "" + key,
-    children: children,
-    containerInfo: containerInfo,
-    implementation: implementation
-  };
-}
-
-// TODO: this is special because it gets imported during build.
-var ReactVersion = "16.13.0";
 
 var emptyObject$1 = {};
 
@@ -20907,7 +21946,7 @@ var getInspectorDataForViewAtPoint;
       );
     } else {
       error(
-        "getInspectorDataForViewAtPoint expects to receieve a host component"
+        "getInspectorDataForViewAtPoint expects to receive a host component"
       );
 
       return;
diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
index 31b089c..53bb58b 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
@@ -6,7 +6,6 @@
  *
  * @noflow
  * @nolint
- * @providesModule ReactNativeRenderer-prod
  * @preventMunge
  * @generated
  */
@@ -16,16 +15,6 @@ require("react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore");
 var ReactNativePrivateInterface = require("react-native/Libraries/ReactPrivate/ReactNativePrivateInterface"),
   React = require("react"),
   Scheduler = require("scheduler");
-function getParent(inst) {
-  do inst = inst.return;
-  while (inst && 5 !== inst.tag);
-  return inst ? inst : null;
-}
-function traverseTwoPhase(inst, fn, arg) {
-  for (var path = []; inst; ) path.push(inst), (inst = getParent(inst));
-  for (inst = path.length; 0 < inst--; ) fn(path[inst], "captured", arg);
-  for (inst = 0; inst < path.length; inst++) fn(path[inst], "bubbled", arg);
-}
 function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
   var funcArgs = Array.prototype.slice.call(arguments, 3);
   try {
@@ -96,109 +85,6 @@ function executeDirectDispatch(event) {
   event._dispatchInstances = null;
   return dispatchListener;
 }
-function getListener(inst, registrationName) {
-  var listener = inst.stateNode;
-  if (!listener) return null;
-  var props = getFiberCurrentPropsFromNode(listener);
-  if (!props) return null;
-  listener = props[registrationName];
-  a: switch (registrationName) {
-    case "onClick":
-    case "onClickCapture":
-    case "onDoubleClick":
-    case "onDoubleClickCapture":
-    case "onMouseDown":
-    case "onMouseDownCapture":
-    case "onMouseMove":
-    case "onMouseMoveCapture":
-    case "onMouseUp":
-    case "onMouseUpCapture":
-    case "onMouseEnter":
-      (props = !props.disabled) ||
-        ((inst = inst.type),
-        (props = !(
-          "button" === inst ||
-          "input" === inst ||
-          "select" === inst ||
-          "textarea" === inst
-        )));
-      inst = !props;
-      break a;
-    default:
-      inst = !1;
-  }
-  if (inst) return null;
-  if (listener && "function" !== typeof listener)
-    throw Error(
-      "Expected `" +
-        registrationName +
-        "` listener to be a function, instead got a value of `" +
-        typeof listener +
-        "` type."
-    );
-  return listener;
-}
-function accumulateInto(current, next) {
-  if (null == next)
-    throw Error(
-      "accumulateInto(...): Accumulated items must not be null or undefined."
-    );
-  if (null == current) return next;
-  if (Array.isArray(current)) {
-    if (Array.isArray(next)) return current.push.apply(current, next), current;
-    current.push(next);
-    return current;
-  }
-  return Array.isArray(next) ? [current].concat(next) : [current, next];
-}
-function forEachAccumulated(arr, cb, scope) {
-  Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
-}
-function accumulateDirectionalDispatches(inst, phase, event) {
-  if (
-    (phase = getListener(
-      inst,
-      event.dispatchConfig.phasedRegistrationNames[phase]
-    ))
-  )
-    (event._dispatchListeners = accumulateInto(
-      event._dispatchListeners,
-      phase
-    )),
-      (event._dispatchInstances = accumulateInto(
-        event._dispatchInstances,
-        inst
-      ));
-}
-function accumulateTwoPhaseDispatchesSingle(event) {
-  event &&
-    event.dispatchConfig.phasedRegistrationNames &&
-    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
-}
-function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
-  if (event && event.dispatchConfig.phasedRegistrationNames) {
-    var targetInst = event._targetInst;
-    targetInst = targetInst ? getParent(targetInst) : null;
-    traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
-  }
-}
-function accumulateDirectDispatchesSingle(event) {
-  if (event && event.dispatchConfig.registrationName) {
-    var inst = event._targetInst;
-    if (inst && event && event.dispatchConfig.registrationName) {
-      var listener = getListener(inst, event.dispatchConfig.registrationName);
-      listener &&
-        ((event._dispatchListeners = accumulateInto(
-          event._dispatchListeners,
-          listener
-        )),
-        (event._dispatchInstances = accumulateInto(
-          event._dispatchInstances,
-          inst
-        )));
-    }
-  }
-}
 function functionThatReturnsTrue() {
   return !0;
 }
@@ -214,6 +100,7 @@ function SyntheticEvent(
   this.dispatchConfig = dispatchConfig;
   this._targetInst = targetInst;
   this.nativeEvent = nativeEvent;
+  this._dispatchInstances = this._dispatchListeners = null;
   dispatchConfig = this.constructor.Interface;
   for (var propName in dispatchConfig)
     dispatchConfig.hasOwnProperty(propName) &&
@@ -293,7 +180,12 @@ SyntheticEvent.extend = function(Interface) {
   return Class;
 };
 addEventPoolingTo(SyntheticEvent);
-function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
+function createOrGetPooledEvent(
+  dispatchConfig,
+  targetInst,
+  nativeEvent,
+  nativeInst
+) {
   if (this.eventPool.length) {
     var instance = this.eventPool.pop();
     this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
@@ -310,8 +202,8 @@ function releasePooledEvent(event) {
   10 > this.eventPool.length && this.eventPool.push(event);
 }
 function addEventPoolingTo(EventConstructor) {
+  EventConstructor.getPooled = createOrGetPooledEvent;
   EventConstructor.eventPool = [];
-  EventConstructor.getPooled = getPooledEvent;
   EventConstructor.release = releasePooledEvent;
 }
 var ResponderSyntheticEvent = SyntheticEvent.extend({
@@ -439,6 +331,22 @@ function accumulate(current, next) {
     ? [current].concat(next)
     : [current, next];
 }
+function accumulateInto(current, next) {
+  if (null == next)
+    throw Error(
+      "accumulateInto(...): Accumulated items must not be null or undefined."
+    );
+  if (null == current) return next;
+  if (Array.isArray(current)) {
+    if (Array.isArray(next)) return current.push.apply(current, next), current;
+    current.push(next);
+    return current;
+  }
+  return Array.isArray(next) ? [current].concat(next) : [current, next];
+}
+function forEachAccumulated(arr, cb, scope) {
+  Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
+}
 var responderInst = null,
   trackedTouchCount = 0;
 function changeResponder(nextResponderInst, blockHostResponder) {
@@ -452,65 +360,132 @@ function changeResponder(nextResponderInst, blockHostResponder) {
     );
 }
 var eventTypes = {
-    startShouldSetResponder: {
-      phasedRegistrationNames: {
-        bubbled: "onStartShouldSetResponder",
-        captured: "onStartShouldSetResponderCapture"
-      },
-      dependencies: startDependencies
-    },
-    scrollShouldSetResponder: {
-      phasedRegistrationNames: {
-        bubbled: "onScrollShouldSetResponder",
-        captured: "onScrollShouldSetResponderCapture"
-      },
-      dependencies: ["topScroll"]
-    },
-    selectionChangeShouldSetResponder: {
-      phasedRegistrationNames: {
-        bubbled: "onSelectionChangeShouldSetResponder",
-        captured: "onSelectionChangeShouldSetResponderCapture"
-      },
-      dependencies: ["topSelectionChange"]
-    },
-    moveShouldSetResponder: {
-      phasedRegistrationNames: {
-        bubbled: "onMoveShouldSetResponder",
-        captured: "onMoveShouldSetResponderCapture"
-      },
-      dependencies: moveDependencies
-    },
-    responderStart: {
-      registrationName: "onResponderStart",
-      dependencies: startDependencies
-    },
-    responderMove: {
-      registrationName: "onResponderMove",
-      dependencies: moveDependencies
+  startShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onStartShouldSetResponder",
+      captured: "onStartShouldSetResponderCapture"
     },
-    responderEnd: {
-      registrationName: "onResponderEnd",
-      dependencies: endDependencies
-    },
-    responderRelease: {
-      registrationName: "onResponderRelease",
-      dependencies: endDependencies
+    dependencies: startDependencies
+  },
+  scrollShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onScrollShouldSetResponder",
+      captured: "onScrollShouldSetResponderCapture"
     },
-    responderTerminationRequest: {
-      registrationName: "onResponderTerminationRequest",
-      dependencies: []
+    dependencies: ["topScroll"]
+  },
+  selectionChangeShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onSelectionChangeShouldSetResponder",
+      captured: "onSelectionChangeShouldSetResponderCapture"
     },
-    responderGrant: { registrationName: "onResponderGrant", dependencies: [] },
-    responderReject: {
-      registrationName: "onResponderReject",
-      dependencies: []
+    dependencies: ["topSelectionChange"]
+  },
+  moveShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onMoveShouldSetResponder",
+      captured: "onMoveShouldSetResponderCapture"
     },
-    responderTerminate: {
-      registrationName: "onResponderTerminate",
-      dependencies: []
-    }
+    dependencies: moveDependencies
+  },
+  responderStart: {
+    registrationName: "onResponderStart",
+    dependencies: startDependencies
+  },
+  responderMove: {
+    registrationName: "onResponderMove",
+    dependencies: moveDependencies
+  },
+  responderEnd: {
+    registrationName: "onResponderEnd",
+    dependencies: endDependencies
   },
-  ResponderEventPlugin = {
+  responderRelease: {
+    registrationName: "onResponderRelease",
+    dependencies: endDependencies
+  },
+  responderTerminationRequest: {
+    registrationName: "onResponderTerminationRequest",
+    dependencies: []
+  },
+  responderGrant: { registrationName: "onResponderGrant", dependencies: [] },
+  responderReject: { registrationName: "onResponderReject", dependencies: [] },
+  responderTerminate: {
+    registrationName: "onResponderTerminate",
+    dependencies: []
+  }
+};
+function getParent(inst) {
+  do inst = inst.return;
+  while (inst && 5 !== inst.tag);
+  return inst ? inst : null;
+}
+function traverseTwoPhase(inst, fn, arg) {
+  for (var path = []; inst; ) path.push(inst), (inst = getParent(inst));
+  for (inst = path.length; 0 < inst--; ) fn(path[inst], "captured", arg);
+  for (inst = 0; inst < path.length; inst++) fn(path[inst], "bubbled", arg);
+}
+function getListener(inst, registrationName) {
+  inst = inst.stateNode;
+  if (null === inst) return null;
+  inst = getFiberCurrentPropsFromNode(inst);
+  if (null === inst) return null;
+  if ((inst = inst[registrationName]) && "function" !== typeof inst)
+    throw Error(
+      "Expected `" +
+        registrationName +
+        "` listener to be a function, instead got a value of `" +
+        typeof inst +
+        "` type."
+    );
+  return inst;
+}
+function accumulateDirectionalDispatches(inst, phase, event) {
+  if (
+    (phase = getListener(
+      inst,
+      event.dispatchConfig.phasedRegistrationNames[phase]
+    ))
+  )
+    (event._dispatchListeners = accumulateInto(
+      event._dispatchListeners,
+      phase
+    )),
+      (event._dispatchInstances = accumulateInto(
+        event._dispatchInstances,
+        inst
+      ));
+}
+function accumulateDirectDispatchesSingle(event) {
+  if (event && event.dispatchConfig.registrationName) {
+    var inst = event._targetInst;
+    if (inst && event && event.dispatchConfig.registrationName) {
+      var listener = getListener(inst, event.dispatchConfig.registrationName);
+      listener &&
+        ((event._dispatchListeners = accumulateInto(
+          event._dispatchListeners,
+          listener
+        )),
+        (event._dispatchInstances = accumulateInto(
+          event._dispatchInstances,
+          inst
+        )));
+    }
+  }
+}
+function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    var targetInst = event._targetInst;
+    targetInst = targetInst ? getParent(targetInst) : null;
+    traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
+  }
+}
+function accumulateTwoPhaseDispatchesSingle(event) {
+  event &&
+    event.dispatchConfig.phasedRegistrationNames &&
+    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
+}
+var ResponderEventPlugin = {
     _getResponder: function() {
       return responderInst;
     },
@@ -571,68 +546,70 @@ var eventTypes = {
             JSCompiler_temp = null;
           }
         else JSCompiler_temp = targetInst;
-        targetInst = JSCompiler_temp === responderInst;
-        JSCompiler_temp = ResponderSyntheticEvent.getPooled(
+        targetInst = JSCompiler_temp;
+        JSCompiler_temp = targetInst === responderInst;
+        shouldSetEventType = ResponderSyntheticEvent.getPooled(
           shouldSetEventType,
-          JSCompiler_temp,
+          targetInst,
           nativeEvent,
           nativeEventTarget
         );
-        JSCompiler_temp.touchHistory = ResponderTouchHistoryStore.touchHistory;
-        targetInst
+        shouldSetEventType.touchHistory =
+          ResponderTouchHistoryStore.touchHistory;
+        JSCompiler_temp
           ? forEachAccumulated(
-              JSCompiler_temp,
+              shouldSetEventType,
               accumulateTwoPhaseDispatchesSingleSkipTarget
             )
           : forEachAccumulated(
-              JSCompiler_temp,
+              shouldSetEventType,
               accumulateTwoPhaseDispatchesSingle
             );
         b: {
-          shouldSetEventType = JSCompiler_temp._dispatchListeners;
-          targetInst = JSCompiler_temp._dispatchInstances;
-          if (Array.isArray(shouldSetEventType))
+          JSCompiler_temp = shouldSetEventType._dispatchListeners;
+          targetInst = shouldSetEventType._dispatchInstances;
+          if (Array.isArray(JSCompiler_temp))
             for (
               depthA = 0;
-              depthA < shouldSetEventType.length &&
-              !JSCompiler_temp.isPropagationStopped();
+              depthA < JSCompiler_temp.length &&
+              !shouldSetEventType.isPropagationStopped();
               depthA++
             ) {
               if (
-                shouldSetEventType[depthA](JSCompiler_temp, targetInst[depthA])
+                JSCompiler_temp[depthA](shouldSetEventType, targetInst[depthA])
               ) {
-                shouldSetEventType = targetInst[depthA];
+                JSCompiler_temp = targetInst[depthA];
                 break b;
               }
             }
           else if (
-            shouldSetEventType &&
-            shouldSetEventType(JSCompiler_temp, targetInst)
+            JSCompiler_temp &&
+            JSCompiler_temp(shouldSetEventType, targetInst)
           ) {
-            shouldSetEventType = targetInst;
+            JSCompiler_temp = targetInst;
             break b;
           }
-          shouldSetEventType = null;
+          JSCompiler_temp = null;
         }
-        JSCompiler_temp._dispatchInstances = null;
-        JSCompiler_temp._dispatchListeners = null;
-        JSCompiler_temp.isPersistent() ||
-          JSCompiler_temp.constructor.release(JSCompiler_temp);
-        if (shouldSetEventType && shouldSetEventType !== responderInst)
+        shouldSetEventType._dispatchInstances = null;
+        shouldSetEventType._dispatchListeners = null;
+        shouldSetEventType.isPersistent() ||
+          shouldSetEventType.constructor.release(shouldSetEventType);
+        if (JSCompiler_temp && JSCompiler_temp !== responderInst)
           if (
-            ((JSCompiler_temp = ResponderSyntheticEvent.getPooled(
+            ((shouldSetEventType = ResponderSyntheticEvent.getPooled(
               eventTypes.responderGrant,
-              shouldSetEventType,
+              JSCompiler_temp,
               nativeEvent,
               nativeEventTarget
             )),
-            (JSCompiler_temp.touchHistory =
+            (shouldSetEventType.touchHistory =
               ResponderTouchHistoryStore.touchHistory),
             forEachAccumulated(
-              JSCompiler_temp,
+              shouldSetEventType,
               accumulateDirectDispatchesSingle
             ),
-            (targetInst = !0 === executeDirectDispatch(JSCompiler_temp)),
+            (targetInst = !0 === executeDirectDispatch(shouldSetEventType)),
             responderInst)
           )
             if (
@@ -659,13 +636,13 @@ var eventTypes = {
               forEachAccumulated(depthA, accumulateDirectDispatchesSingle);
               var JSCompiler_temp$jscomp$0 = accumulate(
                 JSCompiler_temp$jscomp$0,
-                [JSCompiler_temp, depthA]
+                [shouldSetEventType, depthA]
               );
-              changeResponder(shouldSetEventType, targetInst);
+              changeResponder(JSCompiler_temp, targetInst);
             } else
               (shouldSetEventType = ResponderSyntheticEvent.getPooled(
                 eventTypes.responderReject,
-                shouldSetEventType,
+                JSCompiler_temp,
                 nativeEvent,
                 nativeEventTarget
               )),
@@ -682,9 +659,9 @@ var eventTypes = {
           else
             (JSCompiler_temp$jscomp$0 = accumulate(
               JSCompiler_temp$jscomp$0,
-              JSCompiler_temp
+              shouldSetEventType
             )),
-              changeResponder(shouldSetEventType, targetInst);
+              changeResponder(JSCompiler_temp, targetInst);
         else JSCompiler_temp$jscomp$0 = null;
       } else JSCompiler_temp$jscomp$0 = null;
       shouldSetEventType = responderInst && isStartish(topLevelType);
@@ -812,7 +789,6 @@ function recomputePluginOrdering() {
         for (var eventName in pluginIndex) {
           var JSCompiler_inline_result = void 0;
           var dispatchConfig = pluginIndex[eventName],
-            pluginModule$jscomp$0 = pluginModule,
             eventName$jscomp$0 = eventName;
           if (eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0))
             throw Error(
@@ -829,7 +805,7 @@ function recomputePluginOrdering() {
               ) &&
                 publishRegistrationName(
                   phasedRegistrationNames[JSCompiler_inline_result],
-                  pluginModule$jscomp$0,
+                  pluginModule,
                   eventName$jscomp$0
                 );
             JSCompiler_inline_result = !0;
@@ -837,7 +813,7 @@ function recomputePluginOrdering() {
             dispatchConfig.registrationName
               ? (publishRegistrationName(
                   dispatchConfig.registrationName,
-                  pluginModule$jscomp$0,
+                  pluginModule,
                   eventName$jscomp$0
                 ),
                 (JSCompiler_inline_result = !0))
@@ -865,13 +841,75 @@ function publishRegistrationName(registrationName, pluginModule) {
 }
 var plugins = [],
   eventNameDispatchConfigs = {},
-  registrationNameModules = {},
-  customBubblingEventTypes =
+  registrationNameModules = {};
+function getListener$1(inst, registrationName) {
+  inst = inst.stateNode;
+  if (null === inst) return null;
+  inst = getFiberCurrentPropsFromNode(inst);
+  if (null === inst) return null;
+  if ((inst = inst[registrationName]) && "function" !== typeof inst)
+    throw Error(
+      "Expected `" +
+        registrationName +
+        "` listener to be a function, instead got a value of `" +
+        typeof inst +
+        "` type."
+    );
+  return inst;
+}
+var customBubblingEventTypes =
     ReactNativePrivateInterface.ReactNativeViewConfigRegistry
       .customBubblingEventTypes,
   customDirectEventTypes =
     ReactNativePrivateInterface.ReactNativeViewConfigRegistry
       .customDirectEventTypes;
+function accumulateDirectionalDispatches$1(inst, phase, event) {
+  if (
+    (phase = getListener$1(
+      inst,
+      event.dispatchConfig.phasedRegistrationNames[phase]
+    ))
+  )
+    (event._dispatchListeners = accumulateInto(
+      event._dispatchListeners,
+      phase
+    )),
+      (event._dispatchInstances = accumulateInto(
+        event._dispatchInstances,
+        inst
+      ));
+}
+function accumulateTwoPhaseDispatchesSingle$1(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    for (var inst = event._targetInst, path = []; inst; ) {
+      path.push(inst);
+      do inst = inst.return;
+      while (inst && 5 !== inst.tag);
+      inst = inst ? inst : null;
+    }
+    for (inst = path.length; 0 < inst--; )
+      accumulateDirectionalDispatches$1(path[inst], "captured", event);
+    for (inst = 0; inst < path.length; inst++)
+      accumulateDirectionalDispatches$1(path[inst], "bubbled", event);
+  }
+}
+function accumulateDirectDispatchesSingle$1(event) {
+  if (event && event.dispatchConfig.registrationName) {
+    var inst = event._targetInst;
+    if (inst && event && event.dispatchConfig.registrationName) {
+      var listener = getListener$1(inst, event.dispatchConfig.registrationName);
+      listener &&
+        ((event._dispatchListeners = accumulateInto(
+          event._dispatchListeners,
+          listener
+        )),
+        (event._dispatchInstances = accumulateInto(
+          event._dispatchInstances,
+          inst
+        )));
+    }
+  }
+}
 if (eventPluginOrder)
   throw Error(
     "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React."
@@ -881,7 +919,7 @@ eventPluginOrder = Array.prototype.slice.call([
   "ReactNativeBridgeEventPlugin"
 ]);
 recomputePluginOrdering();
-var injectedNamesToPlugins$jscomp$inline_94 = {
+var injectedNamesToPlugins$jscomp$inline_228 = {
     ResponderEventPlugin: ResponderEventPlugin,
     ReactNativeBridgeEventPlugin: {
       eventTypes: {},
@@ -905,42 +943,45 @@ var injectedNamesToPlugins$jscomp$inline_94 = {
           nativeEventTarget
         );
         if (bubbleDispatchConfig)
-          forEachAccumulated(topLevelType, accumulateTwoPhaseDispatchesSingle);
+          forEachAccumulated(
+            topLevelType,
+            accumulateTwoPhaseDispatchesSingle$1
+          );
         else if (directDispatchConfig)
-          forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle);
+          forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle$1);
         else return null;
         return topLevelType;
       }
     }
   },
-  isOrderingDirty$jscomp$inline_95 = !1,
-  pluginName$jscomp$inline_96;
-for (pluginName$jscomp$inline_96 in injectedNamesToPlugins$jscomp$inline_94)
+  isOrderingDirty$jscomp$inline_229 = !1,
+  pluginName$jscomp$inline_230;
+for (pluginName$jscomp$inline_230 in injectedNamesToPlugins$jscomp$inline_228)
   if (
-    injectedNamesToPlugins$jscomp$inline_94.hasOwnProperty(
-      pluginName$jscomp$inline_96
+    injectedNamesToPlugins$jscomp$inline_228.hasOwnProperty(
+      pluginName$jscomp$inline_230
     )
   ) {
-    var pluginModule$jscomp$inline_97 =
-      injectedNamesToPlugins$jscomp$inline_94[pluginName$jscomp$inline_96];
+    var pluginModule$jscomp$inline_231 =
+      injectedNamesToPlugins$jscomp$inline_228[pluginName$jscomp$inline_230];
     if (
-      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_96) ||
-      namesToPlugins[pluginName$jscomp$inline_96] !==
-        pluginModule$jscomp$inline_97
+      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_230) ||
+      namesToPlugins[pluginName$jscomp$inline_230] !==
+        pluginModule$jscomp$inline_231
     ) {
-      if (namesToPlugins[pluginName$jscomp$inline_96])
+      if (namesToPlugins[pluginName$jscomp$inline_230])
         throw Error(
           "EventPluginRegistry: Cannot inject two different event plugins using the same name, `" +
-            pluginName$jscomp$inline_96 +
+            pluginName$jscomp$inline_230 +
             "`."
         );
       namesToPlugins[
-        pluginName$jscomp$inline_96
-      ] = pluginModule$jscomp$inline_97;
-      isOrderingDirty$jscomp$inline_95 = !0;
+        pluginName$jscomp$inline_230
+      ] = pluginModule$jscomp$inline_231;
+      isOrderingDirty$jscomp$inline_229 = !0;
     }
   }
-isOrderingDirty$jscomp$inline_95 && recomputePluginOrdering();
+isOrderingDirty$jscomp$inline_229 && recomputePluginOrdering();
 var instanceCache = new Map(),
   instanceProps = new Map();
 function getInstanceFromTag(tag) {
@@ -986,34 +1027,41 @@ function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
     target = null;
   null != inst && (target = inst.stateNode);
   batchedUpdates(function() {
-    var events = target;
-    for (var events$jscomp$0 = null, i = 0; i < plugins.length; i++) {
-      var possiblePlugin = plugins[i];
+    var JSCompiler_inline_result = target;
+    for (
+      var events = null, legacyPlugins = plugins, i = 0;
+      i < legacyPlugins.length;
+      i++
+    ) {
+      var possiblePlugin = legacyPlugins[i];
       possiblePlugin &&
         (possiblePlugin = possiblePlugin.extractEvents(
           topLevelType,
           inst,
           nativeEvent,
-          events,
-          1
+          JSCompiler_inline_result
         )) &&
-        (events$jscomp$0 = accumulateInto(events$jscomp$0, possiblePlugin));
+        (events = accumulateInto(events, possiblePlugin));
     }
-    events = events$jscomp$0;
-    null !== events && (eventQueue = accumulateInto(eventQueue, events));
-    events = eventQueue;
+    JSCompiler_inline_result = events;
+    null !== JSCompiler_inline_result &&
+      (eventQueue = accumulateInto(eventQueue, JSCompiler_inline_result));
+    JSCompiler_inline_result = eventQueue;
     eventQueue = null;
-    if (events) {
-      forEachAccumulated(events, executeDispatchesAndReleaseTopLevel);
+    if (JSCompiler_inline_result) {
+      forEachAccumulated(
+        JSCompiler_inline_result,
+        executeDispatchesAndReleaseTopLevel
+      );
       if (eventQueue)
         throw Error(
           "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."
         );
       if (hasRethrowError)
-        throw ((events = rethrowError),
+        throw ((JSCompiler_inline_result = rethrowError),
         (hasRethrowError = !1),
         (rethrowError = null),
-        events);
+        JSCompiler_inline_result);
     }
   });
 }
@@ -1028,13 +1076,13 @@ ReactNativePrivateInterface.RCTEventEmitter.register({
     ) {
       var JSCompiler_temp = [];
       for (var i = 0; i < changedIndices.length; i++) {
-        var index = changedIndices[i];
-        JSCompiler_temp.push(touches[index]);
-        touches[index] = null;
+        var index$0 = changedIndices[i];
+        JSCompiler_temp.push(touches[index$0]);
+        touches[index$0] = null;
       }
       for (i = changedIndices = 0; i < touches.length; i++)
-        (index = touches[i]),
-          null !== index && (touches[changedIndices++] = index);
+        (index$0 = touches[i]),
+          null !== index$0 && (touches[changedIndices++] = index$0);
       touches.length = changedIndices;
     } else
       for (JSCompiler_temp = [], i = 0; i < changedIndices.length; i++)
@@ -1047,10 +1095,10 @@ ReactNativePrivateInterface.RCTEventEmitter.register({
       i = JSCompiler_temp[changedIndices];
       i.changedTouches = JSCompiler_temp;
       i.touches = touches;
-      index = null;
+      index$0 = null;
       var target = i.target;
-      null === target || void 0 === target || 1 > target || (index = target);
-      _receiveRootNodeIDEvent(index, eventTopLevelType, i);
+      null === target || void 0 === target || 1 > target || (index$0 = target);
+      _receiveRootNodeIDEvent(index$0, eventTopLevelType, i);
     }
   }
 });
@@ -1076,31 +1124,44 @@ ResponderEventPlugin.injection.injectGlobalResponderHandler({
   }
 });
 var ReactSharedInternals =
-  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
-ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher") ||
-  (ReactSharedInternals.ReactCurrentDispatcher = { current: null });
-ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig") ||
-  (ReactSharedInternals.ReactCurrentBatchConfig = { suspense: null });
-var hasSymbol = "function" === typeof Symbol && Symbol.for,
-  REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103,
-  REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106,
-  REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107,
-  REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108,
-  REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114,
-  REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109,
-  REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110,
-  REACT_CONCURRENT_MODE_TYPE = hasSymbol
-    ? Symbol.for("react.concurrent_mode")
-    : 60111,
-  REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112,
-  REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
-  REACT_SUSPENSE_LIST_TYPE = hasSymbol
-    ? Symbol.for("react.suspense_list")
-    : 60120,
-  REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
-  REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116,
-  REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121,
-  MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;
+    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
+  REACT_ELEMENT_TYPE = 60103,
+  REACT_PORTAL_TYPE = 60106,
+  REACT_FRAGMENT_TYPE = 60107,
+  REACT_STRICT_MODE_TYPE = 60108,
+  REACT_PROFILER_TYPE = 60114,
+  REACT_PROVIDER_TYPE = 60109,
+  REACT_CONTEXT_TYPE = 60110,
+  REACT_FORWARD_REF_TYPE = 60112,
+  REACT_SUSPENSE_TYPE = 60113,
+  REACT_SUSPENSE_LIST_TYPE = 60120,
+  REACT_MEMO_TYPE = 60115,
+  REACT_LAZY_TYPE = 60116,
+  REACT_BLOCK_TYPE = 60121,
+  REACT_DEBUG_TRACING_MODE_TYPE = 60129,
+  REACT_OFFSCREEN_TYPE = 60130,
+  REACT_LEGACY_HIDDEN_TYPE = 60131;
+if ("function" === typeof Symbol && Symbol.for) {
+  var symbolFor = Symbol.for;
+  REACT_ELEMENT_TYPE = symbolFor("react.element");
+  REACT_PORTAL_TYPE = symbolFor("react.portal");
+  REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
+  REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
+  REACT_PROFILER_TYPE = symbolFor("react.profiler");
+  REACT_PROVIDER_TYPE = symbolFor("react.provider");
+  REACT_CONTEXT_TYPE = symbolFor("react.context");
+  REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
+  REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
+  REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
+  REACT_MEMO_TYPE = symbolFor("react.memo");
+  REACT_LAZY_TYPE = symbolFor("react.lazy");
+  REACT_BLOCK_TYPE = symbolFor("react.block");
+  symbolFor("react.scope");
+  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
+  REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
+  REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
+}
+var MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;
 function getIteratorFn(maybeIterable) {
   if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
   maybeIterable =
@@ -1108,27 +1169,6 @@ function getIteratorFn(maybeIterable) {
     maybeIterable["@@iterator"];
   return "function" === typeof maybeIterable ? maybeIterable : null;
 }
-function initializeLazyComponentType(lazyComponent) {
-  if (-1 === lazyComponent._status) {
-    var ctor = lazyComponent._result;
-    ctor || (ctor = lazyComponent._ctor);
-    ctor = ctor();
-    lazyComponent._status = 0;
-    lazyComponent._result = ctor;
-    ctor.then(
-      function(moduleObject) {
-        0 === lazyComponent._status &&
-          ((moduleObject = moduleObject.default),
-          (lazyComponent._status = 1),
-          (lazyComponent._result = moduleObject));
-      },
-      function(error) {
-        0 === lazyComponent._status &&
-          ((lazyComponent._status = 2), (lazyComponent._result = error));
-      }
-    );
-  }
-}
 function getComponentName(type) {
   if (null == type) return null;
   if ("function" === typeof type) return type.displayName || type.name || null;
@@ -1163,10 +1203,13 @@ function getComponentName(type) {
       case REACT_MEMO_TYPE:
         return getComponentName(type.type);
       case REACT_BLOCK_TYPE:
-        return getComponentName(type.render);
+        return getComponentName(type._render);
       case REACT_LAZY_TYPE:
-        if ((type = 1 === type._status ? type._result : null))
-          return getComponentName(type);
+        innerType = type._payload;
+        type = type._init;
+        try {
+          return getComponentName(type(innerType));
+        } catch (x) {}
     }
   return null;
 }
@@ -1218,36 +1261,36 @@ function findCurrentFiberUsingSlowPath(fiber) {
     }
     if (a.return !== b.return) (a = parentA), (b = parentB);
     else {
-      for (var didFindChild = !1, _child = parentA.child; _child; ) {
-        if (_child === a) {
+      for (var didFindChild = !1, child$1 = parentA.child; child$1; ) {
+        if (child$1 === a) {
           didFindChild = !0;
           a = parentA;
           b = parentB;
           break;
         }
-        if (_child === b) {
+        if (child$1 === b) {
           didFindChild = !0;
           b = parentA;
           a = parentB;
           break;
         }
-        _child = _child.sibling;
+        child$1 = child$1.sibling;
       }
       if (!didFindChild) {
-        for (_child = parentB.child; _child; ) {
-          if (_child === a) {
+        for (child$1 = parentB.child; child$1; ) {
+          if (child$1 === a) {
             didFindChild = !0;
             a = parentB;
             b = parentA;
             break;
           }
-          if (_child === b) {
+          if (child$1 === b) {
             didFindChild = !0;
             b = parentB;
             a = parentA;
             break;
           }
-          _child = _child.sibling;
+          child$1 = child$1.sibling;
         }
         if (!didFindChild)
           throw Error(
@@ -1282,6 +1325,18 @@ function findCurrentHostFiber(parent) {
   }
   return null;
 }
+function doesFiberContain(parentFiber, childFiber) {
+  for (
+    var parentFiberAlternate = parentFiber.alternate;
+    null !== childFiber;
+
+  ) {
+    if (childFiber === parentFiber || childFiber === parentFiberAlternate)
+      return !0;
+    childFiber = childFiber.return;
+  }
+  return !1;
+}
 var emptyObject = {},
   removedKeys = null,
   removedKeyCount = 0,
@@ -1486,19 +1541,19 @@ function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
               ),
               (removedKeys = null));
     }
-  for (var _propKey in prevProps)
-    void 0 === nextProps[_propKey] &&
-      (!(attributeConfig = validAttributes[_propKey]) ||
-        (updatePayload && void 0 !== updatePayload[_propKey]) ||
-        ((prevProp = prevProps[_propKey]),
+  for (var propKey$3 in prevProps)
+    void 0 === nextProps[propKey$3] &&
+      (!(attributeConfig = validAttributes[propKey$3]) ||
+        (updatePayload && void 0 !== updatePayload[propKey$3]) ||
+        ((prevProp = prevProps[propKey$3]),
         void 0 !== prevProp &&
           ("object" !== typeof attributeConfig ||
           "function" === typeof attributeConfig.diff ||
           "function" === typeof attributeConfig.process
-            ? (((updatePayload || (updatePayload = {}))[_propKey] = null),
+            ? (((updatePayload || (updatePayload = {}))[propKey$3] = null),
               removedKeys || (removedKeys = {}),
-              removedKeys[_propKey] ||
-                ((removedKeys[_propKey] = !0), removedKeyCount++))
+              removedKeys[propKey$3] ||
+                ((removedKeys[propKey$3] = !0), removedKeyCount++))
             : (updatePayload = clearNestedProperty(
                 updatePayload,
                 prevProp,
@@ -1607,9 +1662,22 @@ function finalizeInitialChildren(parentInstance) {
   return !1;
 }
 var scheduleTimeout = setTimeout,
-  cancelTimeout = clearTimeout,
-  valueStack = [],
+  cancelTimeout = clearTimeout;
+function describeComponentFrame(name, source, ownerName) {
+  source = "";
+  ownerName && (source = " (created by " + ownerName + ")");
+  return "\n    in " + (name || "Unknown") + source;
+}
+function describeFunctionComponentFrame(fn, source) {
+  return fn
+    ? describeComponentFrame(fn.displayName || fn.name || null, source, null)
+    : "";
+}
+var valueStack = [],
   index = -1;
+function createCursor(defaultValue) {
+  return { current: defaultValue };
+}
 function pop(cursor) {
   0 > index ||
     ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
@@ -1620,8 +1688,8 @@ function push(cursor, value) {
   cursor.current = value;
 }
 var emptyContextObject = {},
-  contextStackCursor = { current: emptyContextObject },
-  didPerformWorkStackCursor = { current: !1 },
+  contextStackCursor = createCursor(emptyContextObject),
+  didPerformWorkStackCursor = createCursor(!1),
   previousContext = emptyContextObject;
 function getMaskedContext(workInProgress, unmaskedContext) {
   var contextTypes = workInProgress.type.contextTypes;
@@ -1701,11 +1769,220 @@ function invalidateContextProvider(workInProgress, type, didChange) {
     : pop(didPerformWorkStackCursor);
   push(didPerformWorkStackCursor, didChange);
 }
+var rendererID = null,
+  injectedHook = null,
+  Scheduler_now = Scheduler.unstable_now;
+Scheduler_now();
+var return_highestLanePriority = 10;
+function getHighestPriorityLanes(lanes) {
+  if (0 !== (1 & lanes)) return (return_highestLanePriority = 17), 1;
+  if (0 !== (2 & lanes)) return (return_highestLanePriority = 16), 2;
+  if (0 !== (4 & lanes)) return (return_highestLanePriority = 15), 4;
+  var inputDiscreteLanes = 24 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 14), inputDiscreteLanes;
+  if (0 !== (lanes & 32)) return (return_highestLanePriority = 13), 32;
+  inputDiscreteLanes = 192 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 12), inputDiscreteLanes;
+  if (0 !== (lanes & 256)) return (return_highestLanePriority = 11), 256;
+  inputDiscreteLanes = 3584 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 10), inputDiscreteLanes;
+  if (0 !== (lanes & 4096)) return (return_highestLanePriority = 9), 4096;
+  inputDiscreteLanes = 122880 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 8), inputDiscreteLanes;
+  if (0 !== (lanes & 131072)) return (return_highestLanePriority = 7), 131072;
+  inputDiscreteLanes = 3932160 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 6), inputDiscreteLanes;
+  inputDiscreteLanes = 62914560 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 5), inputDiscreteLanes;
+  if (lanes & 67108864) return (return_highestLanePriority = 4), 67108864;
+  if (0 !== (lanes & 134217728))
+    return (return_highestLanePriority = 3), 134217728;
+  inputDiscreteLanes = 805306368 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 2), inputDiscreteLanes;
+  if (0 !== (1073741824 & lanes))
+    return (return_highestLanePriority = 1), 1073741824;
+  return_highestLanePriority = 10;
+  return lanes;
+}
+function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
+  switch (schedulerPriorityLevel) {
+    case 99:
+      return 17;
+    case 98:
+      return 12;
+    case 97:
+    case 96:
+      return 10;
+    case 95:
+      return 2;
+    default:
+      return 0;
+  }
+}
+function lanePriorityToSchedulerPriority(lanePriority) {
+  switch (lanePriority) {
+    case 17:
+    case 16:
+      return 99;
+    case 15:
+    case 14:
+    case 13:
+    case 12:
+      return 98;
+    case 11:
+    case 10:
+    case 9:
+    case 8:
+    case 7:
+    case 6:
+    case 4:
+    case 5:
+      return 97;
+    case 3:
+    case 2:
+    case 1:
+      return 95;
+    case 0:
+      return 90;
+    default:
+      throw Error(
+        "Invalid update priority: " + lanePriority + ". This is a bug in React."
+      );
+  }
+}
+function getNextLanes(root, wipLanes) {
+  var pendingLanes = root.pendingLanes;
+  if (0 === pendingLanes) return (return_highestLanePriority = 0);
+  var nextLanes = 0,
+    nextLanePriority = 0,
+    expiredLanes = root.expiredLanes,
+    suspendedLanes = root.suspendedLanes,
+    pingedLanes = root.pingedLanes;
+  if (0 !== expiredLanes)
+    (nextLanes = expiredLanes),
+      (nextLanePriority = return_highestLanePriority = 17);
+  else if (((expiredLanes = pendingLanes & 134217727), 0 !== expiredLanes)) {
+    var nonIdleUnblockedLanes = expiredLanes & ~suspendedLanes;
+    0 !== nonIdleUnblockedLanes
+      ? ((nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes)),
+        (nextLanePriority = return_highestLanePriority))
+      : ((pingedLanes &= expiredLanes),
+        0 !== pingedLanes &&
+          ((nextLanes = getHighestPriorityLanes(pingedLanes)),
+          (nextLanePriority = return_highestLanePriority)));
+  } else
+    (expiredLanes = pendingLanes & ~suspendedLanes),
+      0 !== expiredLanes
+        ? ((nextLanes = getHighestPriorityLanes(expiredLanes)),
+          (nextLanePriority = return_highestLanePriority))
+        : 0 !== pingedLanes &&
+          ((nextLanes = getHighestPriorityLanes(pingedLanes)),
+          (nextLanePriority = return_highestLanePriority));
+  if (0 === nextLanes) return 0;
+  nextLanes = 31 - clz32(nextLanes);
+  nextLanes = pendingLanes & (((0 > nextLanes ? 0 : 1 << nextLanes) << 1) - 1);
+  if (
+    0 !== wipLanes &&
+    wipLanes !== nextLanes &&
+    0 === (wipLanes & suspendedLanes)
+  ) {
+    getHighestPriorityLanes(wipLanes);
+    if (nextLanePriority <= return_highestLanePriority) return wipLanes;
+    return_highestLanePriority = nextLanePriority;
+  }
+  wipLanes = root.entangledLanes;
+  if (0 !== wipLanes)
+    for (root = root.entanglements, wipLanes &= nextLanes; 0 < wipLanes; )
+      (pendingLanes = 31 - clz32(wipLanes)),
+        (nextLanePriority = 1 << pendingLanes),
+        (nextLanes |= root[pendingLanes]),
+        (wipLanes &= ~nextLanePriority);
+  return nextLanes;
+}
+function getMostRecentEventTime(root, lanes) {
+  root = root.eventTimes;
+  for (var mostRecentEventTime = -1; 0 < lanes; ) {
+    var index$6 = 31 - clz32(lanes),
+      lane = 1 << index$6;
+    index$6 = root[index$6];
+    index$6 > mostRecentEventTime && (mostRecentEventTime = index$6);
+    lanes &= ~lane;
+  }
+  return mostRecentEventTime;
+}
+function getLanesToRetrySynchronouslyOnError(root) {
+  root = root.pendingLanes & -1073741825;
+  return 0 !== root ? root : root & 1073741824 ? 1073741824 : 0;
+}
+function findUpdateLane(lanePriority, wipLanes) {
+  switch (lanePriority) {
+    case 17:
+      return 1;
+    case 16:
+      return 2;
+    case 14:
+      return (
+        (lanePriority = getHighestPriorityLane(24 & ~wipLanes)),
+        0 === lanePriority ? findUpdateLane(12, wipLanes) : lanePriority
+      );
+    case 12:
+      return (
+        (lanePriority = getHighestPriorityLane(192 & ~wipLanes)),
+        0 === lanePriority ? findUpdateLane(10, wipLanes) : lanePriority
+      );
+    case 10:
+      return (
+        (lanePriority = getHighestPriorityLane(3584 & ~wipLanes)),
+        0 === lanePriority &&
+          ((lanePriority = getHighestPriorityLane(4055040 & ~wipLanes)),
+          0 === lanePriority && (lanePriority = 512)),
+        lanePriority
+      );
+    case 2:
+      return (
+        (wipLanes = getHighestPriorityLane(805306368 & ~wipLanes)),
+        0 === wipLanes && (wipLanes = 268435456),
+        wipLanes
+      );
+  }
+  throw Error(
+    "Invalid update priority: " + lanePriority + ". This is a bug in React."
+  );
+}
+function getHighestPriorityLane(lanes) {
+  return lanes & -lanes;
+}
+function pickArbitraryLane(lanes) {
+  return lanes & -lanes;
+}
+function markRootUpdated(root, updateLane, eventTime) {
+  root.pendingLanes |= updateLane;
+  var higherPriorityLanes = updateLane - 1;
+  root.suspendedLanes &= higherPriorityLanes;
+  root.pingedLanes &= higherPriorityLanes;
+  root = root.eventTimes;
+  updateLane = 31 - clz32(updateLane);
+  root[updateLane] = eventTime;
+}
+var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
+  log = Math.log,
+  LN2 = Math.LN2;
+function clz32Fallback(lanes) {
+  return 0 === lanes ? 32 : (31 - ((log(lanes) / LN2) | 0)) | 0;
+}
 var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
   Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
   Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
+  Scheduler_shouldYield = Scheduler.unstable_shouldYield,
   Scheduler_requestPaint = Scheduler.unstable_requestPaint,
-  Scheduler_now = Scheduler.unstable_now,
+  Scheduler_now$1 = Scheduler.unstable_now,
   Scheduler_getCurrentPriorityLevel =
     Scheduler.unstable_getCurrentPriorityLevel,
   Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
@@ -1714,18 +1991,17 @@ var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
   Scheduler_LowPriority = Scheduler.unstable_LowPriority,
   Scheduler_IdlePriority = Scheduler.unstable_IdlePriority,
   fakeCallbackNode = {},
-  shouldYield = Scheduler.unstable_shouldYield,
   requestPaint =
     void 0 !== Scheduler_requestPaint ? Scheduler_requestPaint : function() {},
   syncQueue = null,
   immediateQueueCallbackNode = null,
   isFlushingSyncQueue = !1,
-  initialTimeMs = Scheduler_now(),
+  initialTimeMs$1 = Scheduler_now$1(),
   now =
-    1e4 > initialTimeMs
-      ? Scheduler_now
+    1e4 > initialTimeMs$1
+      ? Scheduler_now$1
       : function() {
-          return Scheduler_now() - initialTimeMs;
+          return Scheduler_now$1() - initialTimeMs$1;
         };
 function getCurrentPriorityLevel() {
   switch (Scheduler_getCurrentPriorityLevel()) {
@@ -1767,16 +2043,6 @@ function scheduleCallback(reactPriorityLevel, callback, options) {
   reactPriorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
   return Scheduler_scheduleCallback(reactPriorityLevel, callback, options);
 }
-function scheduleSyncCallback(callback) {
-  null === syncQueue
-    ? ((syncQueue = [callback]),
-      (immediateQueueCallbackNode = Scheduler_scheduleCallback(
-        Scheduler_ImmediatePriority,
-        flushSyncCallbackQueueImpl
-      )))
-    : syncQueue.push(callback);
-  return fakeCallbackNode;
-}
 function flushSyncCallbackQueue() {
   if (null !== immediateQueueCallbackNode) {
     var node = immediateQueueCallbackNode;
@@ -1811,6 +2077,42 @@ function flushSyncCallbackQueueImpl() {
     }
   }
 }
+function describeFiber(fiber) {
+  switch (fiber.tag) {
+    case 5:
+      return describeComponentFrame(fiber.type, null, null);
+    case 16:
+      return describeComponentFrame("Lazy", null, null);
+    case 13:
+      return describeComponentFrame("Suspense", null, null);
+    case 19:
+      return describeComponentFrame("SuspenseList", null, null);
+    case 0:
+    case 2:
+    case 15:
+      return describeFunctionComponentFrame(fiber.type, null);
+    case 11:
+      return describeFunctionComponentFrame(fiber.type.render, null);
+    case 22:
+      return describeFunctionComponentFrame(fiber.type._render, null);
+    case 1:
+      return (fiber = describeFunctionComponentFrame(fiber.type, null)), fiber;
+    default:
+      return "";
+  }
+}
+function getStackByFiberInDevAndProd(workInProgress) {
+  try {
+    var info = "";
+    do
+      (info += describeFiber(workInProgress)),
+        (workInProgress = workInProgress.return);
+    while (workInProgress);
+    return info;
+  } catch (x) {
+    return "\nError generating stack: " + x.message + "\n" + x.stack;
+  }
+}
 function is(x, y) {
   return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
@@ -1836,43 +2138,6 @@ function shallowEqual(objA, objB) {
       return !1;
   return !0;
 }
-var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
-function getStackByFiberInDevAndProd(workInProgress) {
-  var info = "";
-  do {
-    a: switch (workInProgress.tag) {
-      case 3:
-      case 4:
-      case 6:
-      case 7:
-      case 10:
-      case 9:
-        var JSCompiler_inline_result = "";
-        break a;
-      default:
-        var owner = workInProgress._debugOwner,
-          source = workInProgress._debugSource,
-          name = getComponentName(workInProgress.type);
-        JSCompiler_inline_result = null;
-        owner && (JSCompiler_inline_result = getComponentName(owner.type));
-        owner = name;
-        name = "";
-        source
-          ? (name =
-              " (at " +
-              source.fileName.replace(BEFORE_SLASH_RE, "") +
-              ":" +
-              source.lineNumber +
-              ")")
-          : JSCompiler_inline_result &&
-            (name = " (created by " + JSCompiler_inline_result + ")");
-        JSCompiler_inline_result = "\n    in " + (owner || "Unknown") + name;
-    }
-    info += JSCompiler_inline_result;
-    workInProgress = workInProgress.return;
-  } while (workInProgress);
-  return info;
-}
 function resolveDefaultProps(Component, baseProps) {
   if (Component && Component.defaultProps) {
     baseProps = Object.assign({}, baseProps);
@@ -1880,10 +2145,11 @@ function resolveDefaultProps(Component, baseProps) {
     for (var propName in Component)
       void 0 === baseProps[propName] &&
         (baseProps[propName] = Component[propName]);
+    return baseProps;
   }
   return baseProps;
 }
-var valueCursor = { current: null },
+var valueCursor = createCursor(null),
   currentlyRenderingFiber = null,
   lastContextDependency = null,
   lastContextWithAllBitsObserved = null;
@@ -1895,31 +2161,29 @@ function popProvider(providerFiber) {
   pop(valueCursor);
   providerFiber.type._context._currentValue = currentValue;
 }
-function scheduleWorkOnParentPath(parent, renderExpirationTime) {
+function scheduleWorkOnParentPath(parent, renderLanes) {
   for (; null !== parent; ) {
     var alternate = parent.alternate;
-    if (parent.childExpirationTime < renderExpirationTime)
-      (parent.childExpirationTime = renderExpirationTime),
-        null !== alternate &&
-          alternate.childExpirationTime < renderExpirationTime &&
-          (alternate.childExpirationTime = renderExpirationTime);
-    else if (
-      null !== alternate &&
-      alternate.childExpirationTime < renderExpirationTime
-    )
-      alternate.childExpirationTime = renderExpirationTime;
-    else break;
+    if ((parent.childLanes & renderLanes) === renderLanes)
+      if (
+        null === alternate ||
+        (alternate.childLanes & renderLanes) === renderLanes
+      )
+        break;
+      else alternate.childLanes |= renderLanes;
+    else
+      (parent.childLanes |= renderLanes),
+        null !== alternate && (alternate.childLanes |= renderLanes);
     parent = parent.return;
   }
 }
-function prepareToReadContext(workInProgress, renderExpirationTime) {
+function prepareToReadContext(workInProgress, renderLanes) {
   currentlyRenderingFiber = workInProgress;
   lastContextWithAllBitsObserved = lastContextDependency = null;
   workInProgress = workInProgress.dependencies;
   null !== workInProgress &&
     null !== workInProgress.firstContext &&
-    (workInProgress.expirationTime >= renderExpirationTime &&
-      (didReceiveUpdate = !0),
+    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
     (workInProgress.firstContext = null));
 }
 function readContext(context, observedBits) {
@@ -1938,7 +2202,7 @@ function readContext(context, observedBits) {
         );
       lastContextDependency = observedBits;
       currentlyRenderingFiber.dependencies = {
-        expirationTime: 0,
+        lanes: 0,
         firstContext: observedBits,
         responders: null
       };
@@ -1950,7 +2214,8 @@ var hasForceUpdate = !1;
 function initializeUpdateQueue(fiber) {
   fiber.updateQueue = {
     baseState: fiber.memoizedState,
-    baseQueue: null,
+    firstBaseUpdate: null,
+    lastBaseUpdate: null,
     shared: { pending: null },
     effects: null
   };
@@ -1960,21 +2225,22 @@ function cloneUpdateQueue(current, workInProgress) {
   workInProgress.updateQueue === current &&
     (workInProgress.updateQueue = {
       baseState: current.baseState,
-      baseQueue: current.baseQueue,
+      firstBaseUpdate: current.firstBaseUpdate,
+      lastBaseUpdate: current.lastBaseUpdate,
       shared: current.shared,
       effects: current.effects
     });
 }
-function createUpdate(expirationTime, suspenseConfig) {
-  expirationTime = {
-    expirationTime: expirationTime,
+function createUpdate(eventTime, lane, suspenseConfig) {
+  return {
+    eventTime: eventTime,
+    lane: lane,
     suspenseConfig: suspenseConfig,
     tag: 0,
     payload: null,
     callback: null,
     next: null
   };
-  return (expirationTime.next = expirationTime);
 }
 function enqueueUpdate(fiber, update) {
   fiber = fiber.updateQueue;
@@ -1987,132 +2253,185 @@ function enqueueUpdate(fiber, update) {
     fiber.pending = update;
   }
 }
-function enqueueCapturedUpdate(workInProgress, update) {
-  var current = workInProgress.alternate;
-  null !== current && cloneUpdateQueue(current, workInProgress);
-  workInProgress = workInProgress.updateQueue;
-  current = workInProgress.baseQueue;
-  null === current
-    ? ((workInProgress.baseQueue = update.next = update),
-      (update.next = update))
-    : ((update.next = current.next), (current.next = update));
+function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
+  var queue = workInProgress.updateQueue,
+    current = workInProgress.alternate;
+  if (
+    null !== current &&
+    ((current = current.updateQueue), queue === current)
+  ) {
+    var newFirst = null,
+      newLast = null;
+    queue = queue.firstBaseUpdate;
+    if (null !== queue) {
+      do {
+        var clone = {
+          eventTime: queue.eventTime,
+          lane: queue.lane,
+          suspenseConfig: queue.suspenseConfig,
+          tag: queue.tag,
+          payload: queue.payload,
+          callback: queue.callback,
+          next: null
+        };
+        null === newLast
+          ? (newFirst = newLast = clone)
+          : (newLast = newLast.next = clone);
+        queue = queue.next;
+      } while (null !== queue);
+      null === newLast
+        ? (newFirst = newLast = capturedUpdate)
+        : (newLast = newLast.next = capturedUpdate);
+    } else newFirst = newLast = capturedUpdate;
+    queue = {
+      baseState: current.baseState,
+      firstBaseUpdate: newFirst,
+      lastBaseUpdate: newLast,
+      shared: current.shared,
+      effects: current.effects
+    };
+    workInProgress.updateQueue = queue;
+    return;
+  }
+  workInProgress = queue.lastBaseUpdate;
+  null === workInProgress
+    ? (queue.firstBaseUpdate = capturedUpdate)
+    : (workInProgress.next = capturedUpdate);
+  queue.lastBaseUpdate = capturedUpdate;
 }
 function processUpdateQueue(
   workInProgress$jscomp$0,
   props,
   instance,
-  renderExpirationTime
+  renderLanes
 ) {
   var queue = workInProgress$jscomp$0.updateQueue;
   hasForceUpdate = !1;
-  var baseQueue = queue.baseQueue,
+  var firstBaseUpdate = queue.firstBaseUpdate,
+    lastBaseUpdate = queue.lastBaseUpdate,
     pendingQueue = queue.shared.pending;
   if (null !== pendingQueue) {
-    if (null !== baseQueue) {
-      var baseFirst = baseQueue.next;
-      baseQueue.next = pendingQueue.next;
-      pendingQueue.next = baseFirst;
-    }
-    baseQueue = pendingQueue;
     queue.shared.pending = null;
-    baseFirst = workInProgress$jscomp$0.alternate;
-    null !== baseFirst &&
-      ((baseFirst = baseFirst.updateQueue),
-      null !== baseFirst && (baseFirst.baseQueue = pendingQueue));
+    var lastPendingUpdate = pendingQueue,
+      firstPendingUpdate = lastPendingUpdate.next;
+    lastPendingUpdate.next = null;
+    null === lastBaseUpdate
+      ? (firstBaseUpdate = firstPendingUpdate)
+      : (lastBaseUpdate.next = firstPendingUpdate);
+    lastBaseUpdate = lastPendingUpdate;
+    var current = workInProgress$jscomp$0.alternate;
+    if (null !== current) {
+      current = current.updateQueue;
+      var currentLastBaseUpdate = current.lastBaseUpdate;
+      currentLastBaseUpdate !== lastBaseUpdate &&
+        (null === currentLastBaseUpdate
+          ? (current.firstBaseUpdate = firstPendingUpdate)
+          : (currentLastBaseUpdate.next = firstPendingUpdate),
+        (current.lastBaseUpdate = lastPendingUpdate));
+    }
   }
-  if (null !== baseQueue) {
-    baseFirst = baseQueue.next;
-    var newState = queue.baseState,
-      newExpirationTime = 0,
-      newBaseState = null,
-      newBaseQueueFirst = null,
-      newBaseQueueLast = null;
-    if (null !== baseFirst) {
-      var update = baseFirst;
-      do {
-        pendingQueue = update.expirationTime;
-        if (pendingQueue < renderExpirationTime) {
-          var clone = {
-            expirationTime: update.expirationTime,
-            suspenseConfig: update.suspenseConfig,
-            tag: update.tag,
-            payload: update.payload,
-            callback: update.callback,
+  if (null !== firstBaseUpdate) {
+    currentLastBaseUpdate = queue.baseState;
+    lastBaseUpdate = 0;
+    current = firstPendingUpdate = lastPendingUpdate = null;
+    do {
+      pendingQueue = firstBaseUpdate.lane;
+      var updateEventTime = firstBaseUpdate.eventTime;
+      if ((renderLanes & pendingQueue) === pendingQueue) {
+        null !== current &&
+          (current = current.next = {
+            eventTime: updateEventTime,
+            lane: 0,
+            suspenseConfig: firstBaseUpdate.suspenseConfig,
+            tag: firstBaseUpdate.tag,
+            payload: firstBaseUpdate.payload,
+            callback: firstBaseUpdate.callback,
             next: null
-          };
-          null === newBaseQueueLast
-            ? ((newBaseQueueFirst = newBaseQueueLast = clone),
-              (newBaseState = newState))
-            : (newBaseQueueLast = newBaseQueueLast.next = clone);
-          pendingQueue > newExpirationTime &&
-            (newExpirationTime = pendingQueue);
-        } else {
-          null !== newBaseQueueLast &&
-            (newBaseQueueLast = newBaseQueueLast.next = {
-              expirationTime: 1073741823,
-              suspenseConfig: update.suspenseConfig,
-              tag: update.tag,
-              payload: update.payload,
-              callback: update.callback,
-              next: null
-            });
-          markRenderEventTimeAndConfig(pendingQueue, update.suspenseConfig);
-          a: {
-            var workInProgress = workInProgress$jscomp$0,
-              update$jscomp$0 = update;
-            pendingQueue = props;
-            clone = instance;
-            switch (update$jscomp$0.tag) {
-              case 1:
-                workInProgress = update$jscomp$0.payload;
-                if ("function" === typeof workInProgress) {
-                  newState = workInProgress.call(clone, newState, pendingQueue);
-                  break a;
-                }
-                newState = workInProgress;
-                break a;
-              case 3:
-                workInProgress.effectTag =
-                  (workInProgress.effectTag & -4097) | 64;
-              case 0:
-                workInProgress = update$jscomp$0.payload;
-                pendingQueue =
-                  "function" === typeof workInProgress
-                    ? workInProgress.call(clone, newState, pendingQueue)
-                    : workInProgress;
-                if (null === pendingQueue || void 0 === pendingQueue) break a;
-                newState = Object.assign({}, newState, pendingQueue);
+          });
+        markRenderEventTimeAndConfig(
+          updateEventTime,
+          firstBaseUpdate.suspenseConfig
+        );
+        a: {
+          var workInProgress = workInProgress$jscomp$0,
+            update = firstBaseUpdate;
+          pendingQueue = props;
+          updateEventTime = instance;
+          switch (update.tag) {
+            case 1:
+              workInProgress = update.payload;
+              if ("function" === typeof workInProgress) {
+                currentLastBaseUpdate = workInProgress.call(
+                  updateEventTime,
+                  currentLastBaseUpdate,
+                  pendingQueue
+                );
                 break a;
-              case 2:
-                hasForceUpdate = !0;
-            }
+              }
+              currentLastBaseUpdate = workInProgress;
+              break a;
+            case 3:
+              workInProgress.effectTag =
+                (workInProgress.effectTag & -4097) | 64;
+            case 0:
+              workInProgress = update.payload;
+              pendingQueue =
+                "function" === typeof workInProgress
+                  ? workInProgress.call(
+                      updateEventTime,
+                      currentLastBaseUpdate,
+                      pendingQueue
+                    )
+                  : workInProgress;
+              if (null === pendingQueue || void 0 === pendingQueue) break a;
+              currentLastBaseUpdate = Object.assign(
+                {},
+                currentLastBaseUpdate,
+                pendingQueue
+              );
+              break a;
+            case 2:
+              hasForceUpdate = !0;
           }
-          null !== update.callback &&
-            ((workInProgress$jscomp$0.effectTag |= 32),
-            (pendingQueue = queue.effects),
-            null === pendingQueue
-              ? (queue.effects = [update])
-              : pendingQueue.push(update));
         }
-        update = update.next;
-        if (null === update || update === baseFirst)
-          if (((pendingQueue = queue.shared.pending), null === pendingQueue))
-            break;
-          else
-            (update = baseQueue.next = pendingQueue.next),
-              (pendingQueue.next = baseFirst),
-              (queue.baseQueue = baseQueue = pendingQueue),
-              (queue.shared.pending = null);
-      } while (1);
-    }
-    null === newBaseQueueLast
-      ? (newBaseState = newState)
-      : (newBaseQueueLast.next = newBaseQueueFirst);
-    queue.baseState = newBaseState;
-    queue.baseQueue = newBaseQueueLast;
-    markUnprocessedUpdateTime(newExpirationTime);
-    workInProgress$jscomp$0.expirationTime = newExpirationTime;
-    workInProgress$jscomp$0.memoizedState = newState;
+        null !== firstBaseUpdate.callback &&
+          ((workInProgress$jscomp$0.effectTag |= 32),
+          (pendingQueue = queue.effects),
+          null === pendingQueue
+            ? (queue.effects = [firstBaseUpdate])
+            : pendingQueue.push(firstBaseUpdate));
+      } else
+        (updateEventTime = {
+          eventTime: updateEventTime,
+          lane: pendingQueue,
+          suspenseConfig: firstBaseUpdate.suspenseConfig,
+          tag: firstBaseUpdate.tag,
+          payload: firstBaseUpdate.payload,
+          callback: firstBaseUpdate.callback,
+          next: null
+        }),
+          null === current
+            ? ((firstPendingUpdate = current = updateEventTime),
+              (lastPendingUpdate = currentLastBaseUpdate))
+            : (current = current.next = updateEventTime),
+          (lastBaseUpdate |= pendingQueue);
+      firstBaseUpdate = firstBaseUpdate.next;
+      if (null === firstBaseUpdate)
+        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
+          break;
+        else
+          (firstBaseUpdate = pendingQueue.next),
+            (pendingQueue.next = null),
+            (queue.lastBaseUpdate = pendingQueue),
+            (queue.shared.pending = null);
+    } while (1);
+    null === current && (lastPendingUpdate = currentLastBaseUpdate);
+    queue.baseState = lastPendingUpdate;
+    queue.firstBaseUpdate = firstPendingUpdate;
+    queue.lastBaseUpdate = current;
+    workInProgressRootSkippedLanes |= lastBaseUpdate;
+    workInProgress$jscomp$0.lanes = lastBaseUpdate;
+    workInProgress$jscomp$0.memoizedState = currentLastBaseUpdate;
   }
 }
 function commitUpdateQueue(finishedWork, finishedQueue, instance) {
@@ -2152,54 +2471,54 @@ function applyDerivedStateFromProps(
       ? ctor
       : Object.assign({}, ctor, getDerivedStateFromProps);
   workInProgress.memoizedState = getDerivedStateFromProps;
-  0 === workInProgress.expirationTime &&
+  0 === workInProgress.lanes &&
     (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
 }
 var classComponentUpdater = {
   isMounted: function(component) {
-    return (component = component._reactInternalFiber)
+    return (component = component._reactInternals)
       ? getNearestMountedFiber(component) === component
       : !1;
   },
   enqueueSetState: function(inst, payload, callback) {
-    inst = inst._reactInternalFiber;
-    var currentTime = requestCurrentTimeForUpdate(),
-      suspenseConfig = ReactCurrentBatchConfig.suspense;
-    currentTime = computeExpirationForFiber(currentTime, inst, suspenseConfig);
-    suspenseConfig = createUpdate(currentTime, suspenseConfig);
+    inst = inst._reactInternals;
+    var eventTime = requestEventTime(),
+      suspenseConfig = ReactCurrentBatchConfig.suspense,
+      lane = requestUpdateLane(inst, suspenseConfig);
+    suspenseConfig = createUpdate(eventTime, lane, suspenseConfig);
     suspenseConfig.payload = payload;
     void 0 !== callback &&
       null !== callback &&
       (suspenseConfig.callback = callback);
     enqueueUpdate(inst, suspenseConfig);
-    scheduleWork(inst, currentTime);
+    scheduleUpdateOnFiber(inst, lane, eventTime);
   },
   enqueueReplaceState: function(inst, payload, callback) {
-    inst = inst._reactInternalFiber;
-    var currentTime = requestCurrentTimeForUpdate(),
-      suspenseConfig = ReactCurrentBatchConfig.suspense;
-    currentTime = computeExpirationForFiber(currentTime, inst, suspenseConfig);
-    suspenseConfig = createUpdate(currentTime, suspenseConfig);
+    inst = inst._reactInternals;
+    var eventTime = requestEventTime(),
+      suspenseConfig = ReactCurrentBatchConfig.suspense,
+      lane = requestUpdateLane(inst, suspenseConfig);
+    suspenseConfig = createUpdate(eventTime, lane, suspenseConfig);
     suspenseConfig.tag = 1;
     suspenseConfig.payload = payload;
     void 0 !== callback &&
       null !== callback &&
       (suspenseConfig.callback = callback);
     enqueueUpdate(inst, suspenseConfig);
-    scheduleWork(inst, currentTime);
+    scheduleUpdateOnFiber(inst, lane, eventTime);
   },
   enqueueForceUpdate: function(inst, callback) {
-    inst = inst._reactInternalFiber;
-    var currentTime = requestCurrentTimeForUpdate(),
-      suspenseConfig = ReactCurrentBatchConfig.suspense;
-    currentTime = computeExpirationForFiber(currentTime, inst, suspenseConfig);
-    suspenseConfig = createUpdate(currentTime, suspenseConfig);
+    inst = inst._reactInternals;
+    var eventTime = requestEventTime(),
+      suspenseConfig = ReactCurrentBatchConfig.suspense,
+      lane = requestUpdateLane(inst, suspenseConfig);
+    suspenseConfig = createUpdate(eventTime, lane, suspenseConfig);
     suspenseConfig.tag = 2;
     void 0 !== callback &&
       null !== callback &&
       (suspenseConfig.callback = callback);
     enqueueUpdate(inst, suspenseConfig);
-    scheduleWork(inst, currentTime);
+    scheduleUpdateOnFiber(inst, lane, eventTime);
   }
 };
 function checkShouldComponentUpdate(
@@ -2237,7 +2556,7 @@ function constructClassInstance(workInProgress, ctor, props) {
     null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
   ctor.updater = classComponentUpdater;
   workInProgress.stateNode = ctor;
-  ctor._reactInternalFiber = workInProgress;
+  ctor._reactInternals = workInProgress;
   isLegacyContextConsumer &&
     ((workInProgress = workInProgress.stateNode),
     (workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
@@ -2258,12 +2577,7 @@ function callComponentWillReceiveProps(
   instance.state !== workInProgress &&
     classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
 }
-function mountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
+function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   var instance = workInProgress.stateNode;
   instance.props = newProps;
   instance.state = workInProgress.memoizedState;
@@ -2276,7 +2590,7 @@ function mountClassInstance(
         ? previousContext
         : contextStackCursor.current),
       (instance.context = getMaskedContext(workInProgress, contextType)));
-  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
+  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
   instance.state = workInProgress.memoizedState;
   contextType = ctor.getDerivedStateFromProps;
   "function" === typeof contextType &&
@@ -2293,12 +2607,7 @@ function mountClassInstance(
       instance.UNSAFE_componentWillMount(),
     ctor !== instance.state &&
       classComponentUpdater.enqueueReplaceState(instance, instance.state, null),
-    processUpdateQueue(
-      workInProgress,
-      newProps,
-      instance,
-      renderExpirationTime
-    ),
+    processUpdateQueue(workInProgress, newProps, instance, renderLanes),
     (instance.state = workInProgress.memoizedState));
   "function" === typeof instance.componentDidMount &&
     (workInProgress.effectTag |= 4);
@@ -2362,7 +2671,7 @@ function throwOnInvalidObjectType(returnFiber, newChild) {
         ("[object Object]" === Object.prototype.toString.call(newChild)
           ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
           : newChild) +
-        ")."
+        "). If you meant to render a collection of children, use an array instead."
     );
 }
 function ChildReconciler(shouldTrackSideEffects) {
@@ -2418,14 +2727,10 @@ function ChildReconciler(shouldTrackSideEffects) {
       (newFiber.effectTag = 2);
     return newFiber;
   }
-  function updateTextNode(returnFiber, current, textContent, expirationTime) {
+  function updateTextNode(returnFiber, current, textContent, lanes) {
     if (null === current || 6 !== current.tag)
       return (
-        (current = createFiberFromText(
-          textContent,
-          returnFiber.mode,
-          expirationTime
-        )),
+        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
         (current.return = returnFiber),
         current
       );
@@ -2433,27 +2738,27 @@ function ChildReconciler(shouldTrackSideEffects) {
     current.return = returnFiber;
     return current;
   }
-  function updateElement(returnFiber, current, element, expirationTime) {
+  function updateElement(returnFiber, current, element, lanes) {
     if (null !== current && current.elementType === element.type)
       return (
-        (expirationTime = useFiber(current, element.props)),
-        (expirationTime.ref = coerceRef(returnFiber, current, element)),
-        (expirationTime.return = returnFiber),
-        expirationTime
+        (lanes = useFiber(current, element.props)),
+        (lanes.ref = coerceRef(returnFiber, current, element)),
+        (lanes.return = returnFiber),
+        lanes
       );
-    expirationTime = createFiberFromTypeAndProps(
+    lanes = createFiberFromTypeAndProps(
       element.type,
       element.key,
       element.props,
       null,
       returnFiber.mode,
-      expirationTime
+      lanes
     );
-    expirationTime.ref = coerceRef(returnFiber, current, element);
-    expirationTime.return = returnFiber;
-    return expirationTime;
+    lanes.ref = coerceRef(returnFiber, current, element);
+    lanes.return = returnFiber;
+    return lanes;
   }
-  function updatePortal(returnFiber, current, portal, expirationTime) {
+  function updatePortal(returnFiber, current, portal, lanes) {
     if (
       null === current ||
       4 !== current.tag ||
@@ -2461,11 +2766,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       current.stateNode.implementation !== portal.implementation
     )
       return (
-        (current = createFiberFromPortal(
-          portal,
-          returnFiber.mode,
-          expirationTime
-        )),
+        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
         (current.return = returnFiber),
         current
       );
@@ -2473,13 +2774,13 @@ function ChildReconciler(shouldTrackSideEffects) {
     current.return = returnFiber;
     return current;
   }
-  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
+  function updateFragment(returnFiber, current, fragment, lanes, key) {
     if (null === current || 7 !== current.tag)
       return (
         (current = createFiberFromFragment(
           fragment,
           returnFiber.mode,
-          expirationTime,
+          lanes,
           key
         )),
         (current.return = returnFiber),
@@ -2489,13 +2790,13 @@ function ChildReconciler(shouldTrackSideEffects) {
     current.return = returnFiber;
     return current;
   }
-  function createChild(returnFiber, newChild, expirationTime) {
+  function createChild(returnFiber, newChild, lanes) {
     if ("string" === typeof newChild || "number" === typeof newChild)
       return (
         (newChild = createFiberFromText(
           "" + newChild,
           returnFiber.mode,
-          expirationTime
+          lanes
         )),
         (newChild.return = returnFiber),
         newChild
@@ -2504,24 +2805,24 @@ function ChildReconciler(shouldTrackSideEffects) {
       switch (newChild.$$typeof) {
         case REACT_ELEMENT_TYPE:
           return (
-            (expirationTime = createFiberFromTypeAndProps(
+            (lanes = createFiberFromTypeAndProps(
               newChild.type,
               newChild.key,
               newChild.props,
               null,
               returnFiber.mode,
-              expirationTime
+              lanes
             )),
-            (expirationTime.ref = coerceRef(returnFiber, null, newChild)),
-            (expirationTime.return = returnFiber),
-            expirationTime
+            (lanes.ref = coerceRef(returnFiber, null, newChild)),
+            (lanes.return = returnFiber),
+            lanes
           );
         case REACT_PORTAL_TYPE:
           return (
             (newChild = createFiberFromPortal(
               newChild,
               returnFiber.mode,
-              expirationTime
+              lanes
             )),
             (newChild.return = returnFiber),
             newChild
@@ -2532,7 +2833,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           (newChild = createFiberFromFragment(
             newChild,
             returnFiber.mode,
-            expirationTime,
+            lanes,
             null
           )),
           (newChild.return = returnFiber),
@@ -2542,12 +2843,12 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
     return null;
   }
-  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
+  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
     var key = null !== oldFiber ? oldFiber.key : null;
     if ("string" === typeof newChild || "number" === typeof newChild)
       return null !== key
         ? null
-        : updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
+        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
     if ("object" === typeof newChild && null !== newChild) {
       switch (newChild.$$typeof) {
         case REACT_ELEMENT_TYPE:
@@ -2557,26 +2858,20 @@ function ChildReconciler(shouldTrackSideEffects) {
                   returnFiber,
                   oldFiber,
                   newChild.props.children,
-                  expirationTime,
+                  lanes,
                   key
                 )
-              : updateElement(returnFiber, oldFiber, newChild, expirationTime)
+              : updateElement(returnFiber, oldFiber, newChild, lanes)
             : null;
         case REACT_PORTAL_TYPE:
           return newChild.key === key
-            ? updatePortal(returnFiber, oldFiber, newChild, expirationTime)
+            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
             : null;
       }
       if (isArray(newChild) || getIteratorFn(newChild))
         return null !== key
           ? null
-          : updateFragment(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime,
-              null
-            );
+          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
       throwOnInvalidObjectType(returnFiber, newChild);
     }
     return null;
@@ -2586,17 +2881,12 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     newIdx,
     newChild,
-    expirationTime
+    lanes
   ) {
     if ("string" === typeof newChild || "number" === typeof newChild)
       return (
         (existingChildren = existingChildren.get(newIdx) || null),
-        updateTextNode(
-          returnFiber,
-          existingChildren,
-          "" + newChild,
-          expirationTime
-        )
+        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
       );
     if ("object" === typeof newChild && null !== newChild) {
       switch (newChild.$$typeof) {
@@ -2611,15 +2901,10 @@ function ChildReconciler(shouldTrackSideEffects) {
                   returnFiber,
                   existingChildren,
                   newChild.props.children,
-                  expirationTime,
+                  lanes,
                   newChild.key
                 )
-              : updateElement(
-                  returnFiber,
-                  existingChildren,
-                  newChild,
-                  expirationTime
-                )
+              : updateElement(returnFiber, existingChildren, newChild, lanes)
           );
         case REACT_PORTAL_TYPE:
           return (
@@ -2627,24 +2912,13 @@ function ChildReconciler(shouldTrackSideEffects) {
               existingChildren.get(
                 null === newChild.key ? newIdx : newChild.key
               ) || null),
-            updatePortal(
-              returnFiber,
-              existingChildren,
-              newChild,
-              expirationTime
-            )
+            updatePortal(returnFiber, existingChildren, newChild, lanes)
           );
       }
       if (isArray(newChild) || getIteratorFn(newChild))
         return (
           (existingChildren = existingChildren.get(newIdx) || null),
-          updateFragment(
-            returnFiber,
-            existingChildren,
-            newChild,
-            expirationTime,
-            null
-          )
+          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
         );
       throwOnInvalidObjectType(returnFiber, newChild);
     }
@@ -2654,7 +2928,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChildren,
-    expirationTime
+    lanes
   ) {
     for (
       var resultingFirstChild = null,
@@ -2672,7 +2946,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         oldFiber,
         newChildren[newIdx],
-        expirationTime
+        lanes
       );
       if (null === newFiber) {
         null === oldFiber && (oldFiber = nextOldFiber);
@@ -2695,11 +2969,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       );
     if (null === oldFiber) {
       for (; newIdx < newChildren.length; newIdx++)
-        (oldFiber = createChild(
-          returnFiber,
-          newChildren[newIdx],
-          expirationTime
-        )),
+        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
           null !== oldFiber &&
             ((currentFirstChild = placeChild(
               oldFiber,
@@ -2722,7 +2992,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         newIdx,
         newChildren[newIdx],
-        expirationTime
+        lanes
       )),
         null !== nextOldFiber &&
           (shouldTrackSideEffects &&
@@ -2749,7 +3019,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChildrenIterable,
-    expirationTime
+    lanes
   ) {
     var iteratorFn = getIteratorFn(newChildrenIterable);
     if ("function" !== typeof iteratorFn)
@@ -2771,12 +3041,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       oldFiber.index > newIdx
         ? ((nextOldFiber = oldFiber), (oldFiber = null))
         : (nextOldFiber = oldFiber.sibling);
-      var newFiber = updateSlot(
-        returnFiber,
-        oldFiber,
-        step.value,
-        expirationTime
-      );
+      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
       if (null === newFiber) {
         null === oldFiber && (oldFiber = nextOldFiber);
         break;
@@ -2796,7 +3061,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;
     if (null === oldFiber) {
       for (; !step.done; newIdx++, step = newChildrenIterable.next())
-        (step = createChild(returnFiber, step.value, expirationTime)),
+        (step = createChild(returnFiber, step.value, lanes)),
           null !== step &&
             ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
             null === previousNewFiber
@@ -2810,13 +3075,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       !step.done;
       newIdx++, step = newChildrenIterable.next()
     )
-      (step = updateFromMap(
-        oldFiber,
-        returnFiber,
-        newIdx,
-        step.value,
-        expirationTime
-      )),
+      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
         null !== step &&
           (shouldTrackSideEffects &&
             null !== step.alternate &&
@@ -2832,7 +3091,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       });
     return iteratorFn;
   }
-  return function(returnFiber, currentFirstChild, newChild, expirationTime) {
+  return function(returnFiber, currentFirstChild, newChild, lanes) {
     var isUnkeyedTopLevelFragment =
       "object" === typeof newChild &&
       null !== newChild &&
@@ -2898,26 +3157,26 @@ function ChildReconciler(shouldTrackSideEffects) {
               ? ((currentFirstChild = createFiberFromFragment(
                   newChild.props.children,
                   returnFiber.mode,
-                  expirationTime,
+                  lanes,
                   newChild.key
                 )),
                 (currentFirstChild.return = returnFiber),
                 (returnFiber = currentFirstChild))
-              : ((expirationTime = createFiberFromTypeAndProps(
+              : ((lanes = createFiberFromTypeAndProps(
                   newChild.type,
                   newChild.key,
                   newChild.props,
                   null,
                   returnFiber.mode,
-                  expirationTime
+                  lanes
                 )),
-                (expirationTime.ref = coerceRef(
+                (lanes.ref = coerceRef(
                   returnFiber,
                   currentFirstChild,
                   newChild
                 )),
-                (expirationTime.return = returnFiber),
-                (returnFiber = expirationTime));
+                (lanes.return = returnFiber),
+                (returnFiber = lanes));
           }
           return placeSingleChild(returnFiber);
         case REACT_PORTAL_TYPE:
@@ -2956,7 +3215,7 @@ function ChildReconciler(shouldTrackSideEffects) {
             currentFirstChild = createFiberFromPortal(
               newChild,
               returnFiber.mode,
-              expirationTime
+              lanes
             );
             currentFirstChild.return = returnFiber;
             returnFiber = currentFirstChild;
@@ -2975,7 +3234,7 @@ function ChildReconciler(shouldTrackSideEffects) {
             (currentFirstChild = createFiberFromText(
               newChild,
               returnFiber.mode,
-              expirationTime
+              lanes
             )),
             (currentFirstChild.return = returnFiber),
             (returnFiber = currentFirstChild)),
@@ -2986,14 +3245,14 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         currentFirstChild,
         newChild,
-        expirationTime
+        lanes
       );
     if (getIteratorFn(newChild))
       return reconcileChildrenIterator(
         returnFiber,
         currentFirstChild,
         newChild,
-        expirationTime
+        lanes
       );
     isObject && throwOnInvalidObjectType(returnFiber, newChild);
     if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment)
@@ -3012,9 +3271,9 @@ function ChildReconciler(shouldTrackSideEffects) {
 var reconcileChildFibers = ChildReconciler(!0),
   mountChildFibers = ChildReconciler(!1),
   NO_CONTEXT = {},
-  contextStackCursor$1 = { current: NO_CONTEXT },
-  contextFiberStackCursor = { current: NO_CONTEXT },
-  rootInstanceStackCursor = { current: NO_CONTEXT };
+  contextStackCursor$1 = createCursor(NO_CONTEXT),
+  contextFiberStackCursor = createCursor(NO_CONTEXT),
+  rootInstanceStackCursor = createCursor(NO_CONTEXT);
 function requiredContext(c) {
   if (c === NO_CONTEXT)
     throw Error(
@@ -3037,26 +3296,26 @@ function popHostContainer() {
 function pushHostContext(fiber) {
   requiredContext(rootInstanceStackCursor.current);
   var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = fiber.type;
-  nextContext =
-    "AndroidTextInput" === nextContext ||
-    "RCTMultilineTextInputView" === nextContext ||
-    "RCTSinglelineTextInputView" === nextContext ||
-    "RCTText" === nextContext ||
-    "RCTVirtualText" === nextContext;
-  nextContext =
-    context.isInAParentText !== nextContext
-      ? { isInAParentText: nextContext }
+  var JSCompiler_inline_result = fiber.type;
+  JSCompiler_inline_result =
+    "AndroidTextInput" === JSCompiler_inline_result ||
+    "RCTMultilineTextInputView" === JSCompiler_inline_result ||
+    "RCTSinglelineTextInputView" === JSCompiler_inline_result ||
+    "RCTText" === JSCompiler_inline_result ||
+    "RCTVirtualText" === JSCompiler_inline_result;
+  JSCompiler_inline_result =
+    context.isInAParentText !== JSCompiler_inline_result
+      ? { isInAParentText: JSCompiler_inline_result }
       : context;
-  context !== nextContext &&
+  context !== JSCompiler_inline_result &&
     (push(contextFiberStackCursor, fiber),
-    push(contextStackCursor$1, nextContext));
+    push(contextStackCursor$1, JSCompiler_inline_result));
 }
 function popHostContext(fiber) {
   contextFiberStackCursor.current === fiber &&
     (pop(contextStackCursor$1), pop(contextFiberStackCursor));
 }
-var suspenseStackCursor = { current: 0 };
+var suspenseStackCursor = createCursor(0);
 function findFirstSuspended(row) {
   for (var node = row; null !== node; ) {
     if (13 === node.tag) {
@@ -3080,16 +3339,20 @@ function findFirstSuspended(row) {
   }
   return null;
 }
-function createDeprecatedResponderListener(responder, props) {
-  return { responder: responder, props: props };
+var workInProgressSources = [];
+function resetWorkInProgressVersions() {
+  for (var i = 0; i < workInProgressSources.length; i++)
+    workInProgressSources[i]._workInProgressVersionPrimary = null;
+  workInProgressSources.length = 0;
 }
-var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
+var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig,
-  renderExpirationTime = 0,
+  renderLanes = 0,
   currentlyRenderingFiber$1 = null,
   currentHook = null,
   workInProgressHook = null,
-  didScheduleRenderPhaseUpdate = !1;
+  didScheduleRenderPhaseUpdate = !1,
+  didScheduleRenderPhaseUpdateDuringThisPass = !1;
 function throwInvalidHookError() {
   throw Error(
     "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem."
@@ -3107,36 +3370,36 @@ function renderWithHooks(
   Component,
   props,
   secondArg,
-  nextRenderExpirationTime
+  nextRenderLanes
 ) {
-  renderExpirationTime = nextRenderExpirationTime;
+  renderLanes = nextRenderLanes;
   currentlyRenderingFiber$1 = workInProgress;
   workInProgress.memoizedState = null;
   workInProgress.updateQueue = null;
-  workInProgress.expirationTime = 0;
-  ReactCurrentDispatcher.current =
+  workInProgress.lanes = 0;
+  ReactCurrentDispatcher$1.current =
     null === current || null === current.memoizedState
       ? HooksDispatcherOnMount
       : HooksDispatcherOnUpdate;
   current = Component(props, secondArg);
-  if (workInProgress.expirationTime === renderExpirationTime) {
-    nextRenderExpirationTime = 0;
+  if (didScheduleRenderPhaseUpdateDuringThisPass) {
+    nextRenderLanes = 0;
     do {
-      workInProgress.expirationTime = 0;
-      if (!(25 > nextRenderExpirationTime))
+      didScheduleRenderPhaseUpdateDuringThisPass = !1;
+      if (!(25 > nextRenderLanes))
         throw Error(
           "Too many re-renders. React limits the number of renders to prevent an infinite loop."
         );
-      nextRenderExpirationTime += 1;
+      nextRenderLanes += 1;
       workInProgressHook = currentHook = null;
       workInProgress.updateQueue = null;
-      ReactCurrentDispatcher.current = HooksDispatcherOnRerender;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnRerender;
       current = Component(props, secondArg);
-    } while (workInProgress.expirationTime === renderExpirationTime);
+    } while (didScheduleRenderPhaseUpdateDuringThisPass);
   }
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
   workInProgress = null !== currentHook && null !== currentHook.next;
-  renderExpirationTime = 0;
+  renderLanes = 0;
   workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
   didScheduleRenderPhaseUpdate = !1;
   if (workInProgress)
@@ -3217,40 +3480,40 @@ function updateReducer(reducer) {
     var newBaseQueueLast = (baseFirst = pendingQueue = null),
       update = baseQueue;
     do {
-      var updateExpirationTime = update.expirationTime;
-      if (updateExpirationTime < renderExpirationTime) {
-        var clone = {
-          expirationTime: update.expirationTime,
-          suspenseConfig: update.suspenseConfig,
-          action: update.action,
-          eagerReducer: update.eagerReducer,
-          eagerState: update.eagerState,
-          next: null
-        };
-        null === newBaseQueueLast
-          ? ((baseFirst = newBaseQueueLast = clone), (pendingQueue = current))
-          : (newBaseQueueLast = newBaseQueueLast.next = clone);
-        updateExpirationTime > currentlyRenderingFiber$1.expirationTime &&
-          ((currentlyRenderingFiber$1.expirationTime = updateExpirationTime),
-          markUnprocessedUpdateTime(updateExpirationTime));
-      } else
-        null !== newBaseQueueLast &&
-          (newBaseQueueLast = newBaseQueueLast.next = {
-            expirationTime: 1073741823,
-            suspenseConfig: update.suspenseConfig,
+      var suspenseConfig = update.suspenseConfig,
+        updateLane = update.lane,
+        updateEventTime = update.eventTime;
+      (renderLanes & updateLane) === updateLane
+        ? (null !== newBaseQueueLast &&
+            (newBaseQueueLast = newBaseQueueLast.next = {
+              eventTime: updateEventTime,
+              lane: 0,
+              suspenseConfig: update.suspenseConfig,
+              action: update.action,
+              eagerReducer: update.eagerReducer,
+              eagerState: update.eagerState,
+              next: null
+            }),
+          markRenderEventTimeAndConfig(updateEventTime, suspenseConfig),
+          (current =
+            update.eagerReducer === reducer
+              ? update.eagerState
+              : reducer(current, update.action)))
+        : ((suspenseConfig = {
+            eventTime: updateEventTime,
+            lane: updateLane,
+            suspenseConfig: suspenseConfig,
             action: update.action,
             eagerReducer: update.eagerReducer,
             eagerState: update.eagerState,
             next: null
           }),
-          markRenderEventTimeAndConfig(
-            updateExpirationTime,
-            update.suspenseConfig
-          ),
-          (current =
-            update.eagerReducer === reducer
-              ? update.eagerState
-              : reducer(current, update.action));
+          null === newBaseQueueLast
+            ? ((baseFirst = newBaseQueueLast = suspenseConfig),
+              (pendingQueue = current))
+            : (newBaseQueueLast = newBaseQueueLast.next = suspenseConfig),
+          (currentlyRenderingFiber$1.lanes |= updateLane),
+          (workInProgressRootSkippedLanes |= updateLane));
       update = update.next;
     } while (null !== update && update !== baseQueue);
     null === newBaseQueueLast
@@ -3287,6 +3550,117 @@ function rerenderReducer(reducer) {
   }
   return [newState, dispatch];
 }
+function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
+  var getVersion = source._getVersion;
+  getVersion = getVersion(source._source);
+  var JSCompiler_inline_result = source._workInProgressVersionPrimary;
+  if (null !== JSCompiler_inline_result)
+    root = JSCompiler_inline_result === getVersion;
+  else if (
+    ((root = root.mutableReadLanes), (root = (renderLanes & root) === root))
+  )
+    (source._workInProgressVersionPrimary = getVersion),
+      workInProgressSources.push(source);
+  if (root) return getSnapshot(source._source);
+  workInProgressSources.push(source);
+  throw Error(
+    "Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue."
+  );
+}
+function useMutableSource(hook, source, getSnapshot, subscribe) {
+  var root = workInProgressRoot;
+  if (null === root)
+    throw Error(
+      "Expected a work-in-progress root. This is a bug in React. Please file an issue."
+    );
+  var getVersion = source._getVersion,
+    version = getVersion(source._source),
+    dispatcher = ReactCurrentDispatcher$1.current,
+    _dispatcher$useState = dispatcher.useState(function() {
+      return readFromUnsubcribedMutableSource(root, source, getSnapshot);
+    }),
+    setSnapshot = _dispatcher$useState[1],
+    snapshot = _dispatcher$useState[0];
+  _dispatcher$useState = workInProgressHook;
+  var memoizedState = hook.memoizedState,
+    refs = memoizedState.refs,
+    prevGetSnapshot = refs.getSnapshot,
+    prevSource = memoizedState.source;
+  memoizedState = memoizedState.subscribe;
+  var fiber = currentlyRenderingFiber$1;
+  hook.memoizedState = { refs: refs, source: source, subscribe: subscribe };
+  dispatcher.useEffect(
+    function() {
+      refs.getSnapshot = getSnapshot;
+      refs.setSnapshot = setSnapshot;
+      var maybeNewVersion = getVersion(source._source);
+      if (!objectIs(version, maybeNewVersion)) {
+        maybeNewVersion = getSnapshot(source._source);
+        objectIs(snapshot, maybeNewVersion) ||
+          (setSnapshot(maybeNewVersion),
+          (maybeNewVersion = requestUpdateLane(
+            fiber,
+            ReactCurrentBatchConfig.suspense
+          )),
+          (root.mutableReadLanes |= maybeNewVersion & root.pendingLanes));
+        maybeNewVersion = root.mutableReadLanes;
+        root.entangledLanes |= maybeNewVersion;
+        for (
+          var entanglements = root.entanglements, lanes = maybeNewVersion;
+          0 < lanes;
+
+        ) {
+          var index$14 = 31 - clz32(lanes),
+            lane = 1 << index$14;
+          entanglements[index$14] |= maybeNewVersion;
+          lanes &= ~lane;
+        }
+      }
+    },
+    [getSnapshot, source, subscribe]
+  );
+  dispatcher.useEffect(
+    function() {
+      return subscribe(source._source, function() {
+        var latestGetSnapshot = refs.getSnapshot,
+          latestSetSnapshot = refs.setSnapshot;
+        try {
+          latestSetSnapshot(latestGetSnapshot(source._source));
+          var lane = requestUpdateLane(fiber, ReactCurrentBatchConfig.suspense);
+          root.mutableReadLanes |= lane & root.pendingLanes;
+        } catch (error) {
+          latestSetSnapshot(function() {
+            throw error;
+          });
+        }
+      });
+    },
+    [source, subscribe]
+  );
+  (objectIs(prevGetSnapshot, getSnapshot) &&
+    objectIs(prevSource, source) &&
+    objectIs(memoizedState, subscribe)) ||
+    ((hook = {
+      pending: null,
+      dispatch: null,
+      lastRenderedReducer: basicStateReducer,
+      lastRenderedState: snapshot
+    }),
+    (hook.dispatch = setSnapshot = dispatchAction.bind(
+      null,
+      currentlyRenderingFiber$1,
+      hook
+    )),
+    (_dispatcher$useState.queue = hook),
+    (_dispatcher$useState.baseQueue = null),
+    (snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot)),
+    (_dispatcher$useState.memoizedState = _dispatcher$useState.baseState = snapshot));
+  return snapshot;
+}
+function updateMutableSource(source, getSnapshot, subscribe) {
+  var hook = updateWorkInProgressHook();
+  return useMutableSource(hook, source, getSnapshot, subscribe);
+}
 function mountState(initialState) {
   var hook = mountWorkInProgressHook();
   "function" === typeof initialState && (initialState = initialState());
@@ -3435,11 +3809,12 @@ function startTransition(setPending, config, callback) {
   });
 }
 function dispatchAction(fiber, queue, action) {
-  var currentTime = requestCurrentTimeForUpdate(),
-    suspenseConfig = ReactCurrentBatchConfig.suspense;
-  currentTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
+  var eventTime = requestEventTime(),
+    suspenseConfig = ReactCurrentBatchConfig.suspense,
+    lane = requestUpdateLane(fiber, suspenseConfig);
   suspenseConfig = {
-    expirationTime: currentTime,
+    eventTime: eventTime,
+    lane: lane,
     suspenseConfig: suspenseConfig,
     action: action,
     eagerReducer: null,
@@ -3456,13 +3831,11 @@ function dispatchAction(fiber, queue, action) {
     fiber === currentlyRenderingFiber$1 ||
     (null !== pending && pending === currentlyRenderingFiber$1)
   )
-    (didScheduleRenderPhaseUpdate = !0),
-      (suspenseConfig.expirationTime = renderExpirationTime),
-      (currentlyRenderingFiber$1.expirationTime = renderExpirationTime);
+    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
   else {
     if (
-      0 === fiber.expirationTime &&
-      (null === pending || 0 === pending.expirationTime) &&
+      0 === fiber.lanes &&
+      (null === pending || 0 === pending.lanes) &&
       ((pending = queue.lastRenderedReducer), null !== pending)
     )
       try {
@@ -3474,10 +3847,9 @@ function dispatchAction(fiber, queue, action) {
       } catch (error) {
       } finally {
       }
-    scheduleWork(fiber, currentTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   }
 }
-function updateEventListener() {}
 var ContextOnlyDispatcher = {
     readContext: readContext,
     useCallback: throwInvalidHookError,
@@ -3490,10 +3862,11 @@ var ContextOnlyDispatcher = {
     useRef: throwInvalidHookError,
     useState: throwInvalidHookError,
     useDebugValue: throwInvalidHookError,
-    useResponder: throwInvalidHookError,
     useDeferredValue: throwInvalidHookError,
     useTransition: throwInvalidHookError,
-    useEvent: throwInvalidHookError
+    useMutableSource: throwInvalidHookError,
+    useOpaqueIdentifier: throwInvalidHookError,
+    unstable_isNewReconciler: !1
   },
   HooksDispatcherOnMount = {
     readContext: readContext,
@@ -3543,7 +3916,6 @@ var ContextOnlyDispatcher = {
     },
     useState: mountState,
     useDebugValue: mountDebugValue,
-    useResponder: createDeprecatedResponderListener,
     useDeferredValue: function(value, config) {
       var _mountState = mountState(value),
         prevValue = _mountState[0],
@@ -3575,7 +3947,19 @@ var ContextOnlyDispatcher = {
         isPending
       ];
     },
-    useEvent: function() {}
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      var hook = mountWorkInProgressHook();
+      hook.memoizedState = {
+        refs: { getSnapshot: getSnapshot, setSnapshot: null },
+        source: source,
+        subscribe: subscribe
+      };
+      return useMutableSource(hook, source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      throw Error("Not yet implemented");
+    },
+    unstable_isNewReconciler: !1
   },
   HooksDispatcherOnUpdate = {
     readContext: readContext,
@@ -3591,7 +3975,6 @@ var ContextOnlyDispatcher = {
       return updateReducer(basicStateReducer);
     },
     useDebugValue: mountDebugValue,
-    useResponder: createDeprecatedResponderListener,
     useDeferredValue: function(value, config) {
       var _updateState = updateReducer(basicStateReducer),
         prevValue = _updateState[0],
@@ -3623,7 +4006,11 @@ var ContextOnlyDispatcher = {
         isPending
       ];
     },
-    useEvent: updateEventListener
+    useMutableSource: updateMutableSource,
+    useOpaqueIdentifier: function() {
+      return updateReducer(basicStateReducer)[0];
+    },
+    unstable_isNewReconciler: !1
   },
   HooksDispatcherOnRerender = {
     readContext: readContext,
@@ -3639,7 +4026,6 @@ var ContextOnlyDispatcher = {
       return rerenderReducer(basicStateReducer);
     },
     useDebugValue: mountDebugValue,
-    useResponder: createDeprecatedResponderListener,
     useDeferredValue: function(value, config) {
       var _rerenderState = rerenderReducer(basicStateReducer),
         prevValue = _rerenderState[0],
@@ -3671,29 +4057,23 @@ var ContextOnlyDispatcher = {
         isPending
       ];
     },
-    useEvent: updateEventListener
+    useMutableSource: updateMutableSource,
+    useOpaqueIdentifier: function() {
+      return rerenderReducer(basicStateReducer)[0];
+    },
+    unstable_isNewReconciler: !1
   },
   ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner,
   didReceiveUpdate = !1;
-function reconcileChildren(
-  current,
-  workInProgress,
-  nextChildren,
-  renderExpirationTime
-) {
+function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
   workInProgress.child =
     null === current
-      ? mountChildFibers(
-          workInProgress,
-          null,
-          nextChildren,
-          renderExpirationTime
-        )
+      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
       : reconcileChildFibers(
           workInProgress,
           current.child,
           nextChildren,
-          renderExpirationTime
+          renderLanes
         );
 }
 function updateForwardRef(
@@ -3701,33 +4081,28 @@ function updateForwardRef(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   Component = Component.render;
   var ref = workInProgress.ref;
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   nextProps = renderWithHooks(
     current,
     workInProgress,
     Component,
     nextProps,
     ref,
-    renderExpirationTime
+    renderLanes
   );
   if (null !== current && !didReceiveUpdate)
     return (
       (workInProgress.updateQueue = current.updateQueue),
       (workInProgress.effectTag &= -517),
-      current.expirationTime <= renderExpirationTime &&
-        (current.expirationTime = 0),
-      bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      )
+      (current.lanes &= ~renderLanes),
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
     );
   workInProgress.effectTag |= 1;
-  reconcileChildren(current, workInProgress, nextProps, renderExpirationTime);
+  reconcileChildren(current, workInProgress, nextProps, renderLanes);
   return workInProgress.child;
 }
 function updateMemoComponent(
@@ -3735,8 +4110,8 @@ function updateMemoComponent(
   workInProgress,
   Component,
   nextProps,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
   if (null === current) {
     var type = Component.type;
@@ -3755,8 +4130,8 @@ function updateMemoComponent(
           workInProgress,
           type,
           nextProps,
-          updateExpirationTime,
-          renderExpirationTime
+          updateLanes,
+          renderLanes
         )
       );
     current = createFiberFromTypeAndProps(
@@ -3765,7 +4140,7 @@ function updateMemoComponent(
       nextProps,
       null,
       workInProgress.mode,
-      renderExpirationTime
+      renderLanes
     );
     current.ref = workInProgress.ref;
     current.return = workInProgress;
@@ -3773,18 +4148,13 @@ function updateMemoComponent(
   }
   type = current.child;
   if (
-    updateExpirationTime < renderExpirationTime &&
-    ((updateExpirationTime = type.memoizedProps),
+    0 === (updateLanes & renderLanes) &&
+    ((updateLanes = type.memoizedProps),
     (Component = Component.compare),
     (Component = null !== Component ? Component : shallowEqual),
-    Component(updateExpirationTime, nextProps) &&
-      current.ref === workInProgress.ref)
+    Component(updateLanes, nextProps) && current.ref === workInProgress.ref)
   )
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   workInProgress.effectTag |= 1;
   current = createWorkInProgress(type, nextProps);
   current.ref = workInProgress.ref;
@@ -3796,29 +4166,66 @@ function updateSimpleMemoComponent(
   workInProgress,
   Component,
   nextProps,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
-  return null !== current &&
+  if (
+    null !== current &&
     shallowEqual(current.memoizedProps, nextProps) &&
-    current.ref === workInProgress.ref &&
-    ((didReceiveUpdate = !1), updateExpirationTime < renderExpirationTime)
-    ? ((workInProgress.expirationTime = current.expirationTime),
-      bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      ))
-    : updateFunctionComponent(
-        current,
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
+    current.ref === workInProgress.ref
+  )
+    if (((didReceiveUpdate = !1), 0 !== (renderLanes & updateLanes)))
+      0 !== (current.effectTag & 16384) && (didReceiveUpdate = !0);
+    else
+      return (
+        (workInProgress.lanes = current.lanes),
+        bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
       );
-}
-function markRef(current, workInProgress) {
-  var ref = workInProgress.ref;
+  return updateFunctionComponent(
+    current,
+    workInProgress,
+    Component,
+    nextProps,
+    renderLanes
+  );
+}
+function updateOffscreenComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps,
+    nextChildren = nextProps.children,
+    prevState = null !== current ? current.memoizedState : null;
+  if (
+    "hidden" === nextProps.mode ||
+    "unstable-defer-without-hiding" === nextProps.mode
+  )
+    if (0 === (workInProgress.mode & 4))
+      (workInProgress.memoizedState = { baseLanes: 0 }),
+        pushRenderLanes(workInProgress, renderLanes);
+    else if (0 !== (renderLanes & 1073741824))
+      (workInProgress.memoizedState = { baseLanes: 0 }),
+        pushRenderLanes(
+          workInProgress,
+          null !== prevState ? prevState.baseLanes : renderLanes
+        );
+    else
+      return (
+        (current =
+          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes),
+        (workInProgress.lanes = workInProgress.childLanes = 1073741824),
+        (workInProgress.memoizedState = { baseLanes: current }),
+        pushRenderLanes(workInProgress, current),
+        null
+      );
+  else
+    null !== prevState
+      ? ((nextProps = prevState.baseLanes | renderLanes),
+        (workInProgress.memoizedState = null))
+      : (nextProps = renderLanes),
+      pushRenderLanes(workInProgress, nextProps);
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+  return workInProgress.child;
+}
+function markRef(current, workInProgress) {
+  var ref = workInProgress.ref;
   if (
     (null === current && null !== ref) ||
     (null !== current && current.ref !== ref)
@@ -3830,35 +4237,30 @@ function updateFunctionComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   var context = isContextProvider(Component)
     ? previousContext
     : contextStackCursor.current;
   context = getMaskedContext(workInProgress, context);
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   Component = renderWithHooks(
     current,
     workInProgress,
     Component,
     nextProps,
     context,
-    renderExpirationTime
+    renderLanes
   );
   if (null !== current && !didReceiveUpdate)
     return (
       (workInProgress.updateQueue = current.updateQueue),
       (workInProgress.effectTag &= -517),
-      current.expirationTime <= renderExpirationTime &&
-        (current.expirationTime = 0),
-      bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      )
+      (current.lanes &= ~renderLanes),
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
     );
   workInProgress.effectTag |= 1;
-  reconcileChildren(current, workInProgress, Component, renderExpirationTime);
+  reconcileChildren(current, workInProgress, Component, renderLanes);
   return workInProgress.child;
 }
 function updateClassComponent(
@@ -3866,25 +4268,20 @@ function updateClassComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   if (isContextProvider(Component)) {
     var hasContext = !0;
     pushContextProvider(workInProgress);
   } else hasContext = !1;
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   if (null === workInProgress.stateNode)
     null !== current &&
       ((current.alternate = null),
       (workInProgress.alternate = null),
       (workInProgress.effectTag |= 2)),
       constructClassInstance(workInProgress, Component, nextProps),
-      mountClassInstance(
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
-      ),
+      mountClassInstance(workInProgress, Component, nextProps, renderLanes),
       (nextProps = !0);
   else if (null === current) {
     var instance = workInProgress.stateNode,
@@ -3915,12 +4312,7 @@ function updateClassComponent(
     hasForceUpdate = !1;
     var oldState = workInProgress.memoizedState;
     instance.state = oldState;
-    processUpdateQueue(
-      workInProgress,
-      nextProps,
-      instance,
-      renderExpirationTime
-    );
+    processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     oldContext = workInProgress.memoizedState;
     oldProps !== nextProps ||
     oldState !== oldContext ||
@@ -3965,117 +4357,111 @@ function updateClassComponent(
       : ("function" === typeof instance.componentDidMount &&
           (workInProgress.effectTag |= 4),
         (nextProps = !1));
-  } else
-    (instance = workInProgress.stateNode),
-      cloneUpdateQueue(current, workInProgress),
-      (oldProps = workInProgress.memoizedProps),
-      (instance.props =
-        workInProgress.type === workInProgress.elementType
-          ? oldProps
-          : resolveDefaultProps(workInProgress.type, oldProps)),
-      (oldContext = instance.context),
-      (contextType = Component.contextType),
-      "object" === typeof contextType && null !== contextType
-        ? (contextType = readContext(contextType))
-        : ((contextType = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (contextType = getMaskedContext(workInProgress, contextType))),
-      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
-      (hasNewLifecycles =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof instance.getSnapshotBeforeUpdate) ||
-        ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof instance.componentWillReceiveProps) ||
-        ((oldProps !== nextProps || oldContext !== contextType) &&
-          callComponentWillReceiveProps(
+  } else {
+    instance = workInProgress.stateNode;
+    cloneUpdateQueue(current, workInProgress);
+    oldProps = workInProgress.memoizedProps;
+    contextType =
+      workInProgress.type === workInProgress.elementType
+        ? oldProps
+        : resolveDefaultProps(workInProgress.type, oldProps);
+    instance.props = contextType;
+    hasNewLifecycles = workInProgress.pendingProps;
+    oldState = instance.context;
+    oldContext = Component.contextType;
+    "object" === typeof oldContext && null !== oldContext
+      ? (oldContext = readContext(oldContext))
+      : ((oldContext = isContextProvider(Component)
+          ? previousContext
+          : contextStackCursor.current),
+        (oldContext = getMaskedContext(workInProgress, oldContext)));
+    var getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;
+    (getDerivedStateFromProps =
+      "function" === typeof getDerivedStateFromProps$jscomp$0 ||
+      "function" === typeof instance.getSnapshotBeforeUpdate) ||
+      ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+        "function" !== typeof instance.componentWillReceiveProps) ||
+      ((oldProps !== hasNewLifecycles || oldState !== oldContext) &&
+        callComponentWillReceiveProps(
+          workInProgress,
+          instance,
+          nextProps,
+          oldContext
+        ));
+    hasForceUpdate = !1;
+    oldState = workInProgress.memoizedState;
+    instance.state = oldState;
+    processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
+    var newState = workInProgress.memoizedState;
+    oldProps !== hasNewLifecycles ||
+    oldState !== newState ||
+    didPerformWorkStackCursor.current ||
+    hasForceUpdate
+      ? ("function" === typeof getDerivedStateFromProps$jscomp$0 &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            getDerivedStateFromProps$jscomp$0,
+            nextProps
+          ),
+          (newState = workInProgress.memoizedState)),
+        (contextType =
+          hasForceUpdate ||
+          checkShouldComponentUpdate(
             workInProgress,
-            instance,
+            Component,
+            contextType,
             nextProps,
-            contextType
-          )),
-      (hasForceUpdate = !1),
-      (oldContext = workInProgress.memoizedState),
-      (instance.state = oldContext),
-      processUpdateQueue(
-        workInProgress,
-        nextProps,
-        instance,
-        renderExpirationTime
-      ),
-      (oldState = workInProgress.memoizedState),
-      oldProps !== nextProps ||
-      oldContext !== oldState ||
-      didPerformWorkStackCursor.current ||
-      hasForceUpdate
-        ? ("function" === typeof getDerivedStateFromProps &&
-            (applyDerivedStateFromProps(
-              workInProgress,
-              Component,
-              getDerivedStateFromProps,
-              nextProps
-            ),
-            (oldState = workInProgress.memoizedState)),
-          (getDerivedStateFromProps =
-            hasForceUpdate ||
-            checkShouldComponentUpdate(
-              workInProgress,
-              Component,
-              oldProps,
-              nextProps,
-              oldContext,
-              oldState,
-              contextType
-            ))
-            ? (hasNewLifecycles ||
-                ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
-                  "function" !== typeof instance.componentWillUpdate) ||
-                ("function" === typeof instance.componentWillUpdate &&
-                  instance.componentWillUpdate(
-                    nextProps,
-                    oldState,
-                    contextType
-                  ),
-                "function" === typeof instance.UNSAFE_componentWillUpdate &&
-                  instance.UNSAFE_componentWillUpdate(
-                    nextProps,
-                    oldState,
-                    contextType
-                  )),
-              "function" === typeof instance.componentDidUpdate &&
-                (workInProgress.effectTag |= 4),
-              "function" === typeof instance.getSnapshotBeforeUpdate &&
-                (workInProgress.effectTag |= 256))
-            : ("function" !== typeof instance.componentDidUpdate ||
-                (oldProps === current.memoizedProps &&
-                  oldContext === current.memoizedState) ||
-                (workInProgress.effectTag |= 4),
-              "function" !== typeof instance.getSnapshotBeforeUpdate ||
-                (oldProps === current.memoizedProps &&
-                  oldContext === current.memoizedState) ||
-                (workInProgress.effectTag |= 256),
-              (workInProgress.memoizedProps = nextProps),
-              (workInProgress.memoizedState = oldState)),
-          (instance.props = nextProps),
-          (instance.state = oldState),
-          (instance.context = contextType),
-          (nextProps = getDerivedStateFromProps))
-        : ("function" !== typeof instance.componentDidUpdate ||
-            (oldProps === current.memoizedProps &&
-              oldContext === current.memoizedState) ||
-            (workInProgress.effectTag |= 4),
-          "function" !== typeof instance.getSnapshotBeforeUpdate ||
-            (oldProps === current.memoizedProps &&
-              oldContext === current.memoizedState) ||
-            (workInProgress.effectTag |= 256),
-          (nextProps = !1));
+            oldState,
+            newState,
+            oldContext
+          ))
+          ? (getDerivedStateFromProps ||
+              ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
+                "function" !== typeof instance.componentWillUpdate) ||
+              ("function" === typeof instance.componentWillUpdate &&
+                instance.componentWillUpdate(nextProps, newState, oldContext),
+              "function" === typeof instance.UNSAFE_componentWillUpdate &&
+                instance.UNSAFE_componentWillUpdate(
+                  nextProps,
+                  newState,
+                  oldContext
+                )),
+            "function" === typeof instance.componentDidUpdate &&
+              (workInProgress.effectTag |= 4),
+            "function" === typeof instance.getSnapshotBeforeUpdate &&
+              (workInProgress.effectTag |= 256))
+          : ("function" !== typeof instance.componentDidUpdate ||
+              (oldProps === current.memoizedProps &&
+                oldState === current.memoizedState) ||
+              (workInProgress.effectTag |= 4),
+            "function" !== typeof instance.getSnapshotBeforeUpdate ||
+              (oldProps === current.memoizedProps &&
+                oldState === current.memoizedState) ||
+              (workInProgress.effectTag |= 256),
+            (workInProgress.memoizedProps = nextProps),
+            (workInProgress.memoizedState = newState)),
+        (instance.props = nextProps),
+        (instance.state = newState),
+        (instance.context = oldContext),
+        (nextProps = contextType))
+      : ("function" !== typeof instance.componentDidUpdate ||
+          (oldProps === current.memoizedProps &&
+            oldState === current.memoizedState) ||
+          (workInProgress.effectTag |= 4),
+        "function" !== typeof instance.getSnapshotBeforeUpdate ||
+          (oldProps === current.memoizedProps &&
+            oldState === current.memoizedState) ||
+          (workInProgress.effectTag |= 256),
+        (nextProps = !1));
+  }
   return finishClassComponent(
     current,
     workInProgress,
     Component,
     nextProps,
     hasContext,
-    renderExpirationTime
+    renderLanes
   );
 }
 function finishClassComponent(
@@ -4084,18 +4470,14 @@ function finishClassComponent(
   Component,
   shouldUpdate,
   hasContext,
-  renderExpirationTime
+  renderLanes
 ) {
   markRef(current, workInProgress);
   var didCaptureError = 0 !== (workInProgress.effectTag & 64);
   if (!shouldUpdate && !didCaptureError)
     return (
       hasContext && invalidateContextProvider(workInProgress, Component, !1),
-      bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      )
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
     );
   shouldUpdate = workInProgress.stateNode;
   ReactCurrentOwner$1.current = workInProgress;
@@ -4109,20 +4491,15 @@ function finishClassComponent(
         workInProgress,
         current.child,
         null,
-        renderExpirationTime
+        renderLanes
       )),
       (workInProgress.child = reconcileChildFibers(
         workInProgress,
         null,
         nextChildren,
-        renderExpirationTime
+        renderLanes
       )))
-    : reconcileChildren(
-        current,
-        workInProgress,
-        nextChildren,
-        renderExpirationTime
-      );
+    : reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   workInProgress.memoizedState = shouldUpdate.state;
   hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
@@ -4139,155 +4516,186 @@ function pushHostRootContext(workInProgress) {
       pushTopLevelContextObject(workInProgress, root.context, !1);
   pushHostContainer(workInProgress, root.containerInfo);
 }
-var SUSPENDED_MARKER = { dehydrated: null, retryTime: 0 };
-function updateSuspenseComponent(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
-  var mode = workInProgress.mode,
-    nextProps = workInProgress.pendingProps,
+var SUSPENDED_MARKER = { dehydrated: null, retryLane: 0 };
+function updateSuspenseComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps,
     suspenseContext = suspenseStackCursor.current,
-    nextDidTimeout = !1,
+    showFallback = !1,
     JSCompiler_temp;
   (JSCompiler_temp = 0 !== (workInProgress.effectTag & 64)) ||
     (JSCompiler_temp =
-      0 !== (suspenseContext & 2) &&
-      (null === current || null !== current.memoizedState));
+      null !== current && null === current.memoizedState
+        ? !1
+        : 0 !== (suspenseContext & 2));
   JSCompiler_temp
-    ? ((nextDidTimeout = !0), (workInProgress.effectTag &= -65))
+    ? ((showFallback = !0), (workInProgress.effectTag &= -65))
     : (null !== current && null === current.memoizedState) ||
       void 0 === nextProps.fallback ||
       !0 === nextProps.unstable_avoidThisFallback ||
       (suspenseContext |= 1);
   push(suspenseStackCursor, suspenseContext & 1);
   if (null === current) {
-    if (nextDidTimeout) {
-      nextDidTimeout = nextProps.fallback;
-      nextProps = createFiberFromFragment(null, mode, 0, null);
-      nextProps.return = workInProgress;
-      if (0 === (workInProgress.mode & 2))
-        for (
-          current =
-            null !== workInProgress.memoizedState
-              ? workInProgress.child.child
-              : workInProgress.child,
-            nextProps.child = current;
-          null !== current;
-
-        )
-          (current.return = nextProps), (current = current.sibling);
-      renderExpirationTime = createFiberFromFragment(
-        nextDidTimeout,
-        mode,
-        renderExpirationTime,
-        null
+    if (showFallback)
+      return (
+        (current = nextProps.fallback),
+        (suspenseContext = workInProgress.mode),
+        (showFallback = workInProgress.child),
+        (nextProps = { mode: "hidden", children: nextProps.children }),
+        0 === (suspenseContext & 2) && null !== showFallback
+          ? ((showFallback.childLanes = 0),
+            (showFallback.pendingProps = nextProps))
+          : (showFallback = createFiberFromOffscreen(
+              nextProps,
+              suspenseContext,
+              0,
+              null
+            )),
+        (current = createFiberFromFragment(
+          current,
+          suspenseContext,
+          renderLanes,
+          null
+        )),
+        (showFallback.return = workInProgress),
+        (current.return = workInProgress),
+        (showFallback.sibling = current),
+        (workInProgress.child = showFallback),
+        (workInProgress.child.memoizedState = { baseLanes: renderLanes }),
+        (workInProgress.memoizedState = SUSPENDED_MARKER),
+        current
       );
-      renderExpirationTime.return = workInProgress;
-      nextProps.sibling = renderExpirationTime;
-      workInProgress.memoizedState = SUSPENDED_MARKER;
-      workInProgress.child = nextProps;
-      return renderExpirationTime;
-    }
-    mode = nextProps.children;
-    workInProgress.memoizedState = null;
-    return (workInProgress.child = mountChildFibers(
-      workInProgress,
-      null,
-      mode,
-      renderExpirationTime
-    ));
+    renderLanes = createFiberFromOffscreen(
+      { mode: "visible", children: nextProps.children },
+      workInProgress.mode,
+      renderLanes,
+      null
+    );
+    renderLanes.return = workInProgress;
+    return (workInProgress.child = renderLanes);
   }
   if (null !== current.memoizedState) {
-    current = current.child;
-    mode = current.sibling;
-    if (nextDidTimeout) {
-      nextProps = nextProps.fallback;
-      renderExpirationTime = createWorkInProgress(
-        current,
-        current.pendingProps
+    if (showFallback)
+      return (
+        (nextProps = updateSuspenseFallbackChildren(
+          current,
+          workInProgress,
+          nextProps.children,
+          nextProps.fallback,
+          renderLanes
+        )),
+        (suspenseContext = workInProgress.child),
+        (showFallback = current.child.memoizedState),
+        (suspenseContext.memoizedState =
+          null === showFallback
+            ? { baseLanes: renderLanes }
+            : { baseLanes: showFallback.baseLanes | renderLanes }),
+        (suspenseContext.childLanes = current.childLanes & ~renderLanes),
+        (workInProgress.memoizedState = SUSPENDED_MARKER),
+        nextProps
       );
-      renderExpirationTime.return = workInProgress;
-      if (
-        0 === (workInProgress.mode & 2) &&
-        ((nextDidTimeout =
-          null !== workInProgress.memoizedState
-            ? workInProgress.child.child
-            : workInProgress.child),
-        nextDidTimeout !== current.child)
-      )
-        for (
-          renderExpirationTime.child = nextDidTimeout;
-          null !== nextDidTimeout;
-
-        )
-          (nextDidTimeout.return = renderExpirationTime),
-            (nextDidTimeout = nextDidTimeout.sibling);
-      mode = createWorkInProgress(mode, nextProps);
-      mode.return = workInProgress;
-      renderExpirationTime.sibling = mode;
-      renderExpirationTime.childExpirationTime = 0;
-      workInProgress.memoizedState = SUSPENDED_MARKER;
-      workInProgress.child = renderExpirationTime;
-      return mode;
-    }
-    renderExpirationTime = reconcileChildFibers(
+    renderLanes = updateSuspensePrimaryChildren(
+      current,
       workInProgress,
-      current.child,
       nextProps.children,
-      renderExpirationTime
+      renderLanes
     );
     workInProgress.memoizedState = null;
-    return (workInProgress.child = renderExpirationTime);
+    return renderLanes;
   }
-  current = current.child;
-  if (nextDidTimeout) {
-    nextDidTimeout = nextProps.fallback;
-    nextProps = createFiberFromFragment(null, mode, 0, null);
-    nextProps.return = workInProgress;
-    nextProps.child = current;
-    null !== current && (current.return = nextProps);
-    if (0 === (workInProgress.mode & 2))
-      for (
-        current =
-          null !== workInProgress.memoizedState
-            ? workInProgress.child.child
-            : workInProgress.child,
-          nextProps.child = current;
-        null !== current;
-
-      )
-        (current.return = nextProps), (current = current.sibling);
-    renderExpirationTime = createFiberFromFragment(
-      nextDidTimeout,
-      mode,
-      renderExpirationTime,
-      null
+  if (showFallback)
+    return (
+      (nextProps = updateSuspenseFallbackChildren(
+        current,
+        workInProgress,
+        nextProps.children,
+        nextProps.fallback,
+        renderLanes
+      )),
+      (suspenseContext = workInProgress.child),
+      (showFallback = current.child.memoizedState),
+      (suspenseContext.memoizedState =
+        null === showFallback
+          ? { baseLanes: renderLanes }
+          : { baseLanes: showFallback.baseLanes | renderLanes }),
+      (suspenseContext.childLanes = current.childLanes & ~renderLanes),
+      (workInProgress.memoizedState = SUSPENDED_MARKER),
+      nextProps
     );
-    renderExpirationTime.return = workInProgress;
-    nextProps.sibling = renderExpirationTime;
-    renderExpirationTime.effectTag |= 2;
-    nextProps.childExpirationTime = 0;
-    workInProgress.memoizedState = SUSPENDED_MARKER;
-    workInProgress.child = nextProps;
-    return renderExpirationTime;
-  }
-  workInProgress.memoizedState = null;
-  return (workInProgress.child = reconcileChildFibers(
-    workInProgress,
+  renderLanes = updateSuspensePrimaryChildren(
     current,
+    workInProgress,
     nextProps.children,
-    renderExpirationTime
-  ));
+    renderLanes
+  );
+  workInProgress.memoizedState = null;
+  return renderLanes;
 }
-function scheduleWorkOnFiber(fiber, renderExpirationTime) {
-  fiber.expirationTime < renderExpirationTime &&
-    (fiber.expirationTime = renderExpirationTime);
+function updateSuspensePrimaryChildren(
+  current,
+  workInProgress,
+  primaryChildren,
+  renderLanes
+) {
+  var currentPrimaryChildFragment = current.child;
+  current = currentPrimaryChildFragment.sibling;
+  primaryChildren = createWorkInProgress(currentPrimaryChildFragment, {
+    mode: "visible",
+    children: primaryChildren
+  });
+  0 === (workInProgress.mode & 2) && (primaryChildren.lanes = renderLanes);
+  primaryChildren.return = workInProgress;
+  primaryChildren.sibling = null;
+  null !== current &&
+    ((current.nextEffect = null),
+    (current.effectTag = 8),
+    (workInProgress.firstEffect = workInProgress.lastEffect = current));
+  return (workInProgress.child = primaryChildren);
+}
+function updateSuspenseFallbackChildren(
+  current,
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode,
+    currentPrimaryChildFragment = current.child;
+  current = currentPrimaryChildFragment.sibling;
+  var primaryChildProps = { mode: "hidden", children: primaryChildren };
+  0 === (mode & 2) && workInProgress.child !== currentPrimaryChildFragment
+    ? ((primaryChildren = workInProgress.child),
+      (primaryChildren.childLanes = 0),
+      (primaryChildren.pendingProps = primaryChildProps),
+      (currentPrimaryChildFragment = primaryChildren.lastEffect),
+      null !== currentPrimaryChildFragment
+        ? ((workInProgress.firstEffect = primaryChildren.firstEffect),
+          (workInProgress.lastEffect = currentPrimaryChildFragment),
+          (currentPrimaryChildFragment.nextEffect = null))
+        : (workInProgress.firstEffect = workInProgress.lastEffect = null))
+    : (primaryChildren = createWorkInProgress(
+        currentPrimaryChildFragment,
+        primaryChildProps
+      ));
+  null !== current
+    ? (fallbackChildren = createWorkInProgress(current, fallbackChildren))
+    : ((fallbackChildren = createFiberFromFragment(
+        fallbackChildren,
+        mode,
+        renderLanes,
+        null
+      )),
+      (fallbackChildren.effectTag |= 2));
+  fallbackChildren.return = workInProgress;
+  primaryChildren.return = workInProgress;
+  primaryChildren.sibling = fallbackChildren;
+  workInProgress.child = primaryChildren;
+  return fallbackChildren;
+}
+function scheduleWorkOnFiber(fiber, renderLanes) {
+  fiber.lanes |= renderLanes;
   var alternate = fiber.alternate;
-  null !== alternate &&
-    alternate.expirationTime < renderExpirationTime &&
-    (alternate.expirationTime = renderExpirationTime);
-  scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
+  null !== alternate && (alternate.lanes |= renderLanes);
+  scheduleWorkOnParentPath(fiber.return, renderLanes);
 }
 function initSuspenseListRenderState(
   workInProgress,
@@ -4318,20 +4726,11 @@ function initSuspenseListRenderState(
       (renderState.tailMode = tailMode),
       (renderState.lastEffect = lastEffectBeforeRendering));
 }
-function updateSuspenseListComponent(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
+function updateSuspenseListComponent(current, workInProgress, renderLanes) {
   var nextProps = workInProgress.pendingProps,
     revealOrder = nextProps.revealOrder,
     tailMode = nextProps.tail;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextProps.children,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
   nextProps = suspenseStackCursor.current;
   if (0 !== (nextProps & 2))
     (nextProps = (nextProps & 1) | 2), (workInProgress.effectTag |= 64);
@@ -4340,9 +4739,8 @@ function updateSuspenseListComponent(
       a: for (current = workInProgress.child; null !== current; ) {
         if (13 === current.tag)
           null !== current.memoizedState &&
-            scheduleWorkOnFiber(current, renderExpirationTime);
-        else if (19 === current.tag)
-          scheduleWorkOnFiber(current, renderExpirationTime);
+            scheduleWorkOnFiber(current, renderLanes);
+        else if (19 === current.tag) scheduleWorkOnFiber(current, renderLanes);
         else if (null !== current.child) {
           current.child.return = current;
           current = current.child;
@@ -4364,30 +4762,29 @@ function updateSuspenseListComponent(
   else
     switch (revealOrder) {
       case "forwards":
-        renderExpirationTime = workInProgress.child;
-        for (revealOrder = null; null !== renderExpirationTime; )
-          (current = renderExpirationTime.alternate),
+        renderLanes = workInProgress.child;
+        for (revealOrder = null; null !== renderLanes; )
+          (current = renderLanes.alternate),
             null !== current &&
               null === findFirstSuspended(current) &&
-              (revealOrder = renderExpirationTime),
-            (renderExpirationTime = renderExpirationTime.sibling);
-        renderExpirationTime = revealOrder;
-        null === renderExpirationTime
+              (revealOrder = renderLanes),
+            (renderLanes = renderLanes.sibling);
+        renderLanes = revealOrder;
+        null === renderLanes
           ? ((revealOrder = workInProgress.child),
             (workInProgress.child = null))
-          : ((revealOrder = renderExpirationTime.sibling),
-            (renderExpirationTime.sibling = null));
+          : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
         initSuspenseListRenderState(
           workInProgress,
           !1,
           revealOrder,
-          renderExpirationTime,
+          renderLanes,
           tailMode,
           workInProgress.lastEffect
         );
         break;
       case "backwards":
-        renderExpirationTime = null;
+        renderLanes = null;
         revealOrder = workInProgress.child;
         for (workInProgress.child = null; null !== revealOrder; ) {
           current = revealOrder.alternate;
@@ -4396,14 +4793,14 @@ function updateSuspenseListComponent(
             break;
           }
           current = revealOrder.sibling;
-          revealOrder.sibling = renderExpirationTime;
-          renderExpirationTime = revealOrder;
+          revealOrder.sibling = renderLanes;
+          renderLanes = revealOrder;
           revealOrder = current;
         }
         initSuspenseListRenderState(
           workInProgress,
           !0,
-          renderExpirationTime,
+          renderLanes,
           null,
           tailMode,
           workInProgress.lastEffect
@@ -4424,35 +4821,28 @@ function updateSuspenseListComponent(
     }
   return workInProgress.child;
 }
-function bailoutOnAlreadyFinishedWork(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
+function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
   null !== current && (workInProgress.dependencies = current.dependencies);
-  var updateExpirationTime = workInProgress.expirationTime;
-  0 !== updateExpirationTime && markUnprocessedUpdateTime(updateExpirationTime);
-  if (workInProgress.childExpirationTime < renderExpirationTime) return null;
-  if (null !== current && workInProgress.child !== current.child)
-    throw Error("Resuming work not yet implemented.");
-  if (null !== workInProgress.child) {
-    current = workInProgress.child;
-    renderExpirationTime = createWorkInProgress(current, current.pendingProps);
-    workInProgress.child = renderExpirationTime;
-    for (
-      renderExpirationTime.return = workInProgress;
-      null !== current.sibling;
-
-    )
-      (current = current.sibling),
-        (renderExpirationTime = renderExpirationTime.sibling = createWorkInProgress(
-          current,
-          current.pendingProps
-        )),
-        (renderExpirationTime.return = workInProgress);
-    renderExpirationTime.sibling = null;
+  workInProgressRootSkippedLanes |= workInProgress.lanes;
+  if (0 !== (renderLanes & workInProgress.childLanes)) {
+    if (null !== current && workInProgress.child !== current.child)
+      throw Error("Resuming work not yet implemented.");
+    if (null !== workInProgress.child) {
+      current = workInProgress.child;
+      renderLanes = createWorkInProgress(current, current.pendingProps);
+      workInProgress.child = renderLanes;
+      for (renderLanes.return = workInProgress; null !== current.sibling; )
+        (current = current.sibling),
+          (renderLanes = renderLanes.sibling = createWorkInProgress(
+            current,
+            current.pendingProps
+          )),
+          (renderLanes.return = workInProgress);
+      renderLanes.sibling = null;
+    }
+    return workInProgress.child;
   }
-  return workInProgress.child;
+  return null;
 }
 var appendAllChildren,
   updateHostContainer,
@@ -4499,17 +4889,17 @@ function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
       break;
     case "collapsed":
       lastTailNode = renderState.tail;
-      for (var _lastTailNode = null; null !== lastTailNode; )
-        null !== lastTailNode.alternate && (_lastTailNode = lastTailNode),
+      for (var lastTailNode$64 = null; null !== lastTailNode; )
+        null !== lastTailNode.alternate && (lastTailNode$64 = lastTailNode),
           (lastTailNode = lastTailNode.sibling);
-      null === _lastTailNode
+      null === lastTailNode$64
         ? hasRenderedATailFallback || null === renderState.tail
           ? (renderState.tail = null)
           : (renderState.tail.sibling = null)
-        : (_lastTailNode.sibling = null);
+        : (lastTailNode$64.sibling = null);
   }
 }
-function completeWork(current, workInProgress, renderExpirationTime) {
+function completeWork(current, workInProgress, renderLanes) {
   var newProps = workInProgress.pendingProps;
   switch (workInProgress.tag) {
     case 2:
@@ -4530,10 +4920,14 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         popHostContainer(),
         pop(didPerformWorkStackCursor),
         pop(contextStackCursor),
-        (current = workInProgress.stateNode),
-        current.pendingContext &&
-          ((current.context = current.pendingContext),
-          (current.pendingContext = null)),
+        resetWorkInProgressVersions(),
+        (newProps = workInProgress.stateNode),
+        newProps.pendingContext &&
+          ((newProps.context = newProps.pendingContext),
+          (newProps.pendingContext = null)),
+        (null !== current && null !== current.child) ||
+          newProps.hydrate ||
+          (workInProgress.effectTag |= 256),
         updateHostContainer(workInProgress),
         null
       );
@@ -4542,12 +4936,12 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       var rootContainerInstance = requiredContext(
         rootInstanceStackCursor.current
       );
-      renderExpirationTime = workInProgress.type;
+      renderLanes = workInProgress.type;
       if (null !== current && null != workInProgress.stateNode)
         updateHostComponent$1(
           current,
           workInProgress,
-          renderExpirationTime,
+          renderLanes,
           newProps,
           rootContainerInstance
         ),
@@ -4563,22 +4957,22 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         }
         requiredContext(contextStackCursor$1.current);
         current = allocateTag();
-        renderExpirationTime = getViewConfigForType(renderExpirationTime);
+        renderLanes = getViewConfigForType(renderLanes);
         var updatePayload = diffProperties(
           null,
           emptyObject,
           newProps,
-          renderExpirationTime.validAttributes
+          renderLanes.validAttributes
         );
         ReactNativePrivateInterface.UIManager.createView(
           current,
-          renderExpirationTime.uiViewClassName,
+          renderLanes.uiViewClassName,
           rootContainerInstance,
           updatePayload
         );
         rootContainerInstance = new ReactNativeFiberHostComponent(
           current,
-          renderExpirationTime,
+          renderLanes,
           workInProgress
         );
         instanceCache.set(current, workInProgress);
@@ -4623,49 +5017,32 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       pop(suspenseStackCursor);
       newProps = workInProgress.memoizedState;
       if (0 !== (workInProgress.effectTag & 64))
-        return (
-          (workInProgress.expirationTime = renderExpirationTime), workInProgress
-        );
+        return (workInProgress.lanes = renderLanes), workInProgress;
       newProps = null !== newProps;
       rootContainerInstance = !1;
       null !== current &&
-        ((renderExpirationTime = current.memoizedState),
-        (rootContainerInstance = null !== renderExpirationTime),
-        newProps ||
-          null === renderExpirationTime ||
-          ((renderExpirationTime = current.child.sibling),
-          null !== renderExpirationTime &&
-            ((updatePayload = workInProgress.firstEffect),
-            null !== updatePayload
-              ? ((workInProgress.firstEffect = renderExpirationTime),
-                (renderExpirationTime.nextEffect = updatePayload))
-              : ((workInProgress.firstEffect = workInProgress.lastEffect = renderExpirationTime),
-                (renderExpirationTime.nextEffect = null)),
-            (renderExpirationTime.effectTag = 8))));
+        (rootContainerInstance = null !== current.memoizedState);
       if (newProps && !rootContainerInstance && 0 !== (workInProgress.mode & 2))
         if (
           (null === current &&
             !0 !== workInProgress.memoizedProps.unstable_avoidThisFallback) ||
           0 !== (suspenseStackCursor.current & 1)
         )
-          workInProgressRootExitStatus === RootIncomplete &&
-            (workInProgressRootExitStatus = RootSuspended);
+          0 === workInProgressRootExitStatus &&
+            (workInProgressRootExitStatus = 3);
         else {
           if (
-            workInProgressRootExitStatus === RootIncomplete ||
-            workInProgressRootExitStatus === RootSuspended
+            0 === workInProgressRootExitStatus ||
+            3 === workInProgressRootExitStatus
           )
-            workInProgressRootExitStatus = RootSuspendedWithDelay;
-          0 !== workInProgressRootNextUnprocessedUpdateTime &&
-            null !== workInProgressRoot &&
-            (markRootSuspendedAtTime(
+            workInProgressRootExitStatus = 4;
+          null === workInProgressRoot ||
+            (0 === (workInProgressRootSkippedLanes & 134217727) &&
+              0 === (workInProgressRootUpdatedLanes & 134217727)) ||
+            markRootSuspended$1(
               workInProgressRoot,
-              renderExpirationTime$1
-            ),
-            markRootUpdatedAtTime(
-              workInProgressRoot,
-              workInProgressRootNextUnprocessedUpdateTime
-            ));
+              workInProgressRootRenderLanes
+            );
         }
       if (newProps || rootContainerInstance) workInProgress.effectTag |= 4;
       return null;
@@ -4685,7 +5062,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         if (rootContainerInstance) cutOffTailIfNeeded(newProps, !1);
         else {
           if (
-            workInProgressRootExitStatus !== RootIncomplete ||
+            0 !== workInProgressRootExitStatus ||
             (null !== current && 0 !== (current.effectTag & 64))
           )
             for (current = workInProgress.child; null !== current; ) {
@@ -4700,27 +5077,27 @@ function completeWork(current, workInProgress, renderExpirationTime) {
                 null === newProps.lastEffect &&
                   (workInProgress.firstEffect = null);
                 workInProgress.lastEffect = newProps.lastEffect;
-                current = renderExpirationTime;
+                current = renderLanes;
                 for (newProps = workInProgress.child; null !== newProps; )
                   (rootContainerInstance = newProps),
-                    (renderExpirationTime = current),
+                    (renderLanes = current),
                     (rootContainerInstance.effectTag &= 2),
                     (rootContainerInstance.nextEffect = null),
                     (rootContainerInstance.firstEffect = null),
                     (rootContainerInstance.lastEffect = null),
                     (updatePayload = rootContainerInstance.alternate),
                     null === updatePayload
-                      ? ((rootContainerInstance.childExpirationTime = 0),
-                        (rootContainerInstance.expirationTime = renderExpirationTime),
+                      ? ((rootContainerInstance.childLanes = 0),
+                        (rootContainerInstance.lanes = renderLanes),
                         (rootContainerInstance.child = null),
                         (rootContainerInstance.memoizedProps = null),
                         (rootContainerInstance.memoizedState = null),
                         (rootContainerInstance.updateQueue = null),
-                        (rootContainerInstance.dependencies = null))
-                      : ((rootContainerInstance.childExpirationTime =
-                          updatePayload.childExpirationTime),
-                        (rootContainerInstance.expirationTime =
-                          updatePayload.expirationTime),
+                        (rootContainerInstance.dependencies = null),
+                        (rootContainerInstance.stateNode = null))
+                      : ((rootContainerInstance.childLanes =
+                          updatePayload.childLanes),
+                        (rootContainerInstance.lanes = updatePayload.lanes),
                         (rootContainerInstance.child = updatePayload.child),
                         (rootContainerInstance.memoizedProps =
                           updatePayload.memoizedProps),
@@ -4728,15 +5105,14 @@ function completeWork(current, workInProgress, renderExpirationTime) {
                           updatePayload.memoizedState),
                         (rootContainerInstance.updateQueue =
                           updatePayload.updateQueue),
-                        (renderExpirationTime = updatePayload.dependencies),
+                        (rootContainerInstance.type = updatePayload.type),
+                        (renderLanes = updatePayload.dependencies),
                         (rootContainerInstance.dependencies =
-                          null === renderExpirationTime
+                          null === renderLanes
                             ? null
                             : {
-                                expirationTime:
-                                  renderExpirationTime.expirationTime,
-                                firstContext: renderExpirationTime.firstContext,
-                                responders: renderExpirationTime.responders
+                                lanes: renderLanes.lanes,
+                                firstContext: renderLanes.firstContext
                               })),
                     (newProps = newProps.sibling);
                 push(
@@ -4773,12 +5149,11 @@ function completeWork(current, workInProgress, renderExpirationTime) {
               );
           } else
             2 * now() - newProps.renderingStartTime > newProps.tailExpiration &&
-              1 < renderExpirationTime &&
+              1073741824 !== renderLanes &&
               ((workInProgress.effectTag |= 64),
               (rootContainerInstance = !0),
               cutOffTailIfNeeded(newProps, !1),
-              (workInProgress.expirationTime = workInProgress.childExpirationTime =
-                renderExpirationTime - 1));
+              (workInProgress.lanes = renderLanes));
         newProps.isBackwards
           ? ((updatePayload.sibling = workInProgress.child),
             (workInProgress.child = updatePayload))
@@ -4806,6 +5181,17 @@ function completeWork(current, workInProgress, renderExpirationTime) {
           ),
           current)
         : null;
+    case 23:
+    case 24:
+      return (
+        popRenderLanes(),
+        null !== current &&
+          (null !== current.memoizedState) !==
+            (null !== workInProgress.memoizedState) &&
+          "unstable-defer-without-hiding" !== newProps.mode &&
+          (workInProgress.effectTag |= 4),
+        null
+      );
   }
   throw Error(
     "Unknown unit of work tag (" +
@@ -4826,6 +5212,7 @@ function unwindWork(workInProgress) {
       popHostContainer();
       pop(didPerformWorkStackCursor);
       pop(contextStackCursor);
+      resetWorkInProgressVersions();
       effectTag = workInProgress.effectTag;
       if (0 !== (effectTag & 64))
         throw Error(
@@ -4850,6 +5237,9 @@ function unwindWork(workInProgress) {
       return popHostContainer(), null;
     case 10:
       return popProvider(workInProgress), null;
+    case 23:
+    case 24:
+      return popRenderLanes(), null;
     default:
       return null;
   }
@@ -4868,51 +5258,61 @@ if (
   throw Error(
     "Expected ReactFiberErrorDialog.showErrorDialog to be a function."
   );
-function logCapturedError(capturedError) {
-  !1 !==
-    ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog(
-      capturedError
-    ) && console.error(capturedError.error);
-}
-var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
-function logError(boundary, errorInfo) {
-  var source = errorInfo.source,
-    stack = errorInfo.stack;
-  null === stack &&
-    null !== source &&
-    (stack = getStackByFiberInDevAndProd(source));
-  errorInfo = {
-    componentName: null !== source ? getComponentName(source.type) : null,
-    componentStack: null !== stack ? stack : "",
-    error: errorInfo.value,
-    errorBoundary: null,
-    errorBoundaryName: null,
-    errorBoundaryFound: !1,
-    willRetry: !1
-  };
-  null !== boundary &&
-    1 === boundary.tag &&
-    ((errorInfo.errorBoundary = boundary.stateNode),
-    (errorInfo.errorBoundaryName = getComponentName(boundary.type)),
-    (errorInfo.errorBoundaryFound = !0),
-    (errorInfo.willRetry = !0));
+function logCapturedError(boundary, errorInfo) {
   try {
-    logCapturedError(errorInfo);
+    !1 !==
+      ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog({
+        componentStack: null !== errorInfo.stack ? errorInfo.stack : "",
+        error: errorInfo.value,
+        errorBoundary:
+          null !== boundary && 1 === boundary.tag ? boundary.stateNode : null
+      }) && console.error(errorInfo.value);
   } catch (e) {
     setTimeout(function() {
       throw e;
     });
   }
 }
-function safelyCallComponentWillUnmount(current, instance) {
-  try {
-    (instance.props = current.memoizedProps),
-      (instance.state = current.memoizedState),
-      instance.componentWillUnmount();
-  } catch (unmountError) {
-    captureCommitPhaseError(current, unmountError);
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
+function createRootErrorUpdate(fiber, errorInfo, lane) {
+  lane = createUpdate(-1, lane, null);
+  lane.tag = 3;
+  lane.payload = { element: null };
+  var error = errorInfo.value;
+  lane.callback = function() {
+    hasUncaughtError || ((hasUncaughtError = !0), (firstUncaughtError = error));
+    logCapturedError(fiber, errorInfo);
+  };
+  return lane;
+}
+function createClassErrorUpdate(fiber, errorInfo, lane) {
+  lane = createUpdate(-1, lane, null);
+  lane.tag = 3;
+  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+  if ("function" === typeof getDerivedStateFromError) {
+    var error = errorInfo.value;
+    lane.payload = function() {
+      logCapturedError(fiber, errorInfo);
+      return getDerivedStateFromError(error);
+    };
   }
+  var inst = fiber.stateNode;
+  null !== inst &&
+    "function" === typeof inst.componentDidCatch &&
+    (lane.callback = function() {
+      "function" !== typeof getDerivedStateFromError &&
+        (null === legacyErrorBoundariesThatAlreadyFailed
+          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
+          : legacyErrorBoundariesThatAlreadyFailed.add(this),
+        logCapturedError(fiber, errorInfo));
+      var stack = errorInfo.stack;
+      this.componentDidCatch(errorInfo.value, {
+        componentStack: null !== stack ? stack : ""
+      });
+    });
+  return lane;
 }
+var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
 function safelyDetachRef(current) {
   var ref = current.ref;
   if (null !== ref)
@@ -4946,6 +5346,7 @@ function commitBeforeMutationLifeCycles(current, finishedWork) {
       }
       return;
     case 3:
+      return;
     case 5:
     case 6:
     case 4:
@@ -4956,58 +5357,57 @@ function commitBeforeMutationLifeCycles(current, finishedWork) {
     "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
   );
 }
-function commitHookEffectListUnmount(tag, finishedWork) {
-  finishedWork = finishedWork.updateQueue;
-  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
-  if (null !== finishedWork) {
-    var effect = (finishedWork = finishedWork.next);
-    do {
-      if ((effect.tag & tag) === tag) {
-        var destroy = effect.destroy;
-        effect.destroy = void 0;
-        void 0 !== destroy && destroy();
-      }
-      effect = effect.next;
-    } while (effect !== finishedWork);
-  }
-}
-function commitHookEffectListMount(tag, finishedWork) {
-  finishedWork = finishedWork.updateQueue;
-  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
-  if (null !== finishedWork) {
-    var effect = (finishedWork = finishedWork.next);
-    do {
-      if ((effect.tag & tag) === tag) {
-        var create = effect.create;
-        effect.destroy = create();
-      }
-      effect = effect.next;
-    } while (effect !== finishedWork);
-  }
-}
 function commitLifeCycles(finishedRoot, current, finishedWork) {
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 15:
     case 22:
-      commitHookEffectListMount(3, finishedWork);
+      current = finishedWork.updateQueue;
+      current = null !== current ? current.lastEffect : null;
+      if (null !== current) {
+        finishedRoot = current = current.next;
+        do {
+          if (3 === (finishedRoot.tag & 3)) {
+            var create$81 = finishedRoot.create;
+            finishedRoot.destroy = create$81();
+          }
+          finishedRoot = finishedRoot.next;
+        } while (finishedRoot !== current);
+      }
+      current = finishedWork.updateQueue;
+      current = null !== current ? current.lastEffect : null;
+      if (null !== current) {
+        finishedRoot = current = current.next;
+        do {
+          var _effect = finishedRoot;
+          create$81 = _effect.next;
+          _effect = _effect.tag;
+          0 !== (_effect & 4) &&
+            0 !== (_effect & 1) &&
+            (enqueuePendingPassiveHookEffectUnmount(finishedWork, finishedRoot),
+            enqueuePendingPassiveHookEffectMount(finishedWork, finishedRoot));
+          finishedRoot = create$81;
+        } while (finishedRoot !== current);
+      }
       return;
     case 1:
       finishedRoot = finishedWork.stateNode;
-      if (finishedWork.effectTag & 4)
-        if (null === current) finishedRoot.componentDidMount();
-        else {
-          var prevProps =
-            finishedWork.elementType === finishedWork.type
-              ? current.memoizedProps
-              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
-          finishedRoot.componentDidUpdate(
-            prevProps,
-            current.memoizedState,
-            finishedRoot.__reactInternalSnapshotBeforeUpdate
-          );
-        }
+      finishedWork.effectTag & 4 &&
+        (null === current
+          ? finishedRoot.componentDidMount()
+          : ((create$81 =
+              finishedWork.elementType === finishedWork.type
+                ? current.memoizedProps
+                : resolveDefaultProps(
+                    finishedWork.type,
+                    current.memoizedProps
+                  )),
+            finishedRoot.componentDidUpdate(
+              create$81,
+              current.memoizedState,
+              finishedRoot.__reactInternalSnapshotBeforeUpdate
+            )));
       current = finishedWork.updateQueue;
       null !== current &&
         commitUpdateQueue(finishedWork, current, finishedRoot);
@@ -5041,78 +5441,138 @@ function commitLifeCycles(finishedRoot, current, finishedWork) {
     case 17:
     case 20:
     case 21:
+    case 23:
+    case 24:
       return;
   }
   throw Error(
     "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
   );
 }
-function commitUnmount(finishedRoot, current$jscomp$0, renderPriorityLevel) {
-  "function" === typeof onCommitFiberUnmount &&
-    onCommitFiberUnmount(current$jscomp$0);
-  switch (current$jscomp$0.tag) {
+function hideOrUnhideAllChildren(finishedWork, isHidden) {
+  for (var node = finishedWork; ; ) {
+    if (5 === node.tag) {
+      var instance = node.stateNode;
+      if (isHidden) {
+        var viewConfig = instance.viewConfig;
+        var updatePayload = diffProperties(
+          null,
+          emptyObject,
+          { style: { display: "none" } },
+          viewConfig.validAttributes
+        );
+        ReactNativePrivateInterface.UIManager.updateView(
+          instance._nativeTag,
+          viewConfig.uiViewClassName,
+          updatePayload
+        );
+      } else {
+        instance = node.stateNode;
+        updatePayload = node.memoizedProps;
+        viewConfig = instance.viewConfig;
+        var prevProps = Object.assign({}, updatePayload, {
+          style: [updatePayload.style, { display: "none" }]
+        });
+        updatePayload = diffProperties(
+          null,
+          prevProps,
+          updatePayload,
+          viewConfig.validAttributes
+        );
+        ReactNativePrivateInterface.UIManager.updateView(
+          instance._nativeTag,
+          viewConfig.uiViewClassName,
+          updatePayload
+        );
+      }
+    } else {
+      if (6 === node.tag) throw Error("Not yet implemented.");
+      if (
+        ((23 !== node.tag && 24 !== node.tag) ||
+          null === node.memoizedState ||
+          node === finishedWork) &&
+        null !== node.child
+      ) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+    }
+    if (node === finishedWork) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === finishedWork) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+}
+function commitUnmount(finishedRoot, current) {
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, current);
+    } catch (err) {}
+  switch (current.tag) {
     case 0:
     case 11:
     case 14:
     case 15:
     case 22:
-      finishedRoot = current$jscomp$0.updateQueue;
+      finishedRoot = current.updateQueue;
       if (
         null !== finishedRoot &&
         ((finishedRoot = finishedRoot.lastEffect), null !== finishedRoot)
       ) {
-        var firstEffect = finishedRoot.next;
-        runWithPriority(
-          97 < renderPriorityLevel ? 97 : renderPriorityLevel,
-          function() {
-            var effect = firstEffect;
-            do {
-              var _destroy = effect.destroy;
-              if (void 0 !== _destroy) {
-                var current = current$jscomp$0;
-                try {
-                  _destroy();
-                } catch (error) {
-                  captureCommitPhaseError(current, error);
-                }
+        var effect = (finishedRoot = finishedRoot.next);
+        do {
+          var _effect2 = effect,
+            destroy = _effect2.destroy;
+          _effect2 = _effect2.tag;
+          if (void 0 !== destroy)
+            if (0 !== (_effect2 & 4))
+              enqueuePendingPassiveHookEffectUnmount(current, effect);
+            else {
+              _effect2 = current;
+              try {
+                destroy();
+              } catch (error) {
+                captureCommitPhaseError(_effect2, error);
               }
-              effect = effect.next;
-            } while (effect !== firstEffect);
-          }
-        );
+            }
+          effect = effect.next;
+        } while (effect !== finishedRoot);
       }
       break;
     case 1:
-      safelyDetachRef(current$jscomp$0);
-      renderPriorityLevel = current$jscomp$0.stateNode;
-      "function" === typeof renderPriorityLevel.componentWillUnmount &&
-        safelyCallComponentWillUnmount(current$jscomp$0, renderPriorityLevel);
+      safelyDetachRef(current);
+      finishedRoot = current.stateNode;
+      if ("function" === typeof finishedRoot.componentWillUnmount)
+        try {
+          (finishedRoot.props = current.memoizedProps),
+            (finishedRoot.state = current.memoizedState),
+            finishedRoot.componentWillUnmount();
+        } catch (unmountError) {
+          captureCommitPhaseError(current, unmountError);
+        }
       break;
     case 5:
-      safelyDetachRef(current$jscomp$0);
+      safelyDetachRef(current);
       break;
     case 4:
-      unmountHostComponents(
-        finishedRoot,
-        current$jscomp$0,
-        renderPriorityLevel
-      );
+      unmountHostComponents(finishedRoot, current);
   }
 }
-function detachFiber(current) {
-  var alternate = current.alternate;
-  current.return = null;
-  current.child = null;
-  current.memoizedState = null;
-  current.updateQueue = null;
-  current.dependencies = null;
-  current.alternate = null;
-  current.firstEffect = null;
-  current.lastEffect = null;
-  current.pendingProps = null;
-  current.memoizedProps = null;
-  current.stateNode = null;
-  null !== alternate && detachFiber(alternate);
+function detachFiberMutation(fiber) {
+  fiber.alternate = null;
+  fiber.child = null;
+  fiber.dependencies = null;
+  fiber.firstEffect = null;
+  fiber.lastEffect = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.return = null;
+  fiber.updateQueue = null;
 }
 function isHostParent(fiber) {
   return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
@@ -5120,16 +5580,14 @@ function isHostParent(fiber) {
 function commitPlacement(finishedWork) {
   a: {
     for (var parent = finishedWork.return; null !== parent; ) {
-      if (isHostParent(parent)) {
-        var parentFiber = parent;
-        break a;
-      }
+      if (isHostParent(parent)) break a;
       parent = parent.return;
     }
     throw Error(
       "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
     );
   }
+  var parentFiber = parent;
   parent = parentFiber.stateNode;
   switch (parentFiber.tag) {
     case 5:
@@ -5264,11 +5722,7 @@ function insertOrAppendPlacementNode(node, before, parent) {
     )
       insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
 }
-function unmountHostComponents(
-  finishedRoot$jscomp$0,
-  current,
-  renderPriorityLevel$jscomp$0
-) {
+function unmountHostComponents(finishedRoot$jscomp$0, current) {
   for (
     var node = current,
       currentParentIsValid = !1,
@@ -5306,13 +5760,12 @@ function unmountHostComponents(
       a: for (
         var finishedRoot = finishedRoot$jscomp$0,
           root = node,
-          renderPriorityLevel = renderPriorityLevel$jscomp$0,
           node$jscomp$0 = root;
         ;
 
       )
         if (
-          (commitUnmount(finishedRoot, node$jscomp$0, renderPriorityLevel),
+          (commitUnmount(finishedRoot, node$jscomp$0),
           null !== node$jscomp$0.child && 4 !== node$jscomp$0.tag)
         )
           (node$jscomp$0.child.return = node$jscomp$0),
@@ -5339,18 +5792,18 @@ function unmountHostComponents(
             [0]
           ))
         : ((finishedRoot = currentParent),
-          (renderPriorityLevel = node.stateNode),
-          recursivelyUncacheFiberNode(renderPriorityLevel),
+          (node$jscomp$0 = node.stateNode),
+          recursivelyUncacheFiberNode(node$jscomp$0),
           (root = finishedRoot._children),
-          (renderPriorityLevel = root.indexOf(renderPriorityLevel)),
-          root.splice(renderPriorityLevel, 1),
+          (node$jscomp$0 = root.indexOf(node$jscomp$0)),
+          root.splice(node$jscomp$0, 1),
           ReactNativePrivateInterface.UIManager.manageChildren(
             finishedRoot._nativeTag,
             [],
             [],
             [],
             [],
-            [renderPriorityLevel]
+            [node$jscomp$0]
           ));
     } else if (4 === node.tag) {
       if (null !== node.child) {
@@ -5361,8 +5814,7 @@ function unmountHostComponents(
         continue;
       }
     } else if (
-      (commitUnmount(finishedRoot$jscomp$0, node, renderPriorityLevel$jscomp$0),
-      null !== node.child)
+      (commitUnmount(finishedRoot$jscomp$0, node), null !== node.child)
     ) {
       node.child.return = node;
       node = node.child;
@@ -5385,31 +5837,42 @@ function commitWork(current, finishedWork) {
     case 14:
     case 15:
     case 22:
-      commitHookEffectListUnmount(3, finishedWork);
+      var updateQueue = finishedWork.updateQueue;
+      updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
+      if (null !== updateQueue) {
+        var effect = (updateQueue = updateQueue.next);
+        do
+          3 === (effect.tag & 3) &&
+            ((finishedWork = effect.destroy),
+            (effect.destroy = void 0),
+            void 0 !== finishedWork && finishedWork()),
+            (effect = effect.next);
+        while (effect !== updateQueue);
+      }
       return;
     case 1:
       return;
     case 5:
-      var instance = finishedWork.stateNode;
-      if (null != instance) {
-        var newProps = finishedWork.memoizedProps;
-        current = null !== current ? current.memoizedProps : newProps;
+      updateQueue = finishedWork.stateNode;
+      if (null != updateQueue) {
+        effect = finishedWork.memoizedProps;
+        current = null !== current ? current.memoizedProps : effect;
         var updatePayload = finishedWork.updateQueue;
         finishedWork.updateQueue = null;
         null !== updatePayload &&
-          ((finishedWork = instance.viewConfig),
-          instanceProps.set(instance._nativeTag, newProps),
-          (newProps = diffProperties(
+          ((finishedWork = updateQueue.viewConfig),
+          instanceProps.set(updateQueue._nativeTag, effect),
+          (effect = diffProperties(
             null,
             current,
-            newProps,
+            effect,
             finishedWork.validAttributes
           )),
-          null != newProps &&
+          null != effect &&
             ReactNativePrivateInterface.UIManager.updateView(
-              instance._nativeTag,
+              updateQueue._nativeTag,
               finishedWork.uiViewClassName,
-              newProps
+              effect
             ));
       }
       return;
@@ -5429,72 +5892,9 @@ function commitWork(current, finishedWork) {
     case 12:
       return;
     case 13:
-      instance = finishedWork;
-      null === finishedWork.memoizedState
-        ? (newProps = !1)
-        : ((newProps = !0),
-          (instance = finishedWork.child),
-          (globalMostRecentFallbackTime = now()));
-      if (null !== instance)
-        a: for (current = instance; ; ) {
-          if (5 === current.tag)
-            if (((updatePayload = current.stateNode), newProps)) {
-              var viewConfig = updatePayload.viewConfig;
-              var updatePayload$jscomp$0 = diffProperties(
-                null,
-                emptyObject,
-                { style: { display: "none" } },
-                viewConfig.validAttributes
-              );
-              ReactNativePrivateInterface.UIManager.updateView(
-                updatePayload._nativeTag,
-                viewConfig.uiViewClassName,
-                updatePayload$jscomp$0
-              );
-            } else {
-              updatePayload = current.stateNode;
-              updatePayload$jscomp$0 = current.memoizedProps;
-              viewConfig = updatePayload.viewConfig;
-              var prevProps = Object.assign({}, updatePayload$jscomp$0, {
-                style: [updatePayload$jscomp$0.style, { display: "none" }]
-              });
-              updatePayload$jscomp$0 = diffProperties(
-                null,
-                prevProps,
-                updatePayload$jscomp$0,
-                viewConfig.validAttributes
-              );
-              ReactNativePrivateInterface.UIManager.updateView(
-                updatePayload._nativeTag,
-                viewConfig.uiViewClassName,
-                updatePayload$jscomp$0
-              );
-            }
-          else {
-            if (6 === current.tag) throw Error("Not yet implemented.");
-            if (
-              13 === current.tag &&
-              null !== current.memoizedState &&
-              null === current.memoizedState.dehydrated
-            ) {
-              updatePayload = current.child.sibling;
-              updatePayload.return = current;
-              current = updatePayload;
-              continue;
-            } else if (null !== current.child) {
-              current.child.return = current;
-              current = current.child;
-              continue;
-            }
-          }
-          if (current === instance) break;
-          for (; null === current.sibling; ) {
-            if (null === current.return || current.return === instance) break a;
-            current = current.return;
-          }
-          current.sibling.return = current.return;
-          current = current.sibling;
-        }
+      null !== finishedWork.memoizedState &&
+        ((globalMostRecentFallbackTime = now()),
+        hideOrUnhideAllChildren(finishedWork.child, !0));
       attachSuspenseRetryListeners(finishedWork);
       return;
     case 19:
@@ -5502,90 +5902,59 @@ function commitWork(current, finishedWork) {
       return;
     case 17:
       return;
+    case 23:
+    case 24:
+      hideOrUnhideAllChildren(
+        finishedWork,
+        null !== finishedWork.memoizedState
+      );
+      return;
   }
   throw Error(
     "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
   );
 }
 function attachSuspenseRetryListeners(finishedWork) {
-  var thenables = finishedWork.updateQueue;
-  if (null !== thenables) {
+  var wakeables = finishedWork.updateQueue;
+  if (null !== wakeables) {
     finishedWork.updateQueue = null;
     var retryCache = finishedWork.stateNode;
     null === retryCache &&
       (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
-    thenables.forEach(function(thenable) {
-      var retry = resolveRetryThenable.bind(null, finishedWork, thenable);
-      retryCache.has(thenable) ||
-        (retryCache.add(thenable), thenable.then(retry, retry));
+    wakeables.forEach(function(wakeable) {
+      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+      retryCache.has(wakeable) ||
+        (retryCache.add(wakeable), wakeable.then(retry, retry));
     });
   }
 }
-var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
-function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
-  expirationTime = createUpdate(expirationTime, null);
-  expirationTime.tag = 3;
-  expirationTime.payload = { element: null };
-  var error = errorInfo.value;
-  expirationTime.callback = function() {
-    hasUncaughtError || ((hasUncaughtError = !0), (firstUncaughtError = error));
-    logError(fiber, errorInfo);
-  };
-  return expirationTime;
-}
-function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
-  expirationTime = createUpdate(expirationTime, null);
-  expirationTime.tag = 3;
-  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
-  if ("function" === typeof getDerivedStateFromError) {
-    var error = errorInfo.value;
-    expirationTime.payload = function() {
-      logError(fiber, errorInfo);
-      return getDerivedStateFromError(error);
-    };
-  }
-  var inst = fiber.stateNode;
-  null !== inst &&
-    "function" === typeof inst.componentDidCatch &&
-    (expirationTime.callback = function() {
-      "function" !== typeof getDerivedStateFromError &&
-        (null === legacyErrorBoundariesThatAlreadyFailed
-          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
-          : legacyErrorBoundariesThatAlreadyFailed.add(this),
-        logError(fiber, errorInfo));
-      var stack = errorInfo.stack;
-      this.componentDidCatch(errorInfo.value, {
-        componentStack: null !== stack ? stack : ""
-      });
-    });
-  return expirationTime;
+function isSuspenseBoundaryBeingHidden(current, finishedWork) {
+  return null !== current &&
+    ((current = current.memoizedState),
+    null === current || null !== current.dehydrated)
+    ? ((finishedWork = finishedWork.memoizedState),
+      null !== finishedWork && null === finishedWork.dehydrated)
+    : !1;
 }
 var ceil = Math.ceil,
-  ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
+  ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
-  NoContext = 0,
-  LegacyUnbatchedContext = 8,
-  RenderContext = 16,
-  CommitContext = 32,
-  RootIncomplete = 0,
-  RootFatalErrored = 1,
-  RootErrored = 2,
-  RootSuspended = 3,
-  RootSuspendedWithDelay = 4,
-  RootCompleted = 5,
-  executionContext = NoContext,
+  executionContext = 0,
   workInProgressRoot = null,
   workInProgress = null,
-  renderExpirationTime$1 = 0,
-  workInProgressRootExitStatus = RootIncomplete,
+  workInProgressRootRenderLanes = 0,
+  subtreeRenderLanes = 0,
+  subtreeRenderLanesCursor = createCursor(0),
+  workInProgressRootExitStatus = 0,
   workInProgressRootFatalError = null,
-  workInProgressRootLatestProcessedExpirationTime = 1073741823,
-  workInProgressRootLatestSuspenseTimeout = 1073741823,
+  workInProgressRootLatestSuspenseTimeout = -1,
   workInProgressRootCanSuspendUsingConfig = null,
-  workInProgressRootNextUnprocessedUpdateTime = 0,
-  workInProgressRootHasPendingPing = !1,
+  workInProgressRootIncludedLanes = 0,
+  workInProgressRootSkippedLanes = 0,
+  workInProgressRootUpdatedLanes = 0,
+  workInProgressRootPingedLanes = 0,
+  mostRecentlyUpdatedRoot = null,
   globalMostRecentFallbackTime = 0,
-  FALLBACK_THROTTLE_MS = 500,
   nextEffect = null,
   hasUncaughtError = !1,
   firstUncaughtError = null,
@@ -5593,205 +5962,200 @@ var ceil = Math.ceil,
   rootDoesHavePassiveEffects = !1,
   rootWithPendingPassiveEffects = null,
   pendingPassiveEffectsRenderPriority = 90,
+  pendingPassiveHookEffectsMount = [],
+  pendingPassiveHookEffectsUnmount = [],
   rootsWithPendingDiscreteUpdates = null,
   nestedUpdateCount = 0,
   rootWithNestedUpdates = null,
-  currentEventTime = 0;
-function requestCurrentTimeForUpdate() {
-  return (executionContext & (RenderContext | CommitContext)) !== NoContext
-    ? 1073741821 - ((now() / 10) | 0)
-    : 0 !== currentEventTime
+  currentEventTime = -1,
+  currentEventWipLanes = 0,
+  currentEventPendingLanes = 0,
+  focusedInstanceHandle = null,
+  shouldFireAfterActiveInstanceBlur = !1;
+function requestEventTime() {
+  return 0 !== (executionContext & 48)
+    ? now()
+    : -1 !== currentEventTime
     ? currentEventTime
-    : (currentEventTime = 1073741821 - ((now() / 10) | 0));
+    : (currentEventTime = now());
 }
-function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {
+function requestUpdateLane(fiber, suspenseConfig) {
   fiber = fiber.mode;
-  if (0 === (fiber & 2)) return 1073741823;
-  var priorityLevel = getCurrentPriorityLevel();
-  if (0 === (fiber & 4)) return 99 === priorityLevel ? 1073741823 : 1073741822;
-  if ((executionContext & RenderContext) !== NoContext)
-    return renderExpirationTime$1;
-  if (null !== suspenseConfig)
-    currentTime =
-      1073741821 -
-      25 *
-        ((((1073741821 -
-          currentTime +
-          (suspenseConfig.timeoutMs | 0 || 5e3) / 10) /
-          25) |
-          0) +
-          1);
-  else
-    switch (priorityLevel) {
-      case 99:
-        currentTime = 1073741823;
-        break;
-      case 98:
-        currentTime =
-          1073741821 - 10 * ((((1073741821 - currentTime + 15) / 10) | 0) + 1);
-        break;
-      case 97:
-      case 96:
-        currentTime =
-          1073741821 - 25 * ((((1073741821 - currentTime + 500) / 25) | 0) + 1);
-        break;
-      case 95:
-        currentTime = 2;
-        break;
-      default:
-        throw Error("Expected a valid priority level");
-    }
-  null !== workInProgressRoot &&
-    currentTime === renderExpirationTime$1 &&
-    --currentTime;
-  return currentTime;
-}
-function scheduleWork(fiber, expirationTime) {
+  if (0 === (fiber & 2)) return 1;
+  if (0 === (fiber & 4)) return 99 === getCurrentPriorityLevel() ? 1 : 2;
+  0 === currentEventWipLanes &&
+    (currentEventWipLanes = workInProgressRootIncludedLanes);
+  if (null !== suspenseConfig) {
+    suspenseConfig = suspenseConfig.timeoutMs;
+    fiber = void 0 === suspenseConfig || 1e4 > (suspenseConfig | 0) ? 8 : 6;
+    0 !== currentEventPendingLanes &&
+      (currentEventPendingLanes =
+        null !== mostRecentlyUpdatedRoot
+          ? mostRecentlyUpdatedRoot.pendingLanes
+          : 0);
+    suspenseConfig = currentEventWipLanes;
+    var pendingLanes = currentEventPendingLanes;
+    if (8 === fiber)
+      (fiber = pickArbitraryLane(122880 & ~pendingLanes)),
+        0 === fiber &&
+          ((fiber = pickArbitraryLane(122880 & ~suspenseConfig)),
+          0 === fiber && (fiber = 8192)),
+        (suspenseConfig = fiber);
+    else if (6 === fiber)
+      (fiber = pickArbitraryLane(3932160 & ~pendingLanes)),
+        0 === fiber &&
+          ((fiber = pickArbitraryLane(3932160 & ~suspenseConfig)),
+          0 === fiber && (fiber = 262144)),
+        (suspenseConfig = fiber);
+    else
+      throw Error(
+        "Invalid transition priority: " + fiber + ". This is a bug in React."
+      );
+    return suspenseConfig;
+  }
+  suspenseConfig = getCurrentPriorityLevel();
+  0 !== (executionContext & 4) && 98 === suspenseConfig
+    ? (suspenseConfig = findUpdateLane(14, currentEventWipLanes))
+    : ((suspenseConfig = schedulerPriorityToLanePriority(suspenseConfig)),
+      (suspenseConfig = findUpdateLane(suspenseConfig, currentEventWipLanes)));
+  return suspenseConfig;
+}
+function scheduleUpdateOnFiber(fiber, lane, eventTime) {
   if (50 < nestedUpdateCount)
     throw ((nestedUpdateCount = 0),
-    (rootWithNestedUpdates = null),
-    Error(
-      "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
-    ));
-  fiber = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
-  if (null !== fiber) {
-    var priorityLevel = getCurrentPriorityLevel();
-    1073741823 === expirationTime
-      ? (executionContext & LegacyUnbatchedContext) !== NoContext &&
-        (executionContext & (RenderContext | CommitContext)) === NoContext
-        ? performSyncWorkOnRoot(fiber)
-        : (ensureRootIsScheduled(fiber),
-          executionContext === NoContext && flushSyncCallbackQueue())
-      : ensureRootIsScheduled(fiber);
-    (executionContext & 4) === NoContext ||
-      (98 !== priorityLevel && 99 !== priorityLevel) ||
-      (null === rootsWithPendingDiscreteUpdates
-        ? (rootsWithPendingDiscreteUpdates = new Map([[fiber, expirationTime]]))
-        : ((priorityLevel = rootsWithPendingDiscreteUpdates.get(fiber)),
-          (void 0 === priorityLevel || priorityLevel > expirationTime) &&
-            rootsWithPendingDiscreteUpdates.set(fiber, expirationTime)));
-  }
-}
-function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
-  fiber.expirationTime < expirationTime &&
-    (fiber.expirationTime = expirationTime);
-  var alternate = fiber.alternate;
-  null !== alternate &&
-    alternate.expirationTime < expirationTime &&
-    (alternate.expirationTime = expirationTime);
-  var node = fiber.return,
-    root = null;
-  if (null === node && 3 === fiber.tag) root = fiber.stateNode;
-  else
-    for (; null !== node; ) {
-      alternate = node.alternate;
-      node.childExpirationTime < expirationTime &&
-        (node.childExpirationTime = expirationTime);
-      null !== alternate &&
-        alternate.childExpirationTime < expirationTime &&
-        (alternate.childExpirationTime = expirationTime);
-      if (null === node.return && 3 === node.tag) {
-        root = node.stateNode;
-        break;
+    (rootWithNestedUpdates = null),
+    Error(
+      "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
+    ));
+  fiber = markUpdateLaneFromFiberToRoot(fiber, lane);
+  if (null === fiber) return null;
+  markRootUpdated(fiber, lane, eventTime);
+  fiber === workInProgressRoot &&
+    ((workInProgressRootUpdatedLanes |= lane),
+    4 === workInProgressRootExitStatus &&
+      markRootSuspended$1(fiber, workInProgressRootRenderLanes));
+  var priorityLevel = getCurrentPriorityLevel();
+  1 === lane
+    ? 0 !== (executionContext & 8) && 0 === (executionContext & 48)
+      ? performSyncWorkOnRoot(fiber)
+      : (ensureRootIsScheduled(fiber, eventTime),
+        0 === executionContext && flushSyncCallbackQueue())
+    : (0 === (executionContext & 4) ||
+        (98 !== priorityLevel && 99 !== priorityLevel) ||
+        (null === rootsWithPendingDiscreteUpdates
+          ? (rootsWithPendingDiscreteUpdates = new Set([fiber]))
+          : rootsWithPendingDiscreteUpdates.add(fiber)),
+      ensureRootIsScheduled(fiber, eventTime));
+  mostRecentlyUpdatedRoot = fiber;
+}
+function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
+  sourceFiber.lanes |= lane;
+  var alternate = sourceFiber.alternate;
+  null !== alternate && (alternate.lanes |= lane);
+  alternate = sourceFiber;
+  for (sourceFiber = sourceFiber.return; null !== sourceFiber; )
+    (sourceFiber.childLanes |= lane),
+      (alternate = sourceFiber.alternate),
+      null !== alternate && (alternate.childLanes |= lane),
+      (alternate = sourceFiber),
+      (sourceFiber = sourceFiber.return);
+  return 3 === alternate.tag ? alternate.stateNode : null;
+}
+function ensureRootIsScheduled(root, currentTime) {
+  for (
+    var existingCallbackNode = root.callbackNode,
+      suspendedLanes = root.suspendedLanes,
+      pingedLanes = root.pingedLanes,
+      expirationTimes = root.expirationTimes,
+      lanes = root.pendingLanes;
+    0 < lanes;
+
+  ) {
+    var index$7 = 31 - clz32(lanes),
+      lane = 1 << index$7,
+      expirationTime = expirationTimes[index$7];
+    if (-1 === expirationTime) {
+      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) {
+        expirationTime = currentTime;
+        getHighestPriorityLanes(lane);
+        var priority = return_highestLanePriority;
+        expirationTimes[index$7] =
+          12 <= priority
+            ? expirationTime + 1e3
+            : 6 <= priority
+            ? expirationTime + 5e3
+            : -1;
       }
-      node = node.return;
-    }
-  null !== root &&
-    (workInProgressRoot === root &&
-      (markUnprocessedUpdateTime(expirationTime),
-      workInProgressRootExitStatus === RootSuspendedWithDelay &&
-        markRootSuspendedAtTime(root, renderExpirationTime$1)),
-    markRootUpdatedAtTime(root, expirationTime));
-  return root;
-}
-function getNextRootExpirationTimeToWorkOn(root) {
-  var lastExpiredTime = root.lastExpiredTime;
-  if (0 !== lastExpiredTime) return lastExpiredTime;
-  lastExpiredTime = root.firstPendingTime;
-  if (!isRootSuspendedAtTime(root, lastExpiredTime)) return lastExpiredTime;
-  var lastPingedTime = root.lastPingedTime;
-  root = root.nextKnownPendingLevel;
-  root = lastPingedTime > root ? lastPingedTime : root;
-  return 2 >= root && lastExpiredTime !== root ? 0 : root;
-}
-function ensureRootIsScheduled(root) {
-  if (0 !== root.lastExpiredTime)
-    (root.callbackExpirationTime = 1073741823),
-      (root.callbackPriority = 99),
-      (root.callbackNode = scheduleSyncCallback(
-        performSyncWorkOnRoot.bind(null, root)
-      ));
+    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
+    lanes &= ~lane;
+  }
+  suspendedLanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
+  );
+  currentTime = return_highestLanePriority;
+  if (0 === suspendedLanes)
+    null !== existingCallbackNode &&
+      (existingCallbackNode !== fakeCallbackNode &&
+        Scheduler_cancelCallback(existingCallbackNode),
+      (root.callbackNode = null),
+      (root.callbackPriority = 0));
   else {
-    var expirationTime = getNextRootExpirationTimeToWorkOn(root),
-      existingCallbackNode = root.callbackNode;
-    if (0 === expirationTime)
-      null !== existingCallbackNode &&
-        ((root.callbackNode = null),
-        (root.callbackExpirationTime = 0),
-        (root.callbackPriority = 90));
-    else {
-      var priorityLevel = requestCurrentTimeForUpdate();
-      1073741823 === expirationTime
-        ? (priorityLevel = 99)
-        : 1 === expirationTime || 2 === expirationTime
-        ? (priorityLevel = 95)
-        : ((priorityLevel =
-            10 * (1073741821 - expirationTime) -
-            10 * (1073741821 - priorityLevel)),
-          (priorityLevel =
-            0 >= priorityLevel
-              ? 99
-              : 250 >= priorityLevel
-              ? 98
-              : 5250 >= priorityLevel
-              ? 97
-              : 95));
-      if (null !== existingCallbackNode) {
-        var existingCallbackPriority = root.callbackPriority;
-        if (
-          root.callbackExpirationTime === expirationTime &&
-          existingCallbackPriority >= priorityLevel
-        )
-          return;
-        existingCallbackNode !== fakeCallbackNode &&
-          Scheduler_cancelCallback(existingCallbackNode);
-      }
-      root.callbackExpirationTime = expirationTime;
-      root.callbackPriority = priorityLevel;
-      expirationTime =
-        1073741823 === expirationTime
-          ? scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root))
-          : scheduleCallback(
-              priorityLevel,
-              performConcurrentWorkOnRoot.bind(null, root),
-              { timeout: 10 * (1073741821 - expirationTime) - now() }
-            );
-      root.callbackNode = expirationTime;
+    if (null !== existingCallbackNode) {
+      if (root.callbackPriority === currentTime) return;
+      existingCallbackNode !== fakeCallbackNode &&
+        Scheduler_cancelCallback(existingCallbackNode);
     }
+    17 === currentTime
+      ? ((existingCallbackNode = performSyncWorkOnRoot.bind(null, root)),
+        null === syncQueue
+          ? ((syncQueue = [existingCallbackNode]),
+            (immediateQueueCallbackNode = Scheduler_scheduleCallback(
+              Scheduler_ImmediatePriority,
+              flushSyncCallbackQueueImpl
+            )))
+          : syncQueue.push(existingCallbackNode),
+        (existingCallbackNode = fakeCallbackNode))
+      : 16 === currentTime
+      ? (existingCallbackNode = scheduleCallback(
+          99,
+          performSyncWorkOnRoot.bind(null, root)
+        ))
+      : ((existingCallbackNode = lanePriorityToSchedulerPriority(currentTime)),
+        (existingCallbackNode = scheduleCallback(
+          existingCallbackNode,
+          performConcurrentWorkOnRoot.bind(null, root)
+        )));
+    root.callbackPriority = currentTime;
+    root.callbackNode = existingCallbackNode;
   }
 }
 function performConcurrentWorkOnRoot(root, didTimeout) {
-  currentEventTime = 0;
-  if (didTimeout) {
-    didTimeout = requestCurrentTimeForUpdate();
-    var lastExpiredTime = root.lastExpiredTime;
-    if (0 === lastExpiredTime || lastExpiredTime > didTimeout)
-      root.lastExpiredTime = didTimeout;
-    ensureRootIsScheduled(root);
-    return null;
-  }
-  lastExpiredTime = getNextRootExpirationTimeToWorkOn(root);
-  if (0 === lastExpiredTime) return null;
-  didTimeout = root.callbackNode;
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+  currentEventTime = -1;
+  currentEventPendingLanes = currentEventWipLanes = 0;
+  if (0 !== (executionContext & 48))
     throw Error("Should not already be working.");
-  flushPassiveEffects();
-  var expirationTime = lastExpiredTime;
-  var exitStatus = executionContext;
-  executionContext |= RenderContext;
+  var originalCallbackNode = root.callbackNode;
+  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
+    return null;
+  var lanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
+  );
+  if (0 === lanes) return null;
+  if (didTimeout)
+    return (
+      (root.expiredLanes |= lanes & root.pendingLanes),
+      ensureRootIsScheduled(root, now()),
+      null
+    );
+  didTimeout = lanes;
+  var prevExecutionContext = executionContext;
+  executionContext |= 16;
   var prevDispatcher = pushDispatcher();
-  (root === workInProgressRoot && expirationTime === renderExpirationTime$1) ||
-    prepareFreshStack(root, expirationTime);
+  (workInProgressRoot === root &&
+    workInProgressRootRenderLanes === didTimeout) ||
+    prepareFreshStack(root, didTimeout);
   do
     try {
       workLoopConcurrent();
@@ -5801,156 +6165,120 @@ function performConcurrentWorkOnRoot(root, didTimeout) {
     }
   while (1);
   resetContextDependencies();
-  ReactCurrentDispatcher$1.current = prevDispatcher;
-  executionContext = exitStatus;
+  ReactCurrentDispatcher$2.current = prevDispatcher;
+  executionContext = prevExecutionContext;
   null !== workInProgress
-    ? (exitStatus = RootIncomplete)
+    ? (didTimeout = 0)
     : ((workInProgressRoot = null),
-      (exitStatus = workInProgressRootExitStatus));
-  if (exitStatus !== RootIncomplete) {
-    exitStatus === RootErrored &&
-      ((lastExpiredTime = 2 < lastExpiredTime ? 2 : lastExpiredTime),
-      (exitStatus = renderRootSync(root, lastExpiredTime)));
-    if (exitStatus === RootFatalErrored)
-      throw ((didTimeout = workInProgressRootFatalError),
-      prepareFreshStack(root, lastExpiredTime),
-      markRootSuspendedAtTime(root, lastExpiredTime),
-      ensureRootIsScheduled(root),
-      didTimeout);
-    expirationTime = root.finishedWork = root.current.alternate;
-    root.finishedExpirationTime = lastExpiredTime;
-    switch (exitStatus) {
-      case RootIncomplete:
-      case RootFatalErrored:
+      (workInProgressRootRenderLanes = 0),
+      (didTimeout = workInProgressRootExitStatus));
+  if (0 !== (workInProgressRootIncludedLanes & workInProgressRootUpdatedLanes))
+    prepareFreshStack(root, 0);
+  else if (0 !== didTimeout) {
+    2 === didTimeout &&
+      ((executionContext |= 64),
+      root.hydrate && (root.hydrate = !1),
+      (lanes = getLanesToRetrySynchronouslyOnError(root)),
+      0 !== lanes && (didTimeout = renderRootSync(root, lanes)));
+    if (1 === didTimeout)
+      throw ((originalCallbackNode = workInProgressRootFatalError),
+      prepareFreshStack(root, 0),
+      markRootSuspended$1(root, lanes),
+      ensureRootIsScheduled(root, now()),
+      originalCallbackNode);
+    root.finishedWork = root.current.alternate;
+    root.finishedLanes = lanes;
+    switch (didTimeout) {
+      case 0:
+      case 1:
         throw Error("Root did not complete. This is a bug in React.");
-      case RootErrored:
+      case 2:
         commitRoot(root);
         break;
-      case RootSuspended:
-        markRootSuspendedAtTime(root, lastExpiredTime);
-        exitStatus = root.lastSuspendedTime;
-        lastExpiredTime === exitStatus &&
-          (root.nextKnownPendingLevel = getRemainingExpirationTime(
-            expirationTime
-          ));
+      case 3:
+        markRootSuspended$1(root, lanes);
         if (
-          1073741823 === workInProgressRootLatestProcessedExpirationTime &&
-          ((expirationTime =
-            globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now()),
-          10 < expirationTime)
+          (lanes & 62914560) === lanes &&
+          ((didTimeout = globalMostRecentFallbackTime + 500 - now()),
+          10 < didTimeout)
         ) {
-          if (
-            workInProgressRootHasPendingPing &&
-            ((prevDispatcher = root.lastPingedTime),
-            0 === prevDispatcher || prevDispatcher >= lastExpiredTime)
-          ) {
-            root.lastPingedTime = lastExpiredTime;
-            prepareFreshStack(root, lastExpiredTime);
-            break;
-          }
-          prevDispatcher = getNextRootExpirationTimeToWorkOn(root);
-          if (0 !== prevDispatcher && prevDispatcher !== lastExpiredTime) break;
-          if (0 !== exitStatus && exitStatus !== lastExpiredTime) {
-            root.lastPingedTime = exitStatus;
+          if (0 !== getNextLanes(root, 0)) break;
+          prevExecutionContext = root.suspendedLanes;
+          if ((prevExecutionContext & lanes) !== lanes) {
+            requestEventTime();
+            root.pingedLanes |= root.suspendedLanes & prevExecutionContext;
             break;
           }
           root.timeoutHandle = scheduleTimeout(
             commitRoot.bind(null, root),
-            expirationTime
+            didTimeout
           );
           break;
         }
         commitRoot(root);
         break;
-      case RootSuspendedWithDelay:
-        markRootSuspendedAtTime(root, lastExpiredTime);
-        exitStatus = root.lastSuspendedTime;
-        lastExpiredTime === exitStatus &&
-          (root.nextKnownPendingLevel = getRemainingExpirationTime(
-            expirationTime
-          ));
-        if (
-          workInProgressRootHasPendingPing &&
-          ((expirationTime = root.lastPingedTime),
-          0 === expirationTime || expirationTime >= lastExpiredTime)
-        ) {
-          root.lastPingedTime = lastExpiredTime;
-          prepareFreshStack(root, lastExpiredTime);
-          break;
-        }
-        expirationTime = getNextRootExpirationTimeToWorkOn(root);
-        if (0 !== expirationTime && expirationTime !== lastExpiredTime) break;
-        if (0 !== exitStatus && exitStatus !== lastExpiredTime) {
-          root.lastPingedTime = exitStatus;
+      case 4:
+        markRootSuspended$1(root, lanes);
+        if (0 !== getNextLanes(root, 0)) break;
+        didTimeout = root.suspendedLanes;
+        if ((didTimeout & lanes) !== lanes) {
+          requestEventTime();
+          root.pingedLanes |= root.suspendedLanes & didTimeout;
           break;
         }
-        1073741823 !== workInProgressRootLatestSuspenseTimeout
-          ? (expirationTime =
-              10 * (1073741821 - workInProgressRootLatestSuspenseTimeout) -
-              now())
-          : 1073741823 === workInProgressRootLatestProcessedExpirationTime
-          ? (expirationTime = 0)
-          : ((expirationTime =
-              10 *
-                (1073741821 - workInProgressRootLatestProcessedExpirationTime) -
-              5e3),
-            (exitStatus = now()),
-            (lastExpiredTime =
-              10 * (1073741821 - lastExpiredTime) - exitStatus),
-            (expirationTime = exitStatus - expirationTime),
-            0 > expirationTime && (expirationTime = 0),
-            (expirationTime =
-              (120 > expirationTime
+        lanes = getMostRecentEventTime(root, lanes);
+        -1 !== workInProgressRootLatestSuspenseTimeout
+          ? (lanes = workInProgressRootLatestSuspenseTimeout - now())
+          : -1 === lanes
+          ? (lanes = 0)
+          : ((lanes = now() - lanes),
+            (lanes =
+              (120 > lanes
                 ? 120
-                : 480 > expirationTime
+                : 480 > lanes
                 ? 480
-                : 1080 > expirationTime
+                : 1080 > lanes
                 ? 1080
-                : 1920 > expirationTime
+                : 1920 > lanes
                 ? 1920
-                : 3e3 > expirationTime
+                : 3e3 > lanes
                 ? 3e3
-                : 4320 > expirationTime
+                : 4320 > lanes
                 ? 4320
-                : 1960 * ceil(expirationTime / 1960)) - expirationTime),
-            lastExpiredTime < expirationTime &&
-              (expirationTime = lastExpiredTime));
-        if (10 < expirationTime) {
+                : 1960 * ceil(lanes / 1960)) - lanes));
+        if (10 < lanes) {
           root.timeoutHandle = scheduleTimeout(
             commitRoot.bind(null, root),
-            expirationTime
+            lanes
           );
           break;
         }
         commitRoot(root);
         break;
-      case RootCompleted:
+      case 5:
+        prevDispatcher = getMostRecentEventTime(root, lanes);
         if (
-          1073741823 !== workInProgressRootLatestProcessedExpirationTime &&
-          null !== workInProgressRootCanSuspendUsingConfig
-        ) {
-          prevDispatcher = workInProgressRootLatestProcessedExpirationTime;
-          var suspenseConfig = workInProgressRootCanSuspendUsingConfig;
-          expirationTime = suspenseConfig.busyMinDurationMs | 0;
-          0 >= expirationTime
-            ? (expirationTime = 0)
-            : ((exitStatus = suspenseConfig.busyDelayMs | 0),
-              (prevDispatcher =
-                now() -
-                (10 * (1073741821 - prevDispatcher) -
-                  (suspenseConfig.timeoutMs | 0 || 5e3))),
-              (expirationTime =
-                prevDispatcher <= exitStatus
+          -1 !== prevDispatcher &&
+          null !== workInProgressRootCanSuspendUsingConfig &&
+          ((didTimeout =
+            workInProgressRootCanSuspendUsingConfig.busyMinDurationMs | 0),
+          0 >= didTimeout
+            ? (didTimeout = 0)
+            : ((prevExecutionContext =
+                workInProgressRootCanSuspendUsingConfig.busyDelayMs | 0),
+              (prevDispatcher = now() - prevDispatcher),
+              (didTimeout =
+                prevDispatcher <= prevExecutionContext
                   ? 0
-                  : exitStatus + expirationTime - prevDispatcher));
-          if (10 < expirationTime) {
-            markRootSuspendedAtTime(root, lastExpiredTime);
-            root.timeoutHandle = scheduleTimeout(
-              commitRoot.bind(null, root),
-              expirationTime
-            );
-            break;
-          }
+                  : prevExecutionContext + didTimeout - prevDispatcher)),
+          10 < didTimeout)
+        ) {
+          markRootSuspended$1(root, lanes);
+          root.timeoutHandle = scheduleTimeout(
+            commitRoot.bind(null, root),
+            didTimeout
+          );
+          break;
         }
         commitRoot(root);
         break;
@@ -5958,42 +6286,68 @@ function performConcurrentWorkOnRoot(root, didTimeout) {
         throw Error("Unknown root exit status.");
     }
   }
-  ensureRootIsScheduled(root);
-  return root.callbackNode === didTimeout
+  ensureRootIsScheduled(root, now());
+  return root.callbackNode === originalCallbackNode
     ? performConcurrentWorkOnRoot.bind(null, root)
     : null;
 }
+function markRootSuspended$1(root, suspendedLanes) {
+  suspendedLanes &= ~workInProgressRootPingedLanes;
+  suspendedLanes &= ~workInProgressRootUpdatedLanes;
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+  for (root = root.expirationTimes; 0 < suspendedLanes; ) {
+    var index$12 = 31 - clz32(suspendedLanes),
+      lane = 1 << index$12;
+    root[index$12] = -1;
+    suspendedLanes &= ~lane;
+  }
+}
 function performSyncWorkOnRoot(root) {
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+  if (0 !== (executionContext & 48))
     throw Error("Should not already be working.");
   flushPassiveEffects();
-  var lastExpiredTime = root.lastExpiredTime;
-  lastExpiredTime =
-    0 !== lastExpiredTime
-      ? root === workInProgressRoot && renderExpirationTime$1 >= lastExpiredTime
-        ? renderExpirationTime$1
-        : lastExpiredTime
-      : 1073741823;
-  var exitStatus = renderRootSync(root, lastExpiredTime);
+  if (
+    root === workInProgressRoot &&
+    0 !== (root.expiredLanes & workInProgressRootRenderLanes)
+  ) {
+    var lanes = workInProgressRootRenderLanes;
+    var exitStatus = renderRootSync(root, lanes);
+    0 !== (workInProgressRootIncludedLanes & workInProgressRootUpdatedLanes) &&
+      ((lanes = getNextLanes(root, lanes)),
+      (exitStatus = renderRootSync(root, lanes)));
+  } else
+    (lanes = getNextLanes(root, 0)), (exitStatus = renderRootSync(root, lanes));
   0 !== root.tag &&
-    exitStatus === RootErrored &&
-    ((lastExpiredTime = 2 < lastExpiredTime ? 2 : lastExpiredTime),
-    (exitStatus = renderRootSync(root, lastExpiredTime)));
-  if (exitStatus === RootFatalErrored)
+    2 === exitStatus &&
+    ((executionContext |= 64),
+    root.hydrate && (root.hydrate = !1),
+    (lanes = getLanesToRetrySynchronouslyOnError(root)),
+    0 !== lanes && (exitStatus = renderRootSync(root, lanes)));
+  if (1 === exitStatus)
     throw ((exitStatus = workInProgressRootFatalError),
-    prepareFreshStack(root, lastExpiredTime),
-    markRootSuspendedAtTime(root, lastExpiredTime),
-    ensureRootIsScheduled(root),
+    prepareFreshStack(root, 0),
+    markRootSuspended$1(root, lanes),
+    ensureRootIsScheduled(root, now()),
     exitStatus);
   root.finishedWork = root.current.alternate;
-  root.finishedExpirationTime = lastExpiredTime;
+  root.finishedLanes = lanes;
   commitRoot(root);
-  ensureRootIsScheduled(root);
+  ensureRootIsScheduled(root, now());
   return null;
 }
-function prepareFreshStack(root, expirationTime) {
+function pushRenderLanes(fiber, lanes) {
+  push(subtreeRenderLanesCursor, subtreeRenderLanes);
+  subtreeRenderLanes |= lanes;
+  workInProgressRootIncludedLanes |= lanes;
+}
+function popRenderLanes() {
+  subtreeRenderLanes = subtreeRenderLanesCursor.current;
+  pop(subtreeRenderLanesCursor);
+}
+function prepareFreshStack(root, lanes) {
   root.finishedWork = null;
-  root.finishedExpirationTime = 0;
+  root.finishedLanes = 0;
   var timeoutHandle = root.timeoutHandle;
   -1 !== timeoutHandle &&
     ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
@@ -6011,6 +6365,7 @@ function prepareFreshStack(root, expirationTime) {
           popHostContainer();
           pop(didPerformWorkStackCursor);
           pop(contextStackCursor);
+          resetWorkInProgressVersions();
           break;
         case 5:
           popHostContext(interruptedWork);
@@ -6026,25 +6381,29 @@ function prepareFreshStack(root, expirationTime) {
           break;
         case 10:
           popProvider(interruptedWork);
+          break;
+        case 23:
+        case 24:
+          popRenderLanes();
       }
       timeoutHandle = timeoutHandle.return;
     }
   workInProgressRoot = root;
   workInProgress = createWorkInProgress(root.current, null);
-  renderExpirationTime$1 = expirationTime;
-  workInProgressRootExitStatus = RootIncomplete;
+  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
+  workInProgressRootExitStatus = 0;
   workInProgressRootFatalError = null;
-  workInProgressRootLatestSuspenseTimeout = workInProgressRootLatestProcessedExpirationTime = 1073741823;
+  workInProgressRootLatestSuspenseTimeout = -1;
   workInProgressRootCanSuspendUsingConfig = null;
-  workInProgressRootNextUnprocessedUpdateTime = 0;
-  workInProgressRootHasPendingPing = !1;
+  workInProgressRootPingedLanes = workInProgressRootUpdatedLanes = workInProgressRootSkippedLanes = 0;
 }
 function handleError(root$jscomp$0, thrownValue) {
   do {
+    var erroredWork = workInProgress;
     try {
       resetContextDependencies();
-      ReactCurrentDispatcher.current = ContextOnlyDispatcher;
-      if (didScheduleRenderPhaseUpdate)
+      ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+      if (didScheduleRenderPhaseUpdate) {
         for (
           var hook = currentlyRenderingFiber$1.memoizedState;
           null !== hook;
@@ -6054,21 +6413,24 @@ function handleError(root$jscomp$0, thrownValue) {
           null !== queue && (queue.pending = null);
           hook = hook.next;
         }
-      renderExpirationTime = 0;
+        didScheduleRenderPhaseUpdate = !1;
+      }
+      renderLanes = 0;
       workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
-      didScheduleRenderPhaseUpdate = !1;
-      if (null === workInProgress || null === workInProgress.return)
-        return (
-          (workInProgressRootExitStatus = RootFatalErrored),
-          (workInProgressRootFatalError = thrownValue),
-          (workInProgress = null)
-        );
+      didScheduleRenderPhaseUpdateDuringThisPass = !1;
+      ReactCurrentOwner$2.current = null;
+      if (null === erroredWork || null === erroredWork.return) {
+        workInProgressRootExitStatus = 1;
+        workInProgressRootFatalError = thrownValue;
+        workInProgress = null;
+        break;
+      }
       a: {
         var root = root$jscomp$0,
-          returnFiber = workInProgress.return,
-          sourceFiber = workInProgress,
+          returnFiber = erroredWork.return,
+          sourceFiber = erroredWork,
           value = thrownValue;
-        thrownValue = renderExpirationTime$1;
+        thrownValue = workInProgressRootRenderLanes;
         sourceFiber.effectTag |= 2048;
         sourceFiber.firstEffect = sourceFiber.lastEffect = null;
         if (
@@ -6076,27 +6438,27 @@ function handleError(root$jscomp$0, thrownValue) {
           "object" === typeof value &&
           "function" === typeof value.then
         ) {
-          var thenable = value;
+          var wakeable = value;
           if (0 === (sourceFiber.mode & 2)) {
             var currentSource = sourceFiber.alternate;
             currentSource
               ? ((sourceFiber.updateQueue = currentSource.updateQueue),
                 (sourceFiber.memoizedState = currentSource.memoizedState),
-                (sourceFiber.expirationTime = currentSource.expirationTime))
+                (sourceFiber.lanes = currentSource.lanes))
               : ((sourceFiber.updateQueue = null),
                 (sourceFiber.memoizedState = null));
           }
           var hasInvisibleParentBoundary =
               0 !== (suspenseStackCursor.current & 1),
-            _workInProgress = returnFiber;
+            workInProgress$76 = returnFiber;
           do {
             var JSCompiler_temp;
-            if ((JSCompiler_temp = 13 === _workInProgress.tag)) {
-              var nextState = _workInProgress.memoizedState;
+            if ((JSCompiler_temp = 13 === workInProgress$76.tag)) {
+              var nextState = workInProgress$76.memoizedState;
               if (null !== nextState)
                 JSCompiler_temp = null !== nextState.dehydrated ? !0 : !1;
               else {
-                var props = _workInProgress.memoizedProps;
+                var props = workInProgress$76.memoizedProps;
                 JSCompiler_temp =
                   void 0 === props.fallback
                     ? !1
@@ -6108,23 +6470,24 @@ function handleError(root$jscomp$0, thrownValue) {
               }
             }
             if (JSCompiler_temp) {
-              var thenables = _workInProgress.updateQueue;
-              if (null === thenables) {
+              var wakeables = workInProgress$76.updateQueue;
+              if (null === wakeables) {
                 var updateQueue = new Set();
-                updateQueue.add(thenable);
-                _workInProgress.updateQueue = updateQueue;
-              } else thenables.add(thenable);
-              if (0 === (_workInProgress.mode & 2)) {
-                _workInProgress.effectTag |= 64;
+                updateQueue.add(wakeable);
+                workInProgress$76.updateQueue = updateQueue;
+              } else wakeables.add(wakeable);
+              if (0 === (workInProgress$76.mode & 2)) {
+                workInProgress$76.effectTag |= 64;
+                sourceFiber.effectTag |= 16384;
                 sourceFiber.effectTag &= -2981;
                 if (1 === sourceFiber.tag)
                   if (null === sourceFiber.alternate) sourceFiber.tag = 17;
                   else {
-                    var update = createUpdate(1073741823, null);
+                    var update = createUpdate(-1, 1, null);
                     update.tag = 2;
                     enqueueUpdate(sourceFiber, update);
                   }
-                sourceFiber.expirationTime = 1073741823;
+                sourceFiber.lanes |= 1;
                 break a;
               }
               value = void 0;
@@ -6133,108 +6496,105 @@ function handleError(root$jscomp$0, thrownValue) {
               null === pingCache
                 ? ((pingCache = root.pingCache = new PossiblyWeakMap()),
                   (value = new Set()),
-                  pingCache.set(thenable, value))
-                : ((value = pingCache.get(thenable)),
+                  pingCache.set(wakeable, value))
+                : ((value = pingCache.get(wakeable)),
                   void 0 === value &&
-                    ((value = new Set()), pingCache.set(thenable, value)));
+                    ((value = new Set()), pingCache.set(wakeable, value)));
               if (!value.has(sourceFiber)) {
                 value.add(sourceFiber);
                 var ping = pingSuspendedRoot.bind(
                   null,
                   root,
-                  thenable,
+                  wakeable,
                   sourceFiber
                 );
-                thenable.then(ping, ping);
+                wakeable.then(ping, ping);
               }
-              _workInProgress.effectTag |= 4096;
-              _workInProgress.expirationTime = thrownValue;
+              workInProgress$76.effectTag |= 4096;
+              workInProgress$76.lanes = thrownValue;
               break a;
             }
-            _workInProgress = _workInProgress.return;
-          } while (null !== _workInProgress);
+            workInProgress$76 = workInProgress$76.return;
+          } while (null !== workInProgress$76);
           value = Error(
             (getComponentName(sourceFiber.type) || "A React component") +
-              " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." +
-              getStackByFiberInDevAndProd(sourceFiber)
+              " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."
           );
         }
-        workInProgressRootExitStatus !== RootCompleted &&
-          (workInProgressRootExitStatus = RootErrored);
+        5 !== workInProgressRootExitStatus &&
+          (workInProgressRootExitStatus = 2);
         value = createCapturedValue(value, sourceFiber);
-        _workInProgress = returnFiber;
+        workInProgress$76 = returnFiber;
         do {
-          switch (_workInProgress.tag) {
+          switch (workInProgress$76.tag) {
             case 3:
-              thenable = value;
-              _workInProgress.effectTag |= 4096;
-              _workInProgress.expirationTime = thrownValue;
-              var _update = createRootErrorUpdate(
-                _workInProgress,
-                thenable,
+              root = value;
+              workInProgress$76.effectTag |= 4096;
+              thrownValue &= -thrownValue;
+              workInProgress$76.lanes |= thrownValue;
+              var update$77 = createRootErrorUpdate(
+                workInProgress$76,
+                root,
                 thrownValue
               );
-              enqueueCapturedUpdate(_workInProgress, _update);
+              enqueueCapturedUpdate(workInProgress$76, update$77);
               break a;
             case 1:
-              thenable = value;
-              var ctor = _workInProgress.type,
-                instance = _workInProgress.stateNode;
+              root = value;
+              var ctor = workInProgress$76.type,
+                instance = workInProgress$76.stateNode;
               if (
-                0 === (_workInProgress.effectTag & 64) &&
+                0 === (workInProgress$76.effectTag & 64) &&
                 ("function" === typeof ctor.getDerivedStateFromError ||
                   (null !== instance &&
                     "function" === typeof instance.componentDidCatch &&
                     (null === legacyErrorBoundariesThatAlreadyFailed ||
                       !legacyErrorBoundariesThatAlreadyFailed.has(instance))))
               ) {
-                _workInProgress.effectTag |= 4096;
-                _workInProgress.expirationTime = thrownValue;
-                var _update2 = createClassErrorUpdate(
-                  _workInProgress,
-                  thenable,
+                workInProgress$76.effectTag |= 4096;
+                thrownValue &= -thrownValue;
+                workInProgress$76.lanes |= thrownValue;
+                var update$80 = createClassErrorUpdate(
+                  workInProgress$76,
+                  root,
                   thrownValue
                 );
-                enqueueCapturedUpdate(_workInProgress, _update2);
+                enqueueCapturedUpdate(workInProgress$76, update$80);
                 break a;
               }
           }
-          _workInProgress = _workInProgress.return;
-        } while (null !== _workInProgress);
+          workInProgress$76 = workInProgress$76.return;
+        } while (null !== workInProgress$76);
       }
-      workInProgress = completeUnitOfWork(workInProgress);
+      completeUnitOfWork(erroredWork);
     } catch (yetAnotherThrownValue) {
       thrownValue = yetAnotherThrownValue;
+      workInProgress === erroredWork &&
+        null !== erroredWork &&
+        (workInProgress = erroredWork = erroredWork.return);
       continue;
     }
     break;
   } while (1);
 }
 function pushDispatcher() {
-  var prevDispatcher = ReactCurrentDispatcher$1.current;
-  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+  var prevDispatcher = ReactCurrentDispatcher$2.current;
+  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
   return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
 }
-function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {
-  expirationTime < workInProgressRootLatestProcessedExpirationTime &&
-    2 < expirationTime &&
-    (workInProgressRootLatestProcessedExpirationTime = expirationTime);
+function markRenderEventTimeAndConfig(eventTime, suspenseConfig) {
   null !== suspenseConfig &&
-    expirationTime < workInProgressRootLatestSuspenseTimeout &&
-    2 < expirationTime &&
-    ((workInProgressRootLatestSuspenseTimeout = expirationTime),
-    (workInProgressRootCanSuspendUsingConfig = suspenseConfig));
-}
-function markUnprocessedUpdateTime(expirationTime) {
-  expirationTime > workInProgressRootNextUnprocessedUpdateTime &&
-    (workInProgressRootNextUnprocessedUpdateTime = expirationTime);
+    ((eventTime += suspenseConfig.timeoutMs | 0 || 5e3),
+    eventTime > workInProgressRootLatestSuspenseTimeout &&
+      ((workInProgressRootLatestSuspenseTimeout = eventTime),
+      (workInProgressRootCanSuspendUsingConfig = suspenseConfig)));
 }
-function renderRootSync(root, expirationTime) {
+function renderRootSync(root, lanes) {
   var prevExecutionContext = executionContext;
-  executionContext |= RenderContext;
+  executionContext |= 16;
   var prevDispatcher = pushDispatcher();
-  (root === workInProgressRoot && expirationTime === renderExpirationTime$1) ||
-    prepareFreshStack(root, expirationTime);
+  (workInProgressRoot === root && workInProgressRootRenderLanes === lanes) ||
+    prepareFreshStack(root, lanes);
   do
     try {
       workLoopSync();
@@ -6245,142 +6605,144 @@ function renderRootSync(root, expirationTime) {
   while (1);
   resetContextDependencies();
   executionContext = prevExecutionContext;
-  ReactCurrentDispatcher$1.current = prevDispatcher;
+  ReactCurrentDispatcher$2.current = prevDispatcher;
   if (null !== workInProgress)
     throw Error(
       "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
     );
   workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
   return workInProgressRootExitStatus;
 }
 function workLoopSync() {
-  for (; null !== workInProgress; )
-    workInProgress = performUnitOfWork(workInProgress);
+  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
 }
 function workLoopConcurrent() {
-  for (; null !== workInProgress && !shouldYield(); )
-    workInProgress = performUnitOfWork(workInProgress);
+  for (; null !== workInProgress && !Scheduler_shouldYield(); )
+    performUnitOfWork(workInProgress);
 }
 function performUnitOfWork(unitOfWork) {
-  var next = beginWork$1(
-    unitOfWork.alternate,
-    unitOfWork,
-    renderExpirationTime$1
-  );
+  var next = beginWork$1(unitOfWork.alternate, unitOfWork, subtreeRenderLanes);
   unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === next && (next = completeUnitOfWork(unitOfWork));
+  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
   ReactCurrentOwner$2.current = null;
-  return next;
 }
 function completeUnitOfWork(unitOfWork) {
-  workInProgress = unitOfWork;
+  var completedWork = unitOfWork;
   do {
-    var current = workInProgress.alternate;
-    unitOfWork = workInProgress.return;
-    if (0 === (workInProgress.effectTag & 2048)) {
-      current = completeWork(current, workInProgress, renderExpirationTime$1);
+    var current = completedWork.alternate;
+    unitOfWork = completedWork.return;
+    if (0 === (completedWork.effectTag & 2048)) {
+      current = completeWork(current, completedWork, subtreeRenderLanes);
+      if (null !== current) {
+        workInProgress = current;
+        return;
+      }
+      current = completedWork;
       if (
-        1 === renderExpirationTime$1 ||
-        1 !== workInProgress.childExpirationTime
+        (24 !== current.tag && 23 !== current.tag) ||
+        null === current.memoizedState ||
+        0 !== (subtreeRenderLanes & 1073741824) ||
+        0 === (current.mode & 4)
       ) {
-        for (
-          var newChildExpirationTime = 0, _child = workInProgress.child;
-          null !== _child;
-
-        ) {
-          var _childUpdateExpirationTime = _child.expirationTime,
-            _childChildExpirationTime = _child.childExpirationTime;
-          _childUpdateExpirationTime > newChildExpirationTime &&
-            (newChildExpirationTime = _childUpdateExpirationTime);
-          _childChildExpirationTime > newChildExpirationTime &&
-            (newChildExpirationTime = _childChildExpirationTime);
-          _child = _child.sibling;
-        }
-        workInProgress.childExpirationTime = newChildExpirationTime;
+        for (var newChildLanes = 0, child = current.child; null !== child; )
+          (newChildLanes |= child.lanes | child.childLanes),
+            (child = child.sibling);
+        current.childLanes = newChildLanes;
       }
-      if (null !== current) return current;
       null !== unitOfWork &&
         0 === (unitOfWork.effectTag & 2048) &&
         (null === unitOfWork.firstEffect &&
-          (unitOfWork.firstEffect = workInProgress.firstEffect),
-        null !== workInProgress.lastEffect &&
+          (unitOfWork.firstEffect = completedWork.firstEffect),
+        null !== completedWork.lastEffect &&
           (null !== unitOfWork.lastEffect &&
-            (unitOfWork.lastEffect.nextEffect = workInProgress.firstEffect),
-          (unitOfWork.lastEffect = workInProgress.lastEffect)),
-        1 < workInProgress.effectTag &&
+            (unitOfWork.lastEffect.nextEffect = completedWork.firstEffect),
+          (unitOfWork.lastEffect = completedWork.lastEffect)),
+        1 < completedWork.effectTag &&
           (null !== unitOfWork.lastEffect
-            ? (unitOfWork.lastEffect.nextEffect = workInProgress)
-            : (unitOfWork.firstEffect = workInProgress),
-          (unitOfWork.lastEffect = workInProgress)));
+            ? (unitOfWork.lastEffect.nextEffect = completedWork)
+            : (unitOfWork.firstEffect = completedWork),
+          (unitOfWork.lastEffect = completedWork)));
     } else {
-      current = unwindWork(workInProgress);
-      if (null !== current) return (current.effectTag &= 2047), current;
+      current = unwindWork(completedWork);
+      if (null !== current) {
+        current.effectTag &= 2047;
+        workInProgress = current;
+        return;
+      }
       null !== unitOfWork &&
         ((unitOfWork.firstEffect = unitOfWork.lastEffect = null),
         (unitOfWork.effectTag |= 2048));
     }
-    current = workInProgress.sibling;
-    if (null !== current) return current;
-    workInProgress = unitOfWork;
-  } while (null !== workInProgress);
-  workInProgressRootExitStatus === RootIncomplete &&
-    (workInProgressRootExitStatus = RootCompleted);
-  return null;
-}
-function getRemainingExpirationTime(fiber) {
-  var updateExpirationTime = fiber.expirationTime;
-  fiber = fiber.childExpirationTime;
-  return updateExpirationTime > fiber ? updateExpirationTime : fiber;
+    completedWork = completedWork.sibling;
+    if (null !== completedWork) {
+      workInProgress = completedWork;
+      return;
+    }
+    workInProgress = completedWork = unitOfWork;
+  } while (null !== completedWork);
+  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
 }
 function commitRoot(root) {
   var renderPriorityLevel = getCurrentPriorityLevel();
   runWithPriority(99, commitRootImpl.bind(null, root, renderPriorityLevel));
   return null;
 }
-function commitRootImpl(root$jscomp$0, renderPriorityLevel$jscomp$0) {
+function commitRootImpl(root, renderPriorityLevel) {
   do flushPassiveEffects();
   while (null !== rootWithPendingPassiveEffects);
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+  if (0 !== (executionContext & 48))
     throw Error("Should not already be working.");
-  var finishedWork = root$jscomp$0.finishedWork,
-    expirationTime = root$jscomp$0.finishedExpirationTime;
+  var finishedWork = root.finishedWork;
   if (null === finishedWork) return null;
-  root$jscomp$0.finishedWork = null;
-  root$jscomp$0.finishedExpirationTime = 0;
-  if (finishedWork === root$jscomp$0.current)
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  if (finishedWork === root.current)
     throw Error(
       "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
     );
-  root$jscomp$0.callbackNode = null;
-  root$jscomp$0.callbackExpirationTime = 0;
-  root$jscomp$0.callbackPriority = 90;
-  root$jscomp$0.nextKnownPendingLevel = 0;
-  var remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(
-    finishedWork
-  );
-  root$jscomp$0.firstPendingTime = remainingExpirationTimeBeforeCommit;
-  expirationTime <= root$jscomp$0.lastSuspendedTime
-    ? (root$jscomp$0.firstSuspendedTime = root$jscomp$0.lastSuspendedTime = root$jscomp$0.nextKnownPendingLevel = 0)
-    : expirationTime <= root$jscomp$0.firstSuspendedTime &&
-      (root$jscomp$0.firstSuspendedTime = expirationTime - 1);
-  expirationTime <= root$jscomp$0.lastPingedTime &&
-    (root$jscomp$0.lastPingedTime = 0);
-  expirationTime <= root$jscomp$0.lastExpiredTime &&
-    (root$jscomp$0.lastExpiredTime = 0);
-  root$jscomp$0 === workInProgressRoot &&
+  root.callbackNode = null;
+  var remainingLanes = finishedWork.lanes | finishedWork.childLanes,
+    remainingLanes$jscomp$0 = remainingLanes,
+    noLongerPendingLanes = root.pendingLanes & ~remainingLanes$jscomp$0;
+  root.pendingLanes = remainingLanes$jscomp$0;
+  root.suspendedLanes = 0;
+  root.pingedLanes = 0;
+  root.expiredLanes &= remainingLanes$jscomp$0;
+  root.mutableReadLanes &= remainingLanes$jscomp$0;
+  root.entangledLanes &= remainingLanes$jscomp$0;
+  remainingLanes$jscomp$0 = root.entanglements;
+  for (
+    var eventTimes = root.eventTimes, expirationTimes = root.expirationTimes;
+    0 < noLongerPendingLanes;
+
+  ) {
+    var index$13 = 31 - clz32(noLongerPendingLanes),
+      lane = 1 << index$13;
+    remainingLanes$jscomp$0[index$13] = 0;
+    eventTimes[index$13] = -1;
+    expirationTimes[index$13] = -1;
+    noLongerPendingLanes &= ~lane;
+  }
+  null !== rootsWithPendingDiscreteUpdates &&
+    0 === (remainingLanes & 24) &&
+    rootsWithPendingDiscreteUpdates.has(root) &&
+    rootsWithPendingDiscreteUpdates.delete(root);
+  root === workInProgressRoot &&
     ((workInProgress = workInProgressRoot = null),
-    (renderExpirationTime$1 = 0));
+    (workInProgressRootRenderLanes = 0));
   1 < finishedWork.effectTag
     ? null !== finishedWork.lastEffect
       ? ((finishedWork.lastEffect.nextEffect = finishedWork),
-        (remainingExpirationTimeBeforeCommit = finishedWork.firstEffect))
-      : (remainingExpirationTimeBeforeCommit = finishedWork)
-    : (remainingExpirationTimeBeforeCommit = finishedWork.firstEffect);
-  if (null !== remainingExpirationTimeBeforeCommit) {
-    var prevExecutionContext = executionContext;
-    executionContext |= CommitContext;
-    ReactCurrentOwner$2.current = null;
-    nextEffect = remainingExpirationTimeBeforeCommit;
+        (remainingLanes = finishedWork.firstEffect))
+      : (remainingLanes = finishedWork)
+    : (remainingLanes = finishedWork.firstEffect);
+  if (null !== remainingLanes) {
+    remainingLanes$jscomp$0 = executionContext;
+    executionContext |= 32;
+    focusedInstanceHandle = ReactCurrentOwner$2.current = null;
+    shouldFireAfterActiveInstanceBlur = !1;
+    nextEffect = remainingLanes;
     do
       try {
         commitBeforeMutationEffects();
@@ -6390,15 +6752,11 @@ function commitRootImpl(root$jscomp$0, renderPriorityLevel$jscomp$0) {
         nextEffect = nextEffect.nextEffect;
       }
     while (null !== nextEffect);
-    nextEffect = remainingExpirationTimeBeforeCommit;
+    focusedInstanceHandle = null;
+    nextEffect = remainingLanes;
     do
       try {
-        for (
-          var root = root$jscomp$0,
-            renderPriorityLevel = renderPriorityLevel$jscomp$0;
-          null !== nextEffect;
-
-        ) {
+        for (eventTimes = root; null !== nextEffect; ) {
           var effectTag = nextEffect.effectTag;
           if (effectTag & 128) {
             var current = nextEffect.alternate;
@@ -6431,27 +6789,25 @@ function commitRootImpl(root$jscomp$0, renderPriorityLevel$jscomp$0) {
               commitWork(nextEffect.alternate, nextEffect);
               break;
             case 8:
-              var current$jscomp$0 = nextEffect;
-              unmountHostComponents(
-                root,
-                current$jscomp$0,
-                renderPriorityLevel
-              );
-              detachFiber(current$jscomp$0);
+              expirationTimes = nextEffect;
+              unmountHostComponents(eventTimes, expirationTimes);
+              var alternate = expirationTimes.alternate;
+              detachFiberMutation(expirationTimes);
+              null !== alternate && detachFiberMutation(alternate);
           }
           nextEffect = nextEffect.nextEffect;
         }
-      } catch (error) {
+      } catch (error$93) {
         if (null === nextEffect) throw Error("Should be working on an effect.");
-        captureCommitPhaseError(nextEffect, error);
+        captureCommitPhaseError(nextEffect, error$93);
         nextEffect = nextEffect.nextEffect;
       }
     while (null !== nextEffect);
-    root$jscomp$0.current = finishedWork;
-    nextEffect = remainingExpirationTimeBeforeCommit;
+    root.current = finishedWork;
+    nextEffect = remainingLanes;
     do
       try {
-        for (effectTag = root$jscomp$0; null !== nextEffect; ) {
+        for (effectTag = root; null !== nextEffect; ) {
           var effectTag$jscomp$0 = nextEffect.effectTag;
           effectTag$jscomp$0 & 36 &&
             commitLifeCycles(effectTag, nextEffect.alternate, nextEffect);
@@ -6474,54 +6830,71 @@ function commitRootImpl(root$jscomp$0, renderPriorityLevel$jscomp$0) {
           }
           nextEffect = nextEffect.nextEffect;
         }
-      } catch (error) {
+      } catch (error$94) {
         if (null === nextEffect) throw Error("Should be working on an effect.");
-        captureCommitPhaseError(nextEffect, error);
+        captureCommitPhaseError(nextEffect, error$94);
         nextEffect = nextEffect.nextEffect;
       }
     while (null !== nextEffect);
     nextEffect = null;
     requestPaint();
-    executionContext = prevExecutionContext;
-  } else root$jscomp$0.current = finishedWork;
+    executionContext = remainingLanes$jscomp$0;
+  } else root.current = finishedWork;
   if (rootDoesHavePassiveEffects)
     (rootDoesHavePassiveEffects = !1),
-      (rootWithPendingPassiveEffects = root$jscomp$0),
-      (pendingPassiveEffectsRenderPriority = renderPriorityLevel$jscomp$0);
+      (rootWithPendingPassiveEffects = root),
+      (pendingPassiveEffectsRenderPriority = renderPriorityLevel);
   else
-    for (
-      nextEffect = remainingExpirationTimeBeforeCommit;
-      null !== nextEffect;
-
-    )
-      (renderPriorityLevel$jscomp$0 = nextEffect.nextEffect),
+    for (nextEffect = remainingLanes; null !== nextEffect; )
+      (renderPriorityLevel = nextEffect.nextEffect),
         (nextEffect.nextEffect = null),
-        (nextEffect = renderPriorityLevel$jscomp$0);
-  renderPriorityLevel$jscomp$0 = root$jscomp$0.firstPendingTime;
-  0 === renderPriorityLevel$jscomp$0 &&
-    (legacyErrorBoundariesThatAlreadyFailed = null);
-  1073741823 === renderPriorityLevel$jscomp$0
-    ? root$jscomp$0 === rootWithNestedUpdates
+        nextEffect.effectTag & 8 &&
+          ((effectTag$jscomp$0 = nextEffect),
+          (effectTag$jscomp$0.sibling = null),
+          (effectTag$jscomp$0.stateNode = null)),
+        (nextEffect = renderPriorityLevel);
+  remainingLanes = root.pendingLanes;
+  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
+  1 === remainingLanes
+    ? root === rootWithNestedUpdates
       ? nestedUpdateCount++
-      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root$jscomp$0))
+      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
     : (nestedUpdateCount = 0);
-  "function" === typeof onCommitFiberRoot &&
-    onCommitFiberRoot(finishedWork.stateNode, expirationTime);
-  ensureRootIsScheduled(root$jscomp$0);
+  finishedWork = finishedWork.stateNode;
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
+    try {
+      injectedHook.onCommitFiberRoot(
+        rendererID,
+        finishedWork,
+        void 0,
+        64 === (finishedWork.current.effectTag & 64)
+      );
+    } catch (err) {}
+  ensureRootIsScheduled(root, now());
   if (hasUncaughtError)
     throw ((hasUncaughtError = !1),
-    (root$jscomp$0 = firstUncaughtError),
+    (root = firstUncaughtError),
     (firstUncaughtError = null),
-    root$jscomp$0);
-  if ((executionContext & LegacyUnbatchedContext) !== NoContext) return null;
+    root);
+  if (0 !== (executionContext & 8)) return null;
   flushSyncCallbackQueue();
   return null;
 }
 function commitBeforeMutationEffects() {
   for (; null !== nextEffect; ) {
+    var current = nextEffect.alternate;
+    shouldFireAfterActiveInstanceBlur ||
+      null === focusedInstanceHandle ||
+      (0 !== (nextEffect.effectTag & 8)
+        ? doesFiberContain(nextEffect, focusedInstanceHandle) &&
+          (shouldFireAfterActiveInstanceBlur = !0)
+        : 13 === nextEffect.tag &&
+          isSuspenseBoundaryBeingHidden(current, nextEffect) &&
+          doesFiberContain(nextEffect, focusedInstanceHandle) &&
+          (shouldFireAfterActiveInstanceBlur = !0));
     var effectTag = nextEffect.effectTag;
     0 !== (effectTag & 256) &&
-      commitBeforeMutationLifeCycles(nextEffect.alternate, nextEffect);
+      commitBeforeMutationLifeCycles(current, nextEffect);
     0 === (effectTag & 512) ||
       rootDoesHavePassiveEffects ||
       ((rootDoesHavePassiveEffects = !0),
@@ -6539,47 +6912,84 @@ function flushPassiveEffects() {
         ? 97
         : pendingPassiveEffectsRenderPriority;
     pendingPassiveEffectsRenderPriority = 90;
+    schedulerPriorityToLanePriority(priorityLevel);
     return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
   }
+  return !1;
+}
+function enqueuePendingPassiveHookEffectMount(fiber, effect) {
+  pendingPassiveHookEffectsMount.push(effect, fiber);
+  rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(97, function() {
+      flushPassiveEffects();
+      return null;
+    }));
+}
+function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
+  pendingPassiveHookEffectsUnmount.push(effect, fiber);
+  rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(97, function() {
+      flushPassiveEffects();
+      return null;
+    }));
 }
 function flushPassiveEffectsImpl() {
   if (null === rootWithPendingPassiveEffects) return !1;
   var root = rootWithPendingPassiveEffects;
   rootWithPendingPassiveEffects = null;
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+  if (0 !== (executionContext & 48))
     throw Error("Cannot flush passive effects while already rendering.");
   var prevExecutionContext = executionContext;
-  executionContext |= CommitContext;
-  for (root = root.current.firstEffect; null !== root; ) {
+  executionContext |= 32;
+  var unmountEffects = pendingPassiveHookEffectsUnmount;
+  pendingPassiveHookEffectsUnmount = [];
+  for (var i = 0; i < unmountEffects.length; i += 2) {
+    var effect$99 = unmountEffects[i],
+      fiber = unmountEffects[i + 1],
+      destroy = effect$99.destroy;
+    effect$99.destroy = void 0;
+    if ("function" === typeof destroy)
+      try {
+        destroy();
+      } catch (error) {
+        if (null === fiber) throw Error("Should be working on an effect.");
+        captureCommitPhaseError(fiber, error);
+      }
+  }
+  unmountEffects = pendingPassiveHookEffectsMount;
+  pendingPassiveHookEffectsMount = [];
+  for (i = 0; i < unmountEffects.length; i += 2) {
+    effect$99 = unmountEffects[i];
+    fiber = unmountEffects[i + 1];
     try {
-      var finishedWork = root;
-      if (0 !== (finishedWork.effectTag & 512))
-        switch (finishedWork.tag) {
-          case 0:
-          case 11:
-          case 15:
-          case 22:
-            commitHookEffectListUnmount(5, finishedWork),
-              commitHookEffectListMount(5, finishedWork);
-        }
-    } catch (error) {
-      if (null === root) throw Error("Should be working on an effect.");
-      captureCommitPhaseError(root, error);
+      var create$103 = effect$99.create;
+      effect$99.destroy = create$103();
+    } catch (error$104) {
+      if (null === fiber) throw Error("Should be working on an effect.");
+      captureCommitPhaseError(fiber, error$104);
     }
-    finishedWork = root.nextEffect;
-    root.nextEffect = null;
-    root = finishedWork;
   }
+  for (create$103 = root.current.firstEffect; null !== create$103; )
+    (root = create$103.nextEffect),
+      (create$103.nextEffect = null),
+      create$103.effectTag & 8 &&
+        ((create$103.sibling = null), (create$103.stateNode = null)),
+      (create$103 = root);
   executionContext = prevExecutionContext;
   flushSyncCallbackQueue();
   return !0;
 }
 function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
   sourceFiber = createCapturedValue(error, sourceFiber);
-  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 1073741823);
+  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 1);
   enqueueUpdate(rootFiber, sourceFiber);
-  rootFiber = markUpdateTimeFromFiberToRoot(rootFiber, 1073741823);
-  null !== rootFiber && ensureRootIsScheduled(rootFiber);
+  sourceFiber = requestEventTime();
+  rootFiber = markUpdateLaneFromFiberToRoot(rootFiber, 1);
+  null !== rootFiber &&
+    (markRootUpdated(rootFiber, 1, sourceFiber),
+    ensureRootIsScheduled(rootFiber, sourceFiber));
 }
 function captureCommitPhaseError(sourceFiber, error) {
   if (3 === sourceFiber.tag)
@@ -6598,143 +7008,156 @@ function captureCommitPhaseError(sourceFiber, error) {
               !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
         ) {
           sourceFiber = createCapturedValue(error, sourceFiber);
-          sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1073741823);
+          sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1);
           enqueueUpdate(fiber, sourceFiber);
-          fiber = markUpdateTimeFromFiberToRoot(fiber, 1073741823);
-          null !== fiber && ensureRootIsScheduled(fiber);
+          sourceFiber = requestEventTime();
+          fiber = markUpdateLaneFromFiberToRoot(fiber, 1);
+          null !== fiber &&
+            (markRootUpdated(fiber, 1, sourceFiber),
+            ensureRootIsScheduled(fiber, sourceFiber));
           break;
         }
       }
       fiber = fiber.return;
     }
 }
-function pingSuspendedRoot(root, thenable, suspendedTime) {
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
   var pingCache = root.pingCache;
-  null !== pingCache && pingCache.delete(thenable);
-  workInProgressRoot === root && renderExpirationTime$1 === suspendedTime
-    ? workInProgressRootExitStatus === RootSuspendedWithDelay ||
-      (workInProgressRootExitStatus === RootSuspended &&
-        1073741823 === workInProgressRootLatestProcessedExpirationTime &&
-        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
-      ? prepareFreshStack(root, renderExpirationTime$1)
-      : (workInProgressRootHasPendingPing = !0)
-    : isRootSuspendedAtTime(root, suspendedTime) &&
-      ((thenable = root.lastPingedTime),
-      (0 !== thenable && thenable < suspendedTime) ||
-        ((root.lastPingedTime = suspendedTime), ensureRootIsScheduled(root)));
-}
-function resolveRetryThenable(boundaryFiber, thenable) {
+  null !== pingCache && pingCache.delete(wakeable);
+  wakeable = requestEventTime();
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+  workInProgressRoot === root &&
+    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
+    (4 === workInProgressRootExitStatus ||
+    (3 === workInProgressRootExitStatus &&
+      (workInProgressRootRenderLanes & 62914560) ===
+        workInProgressRootRenderLanes &&
+      500 > now() - globalMostRecentFallbackTime)
+      ? prepareFreshStack(root, 0)
+      : (workInProgressRootPingedLanes |= pingedLanes));
+  ensureRootIsScheduled(root, wakeable);
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
   var retryCache = boundaryFiber.stateNode;
-  null !== retryCache && retryCache.delete(thenable);
-  thenable = 0;
-  0 === thenable &&
-    ((thenable = requestCurrentTimeForUpdate()),
-    (thenable = computeExpirationForFiber(thenable, boundaryFiber, null)));
-  boundaryFiber = markUpdateTimeFromFiberToRoot(boundaryFiber, thenable);
-  null !== boundaryFiber && ensureRootIsScheduled(boundaryFiber);
+  null !== retryCache && retryCache.delete(wakeable);
+  wakeable = 0;
+  0 === wakeable &&
+    ((wakeable = boundaryFiber.mode),
+    0 === (wakeable & 2)
+      ? (wakeable = 1)
+      : 0 === (wakeable & 4)
+      ? (wakeable = 99 === getCurrentPriorityLevel() ? 1 : 2)
+      : (0 === currentEventWipLanes &&
+          (currentEventWipLanes = workInProgressRootIncludedLanes),
+        (wakeable = getHighestPriorityLane(62914560 & ~currentEventWipLanes)),
+        0 === wakeable && (wakeable = 4194304)));
+  retryCache = requestEventTime();
+  boundaryFiber = markUpdateLaneFromFiberToRoot(boundaryFiber, wakeable);
+  null !== boundaryFiber &&
+    (markRootUpdated(boundaryFiber, wakeable, retryCache),
+    ensureRootIsScheduled(boundaryFiber, retryCache));
 }
 var beginWork$1;
-beginWork$1 = function(current, workInProgress, renderExpirationTime) {
-  var updateExpirationTime = workInProgress.expirationTime;
+beginWork$1 = function(current, workInProgress, renderLanes) {
+  var updateLanes = workInProgress.lanes;
   if (null !== current)
     if (
       current.memoizedProps !== workInProgress.pendingProps ||
       didPerformWorkStackCursor.current
     )
       didReceiveUpdate = !0;
+    else if (0 !== (renderLanes & updateLanes))
+      didReceiveUpdate = 0 !== (current.effectTag & 16384) ? !0 : !1;
     else {
-      if (updateExpirationTime < renderExpirationTime) {
-        didReceiveUpdate = !1;
-        switch (workInProgress.tag) {
-          case 3:
-            pushHostRootContext(workInProgress);
-            break;
-          case 5:
-            pushHostContext(workInProgress);
-            break;
-          case 1:
-            isContextProvider(workInProgress.type) &&
-              pushContextProvider(workInProgress);
-            break;
-          case 4:
-            pushHostContainer(
+      didReceiveUpdate = !1;
+      switch (workInProgress.tag) {
+        case 3:
+          pushHostRootContext(workInProgress);
+          break;
+        case 5:
+          pushHostContext(workInProgress);
+          break;
+        case 1:
+          isContextProvider(workInProgress.type) &&
+            pushContextProvider(workInProgress);
+          break;
+        case 4:
+          pushHostContainer(
+            workInProgress,
+            workInProgress.stateNode.containerInfo
+          );
+          break;
+        case 10:
+          updateLanes = workInProgress.memoizedProps.value;
+          var context = workInProgress.type._context;
+          push(valueCursor, context._currentValue);
+          context._currentValue = updateLanes;
+          break;
+        case 13:
+          if (null !== workInProgress.memoizedState) {
+            if (0 !== (renderLanes & workInProgress.child.childLanes))
+              return updateSuspenseComponent(
+                current,
+                workInProgress,
+                renderLanes
+              );
+            push(suspenseStackCursor, suspenseStackCursor.current & 1);
+            workInProgress = bailoutOnAlreadyFinishedWork(
+              current,
               workInProgress,
-              workInProgress.stateNode.containerInfo
+              renderLanes
             );
-            break;
-          case 10:
-            updateExpirationTime = workInProgress.memoizedProps.value;
-            var context = workInProgress.type._context;
-            push(valueCursor, context._currentValue);
-            context._currentValue = updateExpirationTime;
-            break;
-          case 13:
-            if (null !== workInProgress.memoizedState) {
-              updateExpirationTime = workInProgress.child.childExpirationTime;
-              if (
-                0 !== updateExpirationTime &&
-                updateExpirationTime >= renderExpirationTime
-              )
-                return updateSuspenseComponent(
-                  current,
-                  workInProgress,
-                  renderExpirationTime
-                );
-              push(suspenseStackCursor, suspenseStackCursor.current & 1);
-              workInProgress = bailoutOnAlreadyFinishedWork(
+            return null !== workInProgress ? workInProgress.sibling : null;
+          }
+          push(suspenseStackCursor, suspenseStackCursor.current & 1);
+          break;
+        case 19:
+          updateLanes = 0 !== (renderLanes & workInProgress.childLanes);
+          if (0 !== (current.effectTag & 64)) {
+            if (updateLanes)
+              return updateSuspenseListComponent(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
-              return null !== workInProgress ? workInProgress.sibling : null;
-            }
-            push(suspenseStackCursor, suspenseStackCursor.current & 1);
-            break;
-          case 19:
-            updateExpirationTime =
-              workInProgress.childExpirationTime >= renderExpirationTime;
-            if (0 !== (current.effectTag & 64)) {
-              if (updateExpirationTime)
-                return updateSuspenseListComponent(
-                  current,
-                  workInProgress,
-                  renderExpirationTime
-                );
-              workInProgress.effectTag |= 64;
-            }
-            context = workInProgress.memoizedState;
-            null !== context &&
-              ((context.rendering = null), (context.tail = null));
-            push(suspenseStackCursor, suspenseStackCursor.current);
-            if (!updateExpirationTime) return null;
-        }
-        return bailoutOnAlreadyFinishedWork(
-          current,
-          workInProgress,
-          renderExpirationTime
-        );
+            workInProgress.effectTag |= 64;
+          }
+          context = workInProgress.memoizedState;
+          null !== context &&
+            ((context.rendering = null),
+            (context.tail = null),
+            (context.lastEffect = null));
+          push(suspenseStackCursor, suspenseStackCursor.current);
+          if (updateLanes) break;
+          else return null;
+        case 23:
+        case 24:
+          return (
+            (workInProgress.lanes = 0),
+            updateOffscreenComponent(current, workInProgress, renderLanes)
+          );
       }
-      didReceiveUpdate = !1;
+      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
     }
   else didReceiveUpdate = !1;
-  workInProgress.expirationTime = 0;
+  workInProgress.lanes = 0;
   switch (workInProgress.tag) {
     case 2:
-      updateExpirationTime = workInProgress.type;
+      updateLanes = workInProgress.type;
       null !== current &&
         ((current.alternate = null),
         (workInProgress.alternate = null),
         (workInProgress.effectTag |= 2));
       current = workInProgress.pendingProps;
       context = getMaskedContext(workInProgress, contextStackCursor.current);
-      prepareToReadContext(workInProgress, renderExpirationTime);
+      prepareToReadContext(workInProgress, renderLanes);
       context = renderWithHooks(
         null,
         workInProgress,
-        updateExpirationTime,
+        updateLanes,
         current,
         context,
-        renderExpirationTime
+        renderLanes
       );
       workInProgress.effectTag |= 1;
       if (
@@ -6746,7 +7169,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
         workInProgress.tag = 1;
         workInProgress.memoizedState = null;
         workInProgress.updateQueue = null;
-        if (isContextProvider(updateExpirationTime)) {
+        if (isContextProvider(updateLanes)) {
           var hasContext = !0;
           pushContextProvider(workInProgress);
         } else hasContext = !1;
@@ -6755,53 +7178,41 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
             ? context.state
             : null;
         initializeUpdateQueue(workInProgress);
-        var getDerivedStateFromProps =
-          updateExpirationTime.getDerivedStateFromProps;
+        var getDerivedStateFromProps = updateLanes.getDerivedStateFromProps;
         "function" === typeof getDerivedStateFromProps &&
           applyDerivedStateFromProps(
             workInProgress,
-            updateExpirationTime,
+            updateLanes,
             getDerivedStateFromProps,
             current
           );
         context.updater = classComponentUpdater;
         workInProgress.stateNode = context;
-        context._reactInternalFiber = workInProgress;
-        mountClassInstance(
-          workInProgress,
-          updateExpirationTime,
-          current,
-          renderExpirationTime
-        );
+        context._reactInternals = workInProgress;
+        mountClassInstance(workInProgress, updateLanes, current, renderLanes);
         workInProgress = finishClassComponent(
           null,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           !0,
           hasContext,
-          renderExpirationTime
+          renderLanes
         );
       } else
         (workInProgress.tag = 0),
-          reconcileChildren(
-            null,
-            workInProgress,
-            context,
-            renderExpirationTime
-          ),
+          reconcileChildren(null, workInProgress, context, renderLanes),
           (workInProgress = workInProgress.child);
       return workInProgress;
     case 16:
+      context = workInProgress.elementType;
       a: {
-        context = workInProgress.elementType;
         null !== current &&
           ((current.alternate = null),
           (workInProgress.alternate = null),
           (workInProgress.effectTag |= 2));
         current = workInProgress.pendingProps;
-        initializeLazyComponentType(context);
-        if (1 !== context._status) throw context._result;
-        context = context._result;
+        hasContext = context._init;
+        context = hasContext(context._payload);
         workInProgress.type = context;
         hasContext = workInProgress.tag = resolveLazyComponentTag(context);
         current = resolveDefaultProps(context, current);
@@ -6812,7 +7223,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress,
               context,
               current,
-              renderExpirationTime
+              renderLanes
             );
             break a;
           case 1:
@@ -6821,7 +7232,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress,
               context,
               current,
-              renderExpirationTime
+              renderLanes
             );
             break a;
           case 11:
@@ -6830,7 +7241,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress,
               context,
               current,
-              renderExpirationTime
+              renderLanes
             );
             break a;
           case 14:
@@ -6839,8 +7250,8 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress,
               context,
               resolveDefaultProps(context.type, current),
-              updateExpirationTime,
-              renderExpirationTime
+              updateLanes,
+              renderLanes
             );
             break a;
         }
@@ -6853,126 +7264,106 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
       return workInProgress;
     case 0:
       return (
-        (updateExpirationTime = workInProgress.type),
+        (updateLanes = workInProgress.type),
         (context = workInProgress.pendingProps),
         (context =
-          workInProgress.elementType === updateExpirationTime
+          workInProgress.elementType === updateLanes
             ? context
-            : resolveDefaultProps(updateExpirationTime, context)),
+            : resolveDefaultProps(updateLanes, context)),
         updateFunctionComponent(
           current,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           context,
-          renderExpirationTime
+          renderLanes
         )
       );
     case 1:
       return (
-        (updateExpirationTime = workInProgress.type),
+        (updateLanes = workInProgress.type),
         (context = workInProgress.pendingProps),
         (context =
-          workInProgress.elementType === updateExpirationTime
+          workInProgress.elementType === updateLanes
             ? context
-            : resolveDefaultProps(updateExpirationTime, context)),
+            : resolveDefaultProps(updateLanes, context)),
         updateClassComponent(
           current,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           context,
-          renderExpirationTime
+          renderLanes
         )
       );
     case 3:
       pushHostRootContext(workInProgress);
-      updateExpirationTime = workInProgress.updateQueue;
-      if (null === current || null === updateExpirationTime)
+      updateLanes = workInProgress.updateQueue;
+      if (null === current || null === updateLanes)
         throw Error(
           "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."
         );
-      updateExpirationTime = workInProgress.pendingProps;
+      updateLanes = workInProgress.pendingProps;
       context = workInProgress.memoizedState;
       context = null !== context ? context.element : null;
       cloneUpdateQueue(current, workInProgress);
-      processUpdateQueue(
-        workInProgress,
-        updateExpirationTime,
-        null,
-        renderExpirationTime
-      );
-      updateExpirationTime = workInProgress.memoizedState.element;
-      updateExpirationTime === context
+      processUpdateQueue(workInProgress, updateLanes, null, renderLanes);
+      updateLanes = workInProgress.memoizedState.element;
+      updateLanes === context
         ? (workInProgress = bailoutOnAlreadyFinishedWork(
             current,
             workInProgress,
-            renderExpirationTime
+            renderLanes
           ))
-        : (reconcileChildren(
-            current,
-            workInProgress,
-            updateExpirationTime,
-            renderExpirationTime
-          ),
+        : (reconcileChildren(current, workInProgress, updateLanes, renderLanes),
           (workInProgress = workInProgress.child));
       return workInProgress;
     case 5:
       return (
         pushHostContext(workInProgress),
-        (updateExpirationTime = workInProgress.pendingProps.children),
+        (updateLanes = workInProgress.pendingProps.children),
         markRef(current, workInProgress),
-        reconcileChildren(
-          current,
-          workInProgress,
-          updateExpirationTime,
-          renderExpirationTime
-        ),
-        (workInProgress = workInProgress.child),
-        workInProgress
+        reconcileChildren(current, workInProgress, updateLanes, renderLanes),
+        workInProgress.child
       );
     case 6:
       return null;
     case 13:
-      return updateSuspenseComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
     case 4:
       return (
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         ),
-        (updateExpirationTime = workInProgress.pendingProps),
+        (updateLanes = workInProgress.pendingProps),
         null === current
           ? (workInProgress.child = reconcileChildFibers(
               workInProgress,
               null,
-              updateExpirationTime,
-              renderExpirationTime
+              updateLanes,
+              renderLanes
             ))
           : reconcileChildren(
               current,
               workInProgress,
-              updateExpirationTime,
-              renderExpirationTime
+              updateLanes,
+              renderLanes
             ),
         workInProgress.child
       );
     case 11:
       return (
-        (updateExpirationTime = workInProgress.type),
+        (updateLanes = workInProgress.type),
         (context = workInProgress.pendingProps),
         (context =
-          workInProgress.elementType === updateExpirationTime
+          workInProgress.elementType === updateLanes
             ? context
-            : resolveDefaultProps(updateExpirationTime, context)),
+            : resolveDefaultProps(updateLanes, context)),
         updateForwardRef(
           current,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           context,
-          renderExpirationTime
+          renderLanes
         )
       );
     case 7:
@@ -6981,7 +7372,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           current,
           workInProgress,
           workInProgress.pendingProps,
-          renderExpirationTime
+          renderLanes
         ),
         workInProgress.child
       );
@@ -6991,7 +7382,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           current,
           workInProgress,
           workInProgress.pendingProps.children,
-          renderExpirationTime
+          renderLanes
         ),
         workInProgress.child
       );
@@ -7001,13 +7392,13 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           current,
           workInProgress,
           workInProgress.pendingProps.children,
-          renderExpirationTime
+          renderLanes
         ),
         workInProgress.child
       );
     case 10:
       a: {
-        updateExpirationTime = workInProgress.type._context;
+        updateLanes = workInProgress.type._context;
         context = workInProgress.pendingProps;
         getDerivedStateFromProps = workInProgress.memoizedProps;
         hasContext = context.value;
@@ -7019,9 +7410,8 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
             ((context$jscomp$0 = getDerivedStateFromProps.value),
             (hasContext = objectIs(context$jscomp$0, hasContext)
               ? 0
-              : ("function" ===
-                typeof updateExpirationTime._calculateChangedBits
-                  ? updateExpirationTime._calculateChangedBits(
+              : ("function" === typeof updateLanes._calculateChangedBits
+                  ? updateLanes._calculateChangedBits(
                       context$jscomp$0,
                       hasContext
                     )
@@ -7035,7 +7425,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress = bailoutOnAlreadyFinishedWork(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
               break a;
             }
@@ -7056,25 +7446,25 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
 
                 ) {
                   if (
-                    dependency.context === updateExpirationTime &&
+                    dependency.context === updateLanes &&
                     0 !== (dependency.observedBits & hasContext)
                   ) {
                     1 === context$jscomp$0.tag &&
-                      ((dependency = createUpdate(renderExpirationTime, null)),
+                      ((dependency = createUpdate(
+                        -1,
+                        renderLanes & -renderLanes,
+                        null
+                      )),
                       (dependency.tag = 2),
                       enqueueUpdate(context$jscomp$0, dependency));
-                    context$jscomp$0.expirationTime < renderExpirationTime &&
-                      (context$jscomp$0.expirationTime = renderExpirationTime);
+                    context$jscomp$0.lanes |= renderLanes;
                     dependency = context$jscomp$0.alternate;
-                    null !== dependency &&
-                      dependency.expirationTime < renderExpirationTime &&
-                      (dependency.expirationTime = renderExpirationTime);
+                    null !== dependency && (dependency.lanes |= renderLanes);
                     scheduleWorkOnParentPath(
                       context$jscomp$0.return,
-                      renderExpirationTime
+                      renderLanes
                     );
-                    list.expirationTime < renderExpirationTime &&
-                      (list.expirationTime = renderExpirationTime);
+                    list.lanes |= renderLanes;
                     break;
                   }
                   dependency = dependency.next;
@@ -7112,7 +7502,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           current,
           workInProgress,
           context.children,
-          renderExpirationTime
+          renderLanes
         );
         workInProgress = workInProgress.child;
       }
@@ -7121,17 +7511,12 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
       return (
         (context = workInProgress.type),
         (hasContext = workInProgress.pendingProps),
-        (updateExpirationTime = hasContext.children),
-        prepareToReadContext(workInProgress, renderExpirationTime),
+        (updateLanes = hasContext.children),
+        prepareToReadContext(workInProgress, renderLanes),
         (context = readContext(context, hasContext.unstable_observedBits)),
-        (updateExpirationTime = updateExpirationTime(context)),
+        (updateLanes = updateLanes(context)),
         (workInProgress.effectTag |= 1),
-        reconcileChildren(
-          current,
-          workInProgress,
-          updateExpirationTime,
-          renderExpirationTime
-        ),
+        reconcileChildren(current, workInProgress, updateLanes, renderLanes),
         workInProgress.child
       );
     case 14:
@@ -7147,8 +7532,8 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           workInProgress,
           context,
           hasContext,
-          updateExpirationTime,
-          renderExpirationTime
+          updateLanes,
+          renderLanes
         )
       );
     case 15:
@@ -7157,48 +7542,43 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
         workInProgress,
         workInProgress.type,
         workInProgress.pendingProps,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     case 17:
       return (
-        (updateExpirationTime = workInProgress.type),
+        (updateLanes = workInProgress.type),
         (context = workInProgress.pendingProps),
         (context =
-          workInProgress.elementType === updateExpirationTime
+          workInProgress.elementType === updateLanes
             ? context
-            : resolveDefaultProps(updateExpirationTime, context)),
+            : resolveDefaultProps(updateLanes, context)),
         null !== current &&
           ((current.alternate = null),
           (workInProgress.alternate = null),
           (workInProgress.effectTag |= 2)),
         (workInProgress.tag = 1),
-        isContextProvider(updateExpirationTime)
+        isContextProvider(updateLanes)
           ? ((current = !0), pushContextProvider(workInProgress))
           : (current = !1),
-        prepareToReadContext(workInProgress, renderExpirationTime),
-        constructClassInstance(workInProgress, updateExpirationTime, context),
-        mountClassInstance(
-          workInProgress,
-          updateExpirationTime,
-          context,
-          renderExpirationTime
-        ),
+        prepareToReadContext(workInProgress, renderLanes),
+        constructClassInstance(workInProgress, updateLanes, context),
+        mountClassInstance(workInProgress, updateLanes, context, renderLanes),
         finishClassComponent(
           null,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           !0,
           current,
-          renderExpirationTime
+          renderLanes
         )
       );
     case 19:
-      return updateSuspenseListComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+    case 23:
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
+    case 24:
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
   }
   throw Error(
     "Unknown unit of work tag (" +
@@ -7206,32 +7586,6 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
       "). This error is likely caused by a bug in React. Please file an issue."
   );
 };
-var onCommitFiberRoot = null,
-  onCommitFiberUnmount = null;
-function injectInternals(internals) {
-  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
-  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
-  if (hook.isDisabled || !hook.supportsFiber) return !0;
-  try {
-    var rendererID = hook.inject(internals);
-    onCommitFiberRoot = function(root) {
-      try {
-        hook.onCommitFiberRoot(
-          rendererID,
-          root,
-          void 0,
-          64 === (root.current.effectTag & 64)
-        );
-      } catch (err) {}
-    };
-    onCommitFiberUnmount = function(fiber) {
-      try {
-        hook.onCommitFiberUnmount(rendererID, fiber);
-      } catch (err) {}
-    };
-  } catch (err) {}
-  return !0;
-}
 function FiberNode(tag, pendingProps, key, mode) {
   this.tag = tag;
   this.key = key;
@@ -7243,9 +7597,12 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.mode = mode;
   this.effectTag = 0;
   this.lastEffect = this.firstEffect = this.nextEffect = null;
-  this.childExpirationTime = this.expirationTime = 0;
+  this.childLanes = this.lanes = 0;
   this.alternate = null;
 }
+function createFiber(tag, pendingProps, key, mode) {
+  return new FiberNode(tag, pendingProps, key, mode);
+}
 function shouldConstruct(Component) {
   Component = Component.prototype;
   return !(!Component || !Component.isReactComponent);
@@ -7263,7 +7620,7 @@ function resolveLazyComponentTag(Component) {
 function createWorkInProgress(current, pendingProps) {
   var workInProgress = current.alternate;
   null === workInProgress
-    ? ((workInProgress = new FiberNode(
+    ? ((workInProgress = createFiber(
         current.tag,
         pendingProps,
         current.key,
@@ -7275,12 +7632,13 @@ function createWorkInProgress(current, pendingProps) {
       (workInProgress.alternate = current),
       (current.alternate = workInProgress))
     : ((workInProgress.pendingProps = pendingProps),
+      (workInProgress.type = current.type),
       (workInProgress.effectTag = 0),
       (workInProgress.nextEffect = null),
       (workInProgress.firstEffect = null),
       (workInProgress.lastEffect = null));
-  workInProgress.childExpirationTime = current.childExpirationTime;
-  workInProgress.expirationTime = current.expirationTime;
+  workInProgress.childLanes = current.childLanes;
+  workInProgress.lanes = current.lanes;
   workInProgress.child = current.child;
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
@@ -7289,11 +7647,7 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.dependencies =
     null === pendingProps
       ? null
-      : {
-          expirationTime: pendingProps.expirationTime,
-          firstContext: pendingProps.firstContext,
-          responders: pendingProps.responders
-        };
+      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
   workInProgress.sibling = current.sibling;
   workInProgress.index = current.index;
   workInProgress.ref = current.ref;
@@ -7305,7 +7659,7 @@ function createFiberFromTypeAndProps(
   pendingProps,
   owner,
   mode,
-  expirationTime
+  lanes
 ) {
   var fiberTag = 2;
   owner = type;
@@ -7314,15 +7668,10 @@ function createFiberFromTypeAndProps(
   else
     a: switch (type) {
       case REACT_FRAGMENT_TYPE:
-        return createFiberFromFragment(
-          pendingProps.children,
-          mode,
-          expirationTime,
-          key
-        );
-      case REACT_CONCURRENT_MODE_TYPE:
+        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
+      case REACT_DEBUG_TRACING_MODE_TYPE:
         fiberTag = 8;
-        mode |= 7;
+        mode |= 16;
         break;
       case REACT_STRICT_MODE_TYPE:
         fiberTag = 8;
@@ -7330,25 +7679,34 @@ function createFiberFromTypeAndProps(
         break;
       case REACT_PROFILER_TYPE:
         return (
-          (type = new FiberNode(12, pendingProps, key, mode | 8)),
+          (type = createFiber(12, pendingProps, key, mode | 8)),
           (type.elementType = REACT_PROFILER_TYPE),
           (type.type = REACT_PROFILER_TYPE),
-          (type.expirationTime = expirationTime),
+          (type.lanes = lanes),
           type
         );
       case REACT_SUSPENSE_TYPE:
         return (
-          (type = new FiberNode(13, pendingProps, key, mode)),
+          (type = createFiber(13, pendingProps, key, mode)),
           (type.type = REACT_SUSPENSE_TYPE),
           (type.elementType = REACT_SUSPENSE_TYPE),
-          (type.expirationTime = expirationTime),
+          (type.lanes = lanes),
           type
         );
       case REACT_SUSPENSE_LIST_TYPE:
         return (
-          (type = new FiberNode(19, pendingProps, key, mode)),
+          (type = createFiber(19, pendingProps, key, mode)),
           (type.elementType = REACT_SUSPENSE_LIST_TYPE),
-          (type.expirationTime = expirationTime),
+          (type.lanes = lanes),
+          type
+        );
+      case REACT_OFFSCREEN_TYPE:
+        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+      case REACT_LEGACY_HIDDEN_TYPE:
+        return (
+          (type = createFiber(24, pendingProps, key, mode)),
+          (type.elementType = REACT_LEGACY_HIDDEN_TYPE),
+          (type.lanes = lanes),
           type
         );
       default:
@@ -7380,30 +7738,36 @@ function createFiberFromTypeAndProps(
             "."
         );
     }
-  key = new FiberNode(fiberTag, pendingProps, key, mode);
+  key = createFiber(fiberTag, pendingProps, key, mode);
   key.elementType = type;
   key.type = owner;
-  key.expirationTime = expirationTime;
+  key.lanes = lanes;
   return key;
 }
-function createFiberFromFragment(elements, mode, expirationTime, key) {
-  elements = new FiberNode(7, elements, key, mode);
-  elements.expirationTime = expirationTime;
+function createFiberFromFragment(elements, mode, lanes, key) {
+  elements = createFiber(7, elements, key, mode);
+  elements.lanes = lanes;
   return elements;
 }
-function createFiberFromText(content, mode, expirationTime) {
-  content = new FiberNode(6, content, null, mode);
-  content.expirationTime = expirationTime;
+function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
+  pendingProps = createFiber(23, pendingProps, key, mode);
+  pendingProps.elementType = REACT_OFFSCREEN_TYPE;
+  pendingProps.lanes = lanes;
+  return pendingProps;
+}
+function createFiberFromText(content, mode, lanes) {
+  content = createFiber(6, content, null, mode);
+  content.lanes = lanes;
   return content;
 }
-function createFiberFromPortal(portal, mode, expirationTime) {
-  mode = new FiberNode(
+function createFiberFromPortal(portal, mode, lanes) {
+  mode = createFiber(
     4,
     null !== portal.children ? portal.children : [],
     portal.key,
     mode
   );
-  mode.expirationTime = expirationTime;
+  mode.lanes = lanes;
   mode.stateNode = {
     containerInfo: portal.containerInfo,
     pendingChildren: null,
@@ -7413,51 +7777,31 @@ function createFiberFromPortal(portal, mode, expirationTime) {
 }
 function FiberRootNode(containerInfo, tag, hydrate) {
   this.tag = tag;
-  this.current = null;
   this.containerInfo = containerInfo;
-  this.pingCache = this.pendingChildren = null;
-  this.finishedExpirationTime = 0;
-  this.finishedWork = null;
+  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
   this.timeoutHandle = -1;
   this.pendingContext = this.context = null;
   this.hydrate = hydrate;
   this.callbackNode = null;
-  this.callbackPriority = 90;
-  this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
-}
-function isRootSuspendedAtTime(root, expirationTime) {
-  var firstSuspendedTime = root.firstSuspendedTime;
-  root = root.lastSuspendedTime;
-  return (
-    0 !== firstSuspendedTime &&
-    firstSuspendedTime >= expirationTime &&
-    root <= expirationTime
-  );
+  this.callbackPriority = 0;
+  this.eventTimes = Array(31).fill(0);
+  this.expirationTimes = Array(31).fill(-1);
+  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
+  this.entanglements = Array(31).fill(0);
 }
-function markRootSuspendedAtTime(root, expirationTime) {
-  var firstSuspendedTime = root.firstSuspendedTime,
-    lastSuspendedTime = root.lastSuspendedTime;
-  firstSuspendedTime < expirationTime &&
-    (root.firstSuspendedTime = expirationTime);
-  if (lastSuspendedTime > expirationTime || 0 === firstSuspendedTime)
-    root.lastSuspendedTime = expirationTime;
-  expirationTime <= root.lastPingedTime && (root.lastPingedTime = 0);
-  expirationTime <= root.lastExpiredTime && (root.lastExpiredTime = 0);
-}
-function markRootUpdatedAtTime(root, expirationTime) {
-  expirationTime > root.firstPendingTime &&
-    (root.firstPendingTime = expirationTime);
-  var firstSuspendedTime = root.firstSuspendedTime;
-  0 !== firstSuspendedTime &&
-    (expirationTime >= firstSuspendedTime
-      ? (root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = 0)
-      : expirationTime >= root.lastSuspendedTime &&
-        (root.lastSuspendedTime = expirationTime + 1),
-    expirationTime > root.nextKnownPendingLevel &&
-      (root.nextKnownPendingLevel = expirationTime));
+function createPortal(children, containerInfo, implementation) {
+  var key =
+    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
+  return {
+    $$typeof: REACT_PORTAL_TYPE,
+    key: null == key ? null : "" + key,
+    children: children,
+    containerInfo: containerInfo,
+    implementation: implementation
+  };
 }
 function findHostInstance(component) {
-  var fiber = component._reactInternalFiber;
+  var fiber = component._reactInternals;
   if (void 0 === fiber) {
     if ("function" === typeof component.render)
       throw Error("Unable to find node on an unmounted component.");
@@ -7471,11 +7815,11 @@ function findHostInstance(component) {
 }
 function updateContainer(element, container, parentComponent, callback) {
   var current = container.current,
-    currentTime = requestCurrentTimeForUpdate(),
-    suspenseConfig = ReactCurrentBatchConfig.suspense;
-  currentTime = computeExpirationForFiber(currentTime, current, suspenseConfig);
+    eventTime = requestEventTime(),
+    suspenseConfig = ReactCurrentBatchConfig.suspense,
+    lane = requestUpdateLane(current, suspenseConfig);
   a: if (parentComponent) {
-    parentComponent = parentComponent._reactInternalFiber;
+    parentComponent = parentComponent._reactInternals;
     b: {
       if (
         getNearestMountedFiber(parentComponent) !== parentComponent ||
@@ -7484,22 +7828,23 @@ function updateContainer(element, container, parentComponent, callback) {
         throw Error(
           "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
         );
-      var parentContext = parentComponent;
+      var JSCompiler_inline_result = parentComponent;
       do {
-        switch (parentContext.tag) {
+        switch (JSCompiler_inline_result.tag) {
           case 3:
-            parentContext = parentContext.stateNode.context;
+            JSCompiler_inline_result =
+              JSCompiler_inline_result.stateNode.context;
             break b;
           case 1:
-            if (isContextProvider(parentContext.type)) {
-              parentContext =
-                parentContext.stateNode
+            if (isContextProvider(JSCompiler_inline_result.type)) {
+              JSCompiler_inline_result =
+                JSCompiler_inline_result.stateNode
                   .__reactInternalMemoizedMergedChildContext;
               break b;
             }
         }
-        parentContext = parentContext.return;
-      } while (null !== parentContext);
+        JSCompiler_inline_result = JSCompiler_inline_result.return;
+      } while (null !== JSCompiler_inline_result);
       throw Error(
         "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
       );
@@ -7510,34 +7855,26 @@ function updateContainer(element, container, parentComponent, callback) {
         parentComponent = processChildContext(
           parentComponent,
           Component,
-          parentContext
+          JSCompiler_inline_result
         );
         break a;
       }
     }
-    parentComponent = parentContext;
+    parentComponent = JSCompiler_inline_result;
   } else parentComponent = emptyContextObject;
   null === container.context
     ? (container.context = parentComponent)
     : (container.pendingContext = parentComponent);
-  container = createUpdate(currentTime, suspenseConfig);
+  container = createUpdate(eventTime, lane, suspenseConfig);
   container.payload = { element: element };
   callback = void 0 === callback ? null : callback;
   null !== callback && (container.callback = callback);
   enqueueUpdate(current, container);
-  scheduleWork(current, currentTime);
-  return currentTime;
+  scheduleUpdateOnFiber(current, lane, eventTime);
+  return lane;
 }
-function createPortal(children, containerInfo, implementation) {
-  var key =
-    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
-  return {
-    $$typeof: REACT_PORTAL_TYPE,
-    key: null == key ? null : "" + key,
-    children: children,
-    containerInfo: containerInfo,
-    implementation: implementation
-  };
+function emptyFindFiberByHostInstance() {
+  return null;
 }
 function findNodeHandle(componentOrHandle) {
   if (null == componentOrHandle) return null;
@@ -7566,53 +7903,64 @@ batchedUpdatesImpl = function(fn, a) {
     return fn(a);
   } finally {
     (executionContext = prevExecutionContext),
-      executionContext === NoContext && flushSyncCallbackQueue();
+      0 === executionContext && flushSyncCallbackQueue();
   }
 };
-var roots = new Map();
-(function(devToolsConfig) {
-  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
-  return injectInternals({
-    bundleType: devToolsConfig.bundleType,
-    version: devToolsConfig.version,
-    rendererPackageName: devToolsConfig.rendererPackageName,
-    rendererConfig: devToolsConfig.rendererConfig,
-    overrideHookState: null,
-    overrideProps: null,
-    setSuspenseHandler: null,
-    scheduleUpdate: null,
-    currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
-    findHostInstanceByFiber: function(fiber) {
-      fiber = findCurrentHostFiber(fiber);
-      return null === fiber ? null : fiber.stateNode;
-    },
-    findFiberByHostInstance: function(instance) {
-      return findFiberByHostInstance ? findFiberByHostInstance(instance) : null;
-    },
-    findHostInstancesForRefresh: null,
-    scheduleRefresh: null,
-    scheduleRoot: null,
-    setRefreshHandler: null,
-    getCurrentFiber: null
-  });
-})({
-  findFiberByHostInstance: getInstanceFromTag,
-  bundleType: 0,
-  version: "16.13.0",
-  rendererPackageName: "react-native-renderer",
-  rendererConfig: {
-    getInspectorDataForViewTag: function() {
-      throw Error(
-        "getInspectorDataForViewTag() is not available in production"
-      );
-    },
-    getInspectorDataForViewAtPoint: function() {
-      throw Error(
-        "getInspectorDataForViewAtPoint() is not available in production."
-      );
-    }.bind(null, findNodeHandle)
-  }
-});
+var roots = new Map(),
+  devToolsConfig$jscomp$inline_934 = {
+    findFiberByHostInstance: getInstanceFromTag,
+    bundleType: 0,
+    version: "17.0.0-alpha.0",
+    rendererPackageName: "react-native-renderer",
+    rendererConfig: {
+      getInspectorDataForViewTag: function() {
+        throw Error(
+          "getInspectorDataForViewTag() is not available in production"
+        );
+      },
+      getInspectorDataForViewAtPoint: function() {
+        throw Error(
+          "getInspectorDataForViewAtPoint() is not available in production."
+        );
+      }.bind(null, findNodeHandle)
+    }
+  };
+var internals$jscomp$inline_1135 = {
+  bundleType: devToolsConfig$jscomp$inline_934.bundleType,
+  version: devToolsConfig$jscomp$inline_934.version,
+  rendererPackageName: devToolsConfig$jscomp$inline_934.rendererPackageName,
+  rendererConfig: devToolsConfig$jscomp$inline_934.rendererConfig,
+  overrideHookState: null,
+  overrideProps: null,
+  setSuspenseHandler: null,
+  scheduleUpdate: null,
+  currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
+  findHostInstanceByFiber: function(fiber) {
+    fiber = findCurrentHostFiber(fiber);
+    return null === fiber ? null : fiber.stateNode;
+  },
+  findFiberByHostInstance:
+    devToolsConfig$jscomp$inline_934.findFiberByHostInstance ||
+    emptyFindFiberByHostInstance,
+  findHostInstancesForRefresh: null,
+  scheduleRefresh: null,
+  scheduleRoot: null,
+  setRefreshHandler: null,
+  getCurrentFiber: null
+};
+if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
+  var hook$jscomp$inline_1136 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  if (
+    !hook$jscomp$inline_1136.isDisabled &&
+    hook$jscomp$inline_1136.supportsFiber
+  )
+    try {
+      (rendererID = hook$jscomp$inline_1136.inject(
+        internals$jscomp$inline_1135
+      )),
+        (injectedHook = hook$jscomp$inline_1136);
+    } catch (err) {}
+}
 exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {
   computeComponentStackForErrorReporting: function(reactTag) {
     return (reactTag = getInstanceFromTag(reactTag))
@@ -7659,7 +8007,7 @@ exports.render = function(element, containerTag, callback) {
   var root = roots.get(containerTag);
   if (!root) {
     root = new FiberRootNode(containerTag, 0, !1);
-    var uninitializedFiber = new FiberNode(3, null, null, 0);
+    var uninitializedFiber = createFiber(3, null, null, 0);
     root.current = uninitializedFiber;
     uninitializedFiber.stateNode = root;
     initializeUpdateQueue(uninitializedFiber);
diff --git a/node_modules/react-native/scripts/.packager.env b/node_modules/react-native/scripts/.packager.env
new file mode 100644
index 0000000..361f5fb
--- /dev/null
+++ b/node_modules/react-native/scripts/.packager.env
@@ -0,0 +1 @@
+export RCT_METRO_PORT=8081
