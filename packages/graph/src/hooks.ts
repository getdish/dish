// https://github.com/dai-shi/gqless-hook

import { Accessor, Client, accessorInterceptors, getAccessor } from 'gqless'
import {
  useCallback,
  useEffect,
  useLayoutEffect,
  useReducer,
  useRef,
} from 'react'

import { client } from './graphql'

const wrapperMap = new WeakMap<object, object>()

const isMutableObject = (x: unknown) => {
  try {
    return x !== null && typeof x === 'object' && !!getAccessor(x)
  } catch (e) {
    return false
  }
}

const proxyHandler = {
  get(target: object, property: string) {
    const value = Reflect.get(target, property)
    if (typeof value === 'function' && Array.isArray(target)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const arrayFunc = Array.prototype[property as any]
      // eslint-disable-next-line no-use-before-define, @typescript-eslint/no-use-before-define
      return arrayFunc.bind(wrapMutableObject(target))
    }
    if (typeof value === 'function' || isMutableObject(value)) {
      // eslint-disable-next-line no-use-before-define, @typescript-eslint/no-use-before-define
      return wrapMutableObject(value)
    }
    return value
  },
  apply(target: Function, thisArg: unknown, argsList: unknown[]) {
    const value = Reflect.apply(target, thisArg, argsList)
    if (typeof value === 'function' || isMutableObject(value)) {
      // eslint-disable-next-line no-use-before-define, @typescript-eslint/no-use-before-define
      return wrapMutableObject(value)
    }
    return value
  },
}

const wrapMutableObject = <T extends object>(obj: T): T => {
  let wrapper = wrapperMap.get(obj)
  if (!wrapper) {
    wrapper = new Proxy(obj, proxyHandler)
    wrapperMap.set(obj, wrapper)
  }
  return wrapper as T
}

const notifyMutation = (accessor: Accessor) => {
  if (accessor.data && typeof accessor.data === 'object') {
    const newWrapper = new Proxy(accessor.data, proxyHandler)
    wrapperMap.set(accessor.data, newWrapper)
  }
  if (accessor.parent) {
    notifyMutation(accessor.parent)
  }
}

const isSSR =
  typeof window === 'undefined' ||
  /ServerSideRendering/.test(window.navigator && window.navigator.userAgent)

const useIsomorphicLayoutEffect = isSSR
  ? (cb: () => void) => cb()
  : useLayoutEffect

// CM-safe timer-based cleanup hook
const useCleanup = () => {
  type Cleanup = {
    timer: NodeJS.Timeout
    func: () => void
  }
  const cleanups = useRef<Cleanup[]>([])
  const addCleanup = useCallback((func: () => void) => {
    const timer = setTimeout(func, 5 * 1000)
    cleanups.current.push({ timer, func })
  }, [])
  useEffect(() => {
    const cleanupsCurrent = cleanups.current
    cleanupsCurrent.forEach(({ timer }) => clearTimeout(timer))
    return () => {
      cleanupsCurrent.forEach(({ func }) => func())
    }
  }, [])
  return addCleanup
}

/**
 * useQuery
 *
 * This hook returns query from gqless.
 *
 * @example
 * import { useQuery } from 'gqless-hook';
 * import { client } from '../graphql'; // generated by @gqless/cli
 *
 * const Component = () => {
 *   const query = useQuery(client);
 *   return (
 *     <div>{query.foo}</div>
 *   );
 * };
 */
export const useQueryInner = (client: any) => {
  const addCleanup = useCleanup()

  const [, forceUpdate] = useReducer((c) => c + 1, 0)
  const fetching = useRef(false)
  if (fetching.current) {
    throw new Promise((resolve) => {
      client.scheduler.commit.onFetched.then(() => {
        fetching.current = false
        resolve()
      })
    })
  }
  useIsomorphicLayoutEffect(() => {
    if (client.scheduler.commit.accessors.size > 0) {
      fetching.current = true
      forceUpdate()
    }
  })

  type Callback = (prevData: unknown) => void
  const dataChangeCallbacks = useRef(new Map<Accessor, Callback>())
  const onAccessor = useCallback(
    (accessor: Accessor) => {
      let callback = dataChangeCallbacks.current.get(accessor)
      if (!callback) {
        callback = () => {
          notifyMutation(accessor)
          if (!fetching.current) {
            forceUpdate()
          }
        }
        dataChangeCallbacks.current.set(accessor, callback)
      }
      addCleanup(accessor.onDataChange(callback))
    },
    [addCleanup]
  )
  accessorInterceptors.add(onAccessor)
  const deleteInterceptorTimer = setTimeout(() => {
    accessorInterceptors.delete(onAccessor)
  }, 5 * 1000)
  useEffect(() => {
    clearTimeout(deleteInterceptorTimer)
    accessorInterceptors.delete(onAccessor)
  })

  return wrapMutableObject(client.query)
}
