import { TsickleHost } from 'tsickle'
import { moduleNameAsIdentifier } from 'tsickle/src/annotator_host'

/**
 * @fileoverview Transforms `import localName from "external_module"` to
 * `const localName = global_name_for_the_external_module`.
 * Also transforms `import tslib_any from 'tslib'` to `goog.require("tslib")`.
 */
import ITsccSpecWithTS from './spec/ITsccSpecWithTS'

export function getExternsForExternalModules(
  tsccSpec: ITsccSpecWithTS,
  tsickleHost: TsickleHost
): string {
  const moduleNames = tsccSpec.getExternalModuleNames()
  const toGlobalName = tsccSpec.getExternalModuleNamesToGlobalsMap()
  const header = `\n/** Generated by TSCC */`
  let out = ''
  for (let moduleName of moduleNames) {
    // If a module's type definition is from node_modules, its path is used as a namespace.
    // otherwise, it comes from declare module '...' in user-provided files, in which the module name string
    // is used as a namespace.
    let typeRefFile =
      tsccSpec.resolveExternalModuleTypeReference(moduleName) || moduleName
    out += `
/**
 * @type{${moduleNameAsIdentifier(tsickleHost, typeRefFile)}}
 * @const
 */
${tsickleHost.es5Mode ? 'var' : 'const'} ${toGlobalName[moduleName]} = {};\n`
  }
  if (out.length) out = header + out
  return out
}

export function getGluingModules(
  tsccSpec: ITsccSpecWithTS,
  tsickleHost: TsickleHost
) {
  const moduleNames = tsccSpec.getExternalModuleNames()
  const toGlobalName = tsccSpec.getExternalModuleNamesToGlobalsMap()
  const out: { path: string; content: string }[] = []
  for (let moduleName of moduleNames) {
    const content =
      `goog.module('${moduleName.replace(/([\\'])/g, '\\$1')}')\n` +
      `/** Generated by TSCC */\n` +
      `exports = ${toGlobalName[moduleName]};`
    // A hypothetical path of this gluing module.
    let path =
      tsccSpec.resolveExternalModuleTypeReference(moduleName) || moduleName
    path = path.replace(/(?:\.d)?\.ts$/, '.js')
    out.push({ path, content })
  }
  return out
}
