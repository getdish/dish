diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
index d837754..c88a74b 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
@@ -6,7 +6,6 @@
  *
  * @noflow
  * @nolint
- * @providesModule ReactNativeRenderer-dev
  * @preventMunge
  * @generated
  */
@@ -24,21 +23,7 @@ var Scheduler = require("scheduler");
 var tracing = require("scheduler/tracing");
 
 var ReactSharedInternals =
-  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // Prevent newer renderers from RTE when used with older react package versions.
-// Current owner and dispatcher used to share the same ref,
-// but PR #14548 split them out to better support the react-debug-tools package.
-
-if (!ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher")) {
-  ReactSharedInternals.ReactCurrentDispatcher = {
-    current: null
-  };
-}
-
-if (!ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig")) {
-  ReactSharedInternals.ReactCurrentBatchConfig = {
-    suspense: null
-  };
-}
+  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
 
 // by calls to these methods by a Babel plugin.
 //
@@ -80,19 +65,12 @@ function printWarning(level, format, args) {
   // When changing this logic, you might want to also
   // update consoleWithStackDev.www.js as well.
   {
-    var hasExistingStack =
-      args.length > 0 &&
-      typeof args[args.length - 1] === "string" &&
-      args[args.length - 1].indexOf("\n    in") === 0;
+    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+    var stack = ReactDebugCurrentFrame.getStackAddendum();
 
-    if (!hasExistingStack) {
-      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
-      var stack = ReactDebugCurrentFrame.getStackAddendum();
-
-      if (stack !== "") {
-        format += "%s";
-        args = args.concat([stack]);
-      }
+    if (stack !== "") {
+      format += "%s";
+      args = args.concat([stack]);
     }
 
     var argsWithFormat = args.map(function(item) {
@@ -104,161 +82,10 @@ function printWarning(level, format, args) {
     // eslint-disable-next-line react-internal/no-production-logging
 
     Function.prototype.apply.call(console[level], console, argsWithFormat);
-
-    try {
-      // --- Welcome to debugging React ---
-      // This error was thrown as a convenience so that you can use this stack
-      // to find the callsite that caused this warning to fire.
-      var argIndex = 0;
-      var message =
-        "Warning: " +
-        format.replace(/%s/g, function() {
-          return args[argIndex++];
-        });
-      throw new Error(message);
-    } catch (x) {}
-  }
-}
-
-var FunctionComponent = 0;
-var ClassComponent = 1;
-var IndeterminateComponent = 2; // Before we know whether it is function or class
-
-var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
-
-var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
-
-var HostComponent = 5;
-var HostText = 6;
-var Fragment = 7;
-var Mode = 8;
-var ContextConsumer = 9;
-var ContextProvider = 10;
-var ForwardRef = 11;
-var Profiler = 12;
-var SuspenseComponent = 13;
-var MemoComponent = 14;
-var SimpleMemoComponent = 15;
-var LazyComponent = 16;
-var IncompleteClassComponent = 17;
-var DehydratedFragment = 18;
-var SuspenseListComponent = 19;
-var FundamentalComponent = 20;
-var ScopeComponent = 21;
-var Block = 22;
-
-function getParent(inst) {
-  do {
-    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
-    // That is depending on if we want nested subtrees (layers) to bubble
-    // events to their parent. We could also go through parentNode on the
-    // host node but that wouldn't work for React Native and doesn't let us
-    // do the portal feature.
-  } while (inst && inst.tag !== HostComponent);
-
-  if (inst) {
-    return inst;
-  }
-
-  return null;
-}
-/**
- * Return the lowest common ancestor of A and B, or null if they are in
- * different trees.
- */
-
-function getLowestCommonAncestor(instA, instB) {
-  var depthA = 0;
-
-  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
-    depthA++;
-  }
-
-  var depthB = 0;
-
-  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
-    depthB++;
-  } // If A is deeper, crawl up.
-
-  while (depthA - depthB > 0) {
-    instA = getParent(instA);
-    depthA--;
-  } // If B is deeper, crawl up.
-
-  while (depthB - depthA > 0) {
-    instB = getParent(instB);
-    depthB--;
-  } // Walk in lockstep until we find a match.
-
-  var depth = depthA;
-
-  while (depth--) {
-    if (instA === instB || instA === instB.alternate) {
-      return instA;
-    }
-
-    instA = getParent(instA);
-    instB = getParent(instB);
-  }
-
-  return null;
-}
-/**
- * Return if A is an ancestor of B.
- */
-
-function isAncestor(instA, instB) {
-  while (instB) {
-    if (instA === instB || instA === instB.alternate) {
-      return true;
-    }
-
-    instB = getParent(instB);
-  }
-
-  return false;
-}
-/**
- * Return the parent instance of the passed-in instance.
- */
-
-function getParentInstance(inst) {
-  return getParent(inst);
-}
-/**
- * Simulates the traversal of a two-phase, capture/bubble event dispatch.
- */
-
-function traverseTwoPhase(inst, fn, arg) {
-  var path = [];
-
-  while (inst) {
-    path.push(inst);
-    inst = getParent(inst);
-  }
-
-  var i;
-
-  for (i = path.length; i-- > 0; ) {
-    fn(path[i], "captured", arg);
-  }
-
-  for (i = 0; i < path.length; i++) {
-    fn(path[i], "bubbled", arg);
   }
 }
 
-var invokeGuardedCallbackImpl = function(
-  name,
-  func,
-  context,
-  a,
-  b,
-  c,
-  d,
-  e,
-  f
-) {
+function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
   var funcArgs = Array.prototype.slice.call(arguments, 3);
 
   try {
@@ -266,7 +93,9 @@ var invokeGuardedCallbackImpl = function(
   } catch (error) {
     this.onError(error);
   }
-};
+}
+
+var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
 
 {
   // In DEV mode, we swap out invokeGuardedCallback for a special version
@@ -297,7 +126,7 @@ var invokeGuardedCallbackImpl = function(
   ) {
     var fakeNode = document.createElement("react");
 
-    var invokeGuardedCallbackDev = function(
+    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(
       name,
       func,
       context,
@@ -318,7 +147,8 @@ var invokeGuardedCallbackImpl = function(
         );
       }
 
-      var evt = document.createEvent("Event"); // Keeps track of whether the user-provided callback threw an error. We
+      var evt = document.createEvent("Event");
+      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
       // set this to true at the beginning, then set it to false right after
       // calling the function. If the function errors, `didError` will never be
       // set to false. This strategy works even if the browser is flaky and
@@ -335,13 +165,9 @@ var invokeGuardedCallbackImpl = function(
       var windowEventDescriptor = Object.getOwnPropertyDescriptor(
         window,
         "event"
-      ); // Create an event handler for our fake event. We will synchronously
-      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
-      // call the user-provided callback.
-
-      var funcArgs = Array.prototype.slice.call(arguments, 3);
+      );
 
-      function callCallback() {
+      function restoreAfterDispatch() {
         // We immediately remove the callback from event listeners so that
         // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
         // nested call would trigger the fake event handlers of any call higher
@@ -357,7 +183,15 @@ var invokeGuardedCallbackImpl = function(
         ) {
           window.event = windowEvent;
         }
+      } // Create an event handler for our fake event. We will synchronously
+      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
+      // call the user-provided callback.
+
+      var funcArgs = Array.prototype.slice.call(arguments, 3);
 
+      function callCallback() {
+        didCall = true;
+        restoreAfterDispatch();
         func.apply(context, funcArgs);
         didError = false;
       } // Create a global error event handler. We use this to capture the value
@@ -412,7 +246,7 @@ var invokeGuardedCallbackImpl = function(
         Object.defineProperty(window, "event", windowEventDescriptor);
       }
 
-      if (didError) {
+      if (didCall && didError) {
         if (!didSetError) {
           // The callback errored, but the error event never fired.
           error = new Error(
@@ -437,9 +271,16 @@ var invokeGuardedCallbackImpl = function(
       } // Remove our event listeners
 
       window.removeEventListener("error", handleWindowError);
-    };
 
-    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
+      if (!didCall) {
+        // Something went really wrong, and our event was not dispatched.
+        // https://github.com/facebook/react/issues/16734
+        // https://github.com/facebook/react/issues/16585
+        // Fall back to the production implementation.
+        restoreAfterDispatch();
+        return invokeGuardedCallbackProd.apply(this, arguments);
+      }
+    };
   }
 }
 
@@ -708,293 +549,53 @@ function hasDispatches(event) {
   return !!event._dispatchListeners;
 }
 
-function isInteractive(tag) {
-  return (
-    tag === "button" ||
-    tag === "input" ||
-    tag === "select" ||
-    tag === "textarea"
-  );
-}
-
-function shouldPreventMouseEvent(name, type, props) {
-  switch (name) {
-    case "onClick":
-    case "onClickCapture":
-    case "onDoubleClick":
-    case "onDoubleClickCapture":
-    case "onMouseDown":
-    case "onMouseDownCapture":
-    case "onMouseMove":
-    case "onMouseMoveCapture":
-    case "onMouseUp":
-    case "onMouseUpCapture":
-    case "onMouseEnter":
-      return !!(props.disabled && isInteractive(type));
-
-    default:
-      return false;
-  }
-}
+var EVENT_POOL_SIZE = 10;
 /**
- * @param {object} inst The instance, which is the source of events.
- * @param {string} registrationName Name of listener (e.g. `onClick`).
- * @return {?function} The stored callback.
+ * @interface Event
+ * @see http://www.w3.org/TR/DOM-Level-3-Events/
  */
 
-function getListener(inst, registrationName) {
-  var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
-  // live here; needs to be moved to a better place soon
-
-  var stateNode = inst.stateNode;
-
-  if (!stateNode) {
-    // Work in progress (ex: onload events in incremental mode).
-    return null;
-  }
-
-  var props = getFiberCurrentPropsFromNode(stateNode);
-
-  if (!props) {
-    // Work in progress.
-    return null;
-  }
-
-  listener = props[registrationName];
-
-  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
+var EventInterface = {
+  type: null,
+  target: null,
+  // currentTarget is set when dispatching; no use in copying it here
+  currentTarget: function() {
     return null;
-  }
-
-  if (!(!listener || typeof listener === "function")) {
-    throw Error(
-      "Expected `" +
-        registrationName +
-        "` listener to be a function, instead got a value of `" +
-        typeof listener +
-        "` type."
-    );
-  }
+  },
+  eventPhase: null,
+  bubbles: null,
+  cancelable: null,
+  timeStamp: function(event) {
+    return event.timeStamp || Date.now();
+  },
+  defaultPrevented: null,
+  isTrusted: null
+};
 
-  return listener;
+function functionThatReturnsTrue() {
+  return true;
 }
 
+function functionThatReturnsFalse() {
+  return false;
+}
 /**
- * Accumulates items that must not be null or undefined into the first one. This
- * is used to conserve memory by avoiding array allocations, and thus sacrifices
- * API cleanness. Since `current` can be null before being passed in and not
- * null after this function, make sure to assign it back to `current`:
+ * Synthetic events are dispatched by event plugins, typically in response to a
+ * top-level event delegation handler.
  *
- * `a = accumulateInto(a, b);`
+ * These systems should generally use pooling to reduce the frequency of garbage
+ * collection. The system should check `isPersistent` to determine whether the
+ * event should be released into the pool after being dispatched. Users that
+ * need a persisted event should invoke `persist`.
  *
- * This API should be sparingly used. Try `accumulate` for something cleaner.
+ * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
+ * normalizing browser quirks. Subclasses do not necessarily have to implement a
+ * DOM interface; custom application-specific events can also subclass this.
  *
- * @return {*|array<*>} An accumulation of items.
- */
-
-function accumulateInto(current, next) {
-  if (!(next != null)) {
-    throw Error(
-      "accumulateInto(...): Accumulated items must not be null or undefined."
-    );
-  }
-
-  if (current == null) {
-    return next;
-  } // Both are not empty. Warning: Never call x.concat(y) when you are not
-  // certain that x is an Array (x could be a string with concat method).
-
-  if (Array.isArray(current)) {
-    if (Array.isArray(next)) {
-      current.push.apply(current, next);
-      return current;
-    }
-
-    current.push(next);
-    return current;
-  }
-
-  if (Array.isArray(next)) {
-    // A bit too dangerous to mutate `next`.
-    return [current].concat(next);
-  }
-
-  return [current, next];
-}
-
-/**
- * @param {array} arr an "accumulation" of items which is either an Array or
- * a single item. Useful when paired with the `accumulate` module. This is a
- * simple utility that allows us to reason about a collection of items, but
- * handling the case when there is exactly one item (and we do not need to
- * allocate an array).
- * @param {function} cb Callback invoked with each element or a collection.
- * @param {?} [scope] Scope used as `this` in a callback.
- */
-function forEachAccumulated(arr, cb, scope) {
-  if (Array.isArray(arr)) {
-    arr.forEach(cb, scope);
-  } else if (arr) {
-    cb.call(scope, arr);
-  }
-}
-
-/**
- * Some event types have a notion of different registration names for different
- * "phases" of propagation. This finds listeners by a given phase.
- */
-function listenerAtPhase(inst, event, propagationPhase) {
-  var registrationName =
-    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
-  return getListener(inst, registrationName);
-}
-/**
- * A small set of propagation patterns, each of which will accept a small amount
- * of information, and generate a set of "dispatch ready event objects" - which
- * are sets of events that have already been annotated with a set of dispatched
- * listener functions/ids. The API is designed this way to discourage these
- * propagation strategies from actually executing the dispatches, since we
- * always want to collect the entire set of dispatches before executing even a
- * single one.
- */
-
-/**
- * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
- * here, allows us to not have to bind or create functions for each event.
- * Mutating the event's members allows us to not have to create a wrapping
- * "dispatch" object that pairs the event with the listener.
- */
-
-function accumulateDirectionalDispatches(inst, phase, event) {
-  {
-    if (!inst) {
-      error("Dispatching inst must not be null");
-    }
-  }
-
-  var listener = listenerAtPhase(inst, event, phase);
-
-  if (listener) {
-    event._dispatchListeners = accumulateInto(
-      event._dispatchListeners,
-      listener
-    );
-    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
-  }
-}
-/**
- * Collect dispatches (must be entirely collected before dispatching - see unit
- * tests). Lazily allocate the array to conserve memory.  We must loop through
- * each event and perform the traversal for each one. We cannot perform a
- * single traversal for the entire collection of events because each event may
- * have a different target.
- */
-
-function accumulateTwoPhaseDispatchesSingle(event) {
-  if (event && event.dispatchConfig.phasedRegistrationNames) {
-    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
-  }
-}
-/**
- * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
- */
-
-function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
-  if (event && event.dispatchConfig.phasedRegistrationNames) {
-    var targetInst = event._targetInst;
-    var parentInst = targetInst ? getParentInstance(targetInst) : null;
-    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
-  }
-}
-/**
- * Accumulates without regard to direction, does not look for phased
- * registration names. Same as `accumulateDirectDispatchesSingle` but without
- * requiring that the `dispatchMarker` be the same as the dispatched ID.
- */
-
-function accumulateDispatches(inst, ignoredDirection, event) {
-  if (inst && event && event.dispatchConfig.registrationName) {
-    var registrationName = event.dispatchConfig.registrationName;
-    var listener = getListener(inst, registrationName);
-
-    if (listener) {
-      event._dispatchListeners = accumulateInto(
-        event._dispatchListeners,
-        listener
-      );
-      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
-    }
-  }
-}
-/**
- * Accumulates dispatches on an `SyntheticEvent`, but only for the
- * `dispatchMarker`.
- * @param {SyntheticEvent} event
- */
-
-function accumulateDirectDispatchesSingle(event) {
-  if (event && event.dispatchConfig.registrationName) {
-    accumulateDispatches(event._targetInst, null, event);
-  }
-}
-
-function accumulateTwoPhaseDispatches(events) {
-  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
-}
-function accumulateTwoPhaseDispatchesSkipTarget(events) {
-  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
-}
-function accumulateDirectDispatches(events) {
-  forEachAccumulated(events, accumulateDirectDispatchesSingle);
-}
-
-var EVENT_POOL_SIZE = 10;
-/**
- * @interface Event
- * @see http://www.w3.org/TR/DOM-Level-3-Events/
- */
-
-var EventInterface = {
-  type: null,
-  target: null,
-  // currentTarget is set when dispatching; no use in copying it here
-  currentTarget: function() {
-    return null;
-  },
-  eventPhase: null,
-  bubbles: null,
-  cancelable: null,
-  timeStamp: function(event) {
-    return event.timeStamp || Date.now();
-  },
-  defaultPrevented: null,
-  isTrusted: null
-};
-
-function functionThatReturnsTrue() {
-  return true;
-}
-
-function functionThatReturnsFalse() {
-  return false;
-}
-/**
- * Synthetic events are dispatched by event plugins, typically in response to a
- * top-level event delegation handler.
- *
- * These systems should generally use pooling to reduce the frequency of garbage
- * collection. The system should check `isPersistent` to determine whether the
- * event should be released into the pool after being dispatched. Users that
- * need a persisted event should invoke `persist`.
- *
- * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
- * normalizing browser quirks. Subclasses do not necessarily have to implement a
- * DOM interface; custom application-specific events can also subclass this.
- *
- * @param {object} dispatchConfig Configuration used to dispatch this event.
- * @param {*} targetInst Marker identifying the event target.
- * @param {object} nativeEvent Native browser event.
- * @param {DOMEventTarget} nativeEventTarget Target node.
+ * @param {object} dispatchConfig Configuration used to dispatch this event.
+ * @param {*} targetInst Marker identifying the event target.
+ * @param {object} nativeEvent Native browser event.
+ * @param {DOMEventTarget} nativeEventTarget Target node.
  */
 
 function SyntheticEvent(
@@ -1015,6 +616,8 @@ function SyntheticEvent(
   this.dispatchConfig = dispatchConfig;
   this._targetInst = targetInst;
   this.nativeEvent = nativeEvent;
+  this._dispatchListeners = null;
+  this._dispatchInstances = null;
   var Interface = this.constructor.Interface;
 
   for (var propName in Interface) {
@@ -1240,7 +843,12 @@ function getPooledWarningPropertyDefinition(propName, getVal) {
   }
 }
 
-function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
+function createOrGetPooledEvent(
+  dispatchConfig,
+  targetInst,
+  nativeEvent,
+  nativeInst
+) {
   var EventConstructor = this;
 
   if (EventConstructor.eventPool.length) {
@@ -1280,8 +888,8 @@ function releasePooledEvent(event) {
 }
 
 function addEventPoolingTo(EventConstructor) {
+  EventConstructor.getPooled = createOrGetPooledEvent;
   EventConstructor.eventPool = [];
-  EventConstructor.getPooled = getPooledEvent;
   EventConstructor.release = releasePooledEvent;
 }
 
@@ -1547,63 +1155,152 @@ function accumulate(current, next) {
 }
 
 /**
- * Instance of element that should respond to touch/move types of interactions,
- * as indicated explicitly by relevant callbacks.
+ * Accumulates items that must not be null or undefined into the first one. This
+ * is used to conserve memory by avoiding array allocations, and thus sacrifices
+ * API cleanness. Since `current` can be null before being passed in and not
+ * null after this function, make sure to assign it back to `current`:
+ *
+ * `a = accumulateInto(a, b);`
+ *
+ * This API should be sparingly used. Try `accumulate` for something cleaner.
+ *
+ * @return {*|array<*>} An accumulation of items.
  */
 
-var responderInst = null;
-/**
- * Count of current touches. A textInput should become responder iff the
- * selection changes while there is a touch on the screen.
- */
+function accumulateInto(current, next) {
+  if (!(next != null)) {
+    throw Error(
+      "accumulateInto(...): Accumulated items must not be null or undefined."
+    );
+  }
 
-var trackedTouchCount = 0;
+  if (current == null) {
+    return next;
+  } // Both are not empty. Warning: Never call x.concat(y) when you are not
+  // certain that x is an Array (x could be a string with concat method).
 
-var changeResponder = function(nextResponderInst, blockHostResponder) {
-  var oldResponderInst = responderInst;
-  responderInst = nextResponderInst;
+  if (Array.isArray(current)) {
+    if (Array.isArray(next)) {
+      current.push.apply(current, next);
+      return current;
+    }
 
-  if (ResponderEventPlugin.GlobalResponderHandler !== null) {
-    ResponderEventPlugin.GlobalResponderHandler.onChange(
-      oldResponderInst,
-      nextResponderInst,
-      blockHostResponder
-    );
+    current.push(next);
+    return current;
   }
-};
 
-var eventTypes = {
-  /**
-   * On a `touchStart`/`mouseDown`, is it desired that this element become the
-   * responder?
-   */
-  startShouldSetResponder: {
-    phasedRegistrationNames: {
-      bubbled: "onStartShouldSetResponder",
-      captured: "onStartShouldSetResponderCapture"
-    },
-    dependencies: startDependencies
-  },
+  if (Array.isArray(next)) {
+    // A bit too dangerous to mutate `next`.
+    return [current].concat(next);
+  }
 
-  /**
-   * On a `scroll`, is it desired that this element become the responder? This
-   * is usually not needed, but should be used to retroactively infer that a
-   * `touchStart` had occurred during momentum scroll. During a momentum scroll,
-   * a touch start will be immediately followed by a scroll event if the view is
-   * currently scrolling.
-   *
-   * TODO: This shouldn't bubble.
-   */
-  scrollShouldSetResponder: {
-    phasedRegistrationNames: {
-      bubbled: "onScrollShouldSetResponder",
-      captured: "onScrollShouldSetResponderCapture"
-    },
-    dependencies: [TOP_SCROLL]
-  },
+  return [current, next];
+}
 
-  /**
-   * On text selection change, should this element become the responder? This
+/**
+ * @param {array} arr an "accumulation" of items which is either an Array or
+ * a single item. Useful when paired with the `accumulate` module. This is a
+ * simple utility that allows us to reason about a collection of items, but
+ * handling the case when there is exactly one item (and we do not need to
+ * allocate an array).
+ * @param {function} cb Callback invoked with each element or a collection.
+ * @param {?} [scope] Scope used as `this` in a callback.
+ */
+function forEachAccumulated(arr, cb, scope) {
+  if (Array.isArray(arr)) {
+    arr.forEach(cb, scope);
+  } else if (arr) {
+    cb.call(scope, arr);
+  }
+}
+
+var FunctionComponent = 0;
+var ClassComponent = 1;
+var IndeterminateComponent = 2; // Before we know whether it is function or class
+
+var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
+
+var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
+
+var HostComponent = 5;
+var HostText = 6;
+var Fragment = 7;
+var Mode = 8;
+var ContextConsumer = 9;
+var ContextProvider = 10;
+var ForwardRef = 11;
+var Profiler = 12;
+var SuspenseComponent = 13;
+var MemoComponent = 14;
+var SimpleMemoComponent = 15;
+var LazyComponent = 16;
+var IncompleteClassComponent = 17;
+var DehydratedFragment = 18;
+var SuspenseListComponent = 19;
+var FundamentalComponent = 20;
+var ScopeComponent = 21;
+var Block = 22;
+var OffscreenComponent = 23;
+var LegacyHiddenComponent = 24;
+
+/**
+ * Instance of element that should respond to touch/move types of interactions,
+ * as indicated explicitly by relevant callbacks.
+ */
+
+var responderInst = null;
+/**
+ * Count of current touches. A textInput should become responder iff the
+ * selection changes while there is a touch on the screen.
+ */
+
+var trackedTouchCount = 0;
+
+var changeResponder = function(nextResponderInst, blockHostResponder) {
+  var oldResponderInst = responderInst;
+  responderInst = nextResponderInst;
+
+  if (ResponderEventPlugin.GlobalResponderHandler !== null) {
+    ResponderEventPlugin.GlobalResponderHandler.onChange(
+      oldResponderInst,
+      nextResponderInst,
+      blockHostResponder
+    );
+  }
+};
+
+var eventTypes = {
+  /**
+   * On a `touchStart`/`mouseDown`, is it desired that this element become the
+   * responder?
+   */
+  startShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onStartShouldSetResponder",
+      captured: "onStartShouldSetResponderCapture"
+    },
+    dependencies: startDependencies
+  },
+
+  /**
+   * On a `scroll`, is it desired that this element become the responder? This
+   * is usually not needed, but should be used to retroactively infer that a
+   * `touchStart` had occurred during momentum scroll. During a momentum scroll,
+   * a touch start will be immediately followed by a scroll event if the view is
+   * currently scrolling.
+   *
+   * TODO: This shouldn't bubble.
+   */
+  scrollShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onScrollShouldSetResponder",
+      captured: "onScrollShouldSetResponderCapture"
+    },
+    dependencies: [TOP_SCROLL]
+  },
+
+  /**
+   * On text selection change, should this element become the responder? This
    * is needed for text inputs or other views with native selection, so the
    * JS view can claim the responder.
    *
@@ -1664,360 +1361,568 @@ var eventTypes = {
     registrationName: "onResponderTerminate",
     dependencies: []
   }
-};
+}; // Start of inline: the below functions were inlined from
+// EventPropagator.js, as they deviated from ReactDOM's newer
+// implementations.
+
+function getParent(inst) {
+  do {
+    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
+    // That is depending on if we want nested subtrees (layers) to bubble
+    // events to their parent. We could also go through parentNode on the
+    // host node but that wouldn't work for React Native and doesn't let us
+    // do the portal feature.
+  } while (inst && inst.tag !== HostComponent);
+
+  if (inst) {
+    return inst;
+  }
+
+  return null;
+}
 /**
- *
- * Responder System:
- * ----------------
- *
- * - A global, solitary "interaction lock" on a view.
- * - If a node becomes the responder, it should convey visual feedback
- *   immediately to indicate so, either by highlighting or moving accordingly.
- * - To be the responder means, that touches are exclusively important to that
- *   responder view, and no other view.
- * - While touches are still occurring, the responder lock can be transferred to
- *   a new view, but only to increasingly "higher" views (meaning ancestors of
- *   the current responder).
- *
- * Responder being granted:
- * ------------------------
- *
- * - Touch starts, moves, and scrolls can cause an ID to become the responder.
- * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to
- *   the "appropriate place".
- * - If nothing is currently the responder, the "appropriate place" is the
- *   initiating event's `targetID`.
- * - If something *is* already the responder, the "appropriate place" is the
- *   first common ancestor of the event target and the current `responderInst`.
- * - Some negotiation happens: See the timing diagram below.
- * - Scrolled views automatically become responder. The reasoning is that a
- *   platform scroll view that isn't built on top of the responder system has
- *   began scrolling, and the active responder must now be notified that the
- *   interaction is no longer locked to it - the system has taken over.
- *
- * - Responder being released:
- *   As soon as no more touches that *started* inside of descendants of the
- *   *current* responderInst, an `onResponderRelease` event is dispatched to the
- *   current responder, and the responder lock is released.
- *
- * TODO:
- * - on "end", a callback hook for `onResponderEndShouldRemainResponder` that
- *   determines if the responder lock should remain.
- * - If a view shouldn't "remain" the responder, any active touches should by
- *   default be considered "dead" and do not influence future negotiations or
- *   bubble paths. It should be as if those touches do not exist.
- * -- For multitouch: Usually a translate-z will choose to "remain" responder
- *  after one out of many touches ended. For translate-y, usually the view
- *  doesn't wish to "remain" responder after one of many touches end.
- * - Consider building this on top of a `stopPropagation` model similar to
- *   `W3C` events.
- * - Ensure that `onResponderTerminate` is called on touch cancels, whether or
- *   not `onResponderTerminationRequest` returns `true` or `false`.
- *
+ * Return the lowest common ancestor of A and B, or null if they are in
+ * different trees.
  */
 
-/*                                             Negotiation Performed
-                                             +-----------------------+
-                                            /                         \
-Process low level events to    +     Current Responder      +   wantsResponderID
-determine who to perform negot-|   (if any exists at all)   |
-iation/transition              | Otherwise just pass through|
--------------------------------+----------------------------+------------------+
-Bubble to find first ID        |                            |
-to return true:wantsResponderID|                            |
-                               |                            |
-     +-------------+           |                            |
-     | onTouchStart|           |                            |
-     +------+------+     none  |                            |
-            |            return|                            |
-+-----------v-------------+true| +------------------------+ |
-|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+
-+-----------+-------------+    | +------------------------+ |          |
-            |                  |                            | +--------+-------+
-            | returned true for|       false:REJECT +-------->|onResponderReject
-            | wantsResponderID |                    |       | +----------------+
-            | (now attempt     | +------------------+-----+ |
-            |  handoff)        | |   onResponder          | |
-            +------------------->|      TerminationRequest| |
-                               | +------------------+-----+ |
-                               |                    |       | +----------------+
-                               |         true:GRANT +-------->|onResponderGrant|
-                               |                            | +--------+-------+
-                               | +------------------------+ |          |
-                               | |   onResponderTerminate |<-----------+
-                               | +------------------+-----+ |
-                               |                    |       | +----------------+
-                               |                    +-------->|onResponderStart|
-                               |                            | +----------------+
-Bubble to find first ID        |                            |
-to return true:wantsResponderID|                            |
-                               |                            |
-     +-------------+           |                            |
-     | onTouchMove |           |                            |
-     +------+------+     none  |                            |
-            |            return|                            |
-+-----------v-------------+true| +------------------------+ |
-|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+
-+-----------+-------------+    | +------------------------+ |          |
-            |                  |                            | +--------+-------+
-            | returned true for|       false:REJECT +-------->|onResponderRejec|
-            | wantsResponderID |                    |       | +----------------+
-            | (now attempt     | +------------------+-----+ |
-            |  handoff)        | |   onResponder          | |
-            +------------------->|      TerminationRequest| |
-                               | +------------------+-----+ |
-                               |                    |       | +----------------+
-                               |         true:GRANT +-------->|onResponderGrant|
-                               |                            | +--------+-------+
-                               | +------------------------+ |          |
-                               | |   onResponderTerminate |<-----------+
-                               | +------------------+-----+ |
-                               |                    |       | +----------------+
-                               |                    +-------->|onResponderMove |
-                               |                            | +----------------+
-                               |                            |
-                               |                            |
-      Some active touch started|                            |
-      inside current responder | +------------------------+ |
-      +------------------------->|      onResponderEnd    | |
-      |                        | +------------------------+ |
-  +---+---------+              |                            |
-  | onTouchEnd  |              |                            |
-  +---+---------+              |                            |
-      |                        | +------------------------+ |
-      +------------------------->|     onResponderEnd     | |
-      No active touches started| +-----------+------------+ |
-      inside current responder |             |              |
-                               |             v              |
-                               | +------------------------+ |
-                               | |    onResponderRelease  | |
-                               | +------------------------+ |
-                               |                            |
-                               +                            + */
+function getLowestCommonAncestor(instA, instB) {
+  var depthA = 0;
 
-/**
- * A note about event ordering in the `EventPluginRegistry`.
- *
- * Suppose plugins are injected in the following order:
- *
- * `[R, S, C]`
- *
- * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for
- * `onClick` etc) and `R` is `ResponderEventPlugin`.
- *
- * "Deferred-Dispatched Events":
- *
- * - The current event plugin system will traverse the list of injected plugins,
- *   in order, and extract events by collecting the plugin's return value of
- *   `extractEvents()`.
- * - These events that are returned from `extractEvents` are "deferred
- *   dispatched events".
- * - When returned from `extractEvents`, deferred-dispatched events contain an
- *   "accumulation" of deferred dispatches.
- * - These deferred dispatches are accumulated/collected before they are
- *   returned, but processed at a later time by the `EventPluginRegistry` (hence the
- *   name deferred).
- *
- * In the process of returning their deferred-dispatched events, event plugins
- * themselves can dispatch events on-demand without returning them from
- * `extractEvents`. Plugins might want to do this, so that they can use event
- * dispatching as a tool that helps them decide which events should be extracted
- * in the first place.
- *
- * "On-Demand-Dispatched Events":
- *
- * - On-demand-dispatched events are not returned from `extractEvents`.
- * - On-demand-dispatched events are dispatched during the process of returning
- *   the deferred-dispatched events.
- * - They should not have side effects.
- * - They should be avoided, and/or eventually be replaced with another
- *   abstraction that allows event plugins to perform multiple "rounds" of event
- *   extraction.
- *
- * Therefore, the sequence of event dispatches becomes:
- *
- * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)
- * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)
- * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)
- * - `R`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
- * - `S`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
- * - `C`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
- *
- * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`
- * on-demand dispatch returns `true` (and some other details are satisfied) the
- * `onResponderGrant` deferred dispatched event is returned from
- * `extractEvents`. The sequence of dispatch executions in this case
- * will appear as follows:
- *
- * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)
- * - `touchStartCapture`       (`EventPluginRegistry` dispatches as usual)
- * - `touchStart`              (`EventPluginRegistry` dispatches as usual)
- * - `responderGrant/Reject`   (`EventPluginRegistry` dispatches as usual)
- */
+  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
+    depthA++;
+  }
 
-function setResponderAndExtractTransfer(
-  topLevelType,
-  targetInst,
-  nativeEvent,
-  nativeEventTarget
-) {
-  var shouldSetEventType = isStartish(topLevelType)
-    ? eventTypes.startShouldSetResponder
-    : isMoveish(topLevelType)
-    ? eventTypes.moveShouldSetResponder
-    : topLevelType === TOP_SELECTION_CHANGE
-    ? eventTypes.selectionChangeShouldSetResponder
-    : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.
+  var depthB = 0;
 
-  var bubbleShouldSetFrom = !responderInst
-    ? targetInst
-    : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the "shouldSet" event, we want to skip the target
-  // (deepest ID) if it happens to be the current responder. The reasoning:
-  // It's strange to get an `onMoveShouldSetResponder` when you're *already*
-  // the responder.
+  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
+    depthB++;
+  } // If A is deeper, crawl up.
 
-  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
-  var shouldSetEvent = ResponderSyntheticEvent.getPooled(
-    shouldSetEventType,
-    bubbleShouldSetFrom,
-    nativeEvent,
-    nativeEventTarget
-  );
-  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+  while (depthA - depthB > 0) {
+    instA = getParent(instA);
+    depthA--;
+  } // If B is deeper, crawl up.
 
-  if (skipOverBubbleShouldSetFrom) {
-    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
-  } else {
-    accumulateTwoPhaseDispatches(shouldSetEvent);
-  }
+  while (depthB - depthA > 0) {
+    instB = getParent(instB);
+    depthB--;
+  } // Walk in lockstep until we find a match.
 
-  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
+  var depth = depthA;
 
-  if (!shouldSetEvent.isPersistent()) {
-    shouldSetEvent.constructor.release(shouldSetEvent);
-  }
+  while (depth--) {
+    if (instA === instB || instA === instB.alternate) {
+      return instA;
+    }
 
-  if (!wantsResponderInst || wantsResponderInst === responderInst) {
-    return null;
+    instA = getParent(instA);
+    instB = getParent(instB);
   }
 
-  var extracted;
-  var grantEvent = ResponderSyntheticEvent.getPooled(
-    eventTypes.responderGrant,
-    wantsResponderInst,
-    nativeEvent,
-    nativeEventTarget
-  );
-  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
-  accumulateDirectDispatches(grantEvent);
-  var blockHostResponder = executeDirectDispatch(grantEvent) === true;
-
-  if (responderInst) {
-    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(
-      eventTypes.responderTerminationRequest,
-      responderInst,
-      nativeEvent,
-      nativeEventTarget
-    );
-    terminationRequestEvent.touchHistory =
-      ResponderTouchHistoryStore.touchHistory;
-    accumulateDirectDispatches(terminationRequestEvent);
-    var shouldSwitch =
-      !hasDispatches(terminationRequestEvent) ||
-      executeDirectDispatch(terminationRequestEvent);
+  return null;
+}
+/**
+ * Return if A is an ancestor of B.
+ */
 
-    if (!terminationRequestEvent.isPersistent()) {
-      terminationRequestEvent.constructor.release(terminationRequestEvent);
+function isAncestor(instA, instB) {
+  while (instB) {
+    if (instA === instB || instA === instB.alternate) {
+      return true;
     }
 
-    if (shouldSwitch) {
-      var terminateEvent = ResponderSyntheticEvent.getPooled(
-        eventTypes.responderTerminate,
-        responderInst,
-        nativeEvent,
-        nativeEventTarget
-      );
-      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
-      accumulateDirectDispatches(terminateEvent);
-      extracted = accumulate(extracted, [grantEvent, terminateEvent]);
-      changeResponder(wantsResponderInst, blockHostResponder);
-    } else {
-      var rejectEvent = ResponderSyntheticEvent.getPooled(
-        eventTypes.responderReject,
-        wantsResponderInst,
-        nativeEvent,
-        nativeEventTarget
-      );
-      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
-      accumulateDirectDispatches(rejectEvent);
-      extracted = accumulate(extracted, rejectEvent);
-    }
-  } else {
-    extracted = accumulate(extracted, grantEvent);
-    changeResponder(wantsResponderInst, blockHostResponder);
+    instB = getParent(instB);
   }
 
-  return extracted;
+  return false;
 }
 /**
- * A transfer is a negotiation between a currently set responder and the next
- * element to claim responder status. Any start event could trigger a transfer
- * of responderInst. Any move event could trigger a transfer.
- *
- * @param {string} topLevelType Record from `BrowserEventConstants`.
- * @return {boolean} True if a transfer of responder could possibly occur.
+ * Simulates the traversal of a two-phase, capture/bubble event dispatch.
  */
 
-function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
-  return (
-    topLevelInst && // responderIgnoreScroll: We are trying to migrate away from specifically
-    // tracking native scroll events here and responderIgnoreScroll indicates we
-    // will send topTouchCancel to handle canceling touch events instead
-    ((topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll) ||
-      (trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE) ||
-      isStartish(topLevelType) ||
-      isMoveish(topLevelType))
-  );
+function traverseTwoPhase(inst, fn, arg) {
+  var path = [];
+
+  while (inst) {
+    path.push(inst);
+    inst = getParent(inst);
+  }
+
+  var i;
+
+  for (i = path.length; i-- > 0; ) {
+    fn(path[i], "captured", arg);
+  }
+
+  for (i = 0; i < path.length; i++) {
+    fn(path[i], "bubbled", arg);
+  }
 }
-/**
- * Returns whether or not this touch end event makes it such that there are no
- * longer any touches that started inside of the current `responderInst`.
- *
- * @param {NativeEvent} nativeEvent Native touch end event.
- * @return {boolean} Whether or not this touch end event ends the responder.
- */
 
-function noResponderTouches(nativeEvent) {
-  var touches = nativeEvent.touches;
+function getListener(inst, registrationName) {
+  var stateNode = inst.stateNode;
 
-  if (!touches || touches.length === 0) {
-    return true;
+  if (stateNode === null) {
+    // Work in progress (ex: onload events in incremental mode).
+    return null;
   }
 
-  for (var i = 0; i < touches.length; i++) {
-    var activeTouch = touches[i];
-    var target = activeTouch.target;
+  var props = getFiberCurrentPropsFromNode(stateNode);
 
-    if (target !== null && target !== undefined && target !== 0) {
-      // Is the original touch location inside of the current responder?
-      var targetInst = getInstanceFromNode(target);
+  if (props === null) {
+    // Work in progress.
+    return null;
+  }
 
-      if (isAncestor(responderInst, targetInst)) {
-        return false;
-      }
-    }
+  var listener = props[registrationName];
+
+  if (!(!listener || typeof listener === "function")) {
+    throw Error(
+      "Expected `" +
+        registrationName +
+        "` listener to be a function, instead got a value of `" +
+        typeof listener +
+        "` type."
+    );
   }
 
-  return true;
+  return listener;
 }
 
-var ResponderEventPlugin = {
-  /* For unit testing only */
-  _getResponder: function() {
-    return responderInst;
-  },
-  eventTypes: eventTypes,
-
+function listenerAtPhase(inst, event, propagationPhase) {
+  var registrationName =
+    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
+  return getListener(inst, registrationName);
+}
+
+function accumulateDirectionalDispatches(inst, phase, event) {
+  {
+    if (!inst) {
+      error("Dispatching inst must not be null");
+    }
+  }
+
+  var listener = listenerAtPhase(inst, event, phase);
+
+  if (listener) {
+    event._dispatchListeners = accumulateInto(
+      event._dispatchListeners,
+      listener
+    );
+    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
+  }
+}
+/**
+ * Accumulates without regard to direction, does not look for phased
+ * registration names. Same as `accumulateDirectDispatchesSingle` but without
+ * requiring that the `dispatchMarker` be the same as the dispatched ID.
+ */
+
+function accumulateDispatches(inst, ignoredDirection, event) {
+  if (inst && event && event.dispatchConfig.registrationName) {
+    var registrationName = event.dispatchConfig.registrationName;
+    var listener = getListener(inst, registrationName);
+
+    if (listener) {
+      event._dispatchListeners = accumulateInto(
+        event._dispatchListeners,
+        listener
+      );
+      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
+    }
+  }
+}
+/**
+ * Accumulates dispatches on an `SyntheticEvent`, but only for the
+ * `dispatchMarker`.
+ * @param {SyntheticEvent} event
+ */
+
+function accumulateDirectDispatchesSingle(event) {
+  if (event && event.dispatchConfig.registrationName) {
+    accumulateDispatches(event._targetInst, null, event);
+  }
+}
+
+function accumulateDirectDispatches(events) {
+  forEachAccumulated(events, accumulateDirectDispatchesSingle);
+}
+
+function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    var targetInst = event._targetInst;
+    var parentInst = targetInst ? getParent(targetInst) : null;
+    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
+  }
+}
+
+function accumulateTwoPhaseDispatchesSkipTarget(events) {
+  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
+}
+
+function accumulateTwoPhaseDispatchesSingle(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
+  }
+}
+
+function accumulateTwoPhaseDispatches(events) {
+  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
+} // End of inline
+
+/**
+ *
+ * Responder System:
+ * ----------------
+ *
+ * - A global, solitary "interaction lock" on a view.
+ * - If a node becomes the responder, it should convey visual feedback
+ *   immediately to indicate so, either by highlighting or moving accordingly.
+ * - To be the responder means, that touches are exclusively important to that
+ *   responder view, and no other view.
+ * - While touches are still occurring, the responder lock can be transferred to
+ *   a new view, but only to increasingly "higher" views (meaning ancestors of
+ *   the current responder).
+ *
+ * Responder being granted:
+ * ------------------------
+ *
+ * - Touch starts, moves, and scrolls can cause an ID to become the responder.
+ * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to
+ *   the "appropriate place".
+ * - If nothing is currently the responder, the "appropriate place" is the
+ *   initiating event's `targetID`.
+ * - If something *is* already the responder, the "appropriate place" is the
+ *   first common ancestor of the event target and the current `responderInst`.
+ * - Some negotiation happens: See the timing diagram below.
+ * - Scrolled views automatically become responder. The reasoning is that a
+ *   platform scroll view that isn't built on top of the responder system has
+ *   began scrolling, and the active responder must now be notified that the
+ *   interaction is no longer locked to it - the system has taken over.
+ *
+ * - Responder being released:
+ *   As soon as no more touches that *started* inside of descendants of the
+ *   *current* responderInst, an `onResponderRelease` event is dispatched to the
+ *   current responder, and the responder lock is released.
+ *
+ * TODO:
+ * - on "end", a callback hook for `onResponderEndShouldRemainResponder` that
+ *   determines if the responder lock should remain.
+ * - If a view shouldn't "remain" the responder, any active touches should by
+ *   default be considered "dead" and do not influence future negotiations or
+ *   bubble paths. It should be as if those touches do not exist.
+ * -- For multitouch: Usually a translate-z will choose to "remain" responder
+ *  after one out of many touches ended. For translate-y, usually the view
+ *  doesn't wish to "remain" responder after one of many touches end.
+ * - Consider building this on top of a `stopPropagation` model similar to
+ *   `W3C` events.
+ * - Ensure that `onResponderTerminate` is called on touch cancels, whether or
+ *   not `onResponderTerminationRequest` returns `true` or `false`.
+ *
+ */
+
+/*                                             Negotiation Performed
+                                             +-----------------------+
+                                            /                         \
+Process low level events to    +     Current Responder      +   wantsResponderID
+determine who to perform negot-|   (if any exists at all)   |
+iation/transition              | Otherwise just pass through|
+-------------------------------+----------------------------+------------------+
+Bubble to find first ID        |                            |
+to return true:wantsResponderID|                            |
+                               |                            |
+     +-------------+           |                            |
+     | onTouchStart|           |                            |
+     +------+------+     none  |                            |
+            |            return|                            |
++-----------v-------------+true| +------------------------+ |
+|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+
++-----------+-------------+    | +------------------------+ |          |
+            |                  |                            | +--------+-------+
+            | returned true for|       false:REJECT +-------->|onResponderReject
+            | wantsResponderID |                    |       | +----------------+
+            | (now attempt     | +------------------+-----+ |
+            |  handoff)        | |   onResponder          | |
+            +------------------->|      TerminationRequest| |
+                               | +------------------+-----+ |
+                               |                    |       | +----------------+
+                               |         true:GRANT +-------->|onResponderGrant|
+                               |                            | +--------+-------+
+                               | +------------------------+ |          |
+                               | |   onResponderTerminate |<-----------+
+                               | +------------------+-----+ |
+                               |                    |       | +----------------+
+                               |                    +-------->|onResponderStart|
+                               |                            | +----------------+
+Bubble to find first ID        |                            |
+to return true:wantsResponderID|                            |
+                               |                            |
+     +-------------+           |                            |
+     | onTouchMove |           |                            |
+     +------+------+     none  |                            |
+            |            return|                            |
++-----------v-------------+true| +------------------------+ |
+|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+
++-----------+-------------+    | +------------------------+ |          |
+            |                  |                            | +--------+-------+
+            | returned true for|       false:REJECT +-------->|onResponderRejec|
+            | wantsResponderID |                    |       | +----------------+
+            | (now attempt     | +------------------+-----+ |
+            |  handoff)        | |   onResponder          | |
+            +------------------->|      TerminationRequest| |
+                               | +------------------+-----+ |
+                               |                    |       | +----------------+
+                               |         true:GRANT +-------->|onResponderGrant|
+                               |                            | +--------+-------+
+                               | +------------------------+ |          |
+                               | |   onResponderTerminate |<-----------+
+                               | +------------------+-----+ |
+                               |                    |       | +----------------+
+                               |                    +-------->|onResponderMove |
+                               |                            | +----------------+
+                               |                            |
+                               |                            |
+      Some active touch started|                            |
+      inside current responder | +------------------------+ |
+      +------------------------->|      onResponderEnd    | |
+      |                        | +------------------------+ |
+  +---+---------+              |                            |
+  | onTouchEnd  |              |                            |
+  +---+---------+              |                            |
+      |                        | +------------------------+ |
+      +------------------------->|     onResponderEnd     | |
+      No active touches started| +-----------+------------+ |
+      inside current responder |             |              |
+                               |             v              |
+                               | +------------------------+ |
+                               | |    onResponderRelease  | |
+                               | +------------------------+ |
+                               |                            |
+                               +                            + */
+
+/**
+ * A note about event ordering in the `EventPluginRegistry`.
+ *
+ * Suppose plugins are injected in the following order:
+ *
+ * `[R, S, C]`
+ *
+ * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for
+ * `onClick` etc) and `R` is `ResponderEventPlugin`.
+ *
+ * "Deferred-Dispatched Events":
+ *
+ * - The current event plugin system will traverse the list of injected plugins,
+ *   in order, and extract events by collecting the plugin's return value of
+ *   `extractEvents()`.
+ * - These events that are returned from `extractEvents` are "deferred
+ *   dispatched events".
+ * - When returned from `extractEvents`, deferred-dispatched events contain an
+ *   "accumulation" of deferred dispatches.
+ * - These deferred dispatches are accumulated/collected before they are
+ *   returned, but processed at a later time by the `EventPluginRegistry` (hence the
+ *   name deferred).
+ *
+ * In the process of returning their deferred-dispatched events, event plugins
+ * themselves can dispatch events on-demand without returning them from
+ * `extractEvents`. Plugins might want to do this, so that they can use event
+ * dispatching as a tool that helps them decide which events should be extracted
+ * in the first place.
+ *
+ * "On-Demand-Dispatched Events":
+ *
+ * - On-demand-dispatched events are not returned from `extractEvents`.
+ * - On-demand-dispatched events are dispatched during the process of returning
+ *   the deferred-dispatched events.
+ * - They should not have side effects.
+ * - They should be avoided, and/or eventually be replaced with another
+ *   abstraction that allows event plugins to perform multiple "rounds" of event
+ *   extraction.
+ *
+ * Therefore, the sequence of event dispatches becomes:
+ *
+ * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)
+ * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)
+ * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)
+ * - `R`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
+ * - `S`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
+ * - `C`s extracted events (if any)   (dispatched by `EventPluginRegistry`)
+ *
+ * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`
+ * on-demand dispatch returns `true` (and some other details are satisfied) the
+ * `onResponderGrant` deferred dispatched event is returned from
+ * `extractEvents`. The sequence of dispatch executions in this case
+ * will appear as follows:
+ *
+ * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)
+ * - `touchStartCapture`       (`EventPluginRegistry` dispatches as usual)
+ * - `touchStart`              (`EventPluginRegistry` dispatches as usual)
+ * - `responderGrant/Reject`   (`EventPluginRegistry` dispatches as usual)
+ */
+
+function setResponderAndExtractTransfer(
+  topLevelType,
+  targetInst,
+  nativeEvent,
+  nativeEventTarget
+) {
+  var shouldSetEventType = isStartish(topLevelType)
+    ? eventTypes.startShouldSetResponder
+    : isMoveish(topLevelType)
+    ? eventTypes.moveShouldSetResponder
+    : topLevelType === TOP_SELECTION_CHANGE
+    ? eventTypes.selectionChangeShouldSetResponder
+    : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.
+
+  var bubbleShouldSetFrom = !responderInst
+    ? targetInst
+    : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the "shouldSet" event, we want to skip the target
+  // (deepest ID) if it happens to be the current responder. The reasoning:
+  // It's strange to get an `onMoveShouldSetResponder` when you're *already*
+  // the responder.
+
+  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
+  var shouldSetEvent = ResponderSyntheticEvent.getPooled(
+    shouldSetEventType,
+    bubbleShouldSetFrom,
+    nativeEvent,
+    nativeEventTarget
+  );
+  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+
+  if (skipOverBubbleShouldSetFrom) {
+    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
+  } else {
+    accumulateTwoPhaseDispatches(shouldSetEvent);
+  }
+
+  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
+
+  if (!shouldSetEvent.isPersistent()) {
+    shouldSetEvent.constructor.release(shouldSetEvent);
+  }
+
+  if (!wantsResponderInst || wantsResponderInst === responderInst) {
+    return null;
+  }
+
+  var extracted;
+  var grantEvent = ResponderSyntheticEvent.getPooled(
+    eventTypes.responderGrant,
+    wantsResponderInst,
+    nativeEvent,
+    nativeEventTarget
+  );
+  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+  accumulateDirectDispatches(grantEvent);
+  var blockHostResponder = executeDirectDispatch(grantEvent) === true;
+
+  if (responderInst) {
+    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(
+      eventTypes.responderTerminationRequest,
+      responderInst,
+      nativeEvent,
+      nativeEventTarget
+    );
+    terminationRequestEvent.touchHistory =
+      ResponderTouchHistoryStore.touchHistory;
+    accumulateDirectDispatches(terminationRequestEvent);
+    var shouldSwitch =
+      !hasDispatches(terminationRequestEvent) ||
+      executeDirectDispatch(terminationRequestEvent);
+
+    if (!terminationRequestEvent.isPersistent()) {
+      terminationRequestEvent.constructor.release(terminationRequestEvent);
+    }
+
+    if (shouldSwitch) {
+      var terminateEvent = ResponderSyntheticEvent.getPooled(
+        eventTypes.responderTerminate,
+        responderInst,
+        nativeEvent,
+        nativeEventTarget
+      );
+      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+      accumulateDirectDispatches(terminateEvent);
+      extracted = accumulate(extracted, [grantEvent, terminateEvent]);
+      changeResponder(wantsResponderInst, blockHostResponder);
+    } else {
+      var rejectEvent = ResponderSyntheticEvent.getPooled(
+        eventTypes.responderReject,
+        wantsResponderInst,
+        nativeEvent,
+        nativeEventTarget
+      );
+      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
+      accumulateDirectDispatches(rejectEvent);
+      extracted = accumulate(extracted, rejectEvent);
+    }
+  } else {
+    extracted = accumulate(extracted, grantEvent);
+    changeResponder(wantsResponderInst, blockHostResponder);
+  }
+
+  return extracted;
+}
+/**
+ * A transfer is a negotiation between a currently set responder and the next
+ * element to claim responder status. Any start event could trigger a transfer
+ * of responderInst. Any move event could trigger a transfer.
+ *
+ * @param {string} topLevelType Record from `BrowserEventConstants`.
+ * @return {boolean} True if a transfer of responder could possibly occur.
+ */
+
+function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
+  return (
+    topLevelInst && // responderIgnoreScroll: We are trying to migrate away from specifically
+    // tracking native scroll events here and responderIgnoreScroll indicates we
+    // will send topTouchCancel to handle canceling touch events instead
+    ((topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll) ||
+      (trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE) ||
+      isStartish(topLevelType) ||
+      isMoveish(topLevelType))
+  );
+}
+/**
+ * Returns whether or not this touch end event makes it such that there are no
+ * longer any touches that started inside of the current `responderInst`.
+ *
+ * @param {NativeEvent} nativeEvent Native touch end event.
+ * @return {boolean} Whether or not this touch end event ends the responder.
+ */
+
+function noResponderTouches(nativeEvent) {
+  var touches = nativeEvent.touches;
+
+  if (!touches || touches.length === 0) {
+    return true;
+  }
+
+  for (var i = 0; i < touches.length; i++) {
+    var activeTouch = touches[i];
+    var target = activeTouch.target;
+
+    if (target !== null && target !== undefined && target !== 0) {
+      // Is the original touch location inside of the current responder?
+      var targetInst = getInstanceFromNode(target);
+
+      if (isAncestor(responderInst, targetInst)) {
+        return false;
+      }
+    }
+  }
+
+  return true;
+}
+
+var ResponderEventPlugin = {
+  /* For unit testing only */
+  _getResponder: function() {
+    return responderInst;
+  },
+  eventTypes: eventTypes,
+
   /**
    * We must be resilient to `targetInst` being `null` on `touchMove` or
    * `touchEnd`. On certain platforms, this means that a native scroll has
@@ -2265,107 +2170,250 @@ function publishRegistrationName(registrationName, pluginModule, eventName) {
   {
     var lowerCasedName = registrationName.toLowerCase();
   }
-}
-/**
- * Registers plugins so that they can extract and dispatch events.
- */
+}
+/**
+ * Registers plugins so that they can extract and dispatch events.
+ */
+
+/**
+ * Ordered list of injected plugins.
+ */
+
+var plugins = [];
+/**
+ * Mapping from event name to dispatch config
+ */
+
+var eventNameDispatchConfigs = {};
+/**
+ * Mapping from registration name to plugin module
+ */
+
+var registrationNameModules = {};
+/**
+ * Mapping from registration name to event name
+ */
+
+var registrationNameDependencies = {};
+
+/**
+ * Injects an ordering of plugins (by plugin name). This allows the ordering
+ * to be decoupled from injection of the actual plugins so that ordering is
+ * always deterministic regardless of packaging, on-the-fly injection, etc.
+ *
+ * @param {array} InjectedEventPluginOrder
+ * @internal
+ */
+
+function injectEventPluginOrder(injectedEventPluginOrder) {
+  if (!!eventPluginOrder) {
+    throw Error(
+      "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React."
+    );
+  } // Clone the ordering so it cannot be dynamically mutated.
+
+  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
+  recomputePluginOrdering();
+}
+/**
+ * Injects plugins to be used by plugin event system. The plugin names must be
+ * in the ordering injected by `injectEventPluginOrder`.
+ *
+ * Plugins can be injected as part of page initialization or on-the-fly.
+ *
+ * @param {object} injectedNamesToPlugins Map from names to plugin modules.
+ * @internal
+ */
+
+function injectEventPluginsByName(injectedNamesToPlugins) {
+  var isOrderingDirty = false;
+
+  for (var pluginName in injectedNamesToPlugins) {
+    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
+      continue;
+    }
+
+    var pluginModule = injectedNamesToPlugins[pluginName];
+
+    if (
+      !namesToPlugins.hasOwnProperty(pluginName) ||
+      namesToPlugins[pluginName] !== pluginModule
+    ) {
+      if (!!namesToPlugins[pluginName]) {
+        throw Error(
+          "EventPluginRegistry: Cannot inject two different event plugins using the same name, `" +
+            pluginName +
+            "`."
+        );
+      }
+
+      namesToPlugins[pluginName] = pluginModule;
+      isOrderingDirty = true;
+    }
+  }
+
+  if (isOrderingDirty) {
+    recomputePluginOrdering();
+  }
+}
+
+function getListener$1(inst, registrationName) {
+  var stateNode = inst.stateNode;
+
+  if (stateNode === null) {
+    // Work in progress (ex: onload events in incremental mode).
+    return null;
+  }
+
+  var props = getFiberCurrentPropsFromNode(stateNode);
+
+  if (props === null) {
+    // Work in progress.
+    return null;
+  }
+
+  var listener = props[registrationName];
+
+  if (!(!listener || typeof listener === "function")) {
+    throw Error(
+      "Expected `" +
+        registrationName +
+        "` listener to be a function, instead got a value of `" +
+        typeof listener +
+        "` type."
+    );
+  }
+
+  return listener;
+}
+
+var customBubblingEventTypes =
+    ReactNativePrivateInterface.ReactNativeViewConfigRegistry
+      .customBubblingEventTypes,
+  customDirectEventTypes =
+    ReactNativePrivateInterface.ReactNativeViewConfigRegistry
+      .customDirectEventTypes; // Start of inline: the below functions were inlined from
+// EventPropagator.js, as they deviated from ReactDOM's newer
+// implementations.
+
+function listenerAtPhase$1(inst, event, propagationPhase) {
+  var registrationName =
+    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
+  return getListener$1(inst, registrationName);
+}
+
+function accumulateDirectionalDispatches$1(inst, phase, event) {
+  {
+    if (!inst) {
+      error("Dispatching inst must not be null");
+    }
+  }
+
+  var listener = listenerAtPhase$1(inst, event, phase);
+
+  if (listener) {
+    event._dispatchListeners = accumulateInto(
+      event._dispatchListeners,
+      listener
+    );
+    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
+  }
+}
+
+function getParent$1(inst) {
+  do {
+    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
+    // That is depending on if we want nested subtrees (layers) to bubble
+    // events to their parent. We could also go through parentNode on the
+    // host node but that wouldn't work for React Native and doesn't let us
+    // do the portal feature.
+  } while (inst && inst.tag !== HostComponent);
+
+  if (inst) {
+    return inst;
+  }
 
+  return null;
+}
 /**
- * Ordered list of injected plugins.
+ * Simulates the traversal of a two-phase, capture/bubble event dispatch.
  */
 
-var plugins = [];
-/**
- * Mapping from event name to dispatch config
- */
+function traverseTwoPhase$1(inst, fn, arg) {
+  var path = [];
 
-var eventNameDispatchConfigs = {};
-/**
- * Mapping from registration name to plugin module
- */
+  while (inst) {
+    path.push(inst);
+    inst = getParent$1(inst);
+  }
 
-var registrationNameModules = {};
-/**
- * Mapping from registration name to event name
- */
+  var i;
 
-var registrationNameDependencies = {};
+  for (i = path.length; i-- > 0; ) {
+    fn(path[i], "captured", arg);
+  }
 
-/**
- * Injects an ordering of plugins (by plugin name). This allows the ordering
- * to be decoupled from injection of the actual plugins so that ordering is
- * always deterministic regardless of packaging, on-the-fly injection, etc.
- *
- * @param {array} InjectedEventPluginOrder
- * @internal
- */
+  for (i = 0; i < path.length; i++) {
+    fn(path[i], "bubbled", arg);
+  }
+}
 
-function injectEventPluginOrder(injectedEventPluginOrder) {
-  if (!!eventPluginOrder) {
-    throw Error(
-      "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React."
+function accumulateTwoPhaseDispatchesSingle$1(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    traverseTwoPhase$1(
+      event._targetInst,
+      accumulateDirectionalDispatches$1,
+      event
     );
-  } // Clone the ordering so it cannot be dynamically mutated.
+  }
+}
 
-  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
-  recomputePluginOrdering();
+function accumulateTwoPhaseDispatches$1(events) {
+  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle$1);
 }
 /**
- * Injects plugins to be used by plugin event system. The plugin names must be
- * in the ordering injected by `injectEventPluginOrder`.
- *
- * Plugins can be injected as part of page initialization or on-the-fly.
- *
- * @param {object} injectedNamesToPlugins Map from names to plugin modules.
- * @internal
+ * Accumulates without regard to direction, does not look for phased
+ * registration names. Same as `accumulateDirectDispatchesSingle` but without
+ * requiring that the `dispatchMarker` be the same as the dispatched ID.
  */
 
-function injectEventPluginsByName(injectedNamesToPlugins) {
-  var isOrderingDirty = false;
-
-  for (var pluginName in injectedNamesToPlugins) {
-    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
-      continue;
-    }
-
-    var pluginModule = injectedNamesToPlugins[pluginName];
-
-    if (
-      !namesToPlugins.hasOwnProperty(pluginName) ||
-      namesToPlugins[pluginName] !== pluginModule
-    ) {
-      if (!!namesToPlugins[pluginName]) {
-        throw Error(
-          "EventPluginRegistry: Cannot inject two different event plugins using the same name, `" +
-            pluginName +
-            "`."
-        );
-      }
+function accumulateDispatches$1(inst, ignoredDirection, event) {
+  if (inst && event && event.dispatchConfig.registrationName) {
+    var registrationName = event.dispatchConfig.registrationName;
+    var listener = getListener$1(inst, registrationName);
 
-      namesToPlugins[pluginName] = pluginModule;
-      isOrderingDirty = true;
+    if (listener) {
+      event._dispatchListeners = accumulateInto(
+        event._dispatchListeners,
+        listener
+      );
+      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
     }
   }
+}
+/**
+ * Accumulates dispatches on an `SyntheticEvent`, but only for the
+ * `dispatchMarker`.
+ * @param {SyntheticEvent} event
+ */
 
-  if (isOrderingDirty) {
-    recomputePluginOrdering();
+function accumulateDirectDispatchesSingle$1(event) {
+  if (event && event.dispatchConfig.registrationName) {
+    accumulateDispatches$1(event._targetInst, null, event);
   }
 }
 
-var customBubblingEventTypes =
-    ReactNativePrivateInterface.ReactNativeViewConfigRegistry
-      .customBubblingEventTypes,
-  customDirectEventTypes =
-    ReactNativePrivateInterface.ReactNativeViewConfigRegistry
-      .customDirectEventTypes;
+function accumulateDirectDispatches$1(events) {
+  forEachAccumulated(events, accumulateDirectDispatchesSingle$1);
+} // End of inline
+
 var ReactNativeBridgeEventPlugin = {
   eventTypes: {},
   extractEvents: function(
     topLevelType,
     targetInst,
     nativeEvent,
-    nativeEventTarget,
-    eventSystemFlags
+    nativeEventTarget
   ) {
     if (targetInst == null) {
       // Probably a node belonging to another renderer's tree.
@@ -2389,9 +2437,9 @@ var ReactNativeBridgeEventPlugin = {
     );
 
     if (bubbleDispatchConfig) {
-      accumulateTwoPhaseDispatches(event);
+      accumulateTwoPhaseDispatches$1(event);
     } else if (directDispatchConfig) {
-      accumulateDirectDispatches(event);
+      accumulateDirectDispatches$1(event);
     } else {
       return null;
     }
@@ -2462,23 +2510,16 @@ function updateFiberProps(tag, props) {
   instanceProps.set(tag, props);
 }
 
-var PLUGIN_EVENT_SYSTEM = 1;
-
-var enableProfilerTimer = true;
-var enableFundamentalAPI = false;
-var warnAboutStringRefs = false;
-
+// Used as a way to call batchedUpdates when we don't have a reference to
 // the renderer. Such as when we're dispatching events or if third party
 // libraries need to call batchedUpdates. Eventually, this API will go away when
 // everything is batched by default. We'll then have a similar API to opt-out of
 // scheduled work and instead do synchronous work.
 // Defaults
-
 var batchedUpdatesImpl = function(fn, bookkeeping) {
   return fn(bookkeeping);
 };
 var isInsideEventHandler = false;
-
 function batchedUpdates(fn, bookkeeping) {
   if (isInsideEventHandler) {
     // If we are currently inside another batch, we need to wait until it
@@ -2636,13 +2677,7 @@ function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
   }
 
   batchedUpdates(function() {
-    runExtractedPluginEventsInBatch(
-      topLevelType,
-      inst,
-      nativeEvent,
-      target,
-      PLUGIN_EVENT_SYSTEM
-    );
+    runExtractedPluginEventsInBatch(topLevelType, inst, nativeEvent, target);
   }); // React Native doesn't use ReactControlledComponent but if it did, here's
   // where it would do it.
 }
@@ -2658,22 +2693,21 @@ function extractPluginEvents(
   topLevelType,
   targetInst,
   nativeEvent,
-  nativeEventTarget,
-  eventSystemFlags
+  nativeEventTarget
 ) {
   var events = null;
+  var legacyPlugins = plugins;
 
-  for (var i = 0; i < plugins.length; i++) {
+  for (var i = 0; i < legacyPlugins.length; i++) {
     // Not every plugin in the ordering may be loaded at runtime.
-    var possiblePlugin = plugins[i];
+    var possiblePlugin = legacyPlugins[i];
 
     if (possiblePlugin) {
       var extractedEvents = possiblePlugin.extractEvents(
         topLevelType,
         targetInst,
         nativeEvent,
-        nativeEventTarget,
-        eventSystemFlags
+        nativeEventTarget
       );
 
       if (extractedEvents) {
@@ -2689,15 +2723,13 @@ function runExtractedPluginEventsInBatch(
   topLevelType,
   targetInst,
   nativeEvent,
-  nativeEventTarget,
-  eventSystemFlags
+  nativeEventTarget
 ) {
   var events = extractPluginEvents(
     topLevelType,
     targetInst,
     nativeEvent,
-    nativeEventTarget,
-    eventSystemFlags
+    nativeEventTarget
   );
   runEventsInBatch(events);
 }
@@ -2810,37 +2842,62 @@ ResponderEventPlugin.injection.injectGlobalResponderHandler(
  * If this becomes an actual Map, that will break.
  */
 function get(key) {
-  return key._reactInternalFiber;
+  return key._reactInternals;
 }
 function set(key, value) {
-  key._reactInternalFiber = value;
+  key._reactInternals = value;
 }
 
+// ATTENTION
+// When adding new symbols to this file,
+// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
 // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
 // nor polyfill, then a plain number is used for performance.
-var hasSymbol = typeof Symbol === "function" && Symbol.for;
-var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 0xeac7;
-var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 0xeaca;
-var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 0xeacb;
-var REACT_STRICT_MODE_TYPE = hasSymbol
-  ? Symbol.for("react.strict_mode")
-  : 0xeacc;
-var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 0xead2;
-var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 0xeacd;
-var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
-var REACT_CONCURRENT_MODE_TYPE = hasSymbol
-  ? Symbol.for("react.concurrent_mode")
-  : 0xeacf;
-var REACT_FORWARD_REF_TYPE = hasSymbol
-  ? Symbol.for("react.forward_ref")
-  : 0xead0;
-var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 0xead1;
-var REACT_SUSPENSE_LIST_TYPE = hasSymbol
-  ? Symbol.for("react.suspense_list")
-  : 0xead8;
-var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
-var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;
-var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 0xead9;
+var REACT_ELEMENT_TYPE = 0xeac7;
+var REACT_PORTAL_TYPE = 0xeaca;
+var REACT_FRAGMENT_TYPE = 0xeacb;
+var REACT_STRICT_MODE_TYPE = 0xeacc;
+var REACT_PROFILER_TYPE = 0xead2;
+var REACT_PROVIDER_TYPE = 0xeacd;
+var REACT_CONTEXT_TYPE = 0xeace;
+var REACT_FORWARD_REF_TYPE = 0xead0;
+var REACT_SUSPENSE_TYPE = 0xead1;
+var REACT_SUSPENSE_LIST_TYPE = 0xead8;
+var REACT_MEMO_TYPE = 0xead3;
+var REACT_LAZY_TYPE = 0xead4;
+var REACT_BLOCK_TYPE = 0xead9;
+var REACT_SERVER_BLOCK_TYPE = 0xeada;
+var REACT_FUNDAMENTAL_TYPE = 0xead5;
+var REACT_SCOPE_TYPE = 0xead7;
+var REACT_OPAQUE_ID_TYPE = 0xeae0;
+var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
+var REACT_OFFSCREEN_TYPE = 0xeae2;
+var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
+
+if (typeof Symbol === "function" && Symbol.for) {
+  var symbolFor = Symbol.for;
+  REACT_ELEMENT_TYPE = symbolFor("react.element");
+  REACT_PORTAL_TYPE = symbolFor("react.portal");
+  REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
+  REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
+  REACT_PROFILER_TYPE = symbolFor("react.profiler");
+  REACT_PROVIDER_TYPE = symbolFor("react.provider");
+  REACT_CONTEXT_TYPE = symbolFor("react.context");
+  REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
+  REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
+  REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
+  REACT_MEMO_TYPE = symbolFor("react.memo");
+  REACT_LAZY_TYPE = symbolFor("react.lazy");
+  REACT_BLOCK_TYPE = symbolFor("react.block");
+  REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
+  REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
+  REACT_SCOPE_TYPE = symbolFor("react.scope");
+  REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
+  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
+  REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
+  REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
+}
+
 var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
 var FAUX_ITERATOR_SYMBOL = "@@iterator";
 function getIteratorFn(maybeIterable) {
@@ -2859,63 +2916,6 @@ function getIteratorFn(maybeIterable) {
   return null;
 }
 
-// TODO: Move this to "react" once we can import from externals.
-var Uninitialized = -1;
-var Pending = 0;
-var Resolved = 1;
-var Rejected = 2;
-
-function refineResolvedLazyComponent(lazyComponent) {
-  return lazyComponent._status === Resolved ? lazyComponent._result : null;
-}
-function initializeLazyComponentType(lazyComponent) {
-  if (lazyComponent._status === Uninitialized) {
-    var ctor = lazyComponent._result;
-
-    if (!ctor) {
-      // TODO: Remove this later. THis only exists in case you use an older "react" package.
-      ctor = lazyComponent._ctor;
-    }
-
-    var thenable = ctor(); // Transition to the next state.
-
-    var pending = lazyComponent;
-    pending._status = Pending;
-    pending._result = thenable;
-    thenable.then(
-      function(moduleObject) {
-        if (lazyComponent._status === Pending) {
-          var defaultExport = moduleObject.default;
-
-          {
-            if (defaultExport === undefined) {
-              error(
-                "lazy: Expected the result of a dynamic import() call. " +
-                "Instead received: %s\n\nYour code should look like: \n  " + // Break up imports to avoid accidentally parsing them as dependencies.
-                  "const MyComponent = lazy(() => imp" +
-                  "ort('./MyComponent'))",
-                moduleObject
-              );
-            }
-          } // Transition to the next state.
-
-          var resolved = lazyComponent;
-          resolved._status = Resolved;
-          resolved._result = defaultExport;
-        }
-      },
-      function(error) {
-        if (lazyComponent._status === Pending) {
-          // Transition to the next state.
-          var rejected = lazyComponent;
-          rejected._status = Rejected;
-          rejected._result = error;
-        }
-      }
-    );
-  }
-}
-
 function getWrappedName(outerType, innerType, wrapperName) {
   var functionName = innerType.displayName || innerType.name || "";
   return (
@@ -2988,17 +2988,18 @@ function getComponentName(type) {
         return getComponentName(type.type);
 
       case REACT_BLOCK_TYPE:
-        return getComponentName(type.render);
+        return getComponentName(type._render);
 
       case REACT_LAZY_TYPE: {
-        var thenable = type;
-        var resolvedThenable = refineResolvedLazyComponent(thenable);
+        var lazyComponent = type;
+        var payload = lazyComponent._payload;
+        var init = lazyComponent._init;
 
-        if (resolvedThenable) {
-          return getComponentName(resolvedThenable);
+        try {
+          return getComponentName(init(payload));
+        } catch (x) {
+          return null;
         }
-
-        break;
       }
     }
   }
@@ -3008,62 +3009,76 @@ function getComponentName(type) {
 
 // Don't change these two values. They're used by React Dev Tools.
 var NoEffect =
-  /*              */
+  /*                     */
   0;
 var PerformedWork =
-  /*         */
+  /*                */
   1; // You can change the rest (and add more).
 
 var Placement =
-  /*             */
+  /*                    */
   2;
 var Update =
-  /*                */
+  /*                       */
   4;
 var PlacementAndUpdate =
-  /*    */
+  /*           */
   6;
 var Deletion =
-  /*              */
+  /*                     */
   8;
 var ContentReset =
-  /*          */
+  /*                 */
   16;
 var Callback =
-  /*              */
+  /*                     */
   32;
 var DidCapture =
-  /*            */
+  /*                   */
   64;
 var Ref =
-  /*                   */
+  /*                          */
   128;
 var Snapshot =
-  /*              */
+  /*                     */
   256;
 var Passive =
-  /*               */
-  512;
+  /*                      */
+  512; // TODO (effects) Remove this bit once the new reconciler is synced to the old.
+
+var PassiveUnmountPendingDev =
+  /*     */
+  8192;
 var Hydrating =
-  /*             */
+  /*                    */
   1024;
 var HydratingAndUpdate =
-  /*    */
+  /*           */
   1028; // Passive & Update & Callback & Ref & Snapshot
 
 var LifecycleEffectMask =
-  /*   */
+  /*          */
   932; // Union of all host effects
 
 var HostEffectMask =
-  /*        */
-  2047;
+  /*               */
+  2047; // These are not really side effects, but we still reuse this field.
+
 var Incomplete =
-  /*            */
+  /*                   */
   2048;
 var ShouldCapture =
-  /*         */
+  /*                */
   4096;
+var ForceUpdateForLegacySuspense =
+  /* */
+  16384; // Static tags describe aspects of a fiber that are not specific to a render,
+
+// The rest of the flags are static for better dead code elimination.
+var enableProfilerTimer = true;
+var enableFundamentalAPI = false;
+var warnAboutStringRefs = false;
+var enableNewReconciler = false;
 
 var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 function getNearestMountedFiber(fiber) {
@@ -3338,6 +3353,20 @@ function findCurrentHostFiber(parent) {
 
   return null;
 }
+function doesFiberContain(parentFiber, childFiber) {
+  var node = childFiber;
+  var parentFiberAlternate = parentFiber.alternate;
+
+  while (node !== null) {
+    if (node === parentFiber || node === parentFiberAlternate) {
+      return true;
+    }
+
+    node = node.return;
+  }
+
+  return false;
+}
 
 // Modules provided by RN:
 var emptyObject = {};
@@ -4104,6 +4133,7 @@ function getPublicInstance(instance) {
 }
 function prepareForCommit(containerInfo) {
   // Noop
+  return null;
 }
 function prepareUpdate(
   instance,
@@ -4121,9 +4151,6 @@ function resetAfterCommit(containerInfo) {
 var scheduleTimeout = setTimeout;
 var cancelTimeout = clearTimeout;
 var noTimeout = -1;
-function shouldDeprioritizeSubtree(type, props) {
-  return false;
-}
 function shouldSetTextContent(type, props) {
   // TODO (bvaughn) Revisit this decision.
   // Always returning false simplifies the createInstance() implementation,
@@ -4306,12 +4333,263 @@ function unhideInstance(instance, props) {
     updatePayload
   );
 }
+function clearContainer(container) {
+  // TODO Implement this for React Native
+  // UIManager does not expose a "remove all" type method.
+}
 function unhideTextInstance(textInstance, text) {
   throw new Error("Not yet implemented.");
 }
+function makeClientIdInDEV(warnOnAccessInDEV) {
+  throw new Error("Not yet implemented");
+}
+function preparePortalMount(portalInstance) {
+  // noop
+}
+
+// Helpers to patch console.logs to avoid logging during side-effect free
+// replaying on render function. This currently only patches the object
+// lazily which won't cover if the log function was extracted eagerly.
+// We could also eagerly patch the method.
+var disabledDepth = 0;
+var prevLog;
+var prevInfo;
+var prevWarn;
+var prevError;
+var prevGroup;
+var prevGroupCollapsed;
+var prevGroupEnd;
+
+function disabledLog() {}
+
+disabledLog.__reactDisabledLog = true;
+function disableLogs() {
+  {
+    if (disabledDepth === 0) {
+      /* eslint-disable react-internal/no-production-logging */
+      prevLog = console.log;
+      prevInfo = console.info;
+      prevWarn = console.warn;
+      prevError = console.error;
+      prevGroup = console.group;
+      prevGroupCollapsed = console.groupCollapsed;
+      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
+
+      var props = {
+        configurable: true,
+        enumerable: true,
+        value: disabledLog,
+        writable: true
+      }; // $FlowFixMe Flow thinks console is immutable.
+
+      Object.defineProperties(console, {
+        info: props,
+        log: props,
+        warn: props,
+        error: props,
+        group: props,
+        groupCollapsed: props,
+        groupEnd: props
+      });
+      /* eslint-enable react-internal/no-production-logging */
+    }
+
+    disabledDepth++;
+  }
+}
+function reenableLogs() {
+  {
+    disabledDepth--;
+
+    if (disabledDepth === 0) {
+      /* eslint-disable react-internal/no-production-logging */
+      var props = {
+        configurable: true,
+        enumerable: true,
+        writable: true
+      }; // $FlowFixMe Flow thinks console is immutable.
+
+      Object.defineProperties(console, {
+        log: Object.assign({}, props, {
+          value: prevLog
+        }),
+        info: Object.assign({}, props, {
+          value: prevInfo
+        }),
+        warn: Object.assign({}, props, {
+          value: prevWarn
+        }),
+        error: Object.assign({}, props, {
+          value: prevError
+        }),
+        group: Object.assign({}, props, {
+          value: prevGroup
+        }),
+        groupCollapsed: Object.assign({}, props, {
+          value: prevGroupCollapsed
+        }),
+        groupEnd: Object.assign({}, props, {
+          value: prevGroupEnd
+        })
+      });
+      /* eslint-enable react-internal/no-production-logging */
+    }
+
+    if (disabledDepth < 0) {
+      error(
+        "disabledDepth fell below zero. " +
+          "This is a bug in React. Please file an issue."
+      );
+    }
+  }
+}
+
+var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+function describeBuiltInComponentFrame(name, source, ownerFn) {
+  {
+    var ownerName = null;
+
+    if (ownerFn) {
+      ownerName = ownerFn.displayName || ownerFn.name || null;
+    }
+
+    return describeComponentFrame(name, source, ownerName);
+  }
+}
+var componentFrameCache;
+
+{
+  var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
+  componentFrameCache = new PossiblyWeakMap();
+}
+var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
+
+function describeComponentFrame(name, source, ownerName) {
+  var sourceInfo = "";
+
+  if (source) {
+    var path = source.fileName;
+    var fileName = path.replace(BEFORE_SLASH_RE, ""); // In DEV, include code for a common special case:
+    // prefer "folder/index.js" instead of just "index.js".
+
+    if (/^index\./.test(fileName)) {
+      var match = path.match(BEFORE_SLASH_RE);
+
+      if (match) {
+        var pathBeforeSlash = match[1];
+
+        if (pathBeforeSlash) {
+          var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
+          fileName = folderName + "/" + fileName;
+        }
+      }
+    }
+
+    sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
+  } else if (ownerName) {
+    sourceInfo = " (created by " + ownerName + ")";
+  }
+
+  return "\n    in " + (name || "Unknown") + sourceInfo;
+}
+
+function describeClassComponentFrame(ctor, source, ownerFn) {
+  {
+    return describeFunctionComponentFrame(ctor, source, ownerFn);
+  }
+}
+function describeFunctionComponentFrame(fn, source, ownerFn) {
+  {
+    if (!fn) {
+      return "";
+    }
+
+    var name = fn.displayName || fn.name || null;
+    var ownerName = null;
+
+    if (ownerFn) {
+      ownerName = ownerFn.displayName || ownerFn.name || null;
+    }
+
+    return describeComponentFrame(name, source, ownerName);
+  }
+}
+
+function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
+  if (type == null) {
+    return "";
+  }
+
+  if (typeof type === "function") {
+    {
+      return describeFunctionComponentFrame(type, source, ownerFn);
+    }
+  }
+
+  if (typeof type === "string") {
+    return describeBuiltInComponentFrame(type, source, ownerFn);
+  }
+
+  switch (type) {
+    case REACT_SUSPENSE_TYPE:
+      return describeBuiltInComponentFrame("Suspense", source, ownerFn);
+
+    case REACT_SUSPENSE_LIST_TYPE:
+      return describeBuiltInComponentFrame("SuspenseList", source, ownerFn);
+  }
+
+  if (typeof type === "object") {
+    switch (type.$$typeof) {
+      case REACT_FORWARD_REF_TYPE:
+        return describeFunctionComponentFrame(type.render, source, ownerFn);
+
+      case REACT_MEMO_TYPE:
+        // Memo may contain any component type so we recursively resolve it.
+        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
+
+      case REACT_BLOCK_TYPE:
+        return describeFunctionComponentFrame(type._render, source, ownerFn);
+
+      case REACT_LAZY_TYPE: {
+        var lazyComponent = type;
+        var payload = lazyComponent._payload;
+        var init = lazyComponent._init;
+
+        try {
+          // Lazy may contain any component type so we recursively resolve it.
+          return describeUnknownElementTypeFrameInDEV(
+            init(payload),
+            source,
+            ownerFn
+          );
+        } catch (x) {}
+      }
+    }
+  }
+
+  return "";
+}
 
 var loggedTypeFailures = {};
-function checkPropTypes(typeSpecs, values, location, componentName) {
+var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+
+function setCurrentlyValidatingElement(element) {
+  {
+    if (element) {
+      var owner = element._owner;
+      var stack = describeUnknownElementTypeFrameInDEV(
+        element.type,
+        element._source,
+        owner ? owner.type : null
+      );
+      ReactDebugCurrentFrame.setExtraStackFrame(stack);
+    } else {
+      ReactDebugCurrentFrame.setExtraStackFrame(null);
+    }
+  }
+}
+
+function checkPropTypes(typeSpecs, values, location, componentName, element) {
   {
     // $FlowFixMe This is okay but Flow doesn't know it.
     var has = Function.call.bind(Object.prototype.hasOwnProperty);
@@ -4355,6 +4633,8 @@ function checkPropTypes(typeSpecs, values, location, componentName) {
         }
 
         if (error$1 && !(error$1 instanceof Error)) {
+          setCurrentlyValidatingElement(element);
+
           error(
             "%s: type specification of %s" +
               " `%s` is invalid; the type checker " +
@@ -4367,6 +4647,8 @@ function checkPropTypes(typeSpecs, values, location, componentName) {
             typeSpecName,
             typeof error$1
           );
+
+          setCurrentlyValidatingElement(null);
         }
 
         if (
@@ -4376,455 +4658,14 @@ function checkPropTypes(typeSpecs, values, location, componentName) {
           // Only monitor this failure once because there tends to be a lot of the
           // same error.
           loggedTypeFailures[error$1.message] = true;
+          setCurrentlyValidatingElement(element);
 
           error("Failed %s type: %s", location, error$1.message);
-        }
-      }
-    }
-  }
-}
-
-// Prefix measurements so that it's possible to filter them.
-// Longer prefixes are hard to read in DevTools.
-var reactEmoji = "\u269B";
-var warningEmoji = "\u26D4";
-var supportsUserTiming =
-  typeof performance !== "undefined" &&
-  typeof performance.mark === "function" &&
-  typeof performance.clearMarks === "function" &&
-  typeof performance.measure === "function" &&
-  typeof performance.clearMeasures === "function"; // Keep track of current fiber so that we know the path to unwind on pause.
-// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
-
-var currentFiber = null; // If we're in the middle of user code, which fiber and method is it?
-// Reusing `currentFiber` would be confusing for this because user code fiber
-// can change during commit phase too, but we don't need to unwind it (since
-// lifecycles in the commit phase don't resemble a tree).
-
-var currentPhase = null;
-var currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,
-// so we will keep track of it, and include it in the report.
-// Track commits caused by cascading updates.
-
-var isCommitting = false;
-var hasScheduledUpdateInCurrentCommit = false;
-var hasScheduledUpdateInCurrentPhase = false;
-var commitCountInCurrentWorkLoop = 0;
-var effectCountInCurrentCommit = 0;
-// to avoid stretch the commit phase with measurement overhead.
-
-var labelsInCurrentCommit = new Set();
-
-var formatMarkName = function(markName) {
-  return reactEmoji + " " + markName;
-};
-
-var formatLabel = function(label, warning) {
-  var prefix = warning ? warningEmoji + " " : reactEmoji + " ";
-  var suffix = warning ? " Warning: " + warning : "";
-  return "" + prefix + label + suffix;
-};
-
-var beginMark = function(markName) {
-  performance.mark(formatMarkName(markName));
-};
-
-var clearMark = function(markName) {
-  performance.clearMarks(formatMarkName(markName));
-};
-
-var endMark = function(label, markName, warning) {
-  var formattedMarkName = formatMarkName(markName);
-  var formattedLabel = formatLabel(label, warning);
-
-  try {
-    performance.measure(formattedLabel, formattedMarkName);
-  } catch (err) {} // If previous mark was missing for some reason, this will throw.
-  // This could only happen if React crashed in an unexpected place earlier.
-  // Don't pile on with more errors.
-  // Clear marks immediately to avoid growing buffer.
-
-  performance.clearMarks(formattedMarkName);
-  performance.clearMeasures(formattedLabel);
-};
-
-var getFiberMarkName = function(label, debugID) {
-  return label + " (#" + debugID + ")";
-};
-
-var getFiberLabel = function(componentName, isMounted, phase) {
-  if (phase === null) {
-    // These are composite component total time measurements.
-    return componentName + " [" + (isMounted ? "update" : "mount") + "]";
-  } else {
-    // Composite component methods.
-    return componentName + "." + phase;
-  }
-};
-
-var beginFiberMark = function(fiber, phase) {
-  var componentName = getComponentName(fiber.type) || "Unknown";
-  var debugID = fiber._debugID;
-  var isMounted = fiber.alternate !== null;
-  var label = getFiberLabel(componentName, isMounted, phase);
-
-  if (isCommitting && labelsInCurrentCommit.has(label)) {
-    // During the commit phase, we don't show duplicate labels because
-    // there is a fixed overhead for every measurement, and we don't
-    // want to stretch the commit phase beyond necessary.
-    return false;
-  }
-
-  labelsInCurrentCommit.add(label);
-  var markName = getFiberMarkName(label, debugID);
-  beginMark(markName);
-  return true;
-};
-
-var clearFiberMark = function(fiber, phase) {
-  var componentName = getComponentName(fiber.type) || "Unknown";
-  var debugID = fiber._debugID;
-  var isMounted = fiber.alternate !== null;
-  var label = getFiberLabel(componentName, isMounted, phase);
-  var markName = getFiberMarkName(label, debugID);
-  clearMark(markName);
-};
-
-var endFiberMark = function(fiber, phase, warning) {
-  var componentName = getComponentName(fiber.type) || "Unknown";
-  var debugID = fiber._debugID;
-  var isMounted = fiber.alternate !== null;
-  var label = getFiberLabel(componentName, isMounted, phase);
-  var markName = getFiberMarkName(label, debugID);
-  endMark(label, markName, warning);
-};
-
-var shouldIgnoreFiber = function(fiber) {
-  // Host components should be skipped in the timeline.
-  // We could check typeof fiber.type, but does this work with RN?
-  switch (fiber.tag) {
-    case HostRoot:
-    case HostComponent:
-    case HostText:
-    case HostPortal:
-    case Fragment:
-    case ContextProvider:
-    case ContextConsumer:
-    case Mode:
-      return true;
-
-    default:
-      return false;
-  }
-};
-
-var clearPendingPhaseMeasurement = function() {
-  if (currentPhase !== null && currentPhaseFiber !== null) {
-    clearFiberMark(currentPhaseFiber, currentPhase);
-  }
-
-  currentPhaseFiber = null;
-  currentPhase = null;
-  hasScheduledUpdateInCurrentPhase = false;
-};
-
-var pauseTimers = function() {
-  // Stops all currently active measurements so that they can be resumed
-  // if we continue in a later deferred loop from the same unit of work.
-  var fiber = currentFiber;
-
-  while (fiber) {
-    if (fiber._debugIsCurrentlyTiming) {
-      endFiberMark(fiber, null, null);
-    }
-
-    fiber = fiber.return;
-  }
-};
-
-var resumeTimersRecursively = function(fiber) {
-  if (fiber.return !== null) {
-    resumeTimersRecursively(fiber.return);
-  }
-
-  if (fiber._debugIsCurrentlyTiming) {
-    beginFiberMark(fiber, null);
-  }
-};
-
-var resumeTimers = function() {
-  // Resumes all measurements that were active during the last deferred loop.
-  if (currentFiber !== null) {
-    resumeTimersRecursively(currentFiber);
-  }
-};
-
-function recordEffect() {
-  {
-    effectCountInCurrentCommit++;
-  }
-}
-function recordScheduleUpdate() {
-  {
-    if (isCommitting) {
-      hasScheduledUpdateInCurrentCommit = true;
-    }
 
-    if (
-      currentPhase !== null &&
-      currentPhase !== "componentWillMount" &&
-      currentPhase !== "componentWillReceiveProps"
-    ) {
-      hasScheduledUpdateInCurrentPhase = true;
-    }
-  }
-}
-function startWorkTimer(fiber) {
-  {
-    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
-      return;
-    } // If we pause, this is the fiber to unwind from.
-
-    currentFiber = fiber;
-
-    if (!beginFiberMark(fiber, null)) {
-      return;
-    }
-
-    fiber._debugIsCurrentlyTiming = true;
-  }
-}
-function cancelWorkTimer(fiber) {
-  {
-    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
-      return;
-    } // Remember we shouldn't complete measurement for this fiber.
-    // Otherwise flamechart will be deep even for small updates.
-
-    fiber._debugIsCurrentlyTiming = false;
-    clearFiberMark(fiber, null);
-  }
-}
-function stopWorkTimer(fiber) {
-  {
-    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
-      return;
-    } // If we pause, its parent is the fiber to unwind from.
-
-    currentFiber = fiber.return;
-
-    if (!fiber._debugIsCurrentlyTiming) {
-      return;
-    }
-
-    fiber._debugIsCurrentlyTiming = false;
-    endFiberMark(fiber, null, null);
-  }
-}
-function stopFailedWorkTimer(fiber) {
-  {
-    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
-      return;
-    } // If we pause, its parent is the fiber to unwind from.
-
-    currentFiber = fiber.return;
-
-    if (!fiber._debugIsCurrentlyTiming) {
-      return;
-    }
-
-    fiber._debugIsCurrentlyTiming = false;
-    var warning =
-      fiber.tag === SuspenseComponent
-        ? "Rendering was suspended"
-        : "An error was thrown inside this error boundary";
-    endFiberMark(fiber, null, warning);
-  }
-}
-function startPhaseTimer(fiber, phase) {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    clearPendingPhaseMeasurement();
-
-    if (!beginFiberMark(fiber, phase)) {
-      return;
-    }
-
-    currentPhaseFiber = fiber;
-    currentPhase = phase;
-  }
-}
-function stopPhaseTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    if (currentPhase !== null && currentPhaseFiber !== null) {
-      var warning = hasScheduledUpdateInCurrentPhase
-        ? "Scheduled a cascading update"
-        : null;
-      endFiberMark(currentPhaseFiber, currentPhase, warning);
-    }
-
-    currentPhase = null;
-    currentPhaseFiber = null;
-  }
-}
-function startWorkLoopTimer(nextUnitOfWork) {
-  {
-    currentFiber = nextUnitOfWork;
-
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    commitCountInCurrentWorkLoop = 0; // This is top level call.
-    // Any other measurements are performed within.
-
-    beginMark("(React Tree Reconciliation)"); // Resume any measurements that were in progress during the last loop.
-
-    resumeTimers();
-  }
-}
-function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    var warning = null;
-
-    if (interruptedBy !== null) {
-      if (interruptedBy.tag === HostRoot) {
-        warning = "A top-level update interrupted the previous render";
-      } else {
-        var componentName = getComponentName(interruptedBy.type) || "Unknown";
-        warning =
-          "An update to " + componentName + " interrupted the previous render";
+          setCurrentlyValidatingElement(null);
+        }
       }
-    } else if (commitCountInCurrentWorkLoop > 1) {
-      warning = "There were cascading updates";
-    }
-
-    commitCountInCurrentWorkLoop = 0;
-    var label = didCompleteRoot
-      ? "(React Tree Reconciliation: Completed Root)"
-      : "(React Tree Reconciliation: Yielded)"; // Pause any measurements until the next loop.
-
-    pauseTimers();
-    endMark(label, "(React Tree Reconciliation)", warning);
-  }
-}
-function startCommitTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    isCommitting = true;
-    hasScheduledUpdateInCurrentCommit = false;
-    labelsInCurrentCommit.clear();
-    beginMark("(Committing Changes)");
-  }
-}
-function stopCommitTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    var warning = null;
-
-    if (hasScheduledUpdateInCurrentCommit) {
-      warning = "Lifecycle hook scheduled a cascading update";
-    } else if (commitCountInCurrentWorkLoop > 0) {
-      warning = "Caused by a cascading update in earlier commit";
-    }
-
-    hasScheduledUpdateInCurrentCommit = false;
-    commitCountInCurrentWorkLoop++;
-    isCommitting = false;
-    labelsInCurrentCommit.clear();
-    endMark("(Committing Changes)", "(Committing Changes)", warning);
-  }
-}
-function startCommitSnapshotEffectsTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    effectCountInCurrentCommit = 0;
-    beginMark("(Committing Snapshot Effects)");
-  }
-}
-function stopCommitSnapshotEffectsTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    var count = effectCountInCurrentCommit;
-    effectCountInCurrentCommit = 0;
-    endMark(
-      "(Committing Snapshot Effects: " + count + " Total)",
-      "(Committing Snapshot Effects)",
-      null
-    );
-  }
-}
-function startCommitHostEffectsTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    effectCountInCurrentCommit = 0;
-    beginMark("(Committing Host Effects)");
-  }
-}
-function stopCommitHostEffectsTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    var count = effectCountInCurrentCommit;
-    effectCountInCurrentCommit = 0;
-    endMark(
-      "(Committing Host Effects: " + count + " Total)",
-      "(Committing Host Effects)",
-      null
-    );
-  }
-}
-function startCommitLifeCyclesTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
-    }
-
-    effectCountInCurrentCommit = 0;
-    beginMark("(Calling Lifecycle Methods)");
-  }
-}
-function stopCommitLifeCyclesTimer() {
-  {
-    if (!supportsUserTiming) {
-      return;
     }
-
-    var count = effectCountInCurrentCommit;
-    effectCountInCurrentCommit = 0;
-    endMark(
-      "(Calling Lifecycle Methods: " + count + " Total)",
-      "(Calling Lifecycle Methods)",
-      null
-    );
   }
 }
 
@@ -5031,10 +4872,7 @@ function processChildContext(fiber, type, parentContext) {
       return parentContext;
     }
 
-    var childContext;
-    startPhaseTimer(fiber, "getChildContext");
-    childContext = instance.getChildContext();
-    stopPhaseTimer();
+    var childContext = instance.getChildContext();
 
     for (var contextKey in childContext) {
       if (!(contextKey in childContextTypes)) {
@@ -5155,20 +4993,112 @@ var LegacyRoot = 0;
 var BlockingRoot = 1;
 var ConcurrentRoot = 2;
 
+var rendererID = null;
+var injectedHook = null;
+var hasLoggedError = false;
+var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
+function injectInternals(internals) {
+  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
+    // No DevTools
+    return false;
+  }
+
+  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+
+  if (hook.isDisabled) {
+    // This isn't a real property on the hook, but it can be set to opt out
+    // of DevTools integration and associated warnings and logs.
+    // https://github.com/facebook/react/issues/3877
+    return true;
+  }
+
+  if (!hook.supportsFiber) {
+    {
+      error(
+        "The installed version of React DevTools is too old and will not work " +
+          "with the current version of React. Please update React DevTools. " +
+          "https://fb.me/react-devtools"
+      );
+    } // DevTools exists, even though it doesn't support Fiber.
+
+    return true;
+  }
+
+  try {
+    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
+
+    injectedHook = hook;
+  } catch (err) {
+    // Catch all errors because it is unsafe to throw during initialization.
+    {
+      error("React instrumentation encountered an error: %s.", err);
+    }
+  } // DevTools exists
+
+  return true;
+}
+function onScheduleRoot(root, children) {
+  {
+    if (
+      injectedHook &&
+      typeof injectedHook.onScheduleFiberRoot === "function"
+    ) {
+      try {
+        injectedHook.onScheduleFiberRoot(rendererID, root, children);
+      } catch (err) {
+        if (!hasLoggedError) {
+          hasLoggedError = true;
+
+          error("React instrumentation encountered an error: %s", err);
+        }
+      }
+    }
+  }
+}
+function onCommitRoot(root, priorityLevel) {
+  if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
+    try {
+      var didError = (root.current.effectTag & DidCapture) === DidCapture;
+
+      if (enableProfilerTimer) {
+        injectedHook.onCommitFiberRoot(
+          rendererID,
+          root,
+          priorityLevel,
+          didError
+        );
+      } else {
+        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);
+      }
+    } catch (err) {
+      {
+        if (!hasLoggedError) {
+          hasLoggedError = true;
+
+          error("React instrumentation encountered an error: %s", err);
+        }
+      }
+    }
+  }
+}
+function onCommitUnmount(fiber) {
+  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, fiber);
+    } catch (err) {
+      {
+        if (!hasLoggedError) {
+          hasLoggedError = true;
+
+          error("React instrumentation encountered an error: %s", err);
+        }
+      }
+    }
+  }
+}
+
 // Intentionally not named imports because Rollup would use dynamic dispatch for
-var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
-  Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
-  Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
-  Scheduler_shouldYield = Scheduler.unstable_shouldYield,
-  Scheduler_requestPaint = Scheduler.unstable_requestPaint,
-  Scheduler_now = Scheduler.unstable_now,
-  Scheduler_getCurrentPriorityLevel =
-    Scheduler.unstable_getCurrentPriorityLevel,
-  Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
-  Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
-  Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
-  Scheduler_LowPriority = Scheduler.unstable_LowPriority,
-  Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
+var Scheduler_now = Scheduler.unstable_now;
 
 {
   // Provide explicit error message when production+profiling bundle of e.g.
@@ -5185,8 +5115,6 @@ var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
     );
   }
 }
-
-var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use
 // ascending numbers so we can compare them like numbers. They start at 90 to
 // avoid clashing with Scheduler's priorities.
 
@@ -5197,1214 +5125,1458 @@ var LowPriority = 96;
 var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.
 
 var NoPriority = 90;
-var shouldYield = Scheduler_shouldYield;
-var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.
-  Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function() {};
-var syncQueue = null;
-var immediateQueueCallbackNode = null;
-var isFlushingSyncQueue = false;
 var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
-// This will be the case for modern browsers that support `performance.now`. In
-// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
-// timestamp. In that case, subtract the module initialization time to simulate
-// the behavior of performance.now and keep our times small enough to fit
-// within 32 bits.
-// TODO: Consider lifting this into Scheduler.
 
-var now =
-  initialTimeMs < 10000
-    ? Scheduler_now
-    : function() {
-        return Scheduler_now() - initialTimeMs;
-      };
-function getCurrentPriorityLevel() {
-  switch (Scheduler_getCurrentPriorityLevel()) {
-    case Scheduler_ImmediatePriority:
-      return ImmediatePriority;
+var SyncLanePriority = 17;
+var SyncBatchedLanePriority = 16;
+var InputDiscreteHydrationLanePriority = 15;
+var InputDiscreteLanePriority = 14;
+var InputContinuousHydrationLanePriority = 13;
+var InputContinuousLanePriority = 12;
+var DefaultHydrationLanePriority = 11;
+var DefaultLanePriority = 10;
+var TransitionShortHydrationLanePriority = 9;
+var TransitionShortLanePriority = 8;
+var TransitionLongHydrationLanePriority = 7;
+var TransitionLongLanePriority = 6;
+var RetryLanePriority = 5;
+var SelectiveHydrationLanePriority = 4;
+var IdleHydrationLanePriority = 3;
+var IdleLanePriority = 2;
+var OffscreenLanePriority = 1;
+var NoLanePriority = 0;
+var TotalLanes = 31;
+var NoLanes =
+  /*                        */
+  0;
+var NoLane =
+  /*                          */
+  0;
+var SyncLane =
+  /*                        */
+  1;
+var SyncBatchedLane =
+  /*                 */
+  2;
+var InputDiscreteHydrationLane =
+  /*      */
+  4;
+var InputDiscreteLanes =
+  /*                    */
+  24;
+var InputContinuousHydrationLane =
+  /*           */
+  32;
+var InputContinuousLanes =
+  /*                  */
+  192;
+var DefaultHydrationLane =
+  /*            */
+  256;
+var DefaultLanes =
+  /*                   */
+  3584;
+var TransitionShortHydrationLane =
+  /*           */
+  4096;
+var TransitionShortLanes =
+  /*                  */
+  122880;
+var TransitionLongHydrationLane =
+  /*            */
+  131072;
+var TransitionLongLanes =
+  /*                   */
+  3932160;
+var RetryLanes =
+  /*                            */
+  62914560;
+var SelectiveHydrationLane =
+  /*          */
+  67108864;
+var NonIdleLanes =
+  /*                                 */
+  134217727;
+var IdleHydrationLane =
+  /*               */
+  134217728;
+var IdleLanes =
+  /*                             */
+  805306368;
+var OffscreenLane =
+  /*                   */
+  1073741824;
+var NoTimestamp = -1;
+function setCurrentUpdateLanePriority(newLanePriority) {} // "Registers" used to "return" multiple values
+// Used by getHighestPriorityLanes and getNextLanes:
 
-    case Scheduler_UserBlockingPriority:
-      return UserBlockingPriority;
+var return_highestLanePriority = DefaultLanePriority;
 
-    case Scheduler_NormalPriority:
-      return NormalPriority;
+function getHighestPriorityLanes(lanes) {
+  if ((SyncLane & lanes) !== NoLanes) {
+    return_highestLanePriority = SyncLanePriority;
+    return SyncLane;
+  }
 
-    case Scheduler_LowPriority:
-      return LowPriority;
+  if ((SyncBatchedLane & lanes) !== NoLanes) {
+    return_highestLanePriority = SyncBatchedLanePriority;
+    return SyncBatchedLane;
+  }
 
-    case Scheduler_IdlePriority:
-      return IdlePriority;
+  if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
+    return_highestLanePriority = InputDiscreteHydrationLanePriority;
+    return InputDiscreteHydrationLane;
+  }
 
-    default: {
-      throw Error("Unknown priority level.");
-    }
+  var inputDiscreteLanes = InputDiscreteLanes & lanes;
+
+  if (inputDiscreteLanes !== NoLanes) {
+    return_highestLanePriority = InputDiscreteLanePriority;
+    return inputDiscreteLanes;
+  }
+
+  if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
+    return_highestLanePriority = InputContinuousHydrationLanePriority;
+    return InputContinuousHydrationLane;
+  }
+
+  var inputContinuousLanes = InputContinuousLanes & lanes;
+
+  if (inputContinuousLanes !== NoLanes) {
+    return_highestLanePriority = InputContinuousLanePriority;
+    return inputContinuousLanes;
+  }
+
+  if ((lanes & DefaultHydrationLane) !== NoLanes) {
+    return_highestLanePriority = DefaultHydrationLanePriority;
+    return DefaultHydrationLane;
+  }
+
+  var defaultLanes = DefaultLanes & lanes;
+
+  if (defaultLanes !== NoLanes) {
+    return_highestLanePriority = DefaultLanePriority;
+    return defaultLanes;
+  }
+
+  if ((lanes & TransitionShortHydrationLane) !== NoLanes) {
+    return_highestLanePriority = TransitionShortHydrationLanePriority;
+    return TransitionShortHydrationLane;
+  }
+
+  var transitionShortLanes = TransitionShortLanes & lanes;
+
+  if (transitionShortLanes !== NoLanes) {
+    return_highestLanePriority = TransitionShortLanePriority;
+    return transitionShortLanes;
+  }
+
+  if ((lanes & TransitionLongHydrationLane) !== NoLanes) {
+    return_highestLanePriority = TransitionLongHydrationLanePriority;
+    return TransitionLongHydrationLane;
+  }
+
+  var transitionLongLanes = TransitionLongLanes & lanes;
+
+  if (transitionLongLanes !== NoLanes) {
+    return_highestLanePriority = TransitionLongLanePriority;
+    return transitionLongLanes;
+  }
+
+  var retryLanes = RetryLanes & lanes;
+
+  if (retryLanes !== NoLanes) {
+    return_highestLanePriority = RetryLanePriority;
+    return retryLanes;
+  }
+
+  if (lanes & SelectiveHydrationLane) {
+    return_highestLanePriority = SelectiveHydrationLanePriority;
+    return SelectiveHydrationLane;
+  }
+
+  if ((lanes & IdleHydrationLane) !== NoLanes) {
+    return_highestLanePriority = IdleHydrationLanePriority;
+    return IdleHydrationLane;
   }
+
+  var idleLanes = IdleLanes & lanes;
+
+  if (idleLanes !== NoLanes) {
+    return_highestLanePriority = IdleLanePriority;
+    return idleLanes;
+  }
+
+  if ((OffscreenLane & lanes) !== NoLanes) {
+    return_highestLanePriority = OffscreenLanePriority;
+    return OffscreenLane;
+  }
+
+  {
+    error("Should have found matching lanes. This is a bug in React.");
+  } // This shouldn't be reachable, but as a fallback, return the entire bitmask.
+
+  return_highestLanePriority = DefaultLanePriority;
+  return lanes;
 }
 
-function reactPriorityToSchedulerPriority(reactPriorityLevel) {
-  switch (reactPriorityLevel) {
+function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
+  switch (schedulerPriorityLevel) {
     case ImmediatePriority:
-      return Scheduler_ImmediatePriority;
+      return SyncLanePriority;
 
     case UserBlockingPriority:
-      return Scheduler_UserBlockingPriority;
+      return InputContinuousLanePriority;
 
     case NormalPriority:
-      return Scheduler_NormalPriority;
-
     case LowPriority:
-      return Scheduler_LowPriority;
+      // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
+      return DefaultLanePriority;
 
     case IdlePriority:
-      return Scheduler_IdlePriority;
+      return IdleLanePriority;
 
-    default: {
-      throw Error("Unknown priority level.");
-    }
+    default:
+      return NoLanePriority;
   }
 }
+function lanePriorityToSchedulerPriority(lanePriority) {
+  switch (lanePriority) {
+    case SyncLanePriority:
+    case SyncBatchedLanePriority:
+      return ImmediatePriority;
 
-function runWithPriority(reactPriorityLevel, fn) {
-  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
-  return Scheduler_runWithPriority(priorityLevel, fn);
-}
-function scheduleCallback(reactPriorityLevel, callback, options) {
-  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
-  return Scheduler_scheduleCallback(priorityLevel, callback, options);
-}
-function scheduleSyncCallback(callback) {
-  // Push this callback into an internal queue. We'll flush these either in
-  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
-  if (syncQueue === null) {
-    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.
+    case InputDiscreteHydrationLanePriority:
+    case InputDiscreteLanePriority:
+    case InputContinuousHydrationLanePriority:
+    case InputContinuousLanePriority:
+      return UserBlockingPriority;
 
-    immediateQueueCallbackNode = Scheduler_scheduleCallback(
-      Scheduler_ImmediatePriority,
-      flushSyncCallbackQueueImpl
-    );
-  } else {
-    // Push onto existing queue. Don't need to schedule a callback because
-    // we already scheduled one when we created the queue.
-    syncQueue.push(callback);
-  }
+    case DefaultHydrationLanePriority:
+    case DefaultLanePriority:
+    case TransitionShortHydrationLanePriority:
+    case TransitionShortLanePriority:
+    case TransitionLongHydrationLanePriority:
+    case TransitionLongLanePriority:
+    case SelectiveHydrationLanePriority:
+    case RetryLanePriority:
+      return NormalPriority;
 
-  return fakeCallbackNode;
-}
-function cancelCallback(callbackNode) {
-  if (callbackNode !== fakeCallbackNode) {
-    Scheduler_cancelCallback(callbackNode);
+    case IdleHydrationLanePriority:
+    case IdleLanePriority:
+    case OffscreenLanePriority:
+      return IdlePriority;
+
+    case NoLanePriority:
+      return NoPriority;
+
+    default: {
+      throw Error(
+        "Invalid update priority: " + lanePriority + ". This is a bug in React."
+      );
+    }
   }
 }
-function flushSyncCallbackQueue() {
-  if (immediateQueueCallbackNode !== null) {
-    var node = immediateQueueCallbackNode;
-    immediateQueueCallbackNode = null;
-    Scheduler_cancelCallback(node);
-  }
+function getNextLanes(root, wipLanes) {
+  // Early bailout if there's no pending work left.
+  var pendingLanes = root.pendingLanes;
 
-  flushSyncCallbackQueueImpl();
-}
+  if (pendingLanes === NoLanes) {
+    return_highestLanePriority = NoLanePriority;
+    return NoLanes;
+  }
 
-function flushSyncCallbackQueueImpl() {
-  if (!isFlushingSyncQueue && syncQueue !== null) {
-    // Prevent re-entrancy.
-    isFlushingSyncQueue = true;
-    var i = 0;
+  var nextLanes = NoLanes;
+  var nextLanePriority = NoLanePriority;
+  var expiredLanes = root.expiredLanes;
+  var suspendedLanes = root.suspendedLanes;
+  var pingedLanes = root.pingedLanes; // Check if any work has expired.
 
-    try {
-      var _isSync = true;
-      var queue = syncQueue;
-      runWithPriority(ImmediatePriority, function() {
-        for (; i < queue.length; i++) {
-          var callback = queue[i];
+  if (expiredLanes !== NoLanes) {
+    nextLanes = expiredLanes;
+    nextLanePriority = return_highestLanePriority = SyncLanePriority;
+  } else {
+    // Do not work on any idle work until all the non-idle work has finished,
+    // even if the work is suspended.
+    var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
 
-          do {
-            callback = callback(_isSync);
-          } while (callback !== null);
-        }
-      });
-      syncQueue = null;
-    } catch (error) {
-      // If something throws, leave the remaining callbacks on the queue.
-      if (syncQueue !== null) {
-        syncQueue = syncQueue.slice(i + 1);
-      } // Resume flushing in the next tick
+    if (nonIdlePendingLanes !== NoLanes) {
+      var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
 
-      Scheduler_scheduleCallback(
-        Scheduler_ImmediatePriority,
-        flushSyncCallbackQueue
-      );
-      throw error;
-    } finally {
-      isFlushingSyncQueue = false;
+      if (nonIdleUnblockedLanes !== NoLanes) {
+        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
+        nextLanePriority = return_highestLanePriority;
+      } else {
+        var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
+
+        if (nonIdlePingedLanes !== NoLanes) {
+          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
+          nextLanePriority = return_highestLanePriority;
+        }
+      }
+    } else {
+      // The only remaining work is Idle.
+      var unblockedLanes = pendingLanes & ~suspendedLanes;
+
+      if (unblockedLanes !== NoLanes) {
+        nextLanes = getHighestPriorityLanes(unblockedLanes);
+        nextLanePriority = return_highestLanePriority;
+      } else {
+        if (pingedLanes !== NoLanes) {
+          nextLanes = getHighestPriorityLanes(pingedLanes);
+          nextLanePriority = return_highestLanePriority;
+        }
+      }
     }
   }
-}
 
-var NoMode = 0;
-var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
-// tag instead
+  if (nextLanes === NoLanes) {
+    // This should only be reachable if we're suspended
+    // TODO: Consider warning in this path if a fallback timer is not scheduled.
+    return NoLanes;
+  } // If there are higher priority lanes, we'll include them even if they
+  // are suspended.
 
-var BlockingMode = 2;
-var ConcurrentMode = 4;
-var ProfileMode = 8;
+  nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt
+  // it and we'll lose our progress. We should only do this if the new lanes are
+  // higher priority.
 
-// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
-// Math.pow(2, 30) - 1
-// 0b111111111111111111111111111111
-var MAX_SIGNED_31_BIT_INT = 1073741823;
+  if (
+    wipLanes !== NoLanes &&
+    wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
+    // bother waiting until the root is complete.
+    (wipLanes & suspendedLanes) === NoLanes
+  ) {
+    getHighestPriorityLanes(wipLanes);
+    var wipLanePriority = return_highestLanePriority;
+
+    if (nextLanePriority <= wipLanePriority) {
+      return wipLanes;
+    } else {
+      return_highestLanePriority = nextLanePriority;
+    }
+  } // Check for entangled lanes and add them to the batch.
+  //
+  // A lane is said to be entangled with another when it's not allowed to render
+  // in a batch that does not also include the other lane. Typically we do this
+  // when multiple updates have the same source, and we only want to respond to
+  // the most recent event from that source.
+  //
+  // Note that we apply entanglements *after* checking for partial work above.
+  // This means that if a lane is entangled during an interleaved event while
+  // it's already rendering, we won't interrupt it. This is intentional, since
+  // entanglement is usually "best effort": we'll try our best to render the
+  // lanes in the same batch, but it's not worth throwing out partially
+  // completed work in order to do it.
+  //
+  // For those exceptions where entanglement is semantically important, like
+  // useMutableSource, we should ensure that there is no partial work at the
+  // time we apply the entanglement.
 
-var NoWork = 0; // TODO: Think of a better name for Never. The key difference with Idle is that
-// Never work can be committed in an inconsistent state without tearing the UI.
-// The main example is offscreen content, like a hidden subtree. So one possible
-// name is Offscreen. However, it also includes dehydrated Suspense boundaries,
-// which are inconsistent in the sense that they haven't finished yet, but
-// aren't visibly inconsistent because the server rendered HTML matches what the
-// hydrated tree would look like.
+  var entangledLanes = root.entangledLanes;
 
-var Never = 1; // Idle is slightly higher priority than Never. It must completely finish in
-// order to be consistent.
+  if (entangledLanes !== NoLanes) {
+    var entanglements = root.entanglements;
+    var lanes = nextLanes & entangledLanes;
 
-var Idle = 2; // Continuous Hydration is slightly higher than Idle and is used to increase
-var Sync = MAX_SIGNED_31_BIT_INT;
-var Batched = Sync - 1;
-var UNIT_SIZE = 10;
-var MAGIC_NUMBER_OFFSET = Batched - 1; // 1 unit of expiration time represents 10ms.
+    while (lanes > 0) {
+      var index = pickArbitraryLaneIndex(lanes);
+      var lane = 1 << index;
+      nextLanes |= entanglements[index];
+      lanes &= ~lane;
+    }
+  }
 
-function msToExpirationTime(ms) {
-  // Always subtract from the offset so that we don't clash with the magic number for NoWork.
-  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);
-}
-function expirationTimeToMs(expirationTime) {
-  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
+  return nextLanes;
 }
+function getMostRecentEventTime(root, lanes) {
+  var eventTimes = root.eventTimes;
+  var mostRecentEventTime = NoTimestamp;
 
-function ceiling(num, precision) {
-  return (((num / precision) | 0) + 1) * precision;
-}
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    var eventTime = eventTimes[index];
 
-function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
-  return (
-    MAGIC_NUMBER_OFFSET -
-    ceiling(
-      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,
-      bucketSizeMs / UNIT_SIZE
-    )
-  );
-} // TODO: This corresponds to Scheduler's NormalPriority, not LowPriority. Update
-// the names to reflect.
-
-var LOW_PRIORITY_EXPIRATION = 5000;
-var LOW_PRIORITY_BATCH_SIZE = 250;
-function computeAsyncExpiration(currentTime) {
-  return computeExpirationBucket(
-    currentTime,
-    LOW_PRIORITY_EXPIRATION,
-    LOW_PRIORITY_BATCH_SIZE
-  );
-}
-function computeSuspenseExpiration(currentTime, timeoutMs) {
-  // TODO: Should we warn if timeoutMs is lower than the normal pri expiration time?
-  return computeExpirationBucket(
-    currentTime,
-    timeoutMs,
-    LOW_PRIORITY_BATCH_SIZE
-  );
-} // We intentionally set a higher expiration time for interactive updates in
-// dev than in production.
-//
-// If the main thread is being blocked so long that you hit the expiration,
-// it's a problem that could be solved with better scheduling.
-//
-// People will be more likely to notice this and fix it with the long
-// expiration time in development.
-//
-// In production we opt for better UX at the risk of masking scheduling
-// problems, by expiring fast.
-
-var HIGH_PRIORITY_EXPIRATION = 500;
-var HIGH_PRIORITY_BATCH_SIZE = 100;
-function computeInteractiveExpiration(currentTime) {
-  return computeExpirationBucket(
-    currentTime,
-    HIGH_PRIORITY_EXPIRATION,
-    HIGH_PRIORITY_BATCH_SIZE
-  );
-}
-function inferPriorityFromExpirationTime(currentTime, expirationTime) {
-  if (expirationTime === Sync) {
-    return ImmediatePriority;
-  }
+    if (eventTime > mostRecentEventTime) {
+      mostRecentEventTime = eventTime;
+    }
 
-  if (expirationTime === Never || expirationTime === Idle) {
-    return IdlePriority;
+    lanes &= ~lane;
   }
 
-  var msUntil =
-    expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);
+  return mostRecentEventTime;
+}
 
-  if (msUntil <= 0) {
-    return ImmediatePriority;
-  }
+function computeExpirationTime(lane, currentTime) {
+  // TODO: Expiration heuristic is constant per lane, so could use a map.
+  getHighestPriorityLanes(lane);
+  var priority = return_highestLanePriority;
 
-  if (msUntil <= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {
-    return UserBlockingPriority;
+  if (priority >= InputContinuousLanePriority) {
+    // User interactions should expire slightly more quickly.
+    return currentTime + 1000;
+  } else if (priority >= TransitionLongLanePriority) {
+    return currentTime + 5000;
+  } else {
+    // Anything idle priority or lower should never expire.
+    return NoTimestamp;
   }
+}
 
-  if (msUntil <= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {
-    return NormalPriority;
-  } // TODO: Handle LowPriority
-  // Assume anything lower has idle priority
+function markStarvedLanesAsExpired(root, currentTime) {
+  // TODO: This gets called every time we yield. We can optimize by storing
+  // the earliest expiration time on the root. Then use that to quickly bail out
+  // of this function.
+  var pendingLanes = root.pendingLanes;
+  var suspendedLanes = root.suspendedLanes;
+  var pingedLanes = root.pingedLanes;
+  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
+  // expiration time. If so, we'll assume the update is being starved and mark
+  // it as expired to force it to finish.
 
-  return IdlePriority;
-}
+  var lanes = pendingLanes;
 
-/**
- * inlined Object.is polyfill to avoid requiring consumers ship their own
- * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
- */
-function is(x, y) {
-  return (
-    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
-  );
-}
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    var expirationTime = expirationTimes[index];
 
-var objectIs = typeof Object.is === "function" ? Object.is : is;
+    if (expirationTime === NoTimestamp) {
+      // Found a pending lane with no expiration time. If it's not suspended, or
+      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
+      // using the current time.
+      if (
+        (lane & suspendedLanes) === NoLanes ||
+        (lane & pingedLanes) !== NoLanes
+      ) {
+        // Assumes timestamps are monotonically increasing.
+        expirationTimes[index] = computeExpirationTime(lane, currentTime);
+      }
+    } else if (expirationTime <= currentTime) {
+      // This lane expired
+      root.expiredLanes |= lane;
+    }
 
-var hasOwnProperty = Object.prototype.hasOwnProperty;
-/**
- * Performs equality by iterating through keys on an object and returning false
- * when any key has values which are not strictly equal between the arguments.
- * Returns true when the values of all keys are strictly equal.
- */
+    lanes &= ~lane;
+  }
+} // This returns the highest priority pending lanes regardless of whether they
+function getLanesToRetrySynchronouslyOnError(root) {
+  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
 
-function shallowEqual(objA, objB) {
-  if (objectIs(objA, objB)) {
-    return true;
+  if (everythingButOffscreen !== NoLanes) {
+    return everythingButOffscreen;
   }
 
-  if (
-    typeof objA !== "object" ||
-    objA === null ||
-    typeof objB !== "object" ||
-    objB === null
-  ) {
-    return false;
+  if (everythingButOffscreen & OffscreenLane) {
+    return OffscreenLane;
   }
 
-  var keysA = Object.keys(objA);
-  var keysB = Object.keys(objB);
+  return NoLanes;
+}
+function returnNextLanesPriority() {
+  return return_highestLanePriority;
+}
+function includesNonIdleWork(lanes) {
+  return (lanes & NonIdleLanes) !== NoLanes;
+}
+function includesOnlyRetries(lanes) {
+  return (lanes & RetryLanes) === lanes;
+} // To ensure consistency across multiple updates in the same event, this should
+// be a pure function, so that it always returns the same lane for given inputs.
 
-  if (keysA.length !== keysB.length) {
-    return false;
-  } // Test for A's keys different from B.
+function findUpdateLane(lanePriority, wipLanes) {
+  switch (lanePriority) {
+    case NoLanePriority:
+      break;
 
-  for (var i = 0; i < keysA.length; i++) {
-    if (
-      !hasOwnProperty.call(objB, keysA[i]) ||
-      !objectIs(objA[keysA[i]], objB[keysA[i]])
-    ) {
-      return false;
-    }
-  }
+    case SyncLanePriority:
+      return SyncLane;
 
-  return true;
-}
+    case SyncBatchedLanePriority:
+      return SyncBatchedLane;
 
-var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
-function describeComponentFrame(name, source, ownerName) {
-  var sourceInfo = "";
+    case InputDiscreteLanePriority: {
+      var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
 
-  if (source) {
-    var path = source.fileName;
-    var fileName = path.replace(BEFORE_SLASH_RE, "");
+      if (_lane === NoLane) {
+        // Shift to the next priority level
+        return findUpdateLane(InputContinuousLanePriority, wipLanes);
+      }
 
-    {
-      // In DEV, include code for a common special case:
-      // prefer "folder/index.js" instead of just "index.js".
-      if (/^index\./.test(fileName)) {
-        var match = path.match(BEFORE_SLASH_RE);
+      return _lane;
+    }
 
-        if (match) {
-          var pathBeforeSlash = match[1];
+    case InputContinuousLanePriority: {
+      var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
 
-          if (pathBeforeSlash) {
-            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
-            fileName = folderName + "/" + fileName;
-          }
-        }
+      if (_lane2 === NoLane) {
+        // Shift to the next priority level
+        return findUpdateLane(DefaultLanePriority, wipLanes);
       }
+
+      return _lane2;
     }
 
-    sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
-  } else if (ownerName) {
-    sourceInfo = " (created by " + ownerName + ")";
-  }
+    case DefaultLanePriority: {
+      var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
 
-  return "\n    in " + (name || "Unknown") + sourceInfo;
-}
+      if (_lane3 === NoLane) {
+        // If all the default lanes are already being worked on, look for a
+        // lane in the transition range.
+        _lane3 = pickArbitraryLane(
+          (TransitionShortLanes | TransitionLongLanes) & ~wipLanes
+        );
 
-var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+        if (_lane3 === NoLane) {
+          // All the transition lanes are taken, too. This should be very
+          // rare, but as a last resort, pick a default lane. This will have
+          // the effect of interrupting the current work-in-progress render.
+          _lane3 = pickArbitraryLane(DefaultLanes);
+        }
+      }
 
-function describeFiber(fiber) {
-  switch (fiber.tag) {
-    case HostRoot:
-    case HostPortal:
-    case HostText:
-    case Fragment:
-    case ContextProvider:
-    case ContextConsumer:
-      return "";
+      return _lane3;
+    }
 
-    default:
-      var owner = fiber._debugOwner;
-      var source = fiber._debugSource;
-      var name = getComponentName(fiber.type);
-      var ownerName = null;
+    case TransitionShortLanePriority: // Should be handled by findTransitionLane instead
 
-      if (owner) {
-        ownerName = getComponentName(owner.type);
+    case TransitionLongLanePriority:
+    case RetryLanePriority:
+      // Should be handled by findRetryLane instead
+      break;
+
+    case IdleLanePriority:
+      var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
+
+      if (lane === NoLane) {
+        lane = pickArbitraryLane(IdleLanes);
       }
 
-      return describeComponentFrame(name, source, ownerName);
+      return lane;
   }
-}
 
-function getStackByFiberInDevAndProd(workInProgress) {
-  var info = "";
-  var node = workInProgress;
+  {
+    throw Error(
+      "Invalid update priority: " + lanePriority + ". This is a bug in React."
+    );
+  }
+} // To ensure consistency across multiple updates in the same event, this should
+// be pure function, so that it always returns the same lane for given inputs.
 
-  do {
-    info += describeFiber(node);
-    node = node.return;
-  } while (node);
+function findTransitionLane(lanePriority, wipLanes, pendingLanes) {
+  if (lanePriority === TransitionShortLanePriority) {
+    // First look for lanes that are completely unclaimed, i.e. have no
+    // pending work.
+    var lane = pickArbitraryLane(TransitionShortLanes & ~pendingLanes);
 
-  return info;
-}
-var current = null;
-var isRendering = false;
-function getCurrentFiberOwnerNameInDevOrNull() {
-  {
-    if (current === null) {
-      return null;
+    if (lane === NoLane) {
+      // If all lanes have pending work, look for a lane that isn't currently
+      // being worked on.
+      lane = pickArbitraryLane(TransitionShortLanes & ~wipLanes);
+
+      if (lane === NoLane) {
+        // If everything is being worked on, pick any lane. This has the
+        // effect of interrupting the current work-in-progress.
+        lane = pickArbitraryLane(TransitionShortLanes);
+      }
     }
 
-    var owner = current._debugOwner;
+    return lane;
+  }
 
-    if (owner !== null && typeof owner !== "undefined") {
-      return getComponentName(owner.type);
+  if (lanePriority === TransitionLongLanePriority) {
+    // First look for lanes that are completely unclaimed, i.e. have no
+    // pending work.
+    var _lane4 = pickArbitraryLane(TransitionLongLanes & ~pendingLanes);
+
+    if (_lane4 === NoLane) {
+      // If all lanes have pending work, look for a lane that isn't currently
+      // being worked on.
+      _lane4 = pickArbitraryLane(TransitionLongLanes & ~wipLanes);
+
+      if (_lane4 === NoLane) {
+        // If everything is being worked on, pick any lane. This has the
+        // effect of interrupting the current work-in-progress.
+        _lane4 = pickArbitraryLane(TransitionLongLanes);
+      }
     }
+
+    return _lane4;
   }
 
-  return null;
-}
-function getCurrentFiberStackInDev() {
   {
-    if (current === null) {
-      return "";
-    } // Safe because if current fiber exists, we are reconciling,
-    // and it is guaranteed to be the work-in-progress version.
+    throw Error(
+      "Invalid transition priority: " +
+        lanePriority +
+        ". This is a bug in React."
+    );
+  }
+} // To ensure consistency across multiple updates in the same event, this should
+// be pure function, so that it always returns the same lane for given inputs.
 
-    return getStackByFiberInDevAndProd(current);
+function findRetryLane(wipLanes) {
+  // This is a fork of `findUpdateLane` designed specifically for Suspense
+  // "retries"  a special update that attempts to flip a Suspense boundary
+  // from its placeholder state to its primary/resolved state.
+  var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
+
+  if (lane === NoLane) {
+    lane = pickArbitraryLane(RetryLanes);
   }
+
+  return lane;
 }
-function resetCurrentFiber() {
-  {
-    ReactDebugCurrentFrame.getCurrentStack = null;
-    current = null;
-    isRendering = false;
-  }
+
+function getHighestPriorityLane(lanes) {
+  return lanes & -lanes;
 }
-function setCurrentFiber(fiber) {
-  {
-    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
-    current = fiber;
-    isRendering = false;
-  }
+
+function getLowestPriorityLane(lanes) {
+  // This finds the most significant non-zero bit.
+  var index = 31 - clz32(lanes);
+  return index < 0 ? NoLanes : 1 << index;
 }
-function setIsRendering(rendering) {
-  {
-    isRendering = rendering;
-  }
+
+function getEqualOrHigherPriorityLanes(lanes) {
+  return (getLowestPriorityLane(lanes) << 1) - 1;
 }
 
-var ReactStrictModeWarnings = {
-  recordUnsafeLifecycleWarnings: function(fiber, instance) {},
-  flushPendingUnsafeLifecycleWarnings: function() {},
-  recordLegacyContextWarning: function(fiber, instance) {},
-  flushLegacyContextWarning: function() {},
-  discardPendingWarnings: function() {}
-};
+function pickArbitraryLane(lanes) {
+  // This wrapper function gets inlined. Only exists so to communicate that it
+  // doesn't matter which bit is selected; you can pick any bit without
+  // affecting the algorithms where its used. Here I'm using
+  // getHighestPriorityLane because it requires the fewest operations.
+  return getHighestPriorityLane(lanes);
+}
 
-{
-  var findStrictRoot = function(fiber) {
-    var maybeStrictRoot = null;
-    var node = fiber;
+function pickArbitraryLaneIndex(lanes) {
+  return 31 - clz32(lanes);
+}
 
-    while (node !== null) {
-      if (node.mode & StrictMode) {
-        maybeStrictRoot = node;
-      }
+function laneToIndex(lane) {
+  return pickArbitraryLaneIndex(lane);
+}
 
-      node = node.return;
-    }
+function includesSomeLane(a, b) {
+  return (a & b) !== NoLanes;
+}
+function isSubsetOfLanes(set, subset) {
+  return (set & subset) === subset;
+}
+function mergeLanes(a, b) {
+  return a | b;
+}
+function removeLanes(set, subset) {
+  return set & ~subset;
+} // Seems redundant, but it changes the type from a single lane (used for
+// updates) to a group of lanes (used for flushing work).
 
-    return maybeStrictRoot;
-  };
+function laneToLanes(lane) {
+  return lane;
+}
+function createLaneMap(initial) {
+  return new Array(TotalLanes).fill(initial);
+}
+function markRootUpdated(root, updateLane, eventTime) {
+  root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But
+  // it's not practical to try every single possible combination. We need a
+  // heuristic to decide which lanes to attempt to render, and in which batches.
+  // For now, we use the same heuristic as in the old ExpirationTimes model:
+  // retry any lane at equal or lower priority, but don't try updates at higher
+  // priority without also including the lower priority updates. This works well
+  // when considering updates across different priority levels, but isn't
+  // sufficient for updates within the same priority, since we want to treat
+  // those updates as parallel.
+  // Unsuspend any update at equal or lower priority.
 
-  var setToSortedString = function(set) {
-    var array = [];
-    set.forEach(function(value) {
-      array.push(value);
-    });
-    return array.sort().join(", ");
-  };
+  var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111
 
-  var pendingComponentWillMountWarnings = [];
-  var pendingUNSAFE_ComponentWillMountWarnings = [];
-  var pendingComponentWillReceivePropsWarnings = [];
-  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
-  var pendingComponentWillUpdateWarnings = [];
-  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.
+  root.suspendedLanes &= higherPriorityLanes;
+  root.pingedLanes &= higherPriorityLanes;
+  var eventTimes = root.eventTimes;
+  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
+  // recent event, and we assume time is monotonically increasing.
 
-  var didWarnAboutUnsafeLifecycles = new Set();
+  eventTimes[index] = eventTime;
+}
+function markRootSuspended(root, suspendedLanes) {
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.
 
-  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(
-    fiber,
-    instance
-  ) {
-    // Dedup strategy: Warn once per component.
-    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
-      return;
-    }
+  var expirationTimes = root.expirationTimes;
+  var lanes = suspendedLanes;
+
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    expirationTimes[index] = NoTimestamp;
+    lanes &= ~lane;
+  }
+}
+function markRootPinged(root, pingedLanes, eventTime) {
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+}
+function markRootExpired(root, expiredLanes) {
+  root.expiredLanes |= expiredLanes & root.pendingLanes;
+}
+function hasDiscreteLanes(lanes) {
+  return (lanes & InputDiscreteLanes) !== NoLanes;
+}
+function markRootMutableRead(root, updateLane) {
+  root.mutableReadLanes |= updateLane & root.pendingLanes;
+}
+function markRootFinished(root, remainingLanes) {
+  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
+  root.pendingLanes = remainingLanes; // Let's try everything again
+
+  root.suspendedLanes = 0;
+  root.pingedLanes = 0;
+  root.expiredLanes &= remainingLanes;
+  root.mutableReadLanes &= remainingLanes;
+  root.entangledLanes &= remainingLanes;
+  var entanglements = root.entanglements;
+  var eventTimes = root.eventTimes;
+  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work
 
-    if (
-      typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
-      instance.componentWillMount.__suppressDeprecationWarning !== true
-    ) {
-      pendingComponentWillMountWarnings.push(fiber);
-    }
+  var lanes = noLongerPendingLanes;
 
-    if (
-      fiber.mode & StrictMode &&
-      typeof instance.UNSAFE_componentWillMount === "function"
-    ) {
-      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
-    }
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    entanglements[index] = NoLanes;
+    eventTimes[index] = NoTimestamp;
+    expirationTimes[index] = NoTimestamp;
+    lanes &= ~lane;
+  }
+}
+function markRootEntangled(root, entangledLanes) {
+  root.entangledLanes |= entangledLanes;
+  var entanglements = root.entanglements;
+  var lanes = entangledLanes;
 
-    if (
-      typeof instance.componentWillReceiveProps === "function" &&
-      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
-    ) {
-      pendingComponentWillReceivePropsWarnings.push(fiber);
-    }
+  while (lanes > 0) {
+    var index = pickArbitraryLaneIndex(lanes);
+    var lane = 1 << index;
+    entanglements[index] |= entangledLanes;
+    lanes &= ~lane;
+  }
+}
+var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.
+// Based on:
+// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
 
-    if (
-      fiber.mode & StrictMode &&
-      typeof instance.UNSAFE_componentWillReceiveProps === "function"
-    ) {
-      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
-    }
+var log = Math.log;
+var LN2 = Math.LN2;
 
-    if (
-      typeof instance.componentWillUpdate === "function" &&
-      instance.componentWillUpdate.__suppressDeprecationWarning !== true
-    ) {
-      pendingComponentWillUpdateWarnings.push(fiber);
-    }
+function clz32Fallback(lanes) {
+  if (lanes === 0) {
+    return 32;
+  }
 
-    if (
-      fiber.mode & StrictMode &&
-      typeof instance.UNSAFE_componentWillUpdate === "function"
-    ) {
-      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
-    }
-  };
+  return (31 - ((log(lanes) / LN2) | 0)) | 0;
+}
 
-  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
-    // We do an initial pass to gather component names
-    var componentWillMountUniqueNames = new Set();
+// Intentionally not named imports because Rollup would use dynamic dispatch for
+var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
+  Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
+  Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
+  Scheduler_shouldYield = Scheduler.unstable_shouldYield,
+  Scheduler_requestPaint = Scheduler.unstable_requestPaint,
+  Scheduler_now$1 = Scheduler.unstable_now,
+  Scheduler_getCurrentPriorityLevel =
+    Scheduler.unstable_getCurrentPriorityLevel,
+  Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
+  Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
+  Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
+  Scheduler_LowPriority = Scheduler.unstable_LowPriority,
+  Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
 
-    if (pendingComponentWillMountWarnings.length > 0) {
-      pendingComponentWillMountWarnings.forEach(function(fiber) {
-        componentWillMountUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingComponentWillMountWarnings = [];
-    }
+{
+  // Provide explicit error message when production+profiling bundle of e.g.
+  // react-dom is used with production (non-profiling) bundle of
+  // scheduler/tracing
+  if (
+    !(
+      tracing.__interactionsRef != null &&
+      tracing.__interactionsRef.current != null
+    )
+  ) {
+    throw Error(
+      "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling"
+    );
+  }
+}
 
-    var UNSAFE_componentWillMountUniqueNames = new Set();
+var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use
+// ascending numbers so we can compare them like numbers. They start at 90 to
+// avoid clashing with Scheduler's priorities.
 
-    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
-      pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
-        UNSAFE_componentWillMountUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingUNSAFE_ComponentWillMountWarnings = [];
-    }
+var ImmediatePriority$1 = 99;
+var UserBlockingPriority$1 = 98;
+var NormalPriority$1 = 97;
+var LowPriority$1 = 96;
+var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.
 
-    var componentWillReceivePropsUniqueNames = new Set();
+var NoPriority$1 = 90;
+var shouldYield = Scheduler_shouldYield;
+var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.
+  Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function() {};
+var syncQueue = null;
+var immediateQueueCallbackNode = null;
+var isFlushingSyncQueue = false;
+var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
+// This will be the case for modern browsers that support `performance.now`. In
+// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
+// timestamp. In that case, subtract the module initialization time to simulate
+// the behavior of performance.now and keep our times small enough to fit
+// within 32 bits.
+// TODO: Consider lifting this into Scheduler.
 
-    if (pendingComponentWillReceivePropsWarnings.length > 0) {
-      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
-        componentWillReceivePropsUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingComponentWillReceivePropsWarnings = [];
-    }
+var now =
+  initialTimeMs$1 < 10000
+    ? Scheduler_now$1
+    : function() {
+        return Scheduler_now$1() - initialTimeMs$1;
+      };
+function getCurrentPriorityLevel() {
+  switch (Scheduler_getCurrentPriorityLevel()) {
+    case Scheduler_ImmediatePriority:
+      return ImmediatePriority$1;
 
-    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
+    case Scheduler_UserBlockingPriority:
+      return UserBlockingPriority$1;
 
-    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
-      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
-        UNSAFE_componentWillReceivePropsUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
-    }
+    case Scheduler_NormalPriority:
+      return NormalPriority$1;
 
-    var componentWillUpdateUniqueNames = new Set();
+    case Scheduler_LowPriority:
+      return LowPriority$1;
 
-    if (pendingComponentWillUpdateWarnings.length > 0) {
-      pendingComponentWillUpdateWarnings.forEach(function(fiber) {
-        componentWillUpdateUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingComponentWillUpdateWarnings = [];
+    case Scheduler_IdlePriority:
+      return IdlePriority$1;
+
+    default: {
+      throw Error("Unknown priority level.");
     }
+  }
+}
 
-    var UNSAFE_componentWillUpdateUniqueNames = new Set();
+function reactPriorityToSchedulerPriority(reactPriorityLevel) {
+  switch (reactPriorityLevel) {
+    case ImmediatePriority$1:
+      return Scheduler_ImmediatePriority;
 
-    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
-      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
-        UNSAFE_componentWillUpdateUniqueNames.add(
-          getComponentName(fiber.type) || "Component"
-        );
-        didWarnAboutUnsafeLifecycles.add(fiber.type);
-      });
-      pendingUNSAFE_ComponentWillUpdateWarnings = [];
-    } // Finally, we flush all the warnings
-    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
+    case UserBlockingPriority$1:
+      return Scheduler_UserBlockingPriority;
 
-    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
-      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
+    case NormalPriority$1:
+      return Scheduler_NormalPriority;
 
-      error(
-        "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
-          "\nPlease update the following components: %s",
-        sortedNames
-      );
-    }
+    case LowPriority$1:
+      return Scheduler_LowPriority;
 
-    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
-      var _sortedNames = setToSortedString(
-        UNSAFE_componentWillReceivePropsUniqueNames
-      );
+    case IdlePriority$1:
+      return Scheduler_IdlePriority;
 
-      error(
-        "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended " +
-          "and may indicate bugs in your code. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move data fetching code or side effects to componentDidUpdate.\n" +
-          "* If you're updating state whenever props change, " +
-          "refactor your code to use memoization techniques or move it to " +
-          "static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames
-      );
+    default: {
+      throw Error("Unknown priority level.");
     }
+  }
+}
 
-    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
-      var _sortedNames2 = setToSortedString(
-        UNSAFE_componentWillUpdateUniqueNames
-      );
+function runWithPriority(reactPriorityLevel, fn) {
+  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
+  return Scheduler_runWithPriority(priorityLevel, fn);
+}
+function scheduleCallback(reactPriorityLevel, callback, options) {
+  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
+  return Scheduler_scheduleCallback(priorityLevel, callback, options);
+}
+function scheduleSyncCallback(callback) {
+  // Push this callback into an internal queue. We'll flush these either in
+  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
+  if (syncQueue === null) {
+    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.
 
-      error(
-        "Using UNSAFE_componentWillUpdate in strict mode is not recommended " +
-          "and may indicate bugs in your code. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move data fetching code or side effects to componentDidUpdate.\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames2
-      );
-    }
+    immediateQueueCallbackNode = Scheduler_scheduleCallback(
+      Scheduler_ImmediatePriority,
+      flushSyncCallbackQueueImpl
+    );
+  } else {
+    // Push onto existing queue. Don't need to schedule a callback because
+    // we already scheduled one when we created the queue.
+    syncQueue.push(callback);
+  }
 
-    if (componentWillMountUniqueNames.size > 0) {
-      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
+  return fakeCallbackNode;
+}
+function cancelCallback(callbackNode) {
+  if (callbackNode !== fakeCallbackNode) {
+    Scheduler_cancelCallback(callbackNode);
+  }
+}
+function flushSyncCallbackQueue() {
+  if (immediateQueueCallbackNode !== null) {
+    var node = immediateQueueCallbackNode;
+    immediateQueueCallbackNode = null;
+    Scheduler_cancelCallback(node);
+  }
+
+  flushSyncCallbackQueueImpl();
+}
+
+function flushSyncCallbackQueueImpl() {
+  if (!isFlushingSyncQueue && syncQueue !== null) {
+    // Prevent re-entrancy.
+    isFlushingSyncQueue = true;
+    var i = 0;
 
-      warn(
-        "componentWillMount has been renamed, and is not recommended for use. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
-          "* Rename componentWillMount to UNSAFE_componentWillMount to suppress " +
-          "this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. " +
-          "To rename all deprecated lifecycles to their new names, you can run " +
-          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames3
-      );
-    }
+    try {
+      var _isSync = true;
+      var queue = syncQueue;
+      setCurrentUpdateLanePriority(SyncLanePriority);
+      runWithPriority(ImmediatePriority$1, function() {
+        for (; i < queue.length; i++) {
+          var callback = queue[i];
 
-    if (componentWillReceivePropsUniqueNames.size > 0) {
-      var _sortedNames4 = setToSortedString(
-        componentWillReceivePropsUniqueNames
-      );
+          do {
+            callback = callback(_isSync);
+          } while (callback !== null);
+        }
+      });
+      syncQueue = null;
+    } catch (error) {
+      // If something throws, leave the remaining callbacks on the queue.
+      if (syncQueue !== null) {
+        syncQueue = syncQueue.slice(i + 1);
+      } // Resume flushing in the next tick
 
-      warn(
-        "componentWillReceiveProps has been renamed, and is not recommended for use. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move data fetching code or side effects to componentDidUpdate.\n" +
-          "* If you're updating state whenever props change, refactor your " +
-          "code to use memoization techniques or move it to " +
-          "static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n" +
-          "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress " +
-          "this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. " +
-          "To rename all deprecated lifecycles to their new names, you can run " +
-          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames4
+      Scheduler_scheduleCallback(
+        Scheduler_ImmediatePriority,
+        flushSyncCallbackQueue
       );
+      throw error;
+    } finally {
+      isFlushingSyncQueue = false;
     }
+  }
+}
 
-    if (componentWillUpdateUniqueNames.size > 0) {
-      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
+function describeFiber(fiber) {
+  var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
+  var source = fiber._debugSource;
 
-      warn(
-        "componentWillUpdate has been renamed, and is not recommended for use. " +
-          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
-          "* Move data fetching code or side effects to componentDidUpdate.\n" +
-          "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress " +
-          "this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. " +
-          "To rename all deprecated lifecycles to their new names, you can run " +
-          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
-          "\nPlease update the following components: %s",
-        _sortedNames5
-      );
-    }
-  };
+  switch (fiber.tag) {
+    case HostComponent:
+      return describeBuiltInComponentFrame(fiber.type, source, owner);
 
-  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.
+    case LazyComponent:
+      return describeBuiltInComponentFrame("Lazy", source, owner);
 
-  var didWarnAboutLegacyContext = new Set();
+    case SuspenseComponent:
+      return describeBuiltInComponentFrame("Suspense", source, owner);
 
-  ReactStrictModeWarnings.recordLegacyContextWarning = function(
-    fiber,
-    instance
-  ) {
-    var strictRoot = findStrictRoot(fiber);
+    case SuspenseListComponent:
+      return describeBuiltInComponentFrame("SuspenseList", source, owner);
 
-    if (strictRoot === null) {
-      error(
-        "Expected to find a StrictMode component in a strict mode tree. " +
-          "This error is likely caused by a bug in React. Please file an issue."
-      );
+    case FunctionComponent:
+    case IndeterminateComponent:
+    case SimpleMemoComponent:
+      return describeFunctionComponentFrame(fiber.type, source, owner);
 
-      return;
-    } // Dedup strategy: Warn once per component.
+    case ForwardRef:
+      return describeFunctionComponentFrame(fiber.type.render, source, owner);
 
-    if (didWarnAboutLegacyContext.has(fiber.type)) {
-      return;
-    }
+    case Block:
+      return describeFunctionComponentFrame(fiber.type._render, source, owner);
 
-    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
+    case ClassComponent:
+      return describeClassComponentFrame(fiber.type, source, owner);
 
-    if (
-      fiber.type.contextTypes != null ||
-      fiber.type.childContextTypes != null ||
-      (instance !== null && typeof instance.getChildContext === "function")
-    ) {
-      if (warningsForRoot === undefined) {
-        warningsForRoot = [];
-        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
-      }
+    default:
+      return "";
+  }
+}
 
-      warningsForRoot.push(fiber);
-    }
-  };
+function getStackByFiberInDevAndProd(workInProgress) {
+  try {
+    var info = "";
+    var node = workInProgress;
 
-  ReactStrictModeWarnings.flushLegacyContextWarning = function() {
-    pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
-      if (fiberArray.length === 0) {
-        return;
-      }
+    do {
+      info += describeFiber(node);
+      node = node.return;
+    } while (node);
 
-      var firstFiber = fiberArray[0];
-      var uniqueNames = new Set();
-      fiberArray.forEach(function(fiber) {
-        uniqueNames.add(getComponentName(fiber.type) || "Component");
-        didWarnAboutLegacyContext.add(fiber.type);
-      });
-      var sortedNames = setToSortedString(uniqueNames);
-      var firstComponentStack = getStackByFiberInDevAndProd(firstFiber);
+    return info;
+  } catch (x) {
+    return "\nError generating stack: " + x.message + "\n" + x.stack;
+  }
+}
 
-      error(
-        "Legacy context API has been detected within a strict-mode tree." +
-          "\n\nThe old API will be supported in all 16.x releases, but applications " +
-          "using it should migrate to the new version." +
-          "\n\nPlease update the following components: %s" +
-          "\n\nLearn more about this warning here: https://fb.me/react-legacy-context" +
-          "%s",
-        sortedNames,
-        firstComponentStack
-      );
-    });
-  };
+var NoMode = 0;
+var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
+// tag instead
 
-  ReactStrictModeWarnings.discardPendingWarnings = function() {
-    pendingComponentWillMountWarnings = [];
-    pendingUNSAFE_ComponentWillMountWarnings = [];
-    pendingComponentWillReceivePropsWarnings = [];
-    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
-    pendingComponentWillUpdateWarnings = [];
-    pendingUNSAFE_ComponentWillUpdateWarnings = [];
-    pendingLegacyContextWarning = new Map();
-  };
+var BlockingMode = 2;
+var ConcurrentMode = 4;
+var ProfileMode = 8;
+var DebugTracingMode = 16;
+
+/**
+ * inlined Object.is polyfill to avoid requiring consumers ship their own
+ * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
+ */
+function is(x, y) {
+  return (
+    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
+  );
 }
 
-var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.
+var objectIs = typeof Object.is === "function" ? Object.is : is;
 
-var failedBoundaries = null;
-var setRefreshHandler = function(handler) {
-  {
-    resolveFamily = handler;
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+/**
+ * Performs equality by iterating through keys on an object and returning false
+ * when any key has values which are not strictly equal between the arguments.
+ * Returns true when the values of all keys are strictly equal.
+ */
+
+function shallowEqual(objA, objB) {
+  if (objectIs(objA, objB)) {
+    return true;
   }
-};
-function resolveFunctionForHotReloading(type) {
-  {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return type;
-    }
 
-    var family = resolveFamily(type);
+  if (
+    typeof objA !== "object" ||
+    objA === null ||
+    typeof objB !== "object" ||
+    objB === null
+  ) {
+    return false;
+  }
 
-    if (family === undefined) {
-      return type;
-    } // Use the latest known implementation.
+  var keysA = Object.keys(objA);
+  var keysB = Object.keys(objB);
 
-    return family.current;
+  if (keysA.length !== keysB.length) {
+    return false;
+  } // Test for A's keys different from B.
+
+  for (var i = 0; i < keysA.length; i++) {
+    if (
+      !hasOwnProperty.call(objB, keysA[i]) ||
+      !objectIs(objA[keysA[i]], objB[keysA[i]])
+    ) {
+      return false;
+    }
   }
+
+  return true;
 }
-function resolveClassForHotReloading(type) {
-  // No implementation differences.
-  return resolveFunctionForHotReloading(type);
-}
-function resolveForwardRefForHotReloading(type) {
+
+var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
+var current = null;
+var isRendering = false;
+function getCurrentFiberOwnerNameInDevOrNull() {
   {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return type;
+    if (current === null) {
+      return null;
     }
 
-    var family = resolveFamily(type);
-
-    if (family === undefined) {
-      // Check if we're dealing with a real forwardRef. Don't want to crash early.
-      if (
-        type !== null &&
-        type !== undefined &&
-        typeof type.render === "function"
-      ) {
-        // ForwardRef is special because its resolved .type is an object,
-        // but it's possible that we only have its inner render function in the map.
-        // If that inner render function is different, we'll build a new forwardRef type.
-        var currentRender = resolveFunctionForHotReloading(type.render);
+    var owner = current._debugOwner;
 
-        if (type.render !== currentRender) {
-          var syntheticType = {
-            $$typeof: REACT_FORWARD_REF_TYPE,
-            render: currentRender
-          };
+    if (owner !== null && typeof owner !== "undefined") {
+      return getComponentName(owner.type);
+    }
+  }
 
-          if (type.displayName !== undefined) {
-            syntheticType.displayName = type.displayName;
-          }
+  return null;
+}
 
-          return syntheticType;
-        }
-      }
+function getCurrentFiberStackInDev() {
+  {
+    if (current === null) {
+      return "";
+    } // Safe because if current fiber exists, we are reconciling,
+    // and it is guaranteed to be the work-in-progress version.
 
-      return type;
-    } // Use the latest known implementation.
+    return getStackByFiberInDevAndProd(current);
+  }
+}
 
-    return family.current;
+function resetCurrentFiber() {
+  {
+    ReactDebugCurrentFrame$1.getCurrentStack = null;
+    current = null;
+    isRendering = false;
   }
 }
-function isCompatibleFamilyForHotReloading(fiber, element) {
+function setCurrentFiber(fiber) {
   {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return false;
-    }
-
-    var prevType = fiber.elementType;
-    var nextType = element.type; // If we got here, we know types aren't === equal.
+    ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;
+    current = fiber;
+    isRendering = false;
+  }
+}
+function setIsRendering(rendering) {
+  {
+    isRendering = rendering;
+  }
+}
+function getIsRendering() {
+  {
+    return isRendering;
+  }
+}
 
-    var needsCompareFamilies = false;
-    var $$typeofNextType =
-      typeof nextType === "object" && nextType !== null
-        ? nextType.$$typeof
-        : null;
+var ReactStrictModeWarnings = {
+  recordUnsafeLifecycleWarnings: function(fiber, instance) {},
+  flushPendingUnsafeLifecycleWarnings: function() {},
+  recordLegacyContextWarning: function(fiber, instance) {},
+  flushLegacyContextWarning: function() {},
+  discardPendingWarnings: function() {}
+};
 
-    switch (fiber.tag) {
-      case ClassComponent: {
-        if (typeof nextType === "function") {
-          needsCompareFamilies = true;
-        }
+{
+  var findStrictRoot = function(fiber) {
+    var maybeStrictRoot = null;
+    var node = fiber;
 
-        break;
+    while (node !== null) {
+      if (node.mode & StrictMode) {
+        maybeStrictRoot = node;
       }
 
-      case FunctionComponent: {
-        if (typeof nextType === "function") {
-          needsCompareFamilies = true;
-        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
-          // We don't know the inner type yet.
-          // We're going to assume that the lazy inner type is stable,
-          // and so it is sufficient to avoid reconciling it away.
-          // We're not going to unwrap or actually use the new lazy type.
-          needsCompareFamilies = true;
-        }
-
-        break;
-      }
+      node = node.return;
+    }
 
-      case ForwardRef: {
-        if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
-          needsCompareFamilies = true;
-        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
-          needsCompareFamilies = true;
-        }
+    return maybeStrictRoot;
+  };
 
-        break;
-      }
+  var setToSortedString = function(set) {
+    var array = [];
+    set.forEach(function(value) {
+      array.push(value);
+    });
+    return array.sort().join(", ");
+  };
 
-      case MemoComponent:
-      case SimpleMemoComponent: {
-        if ($$typeofNextType === REACT_MEMO_TYPE) {
-          // TODO: if it was but can no longer be simple,
-          // we shouldn't set this.
-          needsCompareFamilies = true;
-        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
-          needsCompareFamilies = true;
-        }
+  var pendingComponentWillMountWarnings = [];
+  var pendingUNSAFE_ComponentWillMountWarnings = [];
+  var pendingComponentWillReceivePropsWarnings = [];
+  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
+  var pendingComponentWillUpdateWarnings = [];
+  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.
 
-        break;
-      }
+  var didWarnAboutUnsafeLifecycles = new Set();
 
-      default:
-        return false;
-    } // Check if both types have a family and it's the same one.
+  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(
+    fiber,
+    instance
+  ) {
+    // Dedup strategy: Warn once per component.
+    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
+      return;
+    }
 
-    if (needsCompareFamilies) {
-      // Note: memo() and forwardRef() we'll compare outer rather than inner type.
-      // This means both of them need to be registered to preserve state.
-      // If we unwrapped and compared the inner types for wrappers instead,
-      // then we would risk falsely saying two separate memo(Foo)
-      // calls are equivalent because they wrap the same Foo function.
-      var prevFamily = resolveFamily(prevType);
+    if (
+      typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
+      instance.componentWillMount.__suppressDeprecationWarning !== true
+    ) {
+      pendingComponentWillMountWarnings.push(fiber);
+    }
 
-      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
-        return true;
-      }
+    if (
+      fiber.mode & StrictMode &&
+      typeof instance.UNSAFE_componentWillMount === "function"
+    ) {
+      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
     }
 
-    return false;
-  }
-}
-function markFailedErrorBoundaryForHotReloading(fiber) {
-  {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return;
+    if (
+      typeof instance.componentWillReceiveProps === "function" &&
+      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
+    ) {
+      pendingComponentWillReceivePropsWarnings.push(fiber);
     }
 
-    if (typeof WeakSet !== "function") {
-      return;
+    if (
+      fiber.mode & StrictMode &&
+      typeof instance.UNSAFE_componentWillReceiveProps === "function"
+    ) {
+      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
     }
 
-    if (failedBoundaries === null) {
-      failedBoundaries = new WeakSet();
+    if (
+      typeof instance.componentWillUpdate === "function" &&
+      instance.componentWillUpdate.__suppressDeprecationWarning !== true
+    ) {
+      pendingComponentWillUpdateWarnings.push(fiber);
     }
 
-    failedBoundaries.add(fiber);
-  }
-}
-var scheduleRefresh = function(root, update) {
-  {
-    if (resolveFamily === null) {
-      // Hot reloading is disabled.
-      return;
+    if (
+      fiber.mode & StrictMode &&
+      typeof instance.UNSAFE_componentWillUpdate === "function"
+    ) {
+      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
     }
+  };
 
-    var staleFamilies = update.staleFamilies,
-      updatedFamilies = update.updatedFamilies;
-    flushPassiveEffects();
-    flushSync(function() {
-      scheduleFibersWithFamiliesRecursively(
-        root.current,
-        updatedFamilies,
-        staleFamilies
-      );
-    });
-  }
-};
-var scheduleRoot = function(root, element) {
-  {
-    if (root.context !== emptyContextObject) {
-      // Super edge case: root has a legacy _renderSubtree context
-      // but we don't know the parentComponent so we can't pass it.
-      // Just ignore. We'll delete this with _renderSubtree code path later.
-      return;
+  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
+    // We do an initial pass to gather component names
+    var componentWillMountUniqueNames = new Set();
+
+    if (pendingComponentWillMountWarnings.length > 0) {
+      pendingComponentWillMountWarnings.forEach(function(fiber) {
+        componentWillMountUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingComponentWillMountWarnings = [];
     }
 
-    flushPassiveEffects();
-    syncUpdates(function() {
-      updateContainer(element, root, null, null);
-    });
-  }
-};
+    var UNSAFE_componentWillMountUniqueNames = new Set();
 
-function scheduleFibersWithFamiliesRecursively(
-  fiber,
-  updatedFamilies,
-  staleFamilies
-) {
-  {
-    var alternate = fiber.alternate,
-      child = fiber.child,
-      sibling = fiber.sibling,
-      tag = fiber.tag,
-      type = fiber.type;
-    var candidateType = null;
+    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
+      pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
+        UNSAFE_componentWillMountUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingUNSAFE_ComponentWillMountWarnings = [];
+    }
 
-    switch (tag) {
-      case FunctionComponent:
-      case SimpleMemoComponent:
-      case ClassComponent:
-        candidateType = type;
-        break;
+    var componentWillReceivePropsUniqueNames = new Set();
 
-      case ForwardRef:
-        candidateType = type.render;
-        break;
+    if (pendingComponentWillReceivePropsWarnings.length > 0) {
+      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
+        componentWillReceivePropsUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingComponentWillReceivePropsWarnings = [];
     }
 
-    if (resolveFamily === null) {
-      throw new Error("Expected resolveFamily to be set during hot reload.");
-    }
+    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
 
-    var needsRender = false;
-    var needsRemount = false;
+    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
+      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
+        UNSAFE_componentWillReceivePropsUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
+    }
 
-    if (candidateType !== null) {
-      var family = resolveFamily(candidateType);
+    var componentWillUpdateUniqueNames = new Set();
 
-      if (family !== undefined) {
-        if (staleFamilies.has(family)) {
-          needsRemount = true;
-        } else if (updatedFamilies.has(family)) {
-          if (tag === ClassComponent) {
-            needsRemount = true;
-          } else {
-            needsRender = true;
-          }
-        }
-      }
+    if (pendingComponentWillUpdateWarnings.length > 0) {
+      pendingComponentWillUpdateWarnings.forEach(function(fiber) {
+        componentWillUpdateUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingComponentWillUpdateWarnings = [];
     }
 
-    if (failedBoundaries !== null) {
-      if (
-        failedBoundaries.has(fiber) ||
-        (alternate !== null && failedBoundaries.has(alternate))
-      ) {
-        needsRemount = true;
-      }
-    }
+    var UNSAFE_componentWillUpdateUniqueNames = new Set();
 
-    if (needsRemount) {
-      fiber._debugNeedsRemount = true;
-    }
+    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
+      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
+        UNSAFE_componentWillUpdateUniqueNames.add(
+          getComponentName(fiber.type) || "Component"
+        );
+        didWarnAboutUnsafeLifecycles.add(fiber.type);
+      });
+      pendingUNSAFE_ComponentWillUpdateWarnings = [];
+    } // Finally, we flush all the warnings
+    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
 
-    if (needsRemount || needsRender) {
-      scheduleWork(fiber, Sync);
-    }
+    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
+      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
 
-    if (child !== null && !needsRemount) {
-      scheduleFibersWithFamiliesRecursively(
-        child,
-        updatedFamilies,
-        staleFamilies
+      error(
+        "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. " +
+          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
+          "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
+          "\nPlease update the following components: %s",
+        sortedNames
       );
     }
 
-    if (sibling !== null) {
-      scheduleFibersWithFamiliesRecursively(
-        sibling,
-        updatedFamilies,
-        staleFamilies
+    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
+      var _sortedNames = setToSortedString(
+        UNSAFE_componentWillReceivePropsUniqueNames
+      );
+
+      error(
+        "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended " +
+          "and may indicate bugs in your code. " +
+          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
+          "* Move data fetching code or side effects to componentDidUpdate.\n" +
+          "* If you're updating state whenever props change, " +
+          "refactor your code to use memoization techniques or move it to " +
+          "static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames
       );
     }
-  }
-}
 
-var findHostInstancesForRefresh = function(root, families) {
-  {
-    var hostInstances = new Set();
-    var types = new Set(
-      families.map(function(family) {
-        return family.current;
-      })
-    );
-    findHostInstancesForMatchingFibersRecursively(
-      root.current,
-      types,
-      hostInstances
-    );
-    return hostInstances;
-  }
-};
+    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
+      var _sortedNames2 = setToSortedString(
+        UNSAFE_componentWillUpdateUniqueNames
+      );
 
-function findHostInstancesForMatchingFibersRecursively(
-  fiber,
-  types,
-  hostInstances
-) {
-  {
-    var child = fiber.child,
-      sibling = fiber.sibling,
-      tag = fiber.tag,
-      type = fiber.type;
-    var candidateType = null;
+      error(
+        "Using UNSAFE_componentWillUpdate in strict mode is not recommended " +
+          "and may indicate bugs in your code. " +
+          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
+          "* Move data fetching code or side effects to componentDidUpdate.\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames2
+      );
+    }
 
-    switch (tag) {
-      case FunctionComponent:
-      case SimpleMemoComponent:
-      case ClassComponent:
-        candidateType = type;
-        break;
+    if (componentWillMountUniqueNames.size > 0) {
+      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
 
-      case ForwardRef:
-        candidateType = type.render;
-        break;
+      warn(
+        "componentWillMount has been renamed, and is not recommended for use. " +
+          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
+          "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
+          "* Rename componentWillMount to UNSAFE_componentWillMount to suppress " +
+          "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
+          "To rename all deprecated lifecycles to their new names, you can run " +
+          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames3
+      );
     }
 
-    var didMatch = false;
+    if (componentWillReceivePropsUniqueNames.size > 0) {
+      var _sortedNames4 = setToSortedString(
+        componentWillReceivePropsUniqueNames
+      );
 
-    if (candidateType !== null) {
-      if (types.has(candidateType)) {
-        didMatch = true;
-      }
+      warn(
+        "componentWillReceiveProps has been renamed, and is not recommended for use. " +
+          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
+          "* Move data fetching code or side effects to componentDidUpdate.\n" +
+          "* If you're updating state whenever props change, refactor your " +
+          "code to use memoization techniques or move it to " +
+          "static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n" +
+          "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress " +
+          "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
+          "To rename all deprecated lifecycles to their new names, you can run " +
+          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames4
+      );
     }
 
-    if (didMatch) {
-      // We have a match. This only drills down to the closest host components.
-      // There's no need to search deeper because for the purpose of giving
-      // visual feedback, "flashing" outermost parent rectangles is sufficient.
-      findHostInstancesForFiberShallowly(fiber, hostInstances);
-    } else {
-      // If there's no match, maybe there will be one further down in the child tree.
-      if (child !== null) {
-        findHostInstancesForMatchingFibersRecursively(
-          child,
-          types,
-          hostInstances
-        );
-      }
-    }
+    if (componentWillUpdateUniqueNames.size > 0) {
+      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
 
-    if (sibling !== null) {
-      findHostInstancesForMatchingFibersRecursively(
-        sibling,
-        types,
-        hostInstances
+      warn(
+        "componentWillUpdate has been renamed, and is not recommended for use. " +
+          "See https://fb.me/react-unsafe-component-lifecycles for details.\n\n" +
+          "* Move data fetching code or side effects to componentDidUpdate.\n" +
+          "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress " +
+          "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
+          "To rename all deprecated lifecycles to their new names, you can run " +
+          "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" +
+          "\nPlease update the following components: %s",
+        _sortedNames5
       );
     }
-  }
-}
+  };
 
-function findHostInstancesForFiberShallowly(fiber, hostInstances) {
-  {
-    var foundHostInstances = findChildHostInstancesForFiberShallowly(
-      fiber,
-      hostInstances
-    );
+  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.
 
-    if (foundHostInstances) {
-      return;
-    } // If we didn't find any host children, fallback to closest host parent.
+  var didWarnAboutLegacyContext = new Set();
 
-    var node = fiber;
+  ReactStrictModeWarnings.recordLegacyContextWarning = function(
+    fiber,
+    instance
+  ) {
+    var strictRoot = findStrictRoot(fiber);
 
-    while (true) {
-      switch (node.tag) {
-        case HostComponent:
-          hostInstances.add(node.stateNode);
-          return;
+    if (strictRoot === null) {
+      error(
+        "Expected to find a StrictMode component in a strict mode tree. " +
+          "This error is likely caused by a bug in React. Please file an issue."
+      );
 
-        case HostPortal:
-          hostInstances.add(node.stateNode.containerInfo);
-          return;
+      return;
+    } // Dedup strategy: Warn once per component.
 
-        case HostRoot:
-          hostInstances.add(node.stateNode.containerInfo);
-          return;
-      }
+    if (didWarnAboutLegacyContext.has(fiber.type)) {
+      return;
+    }
+
+    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
 
-      if (node.return === null) {
-        throw new Error("Expected to reach root first.");
+    if (
+      fiber.type.contextTypes != null ||
+      fiber.type.childContextTypes != null ||
+      (instance !== null && typeof instance.getChildContext === "function")
+    ) {
+      if (warningsForRoot === undefined) {
+        warningsForRoot = [];
+        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
       }
 
-      node = node.return;
+      warningsForRoot.push(fiber);
     }
-  }
-}
-
-function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
-  {
-    var node = fiber;
-    var foundHostInstances = false;
+  };
 
-    while (true) {
-      if (node.tag === HostComponent) {
-        // We got a match.
-        foundHostInstances = true;
-        hostInstances.add(node.stateNode); // There may still be more, so keep searching.
-      } else if (node.child !== null) {
-        node.child.return = node;
-        node = node.child;
-        continue;
+  ReactStrictModeWarnings.flushLegacyContextWarning = function() {
+    pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
+      if (fiberArray.length === 0) {
+        return;
       }
 
-      if (node === fiber) {
-        return foundHostInstances;
-      }
+      var firstFiber = fiberArray[0];
+      var uniqueNames = new Set();
+      fiberArray.forEach(function(fiber) {
+        uniqueNames.add(getComponentName(fiber.type) || "Component");
+        didWarnAboutLegacyContext.add(fiber.type);
+      });
+      var sortedNames = setToSortedString(uniqueNames);
 
-      while (node.sibling === null) {
-        if (node.return === null || node.return === fiber) {
-          return foundHostInstances;
-        }
+      try {
+        setCurrentFiber(firstFiber);
 
-        node = node.return;
+        error(
+          "Legacy context API has been detected within a strict-mode tree." +
+            "\n\nThe old API will be supported in all 16.x releases, but applications " +
+            "using it should migrate to the new version." +
+            "\n\nPlease update the following components: %s" +
+            "\n\nLearn more about this warning here: https://fb.me/react-legacy-context",
+          sortedNames
+        );
+      } finally {
+        resetCurrentFiber();
       }
+    });
+  };
 
-      node.sibling.return = node.return;
-      node = node.sibling;
-    }
-  }
-
-  return false;
+  ReactStrictModeWarnings.discardPendingWarnings = function() {
+    pendingComponentWillMountWarnings = [];
+    pendingUNSAFE_ComponentWillMountWarnings = [];
+    pendingComponentWillReceivePropsWarnings = [];
+    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
+    pendingComponentWillUpdateWarnings = [];
+    pendingUNSAFE_ComponentWillUpdateWarnings = [];
+    pendingLegacyContextWarning = new Map();
+  };
 }
 
 function resolveDefaultProps(Component, baseProps) {
@@ -6424,15 +6596,11 @@ function resolveDefaultProps(Component, baseProps) {
 
   return baseProps;
 }
-function readLazyComponentType(lazyComponent) {
-  initializeLazyComponentType(lazyComponent);
-
-  if (lazyComponent._status !== Resolved) {
-    throw lazyComponent._result;
-  }
 
-  return lazyComponent._result;
-}
+// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
+// Math.pow(2, 30) - 1
+// 0b111111111111111111111111111111
+var MAX_SIGNED_31_BIT_INT = 1073741823;
 
 var valueCursor = createCursor(null);
 var rendererSigil;
@@ -6522,28 +6690,24 @@ function calculateChangedBits(context, newValue, oldValue) {
     return changedBits | 0;
   }
 }
-function scheduleWorkOnParentPath(parent, renderExpirationTime) {
-  // Update the child expiration time of all the ancestors, including
-  // the alternates.
+function scheduleWorkOnParentPath(parent, renderLanes) {
+  // Update the child lanes of all the ancestors, including the alternates.
   var node = parent;
 
   while (node !== null) {
     var alternate = node.alternate;
 
-    if (node.childExpirationTime < renderExpirationTime) {
-      node.childExpirationTime = renderExpirationTime;
+    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
+      node.childLanes = mergeLanes(node.childLanes, renderLanes);
 
-      if (
-        alternate !== null &&
-        alternate.childExpirationTime < renderExpirationTime
-      ) {
-        alternate.childExpirationTime = renderExpirationTime;
+      if (alternate !== null) {
+        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
       }
     } else if (
       alternate !== null &&
-      alternate.childExpirationTime < renderExpirationTime
+      !isSubsetOfLanes(alternate.childLanes, renderLanes)
     ) {
-      alternate.childExpirationTime = renderExpirationTime;
+      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
     } else {
       // Neither alternate was updated, which means the rest of the
       // ancestor path already has sufficient priority.
@@ -6557,7 +6721,7 @@ function propagateContextChange(
   workInProgress,
   context,
   changedBits,
-  renderExpirationTime
+  renderLanes
 ) {
   var fiber = workInProgress.child;
 
@@ -6584,7 +6748,11 @@ function propagateContextChange(
           // Match! Schedule an update on this fiber.
           if (fiber.tag === ClassComponent) {
             // Schedule a force update on the work-in-progress.
-            var update = createUpdate(renderExpirationTime, null);
+            var update = createUpdate(
+              NoTimestamp,
+              pickArbitraryLane(renderLanes),
+              null
+            );
             update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
             // update to the current fiber, too, which means it will persist even if
             // this render is thrown away. Since it's a race condition, not sure it's
@@ -6593,24 +6761,16 @@ function propagateContextChange(
             enqueueUpdate(fiber, update);
           }
 
-          if (fiber.expirationTime < renderExpirationTime) {
-            fiber.expirationTime = renderExpirationTime;
-          }
-
+          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
           var alternate = fiber.alternate;
 
-          if (
-            alternate !== null &&
-            alternate.expirationTime < renderExpirationTime
-          ) {
-            alternate.expirationTime = renderExpirationTime;
+          if (alternate !== null) {
+            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
           }
 
-          scheduleWorkOnParentPath(fiber.return, renderExpirationTime); // Mark the expiration time on the list, too.
+          scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.
 
-          if (list.expirationTime < renderExpirationTime) {
-            list.expirationTime = renderExpirationTime;
-          } // Since we already found a match, we can stop traversing the
+          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
           // dependency list.
 
           break;
@@ -6656,7 +6816,7 @@ function propagateContextChange(
     fiber = nextFiber;
   }
 }
-function prepareToReadContext(workInProgress, renderExpirationTime) {
+function prepareToReadContext(workInProgress, renderLanes) {
   currentlyRenderingFiber = workInProgress;
   lastContextDependency = null;
   lastContextWithAllBitsObserved = null;
@@ -6666,7 +6826,7 @@ function prepareToReadContext(workInProgress, renderExpirationTime) {
     var firstContext = dependencies.firstContext;
 
     if (firstContext !== null) {
-      if (dependencies.expirationTime >= renderExpirationTime) {
+      if (includesSomeLane(dependencies.lanes, renderLanes)) {
         // Context list has a pending update. Mark that this fiber performed work.
         markWorkInProgressReceivedUpdate();
       } // Reset the work-in-progress list
@@ -6720,7 +6880,7 @@ function readContext(context, observedBits) {
 
       lastContextDependency = contextItem;
       currentlyRenderingFiber.dependencies = {
-        expirationTime: NoWork,
+        lanes: NoLanes,
         firstContext: contextItem,
         responders: null
       };
@@ -6752,7 +6912,8 @@ var currentlyProcessingQueue;
 function initializeUpdateQueue(fiber) {
   var queue = {
     baseState: fiber.memoizedState,
-    baseQueue: null,
+    firstBaseUpdate: null,
+    lastBaseUpdate: null,
     shared: {
       pending: null
     },
@@ -6768,28 +6929,24 @@ function cloneUpdateQueue(current, workInProgress) {
   if (queue === currentQueue) {
     var clone = {
       baseState: currentQueue.baseState,
-      baseQueue: currentQueue.baseQueue,
+      firstBaseUpdate: currentQueue.firstBaseUpdate,
+      lastBaseUpdate: currentQueue.lastBaseUpdate,
       shared: currentQueue.shared,
       effects: currentQueue.effects
     };
     workInProgress.updateQueue = clone;
   }
 }
-function createUpdate(expirationTime, suspenseConfig) {
+function createUpdate(eventTime, lane, suspenseConfig) {
   var update = {
-    expirationTime: expirationTime,
+    eventTime: eventTime,
+    lane: lane,
     suspenseConfig: suspenseConfig,
     tag: UpdateState,
     payload: null,
     callback: null,
     next: null
   };
-  update.next = update;
-
-  {
-    update.priority = getCurrentPriorityLevel();
-  }
-
   return update;
 }
 function enqueueUpdate(fiber, update) {
@@ -6829,25 +6986,85 @@ function enqueueUpdate(fiber, update) {
     }
   }
 }
-function enqueueCapturedUpdate(workInProgress, update) {
+function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
+  // Captured updates are updates that are thrown by a child during the render
+  // phase. They should be discarded if the render is aborted. Therefore,
+  // we should only put them on the work-in-progress queue, not the current one.
+  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.
+
   var current = workInProgress.alternate;
 
   if (current !== null) {
-    // Ensure the work-in-progress queue is a clone
-    cloneUpdateQueue(current, workInProgress);
-  } // Captured updates go only on the work-in-progress queue.
+    var currentQueue = current.updateQueue;
+
+    if (queue === currentQueue) {
+      // The work-in-progress queue is the same as current. This happens when
+      // we bail out on a parent fiber that then captures an error thrown by
+      // a child. Since we want to append the update only to the work-in
+      // -progress queue, we need to clone the updates. We usually clone during
+      // processUpdateQueue, but that didn't happen in this case because we
+      // skipped over the parent when we bailed out.
+      var newFirst = null;
+      var newLast = null;
+      var firstBaseUpdate = queue.firstBaseUpdate;
+
+      if (firstBaseUpdate !== null) {
+        // Loop through the updates and clone them.
+        var update = firstBaseUpdate;
+
+        do {
+          var clone = {
+            eventTime: update.eventTime,
+            lane: update.lane,
+            suspenseConfig: update.suspenseConfig,
+            tag: update.tag,
+            payload: update.payload,
+            callback: update.callback,
+            next: null
+          };
 
-  var queue = workInProgress.updateQueue; // Append the update to the end of the list.
+          if (newLast === null) {
+            newFirst = newLast = clone;
+          } else {
+            newLast.next = clone;
+            newLast = clone;
+          }
 
-  var last = queue.baseQueue;
+          update = update.next;
+        } while (update !== null); // Append the captured update the end of the cloned list.
 
-  if (last === null) {
-    queue.baseQueue = update.next = update;
-    update.next = update;
+        if (newLast === null) {
+          newFirst = newLast = capturedUpdate;
+        } else {
+          newLast.next = capturedUpdate;
+          newLast = capturedUpdate;
+        }
+      } else {
+        // There are no base updates.
+        newFirst = newLast = capturedUpdate;
+      }
+
+      queue = {
+        baseState: currentQueue.baseState,
+        firstBaseUpdate: newFirst,
+        lastBaseUpdate: newLast,
+        shared: currentQueue.shared,
+        effects: currentQueue.effects
+      };
+      workInProgress.updateQueue = queue;
+      return;
+    }
+  } // Append the update to the end of the list.
+
+  var lastBaseUpdate = queue.lastBaseUpdate;
+
+  if (lastBaseUpdate === null) {
+    queue.firstBaseUpdate = capturedUpdate;
   } else {
-    update.next = last.next;
-    last.next = update;
+    lastBaseUpdate.next = capturedUpdate;
   }
+
+  queue.lastBaseUpdate = capturedUpdate;
 }
 
 function getStateFromUpdate(
@@ -6871,6 +7088,16 @@ function getStateFromUpdate(
         var nextState = payload.call(instance, prevState, nextProps);
 
         {
+          if (workInProgress.mode & StrictMode) {
+            disableLogs();
+
+            try {
+              payload.call(instance, prevState, nextProps);
+            } finally {
+              reenableLogs();
+            }
+          }
+
           exitDisallowedContextReadInDEV();
         }
 
@@ -6899,6 +7126,16 @@ function getStateFromUpdate(
         partialState = _payload.call(instance, prevState, nextProps);
 
         {
+          if (workInProgress.mode & StrictMode) {
+            disableLogs();
+
+            try {
+              _payload.call(instance, prevState, nextProps);
+            } finally {
+              reenableLogs();
+            }
+          }
+
           exitDisallowedContextReadInDEV();
         }
       } else {
@@ -6923,161 +7160,172 @@ function getStateFromUpdate(
   return prevState;
 }
 
-function processUpdateQueue(
-  workInProgress,
-  props,
-  instance,
-  renderExpirationTime
-) {
+function processUpdateQueue(workInProgress, props, instance, renderLanes) {
   // This is always non-null on a ClassComponent or HostRoot
   var queue = workInProgress.updateQueue;
   hasForceUpdate = false;
 
   {
     currentlyProcessingQueue = queue.shared;
-  } // The last rebase update that is NOT part of the base state.
+  }
 
-  var baseQueue = queue.baseQueue; // The last pending update that hasn't been processed yet.
+  var firstBaseUpdate = queue.firstBaseUpdate;
+  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.
 
   var pendingQueue = queue.shared.pending;
 
   if (pendingQueue !== null) {
-    // We have new updates that haven't been processed yet.
-    // We'll add them to the base queue.
-    if (baseQueue !== null) {
-      // Merge the pending queue and the base queue.
-      var baseFirst = baseQueue.next;
-      var pendingFirst = pendingQueue.next;
-      baseQueue.next = pendingFirst;
-      pendingQueue.next = baseFirst;
+    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
+    // and last so that it's non-circular.
+
+    var lastPendingUpdate = pendingQueue;
+    var firstPendingUpdate = lastPendingUpdate.next;
+    lastPendingUpdate.next = null; // Append pending updates to base queue
+
+    if (lastBaseUpdate === null) {
+      firstBaseUpdate = firstPendingUpdate;
+    } else {
+      lastBaseUpdate.next = firstPendingUpdate;
     }
 
-    baseQueue = pendingQueue;
-    queue.shared.pending = null; // TODO: Pass `current` as argument
+    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
+    // we need to transfer the updates to that queue, too. Because the base
+    // queue is a singly-linked list with no cycles, we can append to both
+    // lists and take advantage of structural sharing.
+    // TODO: Pass `current` as argument
 
     var current = workInProgress.alternate;
 
     if (current !== null) {
+      // This is always non-null on a ClassComponent or HostRoot
       var currentQueue = current.updateQueue;
+      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
+
+      if (currentLastBaseUpdate !== lastBaseUpdate) {
+        if (currentLastBaseUpdate === null) {
+          currentQueue.firstBaseUpdate = firstPendingUpdate;
+        } else {
+          currentLastBaseUpdate.next = firstPendingUpdate;
+        }
 
-      if (currentQueue !== null) {
-        currentQueue.baseQueue = pendingQueue;
+        currentQueue.lastBaseUpdate = lastPendingUpdate;
       }
     }
   } // These values may change as we process the queue.
 
-  if (baseQueue !== null) {
-    var first = baseQueue.next; // Iterate through the list of updates to compute the result.
+  if (firstBaseUpdate !== null) {
+    // Iterate through the list of updates to compute the result.
+    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
+    // from the original lanes.
 
-    var newState = queue.baseState;
-    var newExpirationTime = NoWork;
+    var newLanes = NoLanes;
     var newBaseState = null;
-    var newBaseQueueFirst = null;
-    var newBaseQueueLast = null;
+    var newFirstBaseUpdate = null;
+    var newLastBaseUpdate = null;
+    var update = firstBaseUpdate;
 
-    if (first !== null) {
-      var update = first;
+    do {
+      var updateLane = update.lane;
+      var updateEventTime = update.eventTime;
+
+      if (!isSubsetOfLanes(renderLanes, updateLane)) {
+        // Priority is insufficient. Skip this update. If this is the first
+        // skipped update, the previous update/state is the new base
+        // update/state.
+        var clone = {
+          eventTime: updateEventTime,
+          lane: updateLane,
+          suspenseConfig: update.suspenseConfig,
+          tag: update.tag,
+          payload: update.payload,
+          callback: update.callback,
+          next: null
+        };
 
-      do {
-        var updateExpirationTime = update.expirationTime;
+        if (newLastBaseUpdate === null) {
+          newFirstBaseUpdate = newLastBaseUpdate = clone;
+          newBaseState = newState;
+        } else {
+          newLastBaseUpdate = newLastBaseUpdate.next = clone;
+        } // Update the remaining priority in the queue.
 
-        if (updateExpirationTime < renderExpirationTime) {
-          // Priority is insufficient. Skip this update. If this is the first
-          // skipped update, the previous update/state is the new base
-          // update/state.
-          var clone = {
-            expirationTime: update.expirationTime,
+        newLanes = mergeLanes(newLanes, updateLane);
+      } else {
+        // This update does have sufficient priority.
+        if (newLastBaseUpdate !== null) {
+          var _clone = {
+            eventTime: updateEventTime,
+            // This update is going to be committed so we never want uncommit
+            // it. Using NoLane works because 0 is a subset of all bitmasks, so
+            // this will never be skipped by the check above.
+            lane: NoLane,
             suspenseConfig: update.suspenseConfig,
             tag: update.tag,
             payload: update.payload,
             callback: update.callback,
             next: null
           };
+          newLastBaseUpdate = newLastBaseUpdate.next = _clone;
+        } // Mark the event time of this update as relevant to this render pass.
+        // TODO: This should ideally use the true event time of this update rather than
+        // its priority which is a derived and not reversible value.
+        // TODO: We should skip this update if it was already committed but currently
+        // we have no way of detecting the difference between a committed and suspended
+        // update here.
 
-          if (newBaseQueueLast === null) {
-            newBaseQueueFirst = newBaseQueueLast = clone;
-            newBaseState = newState;
-          } else {
-            newBaseQueueLast = newBaseQueueLast.next = clone;
-          } // Update the remaining priority in the queue.
+        markRenderEventTimeAndConfig(updateEventTime, update.suspenseConfig); // Process this update.
 
-          if (updateExpirationTime > newExpirationTime) {
-            newExpirationTime = updateExpirationTime;
-          }
-        } else {
-          // This update does have sufficient priority.
-          if (newBaseQueueLast !== null) {
-            var _clone = {
-              expirationTime: Sync,
-              // This update is going to be committed so we never want uncommit it.
-              suspenseConfig: update.suspenseConfig,
-              tag: update.tag,
-              payload: update.payload,
-              callback: update.callback,
-              next: null
-            };
-            newBaseQueueLast = newBaseQueueLast.next = _clone;
-          } // Mark the event time of this update as relevant to this render pass.
-          // TODO: This should ideally use the true event time of this update rather than
-          // its priority which is a derived and not reverseable value.
-          // TODO: We should skip this update if it was already committed but currently
-          // we have no way of detecting the difference between a committed and suspended
-          // update here.
-
-          markRenderEventTimeAndConfig(
-            updateExpirationTime,
-            update.suspenseConfig
-          ); // Process this update.
-
-          newState = getStateFromUpdate(
-            workInProgress,
-            queue,
-            update,
-            newState,
-            props,
-            instance
-          );
-          var callback = update.callback;
+        newState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          newState,
+          props,
+          instance
+        );
+        var callback = update.callback;
 
-          if (callback !== null) {
-            workInProgress.effectTag |= Callback;
-            var effects = queue.effects;
+        if (callback !== null) {
+          workInProgress.effectTag |= Callback;
+          var effects = queue.effects;
 
-            if (effects === null) {
-              queue.effects = [update];
-            } else {
-              effects.push(update);
-            }
+          if (effects === null) {
+            queue.effects = [update];
+          } else {
+            effects.push(update);
           }
         }
+      }
 
-        update = update.next;
+      update = update.next;
 
-        if (update === null || update === first) {
-          pendingQueue = queue.shared.pending;
+      if (update === null) {
+        pendingQueue = queue.shared.pending;
 
-          if (pendingQueue === null) {
-            break;
-          } else {
-            // An update was scheduled from inside a reducer. Add the new
-            // pending updates to the end of the list and keep processing.
-            update = baseQueue.next = pendingQueue.next;
-            pendingQueue.next = first;
-            queue.baseQueue = baseQueue = pendingQueue;
-            queue.shared.pending = null;
-          }
+        if (pendingQueue === null) {
+          break;
+        } else {
+          // An update was scheduled from inside a reducer. Add the new
+          // pending updates to the end of the list and keep processing.
+          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
+          // unravel them when transferring them to the base queue.
+
+          var _firstPendingUpdate = _lastPendingUpdate.next;
+          _lastPendingUpdate.next = null;
+          update = _firstPendingUpdate;
+          queue.lastBaseUpdate = _lastPendingUpdate;
+          queue.shared.pending = null;
         }
-      } while (true);
-    }
+      }
+    } while (true);
 
-    if (newBaseQueueLast === null) {
+    if (newLastBaseUpdate === null) {
       newBaseState = newState;
-    } else {
-      newBaseQueueLast.next = newBaseQueueFirst;
     }
 
     queue.baseState = newBaseState;
-    queue.baseQueue = newBaseQueueLast; // Set the remaining expiration time to be whatever is remaining in the queue.
+    queue.firstBaseUpdate = newFirstBaseUpdate;
+    queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.
     // This should be fine because the only two other things that contribute to
     // expiration time are props and context. We're already in the middle of the
     // begin phase by the time we start processing the queue, so we've already
@@ -7085,8 +7333,8 @@ function processUpdateQueue(
     // shouldComponentUpdate is tricky; but we'll have to account for
     // that regardless.
 
-    markUnprocessedUpdateTime(newExpirationTime);
-    workInProgress.expirationTime = newExpirationTime;
+    markSkippedUpdateLanes(newLanes);
+    workInProgress.lanes = newLanes;
     workInProgress.memoizedState = newState;
   }
 
@@ -7222,6 +7470,19 @@ function applyDerivedStateFromProps(
 ) {
   var prevState = workInProgress.memoizedState;
 
+  {
+    if (workInProgress.mode & StrictMode) {
+      disableLogs();
+
+      try {
+        // Invoke the function an extra time to help detect side-effects.
+        getDerivedStateFromProps(nextProps, prevState);
+      } finally {
+        reenableLogs();
+      }
+    }
+  }
+
   var partialState = getDerivedStateFromProps(nextProps, prevState);
 
   {
@@ -7235,7 +7496,7 @@ function applyDerivedStateFromProps(
   workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
   // base state.
 
-  if (workInProgress.expirationTime === NoWork) {
+  if (workInProgress.lanes === NoLanes) {
     // Queue is always non-null for classes
     var updateQueue = workInProgress.updateQueue;
     updateQueue.baseState = memoizedState;
@@ -7245,14 +7506,10 @@ var classComponentUpdater = {
   isMounted: isMounted,
   enqueueSetState: function(inst, payload, callback) {
     var fiber = get(inst);
-    var currentTime = requestCurrentTimeForUpdate();
+    var eventTime = requestEventTime();
     var suspenseConfig = requestCurrentSuspenseConfig();
-    var expirationTime = computeExpirationForFiber(
-      currentTime,
-      fiber,
-      suspenseConfig
-    );
-    var update = createUpdate(expirationTime, suspenseConfig);
+    var lane = requestUpdateLane(fiber, suspenseConfig);
+    var update = createUpdate(eventTime, lane, suspenseConfig);
     update.payload = payload;
 
     if (callback !== undefined && callback !== null) {
@@ -7264,18 +7521,14 @@ var classComponentUpdater = {
     }
 
     enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   },
   enqueueReplaceState: function(inst, payload, callback) {
     var fiber = get(inst);
-    var currentTime = requestCurrentTimeForUpdate();
+    var eventTime = requestEventTime();
     var suspenseConfig = requestCurrentSuspenseConfig();
-    var expirationTime = computeExpirationForFiber(
-      currentTime,
-      fiber,
-      suspenseConfig
-    );
-    var update = createUpdate(expirationTime, suspenseConfig);
+    var lane = requestUpdateLane(fiber, suspenseConfig);
+    var update = createUpdate(eventTime, lane, suspenseConfig);
     update.tag = ReplaceState;
     update.payload = payload;
 
@@ -7288,18 +7541,14 @@ var classComponentUpdater = {
     }
 
     enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   },
   enqueueForceUpdate: function(inst, callback) {
     var fiber = get(inst);
-    var currentTime = requestCurrentTimeForUpdate();
+    var eventTime = requestEventTime();
     var suspenseConfig = requestCurrentSuspenseConfig();
-    var expirationTime = computeExpirationForFiber(
-      currentTime,
-      fiber,
-      suspenseConfig
-    );
-    var update = createUpdate(expirationTime, suspenseConfig);
+    var lane = requestUpdateLane(fiber, suspenseConfig);
+    var update = createUpdate(eventTime, lane, suspenseConfig);
     update.tag = ForceUpdate;
 
     if (callback !== undefined && callback !== null) {
@@ -7311,7 +7560,7 @@ var classComponentUpdater = {
     }
 
     enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   }
 };
 
@@ -7327,13 +7576,24 @@ function checkShouldComponentUpdate(
   var instance = workInProgress.stateNode;
 
   if (typeof instance.shouldComponentUpdate === "function") {
-    startPhaseTimer(workInProgress, "shouldComponentUpdate");
+    {
+      if (workInProgress.mode & StrictMode) {
+        disableLogs();
+
+        try {
+          // Invoke the function an extra time to help detect side-effects.
+          instance.shouldComponentUpdate(newProps, newState, nextContext);
+        } finally {
+          reenableLogs();
+        }
+      }
+    }
+
     var shouldUpdate = instance.shouldComponentUpdate(
       newProps,
       newState,
       nextContext
     );
-    stopPhaseTimer();
 
     {
       if (shouldUpdate === undefined) {
@@ -7652,6 +7912,18 @@ function constructClassInstance(workInProgress, ctor, props) {
       : emptyContextObject;
   } // Instantiate twice to help detect side-effects.
 
+  {
+    if (workInProgress.mode & StrictMode) {
+      disableLogs();
+
+      try {
+        new ctor(props, context); // eslint-disable-line no-new
+      } finally {
+        reenableLogs();
+      }
+    }
+  }
+
   var instance = new ctor(props, context);
   var state = (workInProgress.memoizedState =
     instance.state !== null && instance.state !== undefined
@@ -7759,7 +8031,6 @@ function constructClassInstance(workInProgress, ctor, props) {
 }
 
 function callComponentWillMount(workInProgress, instance) {
-  startPhaseTimer(workInProgress, "componentWillMount");
   var oldState = instance.state;
 
   if (typeof instance.componentWillMount === "function") {
@@ -7770,8 +8041,6 @@ function callComponentWillMount(workInProgress, instance) {
     instance.UNSAFE_componentWillMount();
   }
 
-  stopPhaseTimer();
-
   if (oldState !== instance.state) {
     {
       error(
@@ -7793,7 +8062,6 @@ function callComponentWillReceiveProps(
   nextContext
 ) {
   var oldState = instance.state;
-  startPhaseTimer(workInProgress, "componentWillReceiveProps");
 
   if (typeof instance.componentWillReceiveProps === "function") {
     instance.componentWillReceiveProps(newProps, nextContext);
@@ -7803,8 +8071,6 @@ function callComponentWillReceiveProps(
     instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
   }
 
-  stopPhaseTimer();
-
   if (instance.state !== oldState) {
     {
       var componentName = getComponentName(workInProgress.type) || "Component";
@@ -7825,12 +8091,7 @@ function callComponentWillReceiveProps(
   }
 } // Invokes the mount life-cycles on a previously never rendered instance.
 
-function mountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
+function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   {
     checkClassInstance(workInProgress, ctor, newProps);
   }
@@ -7880,7 +8141,7 @@ function mountClassInstance(
     }
   }
 
-  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
+  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
   instance.state = workInProgress.memoizedState;
   var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
 
@@ -7904,12 +8165,7 @@ function mountClassInstance(
     callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
     // process them now.
 
-    processUpdateQueue(
-      workInProgress,
-      newProps,
-      instance,
-      renderExpirationTime
-    );
+    processUpdateQueue(workInProgress, newProps, instance, renderLanes);
     instance.state = workInProgress.memoizedState;
   }
 
@@ -7918,12 +8174,7 @@ function mountClassInstance(
   }
 }
 
-function resumeMountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
+function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   var instance = workInProgress.stateNode;
   var oldProps = workInProgress.memoizedProps;
   instance.props = oldProps;
@@ -7969,7 +8220,7 @@ function resumeMountClassInstance(
   resetHasForceUpdateBeforeProcessing();
   var oldState = workInProgress.memoizedState;
   var newState = (instance.state = oldState);
-  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
+  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
   newState = workInProgress.memoizedState;
 
   if (
@@ -8017,8 +8268,6 @@ function resumeMountClassInstance(
       (typeof instance.UNSAFE_componentWillMount === "function" ||
         typeof instance.componentWillMount === "function")
     ) {
-      startPhaseTimer(workInProgress, "componentWillMount");
-
       if (typeof instance.componentWillMount === "function") {
         instance.componentWillMount();
       }
@@ -8026,8 +8275,6 @@ function resumeMountClassInstance(
       if (typeof instance.UNSAFE_componentWillMount === "function") {
         instance.UNSAFE_componentWillMount();
       }
-
-      stopPhaseTimer();
     }
 
     if (typeof instance.componentDidMount === "function") {
@@ -8057,15 +8304,17 @@ function updateClassInstance(
   workInProgress,
   ctor,
   newProps,
-  renderExpirationTime
+  renderLanes
 ) {
   var instance = workInProgress.stateNode;
   cloneUpdateQueue(current, workInProgress);
-  var oldProps = workInProgress.memoizedProps;
-  instance.props =
+  var unresolvedOldProps = workInProgress.memoizedProps;
+  var oldProps =
     workInProgress.type === workInProgress.elementType
-      ? oldProps
-      : resolveDefaultProps(workInProgress.type, oldProps);
+      ? unresolvedOldProps
+      : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
+  instance.props = oldProps;
+  var unresolvedNewProps = workInProgress.pendingProps;
   var oldContext = instance.context;
   var contextType = ctor.contextType;
   var nextContext = emptyContextObject;
@@ -8091,7 +8340,10 @@ function updateClassInstance(
     (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
       typeof instance.componentWillReceiveProps === "function")
   ) {
-    if (oldProps !== newProps || oldContext !== nextContext) {
+    if (
+      unresolvedOldProps !== unresolvedNewProps ||
+      oldContext !== nextContext
+    ) {
       callComponentWillReceiveProps(
         workInProgress,
         instance,
@@ -8104,11 +8356,11 @@ function updateClassInstance(
   resetHasForceUpdateBeforeProcessing();
   var oldState = workInProgress.memoizedState;
   var newState = (instance.state = oldState);
-  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
+  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
   newState = workInProgress.memoizedState;
 
   if (
-    oldProps === newProps &&
+    unresolvedOldProps === unresolvedNewProps &&
     oldState === newState &&
     !hasContextChanged() &&
     !checkHasForceUpdateAfterProcessing()
@@ -8117,7 +8369,7 @@ function updateClassInstance(
     // effect even though we're bailing out, so that cWU/cDU are called.
     if (typeof instance.componentDidUpdate === "function") {
       if (
-        oldProps !== current.memoizedProps ||
+        unresolvedOldProps !== current.memoizedProps ||
         oldState !== current.memoizedState
       ) {
         workInProgress.effectTag |= Update;
@@ -8126,7 +8378,7 @@ function updateClassInstance(
 
     if (typeof instance.getSnapshotBeforeUpdate === "function") {
       if (
-        oldProps !== current.memoizedProps ||
+        unresolvedOldProps !== current.memoizedProps ||
         oldState !== current.memoizedState
       ) {
         workInProgress.effectTag |= Snapshot;
@@ -8166,8 +8418,6 @@ function updateClassInstance(
       (typeof instance.UNSAFE_componentWillUpdate === "function" ||
         typeof instance.componentWillUpdate === "function")
     ) {
-      startPhaseTimer(workInProgress, "componentWillUpdate");
-
       if (typeof instance.componentWillUpdate === "function") {
         instance.componentWillUpdate(newProps, newState, nextContext);
       }
@@ -8175,8 +8425,6 @@ function updateClassInstance(
       if (typeof instance.UNSAFE_componentWillUpdate === "function") {
         instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
       }
-
-      stopPhaseTimer();
     }
 
     if (typeof instance.componentDidUpdate === "function") {
@@ -8191,7 +8439,7 @@ function updateClassInstance(
     // effect even though we're bailing out, so that cWU/cDU are called.
     if (typeof instance.componentDidUpdate === "function") {
       if (
-        oldProps !== current.memoizedProps ||
+        unresolvedOldProps !== current.memoizedProps ||
         oldState !== current.memoizedState
       ) {
         workInProgress.effectTag |= Update;
@@ -8200,7 +8448,7 @@ function updateClassInstance(
 
     if (typeof instance.getSnapshotBeforeUpdate === "function") {
       if (
-        oldProps !== current.memoizedProps ||
+        unresolvedOldProps !== current.memoizedProps ||
         oldState !== current.memoizedState
       ) {
         workInProgress.effectTag |= Snapshot;
@@ -8225,7 +8473,7 @@ var didWarnAboutStringRefs;
 var ownerHasKeyUseWarning;
 var ownerHasFunctionTypeWarning;
 
-var warnForMissingKey = function(child) {};
+var warnForMissingKey = function(child, returnFiber) {};
 
 {
   didWarnAboutMaps = false;
@@ -8240,7 +8488,7 @@ var warnForMissingKey = function(child) {};
   ownerHasKeyUseWarning = {};
   ownerHasFunctionTypeWarning = {};
 
-  warnForMissingKey = function(child) {
+  warnForMissingKey = function(child, returnFiber) {
     if (child === null || typeof child !== "object") {
       return;
     }
@@ -8256,17 +8504,13 @@ var warnForMissingKey = function(child) {};
     }
 
     child._store.validated = true;
-    var currentComponentErrorInfo =
-      "Each child in a list should have a unique " +
-      '"key" prop. See https://fb.me/react-warning-keys for ' +
-      "more information." +
-      getCurrentFiberStackInDev();
+    var componentName = getComponentName(returnFiber.type) || "Component";
 
-    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
+    if (ownerHasKeyUseWarning[componentName]) {
       return;
     }
 
-    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
+    ownerHasKeyUseWarning[componentName] = true;
 
     error(
       "Each child in a list should have a unique " +
@@ -8308,9 +8552,8 @@ function coerceRef(returnFiber, current, element) {
                 "String refs are a source of potential bugs and should be avoided. " +
                 "We recommend using useRef() or createRef() instead. " +
                 "Learn more about using refs safely here: " +
-                "https://fb.me/react-strict-mode-string-ref%s",
-              mixedRef,
-              getStackByFiberInDevAndProd(returnFiber)
+                "https://fb.me/react-strict-mode-string-ref",
+              mixedRef
             );
           }
 
@@ -8393,41 +8636,27 @@ function coerceRef(returnFiber, current, element) {
 
 function throwOnInvalidObjectType(returnFiber, newChild) {
   if (returnFiber.type !== "textarea") {
-    var addendum = "";
-
-    {
-      addendum =
-        " If you meant to render a collection of children, use an array " +
-        "instead." +
-        getCurrentFiberStackInDev();
-    }
-
     {
       throw Error(
         "Objects are not valid as a React child (found: " +
           (Object.prototype.toString.call(newChild) === "[object Object]"
             ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
             : newChild) +
-          ")." +
-          addendum
+          "). If you meant to render a collection of children, use an array instead."
       );
     }
   }
 }
 
-function warnOnFunctionType() {
+function warnOnFunctionType(returnFiber) {
   {
-    var currentComponentErrorInfo =
-      "Functions are not valid as a React child. This may happen if " +
-      "you return a Component instead of <Component /> from render. " +
-      "Or maybe you meant to call this function rather than return it." +
-      getCurrentFiberStackInDev();
+    var componentName = getComponentName(returnFiber.type) || "Component";
 
-    if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
+    if (ownerHasFunctionTypeWarning[componentName]) {
       return;
     }
 
-    ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
+    ownerHasFunctionTypeWarning[componentName] = true;
 
     error(
       "Functions are not valid as a React child. This may happen if " +
@@ -8435,7 +8664,7 @@ function warnOnFunctionType() {
         "Or maybe you meant to call this function rather than return it."
     );
   }
-} // This wrapper function exists because I expect to clone the code in each path
+} // We avoid inlining this to avoid potential deopts from using try/catch.
 // to be able to optimize each path individually by branching early. This needs
 // a compiler or we can do it manually. Helpers that don't need this branching
 // live outside of this function.
@@ -8548,14 +8777,10 @@ function ChildReconciler(shouldTrackSideEffects) {
     return newFiber;
   }
 
-  function updateTextNode(returnFiber, current, textContent, expirationTime) {
+  function updateTextNode(returnFiber, current, textContent, lanes) {
     if (current === null || current.tag !== HostText) {
       // Insert
-      var created = createFiberFromText(
-        textContent,
-        returnFiber.mode,
-        expirationTime
-      );
+      var created = createFiberFromText(textContent, returnFiber.mode, lanes);
       created.return = returnFiber;
       return created;
     } else {
@@ -8566,7 +8791,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
   }
 
-  function updateElement(returnFiber, current, element, expirationTime) {
+  function updateElement(returnFiber, current, element, lanes) {
     if (current !== null) {
       if (
         current.elementType === element.type || // Keep this check inline so it only runs on the false path:
@@ -8586,17 +8811,13 @@ function ChildReconciler(shouldTrackSideEffects) {
       }
     } // Insert
 
-    var created = createFiberFromElement(
-      element,
-      returnFiber.mode,
-      expirationTime
-    );
+    var created = createFiberFromElement(element, returnFiber.mode, lanes);
     created.ref = coerceRef(returnFiber, current, element);
     created.return = returnFiber;
     return created;
   }
 
-  function updatePortal(returnFiber, current, portal, expirationTime) {
+  function updatePortal(returnFiber, current, portal, lanes) {
     if (
       current === null ||
       current.tag !== HostPortal ||
@@ -8604,11 +8825,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       current.stateNode.implementation !== portal.implementation
     ) {
       // Insert
-      var created = createFiberFromPortal(
-        portal,
-        returnFiber.mode,
-        expirationTime
-      );
+      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
       created.return = returnFiber;
       return created;
     } else {
@@ -8619,13 +8836,13 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
   }
 
-  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
+  function updateFragment(returnFiber, current, fragment, lanes, key) {
     if (current === null || current.tag !== Fragment) {
       // Insert
       var created = createFiberFromFragment(
         fragment,
         returnFiber.mode,
-        expirationTime,
+        lanes,
         key
       );
       created.return = returnFiber;
@@ -8638,16 +8855,12 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
   }
 
-  function createChild(returnFiber, newChild, expirationTime) {
+  function createChild(returnFiber, newChild, lanes) {
     if (typeof newChild === "string" || typeof newChild === "number") {
       // Text nodes don't have keys. If the previous node is implicitly keyed
       // we can continue to replace it without aborting even if it is not a text
       // node.
-      var created = createFiberFromText(
-        "" + newChild,
-        returnFiber.mode,
-        expirationTime
-      );
+      var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
       created.return = returnFiber;
       return created;
     }
@@ -8658,7 +8871,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           var _created = createFiberFromElement(
             newChild,
             returnFiber.mode,
-            expirationTime
+            lanes
           );
 
           _created.ref = coerceRef(returnFiber, null, newChild);
@@ -8670,7 +8883,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           var _created2 = createFiberFromPortal(
             newChild,
             returnFiber.mode,
-            expirationTime
+            lanes
           );
 
           _created2.return = returnFiber;
@@ -8682,7 +8895,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         var _created3 = createFiberFromFragment(
           newChild,
           returnFiber.mode,
-          expirationTime,
+          lanes,
           null
         );
 
@@ -8695,14 +8908,14 @@ function ChildReconciler(shouldTrackSideEffects) {
 
     {
       if (typeof newChild === "function") {
-        warnOnFunctionType();
+        warnOnFunctionType(returnFiber);
       }
     }
 
     return null;
   }
 
-  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
+  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
     // Update the fiber if the keys match, otherwise return null.
     var key = oldFiber !== null ? oldFiber.key : null;
 
@@ -8714,12 +8927,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         return null;
       }
 
-      return updateTextNode(
-        returnFiber,
-        oldFiber,
-        "" + newChild,
-        expirationTime
-      );
+      return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
     }
 
     if (typeof newChild === "object" && newChild !== null) {
@@ -8731,17 +8939,12 @@ function ChildReconciler(shouldTrackSideEffects) {
                 returnFiber,
                 oldFiber,
                 newChild.props.children,
-                expirationTime,
+                lanes,
                 key
               );
             }
 
-            return updateElement(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime
-            );
+            return updateElement(returnFiber, oldFiber, newChild, lanes);
           } else {
             return null;
           }
@@ -8749,12 +8952,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
         case REACT_PORTAL_TYPE: {
           if (newChild.key === key) {
-            return updatePortal(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime
-            );
+            return updatePortal(returnFiber, oldFiber, newChild, lanes);
           } else {
             return null;
           }
@@ -8766,13 +8964,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           return null;
         }
 
-        return updateFragment(
-          returnFiber,
-          oldFiber,
-          newChild,
-          expirationTime,
-          null
-        );
+        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
       }
 
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -8780,7 +8972,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
     {
       if (typeof newChild === "function") {
-        warnOnFunctionType();
+        warnOnFunctionType(returnFiber);
       }
     }
 
@@ -8792,18 +8984,13 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     newIdx,
     newChild,
-    expirationTime
+    lanes
   ) {
     if (typeof newChild === "string" || typeof newChild === "number") {
       // Text nodes don't have keys, so we neither have to check the old nor
       // new node for the key. If both are text nodes, they match.
       var matchedFiber = existingChildren.get(newIdx) || null;
-      return updateTextNode(
-        returnFiber,
-        matchedFiber,
-        "" + newChild,
-        expirationTime
-      );
+      return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
     }
 
     if (typeof newChild === "object" && newChild !== null) {
@@ -8819,17 +9006,12 @@ function ChildReconciler(shouldTrackSideEffects) {
               returnFiber,
               _matchedFiber,
               newChild.props.children,
-              expirationTime,
+              lanes,
               newChild.key
             );
           }
 
-          return updateElement(
-            returnFiber,
-            _matchedFiber,
-            newChild,
-            expirationTime
-          );
+          return updateElement(returnFiber, _matchedFiber, newChild, lanes);
         }
 
         case REACT_PORTAL_TYPE: {
@@ -8838,12 +9020,7 @@ function ChildReconciler(shouldTrackSideEffects) {
               newChild.key === null ? newIdx : newChild.key
             ) || null;
 
-          return updatePortal(
-            returnFiber,
-            _matchedFiber2,
-            newChild,
-            expirationTime
-          );
+          return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
         }
       }
 
@@ -8854,7 +9031,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           returnFiber,
           _matchedFiber3,
           newChild,
-          expirationTime,
+          lanes,
           null
         );
       }
@@ -8864,7 +9041,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
     {
       if (typeof newChild === "function") {
-        warnOnFunctionType();
+        warnOnFunctionType(returnFiber);
       }
     }
 
@@ -8874,7 +9051,7 @@ function ChildReconciler(shouldTrackSideEffects) {
    * Warns if there is a duplicate or missing key
    */
 
-  function warnOnInvalidKey(child, knownKeys) {
+  function warnOnInvalidKey(child, knownKeys, returnFiber) {
     {
       if (typeof child !== "object" || child === null) {
         return knownKeys;
@@ -8883,7 +9060,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       switch (child.$$typeof) {
         case REACT_ELEMENT_TYPE:
         case REACT_PORTAL_TYPE:
-          warnForMissingKey(child);
+          warnForMissingKey(child, returnFiber);
           var key = child.key;
 
           if (typeof key !== "string") {
@@ -8921,7 +9098,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChildren,
-    expirationTime
+    lanes
   ) {
     // This algorithm can't optimize by searching from both ends since we
     // don't have backpointers on fibers. I'm trying to see how far we can get
@@ -8944,7 +9121,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
       for (var i = 0; i < newChildren.length; i++) {
         var child = newChildren[i];
-        knownKeys = warnOnInvalidKey(child, knownKeys);
+        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
       }
     }
 
@@ -8967,7 +9144,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         oldFiber,
         newChildren[newIdx],
-        expirationTime
+        lanes
       );
 
       if (newFiber === null) {
@@ -9017,11 +9194,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       // If we don't have any more existing children we can choose a fast path
       // since the rest will all be insertions.
       for (; newIdx < newChildren.length; newIdx++) {
-        var _newFiber = createChild(
-          returnFiber,
-          newChildren[newIdx],
-          expirationTime
-        );
+        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
 
         if (_newFiber === null) {
           continue;
@@ -9050,7 +9223,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         newIdx,
         newChildren[newIdx],
-        expirationTime
+        lanes
       );
 
       if (_newFiber2 !== null) {
@@ -9093,7 +9266,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChildrenIterable,
-    expirationTime
+    lanes
   ) {
     // This is the same implementation as reconcileChildrenArray(),
     // but using the iterator instead.
@@ -9128,9 +9301,8 @@ function ChildReconciler(shouldTrackSideEffects) {
       if (newChildrenIterable.entries === iteratorFn) {
         if (!didWarnAboutMaps) {
           error(
-            "Using Maps as children is unsupported and will likely yield " +
-              "unexpected results. Convert it to a sequence/iterable of keyed " +
-              "ReactElements instead."
+            "Using Maps as children is not supported. " +
+              "Use an array of keyed ReactElements instead."
           );
         }
 
@@ -9147,7 +9319,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
         for (; !_step.done; _step = _newChildren.next()) {
           var child = _step.value;
-          knownKeys = warnOnInvalidKey(child, knownKeys);
+          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
         }
       }
     }
@@ -9178,12 +9350,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         nextOldFiber = oldFiber.sibling;
       }
 
-      var newFiber = updateSlot(
-        returnFiber,
-        oldFiber,
-        step.value,
-        expirationTime
-      );
+      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
 
       if (newFiber === null) {
         // TODO: This breaks on empty slots like null children. That's
@@ -9232,7 +9399,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       // If we don't have any more existing children we can choose a fast path
       // since the rest will all be insertions.
       for (; !step.done; newIdx++, step = newChildren.next()) {
-        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
+        var _newFiber3 = createChild(returnFiber, step.value, lanes);
 
         if (_newFiber3 === null) {
           continue;
@@ -9261,7 +9428,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         newIdx,
         step.value,
-        expirationTime
+        lanes
       );
 
       if (_newFiber4 !== null) {
@@ -9304,7 +9471,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     textContent,
-    expirationTime
+    lanes
   ) {
     // There's no need to check for keys on text nodes since we don't have a
     // way to define them.
@@ -9319,11 +9486,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     // and delete the existing ones.
 
     deleteRemainingChildren(returnFiber, currentFirstChild);
-    var created = createFiberFromText(
-      textContent,
-      returnFiber.mode,
-      expirationTime
-    );
+    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
     created.return = returnFiber;
     return created;
   }
@@ -9332,7 +9495,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     element,
-    expirationTime
+    lanes
   ) {
     var key = element.key;
     var child = currentFirstChild;
@@ -9401,17 +9564,13 @@ function ChildReconciler(shouldTrackSideEffects) {
       var created = createFiberFromFragment(
         element.props.children,
         returnFiber.mode,
-        expirationTime,
+        lanes,
         element.key
       );
       created.return = returnFiber;
       return created;
     } else {
-      var _created4 = createFiberFromElement(
-        element,
-        returnFiber.mode,
-        expirationTime
-      );
+      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
 
       _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
       _created4.return = returnFiber;
@@ -9423,7 +9582,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     portal,
-    expirationTime
+    lanes
   ) {
     var key = portal.key;
     var child = currentFirstChild;
@@ -9452,11 +9611,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       child = child.sibling;
     }
 
-    var created = createFiberFromPortal(
-      portal,
-      returnFiber.mode,
-      expirationTime
-    );
+    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
     created.return = returnFiber;
     return created;
   } // This API will tag the children with the side-effect of the reconciliation
@@ -9467,7 +9622,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChild,
-    expirationTime
+    lanes
   ) {
     // This function is not recursive.
     // If the top level item is an array, we treat it as a set of children,
@@ -9496,7 +9651,7 @@ function ChildReconciler(shouldTrackSideEffects) {
               returnFiber,
               currentFirstChild,
               newChild,
-              expirationTime
+              lanes
             )
           );
 
@@ -9506,7 +9661,7 @@ function ChildReconciler(shouldTrackSideEffects) {
               returnFiber,
               currentFirstChild,
               newChild,
-              expirationTime
+              lanes
             )
           );
       }
@@ -9518,7 +9673,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           returnFiber,
           currentFirstChild,
           "" + newChild,
-          expirationTime
+          lanes
         )
       );
     }
@@ -9528,7 +9683,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         currentFirstChild,
         newChild,
-        expirationTime
+        lanes
       );
     }
 
@@ -9537,7 +9692,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         currentFirstChild,
         newChild,
-        expirationTime
+        lanes
       );
     }
 
@@ -9547,7 +9702,7 @@ function ChildReconciler(shouldTrackSideEffects) {
 
     {
       if (typeof newChild === "function") {
-        warnOnFunctionType();
+        warnOnFunctionType(returnFiber);
       }
     }
 
@@ -9617,11 +9772,11 @@ function cloneChildFibers(current, workInProgress) {
   newChild.sibling = null;
 } // Reset a workInProgress child set to prepare it for a second pass.
 
-function resetChildFibers(workInProgress, renderExpirationTime) {
+function resetChildFibers(workInProgress, lanes) {
   var child = workInProgress.child;
 
   while (child !== null) {
-    resetWorkInProgress(child, renderExpirationTime);
+    resetWorkInProgress(child, lanes);
     child = child.sibling;
   }
 }
@@ -9739,6 +9894,13 @@ function popSuspenseContext(fiber) {
   pop(suspenseStackCursor, fiber);
 }
 
+// A non-null SuspenseState means that it is blocked for one reason or another.
+// - A non-null dehydrated field means it's blocked pending hydration.
+//   - A non-null dehydrated field can use isSuspenseInstancePending or
+//     isSuspenseInstanceFallback to query the reason for being dehydrated.
+// - A null dehydrated field means it's blocked by something suspending and
+//   we're currently showing a fallback instead.
+
 function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
   // If it was the primary children that just suspended, capture and render the
   // fallback. Otherwise, don't capture and bubble to the next boundary.
@@ -9823,18 +9985,9 @@ function findFirstSuspended(row) {
   return null;
 }
 
-function createDeprecatedResponderListener(responder, props) {
-  var eventResponderListener = {
-    responder: responder,
-    props: props
-  };
-
-  {
-    Object.freeze(eventResponderListener);
-  }
-
-  return eventResponderListener;
-}
+var NoEffect$1 =
+  /*  */
+  0; // Represents whether effect should fire.
 
 var HasEffect =
   /* */
@@ -9847,16 +10000,113 @@ var Passive$1 =
   /*   */
   4;
 
-var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
+var isHydrating = false;
+
+function enterHydrationState(fiber) {
+  {
+    return false;
+  }
+}
+
+function prepareToHydrateHostInstance(
+  fiber,
+  rootContainerInstance,
+  hostContext
+) {
+  {
+    {
+      throw Error(
+        "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
+      );
+    }
+  }
+}
+
+function prepareToHydrateHostTextInstance(fiber) {
+  {
+    {
+      throw Error(
+        "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
+      );
+    }
+  }
+  var shouldUpdate = hydrateTextInstance();
+}
+
+function popHydrationState(fiber) {
+  {
+    return false;
+  }
+}
+
+function getIsHydrating() {
+  return isHydrating;
+}
+
+// and should be reset before starting a new render.
+// This tracks which mutable sources need to be reset after a render.
+
+var workInProgressSources = [];
+var rendererSigil$1;
+
+{
+  // Used to detect multiple renderers using the same mutable source.
+  rendererSigil$1 = {};
+}
+
+function markSourceAsDirty(mutableSource) {
+  workInProgressSources.push(mutableSource);
+}
+function resetWorkInProgressVersions() {
+  for (var i = 0; i < workInProgressSources.length; i++) {
+    var mutableSource = workInProgressSources[i];
+
+    {
+      mutableSource._workInProgressVersionPrimary = null;
+    }
+  }
+
+  workInProgressSources.length = 0;
+}
+function getWorkInProgressVersion(mutableSource) {
+  {
+    return mutableSource._workInProgressVersionPrimary;
+  }
+}
+function setWorkInProgressVersion(mutableSource, version) {
+  {
+    mutableSource._workInProgressVersionPrimary = version;
+  }
+
+  workInProgressSources.push(mutableSource);
+}
+function warnAboutMultipleRenderersDEV(mutableSource) {
+  {
+    {
+      if (mutableSource._currentPrimaryRenderer == null) {
+        mutableSource._currentPrimaryRenderer = rendererSigil$1;
+      } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
+        error(
+          "Detected multiple renderers concurrently rendering the " +
+            "same mutable source. This is currently unsupported."
+        );
+      }
+    }
+  }
+} // Eager reads the version of a mutable source and stores it on the root.
+
+var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
 var didWarnAboutMismatchedHooksForComponent;
+var didWarnAboutUseOpaqueIdentifier;
 
 {
+  didWarnAboutUseOpaqueIdentifier = {};
   didWarnAboutMismatchedHooksForComponent = new Set();
 }
 
 // These are set right before calling the component.
-var renderExpirationTime = NoWork; // The work-in-progress fiber. I've named it differently to distinguish it from
+var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
 // the work-in-progress hook.
 
 var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
@@ -9870,7 +10120,12 @@ var workInProgressHook = null; // Whether an update was scheduled at any point d
 // finished evaluating this component. This is an optimization so we know
 // whether we need to clear render phase updates after a throw.
 
-var didScheduleRenderPhaseUpdate = false;
+var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
+// gets reset after each attempt.
+// TODO: Maybe there's some way to consolidate this with
+// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
+
+var didScheduleRenderPhaseUpdateDuringThisPass = false;
 var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook
 
 var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
@@ -10029,9 +10284,9 @@ function renderWithHooks(
   Component,
   props,
   secondArg,
-  nextRenderExpirationTime
+  nextRenderLanes
 ) {
-  renderExpirationTime = nextRenderExpirationTime;
+  renderLanes = nextRenderLanes;
   currentlyRenderingFiber$1 = workInProgress;
 
   {
@@ -10044,7 +10299,7 @@ function renderWithHooks(
 
   workInProgress.memoizedState = null;
   workInProgress.updateQueue = null;
-  workInProgress.expirationTime = NoWork; // The following should have already been reset
+  workInProgress.lanes = NoLanes; // The following should have already been reset
   // currentHook = null;
   // workInProgressHook = null;
   // didScheduleRenderPhaseUpdate = false;
@@ -10057,28 +10312,28 @@ function renderWithHooks(
 
   {
     if (current !== null && current.memoizedState !== null) {
-      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
     } else if (hookTypesDev !== null) {
       // This dispatcher handles an edge case where a component is updating,
       // but no stateful hooks have been used.
       // We want to match the production code behavior (which will use HooksDispatcherOnMount),
       // but with the extra DEV validation to ensure hooks ordering hasn't changed.
       // This dispatcher does that.
-      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
     } else {
-      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
     }
   }
 
   var children = Component(props, secondArg); // Check if there was a render phase update
 
-  if (workInProgress.expirationTime === renderExpirationTime) {
+  if (didScheduleRenderPhaseUpdateDuringThisPass) {
     // Keep rendering in a loop for as long as render phase updates continue to
     // be scheduled. Use a counter to prevent infinite loops.
     var numberOfReRenders = 0;
 
     do {
-      workInProgress.expirationTime = NoWork;
+      didScheduleRenderPhaseUpdateDuringThisPass = false;
 
       if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
         throw Error(
@@ -10103,13 +10358,13 @@ function renderWithHooks(
         hookTypesUpdateIndexDev = -1;
       }
 
-      ReactCurrentDispatcher.current = HooksDispatcherOnRerenderInDEV;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
       children = Component(props, secondArg);
-    } while (workInProgress.expirationTime === renderExpirationTime);
+    } while (didScheduleRenderPhaseUpdateDuringThisPass);
   } // We can assume the previous dispatcher is always this one, since we set it
   // at the beginning of the render phase and there's no re-entrancy.
 
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
 
   {
     workInProgress._debugHookTypes = hookTypesDev;
@@ -10117,7 +10372,7 @@ function renderWithHooks(
   // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
 
   var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
-  renderExpirationTime = NoWork;
+  renderLanes = NoLanes;
   currentlyRenderingFiber$1 = null;
   currentHook = null;
   workInProgressHook = null;
@@ -10138,18 +10393,15 @@ function renderWithHooks(
 
   return children;
 }
-function bailoutHooks(current, workInProgress, expirationTime) {
+function bailoutHooks(current, workInProgress, lanes) {
   workInProgress.updateQueue = current.updateQueue;
   workInProgress.effectTag &= ~(Passive | Update);
-
-  if (current.expirationTime <= expirationTime) {
-    current.expirationTime = NoWork;
-  }
+  current.lanes = removeLanes(current.lanes, lanes);
 }
 function resetHooksAfterThrow() {
   // We can assume the previous dispatcher is always this one, since we set it
   // at the beginning of the render phase and there's no re-entrancy.
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
 
   if (didScheduleRenderPhaseUpdate) {
     // There were render phase updates. These are only valid for this render
@@ -10171,9 +10423,11 @@ function resetHooksAfterThrow() {
 
       hook = hook.next;
     }
+
+    didScheduleRenderPhaseUpdate = false;
   }
 
-  renderExpirationTime = NoWork;
+  renderLanes = NoLanes;
   currentlyRenderingFiber$1 = null;
   currentHook = null;
   workInProgressHook = null;
@@ -10182,9 +10436,10 @@ function resetHooksAfterThrow() {
     hookTypesDev = null;
     hookTypesUpdateIndexDev = -1;
     currentHookNameInDev = null;
+    isUpdatingOpaqueValueInRenderPhase = false;
   }
 
-  didScheduleRenderPhaseUpdate = false;
+  didScheduleRenderPhaseUpdateDuringThisPass = false;
 }
 
 function mountWorkInProgressHook() {
@@ -10331,6 +10586,17 @@ function updateReducer(reducer, initialArg, init) {
       pendingQueue.next = baseFirst;
     }
 
+    {
+      if (current.baseQueue !== baseQueue) {
+        // Internal invariant that should never happen, but feasibly could in
+        // the future if we implement resuming, or some form of that.
+        error(
+          "Internal error: Expected work-in-progress queue to be a clone. " +
+            "This is a bug in React."
+        );
+      }
+    }
+
     current.baseQueue = baseQueue = pendingQueue;
     queue.pending = null;
   }
@@ -10345,15 +10611,18 @@ function updateReducer(reducer, initialArg, init) {
     var update = first;
 
     do {
-      var updateExpirationTime = update.expirationTime;
+      var suspenseConfig = update.suspenseConfig;
+      var updateLane = update.lane;
+      var updateEventTime = update.eventTime;
 
-      if (updateExpirationTime < renderExpirationTime) {
+      if (!isSubsetOfLanes(renderLanes, updateLane)) {
         // Priority is insufficient. Skip this update. If this is the first
         // skipped update, the previous update/state is the new base
         // update/state.
         var clone = {
-          expirationTime: update.expirationTime,
-          suspenseConfig: update.suspenseConfig,
+          eventTime: updateEventTime,
+          lane: updateLane,
+          suspenseConfig: suspenseConfig,
           action: update.action,
           eagerReducer: update.eagerReducer,
           eagerState: update.eagerState,
@@ -10366,17 +10635,23 @@ function updateReducer(reducer, initialArg, init) {
         } else {
           newBaseQueueLast = newBaseQueueLast.next = clone;
         } // Update the remaining priority in the queue.
+        // TODO: Don't need to accumulate this. Instead, we can remove
+        // renderLanes from the original lanes.
 
-        if (updateExpirationTime > currentlyRenderingFiber$1.expirationTime) {
-          currentlyRenderingFiber$1.expirationTime = updateExpirationTime;
-          markUnprocessedUpdateTime(updateExpirationTime);
-        }
+        currentlyRenderingFiber$1.lanes = mergeLanes(
+          currentlyRenderingFiber$1.lanes,
+          updateLane
+        );
+        markSkippedUpdateLanes(updateLane);
       } else {
         // This update does have sufficient priority.
         if (newBaseQueueLast !== null) {
           var _clone = {
-            expirationTime: Sync,
-            // This update is going to be committed so we never want uncommit it.
+            eventTime: updateEventTime,
+            // This update is going to be committed so we never want uncommit
+            // it. Using NoLane works because 0 is a subset of all bitmasks, so
+            // this will never be skipped by the check above.
+            lane: NoLane,
             suspenseConfig: update.suspenseConfig,
             action: update.action,
             eagerReducer: update.eagerReducer,
@@ -10386,15 +10661,12 @@ function updateReducer(reducer, initialArg, init) {
           newBaseQueueLast = newBaseQueueLast.next = _clone;
         } // Mark the event time of this update as relevant to this render pass.
         // TODO: This should ideally use the true event time of this update rather than
-        // its priority which is a derived and not reverseable value.
+        // its priority which is a derived and not reversible value.
         // TODO: We should skip this update if it was already committed but currently
         // we have no way of detecting the difference between a committed and suspended
         // update here.
 
-        markRenderEventTimeAndConfig(
-          updateExpirationTime,
-          update.suspenseConfig
-        ); // Process this update.
+        markRenderEventTimeAndConfig(updateEventTime, suspenseConfig); // Process this update.
 
         if (update.eagerReducer === reducer) {
           // If this update was processed eagerly, and its reducer matches the
@@ -10482,6 +10754,253 @@ function rerenderReducer(reducer, initialArg, init) {
   return [newState, dispatch];
 }
 
+function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
+  {
+    warnAboutMultipleRenderersDEV(source);
+  }
+
+  var getVersion = source._getVersion;
+  var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?
+
+  var isSafeToReadFromSource = false; // Check the version first.
+  // If this render has already been started with a specific version,
+  // we can use it alone to determine if we can safely read from the source.
+
+  var currentRenderVersion = getWorkInProgressVersion(source);
+
+  if (currentRenderVersion !== null) {
+    // It's safe to read if the store hasn't been mutated since the last time
+    // we read something.
+    isSafeToReadFromSource = currentRenderVersion === version;
+  } else {
+    // If there's no version, then this is the first time we've read from the
+    // source during the current render pass, so we need to do a bit more work.
+    // What we need to determine is if there are any hooks that already
+    // subscribed to the source, and if so, whether there are any pending
+    // mutations that haven't been synchronized yet.
+    //
+    // If there are no pending mutations, then `root.mutableReadLanes` will be
+    // empty, and we know we can safely read.
+    //
+    // If there *are* pending mutations, we may still be able to safely read
+    // if the currently rendering lanes are inclusive of the pending mutation
+    // lanes, since that guarantees that the value we're about to read from
+    // the source is consistent with the values that we read during the most
+    // recent mutation.
+    isSafeToReadFromSource = isSubsetOfLanes(
+      renderLanes,
+      root.mutableReadLanes
+    );
+
+    if (isSafeToReadFromSource) {
+      // If it's safe to read from this source during the current render,
+      // store the version in case other components read from it.
+      // A changed version number will let those components know to throw and restart the render.
+      setWorkInProgressVersion(source, version);
+    }
+  }
+
+  if (isSafeToReadFromSource) {
+    var snapshot = getSnapshot(source._source);
+
+    {
+      if (typeof snapshot === "function") {
+        error(
+          "Mutable source should not return a function as the snapshot value. " +
+            "Functions may close over mutable values and cause tearing."
+        );
+      }
+    }
+
+    return snapshot;
+  } else {
+    // This handles the special case of a mutable source being shared between renderers.
+    // In that case, if the source is mutated between the first and second renderer,
+    // The second renderer don't know that it needs to reset the WIP version during unwind,
+    // (because the hook only marks sources as dirty if it's written to their WIP version).
+    // That would cause this tear check to throw again and eventually be visible to the user.
+    // We can avoid this infinite loop by explicitly marking the source as dirty.
+    //
+    // This can lead to tearing in the first renderer when it resumes,
+    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).
+    markSourceAsDirty(source);
+
+    {
+      throw Error(
+        "Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue."
+      );
+    }
+  }
+}
+
+function useMutableSource(hook, source, getSnapshot, subscribe) {
+  var root = getWorkInProgressRoot();
+
+  if (!(root !== null)) {
+    throw Error(
+      "Expected a work-in-progress root. This is a bug in React. Please file an issue."
+    );
+  }
+
+  var getVersion = source._getVersion;
+  var version = getVersion(source._source);
+  var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const
+
+  var _dispatcher$useState = dispatcher.useState(function() {
+      return readFromUnsubcribedMutableSource(root, source, getSnapshot);
+    }),
+    currentSnapshot = _dispatcher$useState[0],
+    setSnapshot = _dispatcher$useState[1];
+
+  var snapshot = currentSnapshot; // Grab a handle to the state hook as well.
+  // We use it to clear the pending update queue if we have a new source.
+
+  var stateHook = workInProgressHook;
+  var memoizedState = hook.memoizedState;
+  var refs = memoizedState.refs;
+  var prevGetSnapshot = refs.getSnapshot;
+  var prevSource = memoizedState.source;
+  var prevSubscribe = memoizedState.subscribe;
+  var fiber = currentlyRenderingFiber$1;
+  hook.memoizedState = {
+    refs: refs,
+    source: source,
+    subscribe: subscribe
+  }; // Sync the values needed by our subscription handler after each commit.
+
+  dispatcher.useEffect(
+    function() {
+      refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,
+      // but this hook recreates the queue in certain cases  to avoid updates from stale sources.
+      // handleChange() below needs to reference the dispatch function without re-subscribing,
+      // so we use a ref to ensure that it always has the latest version.
+
+      refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.
+
+      var maybeNewVersion = getVersion(source._source);
+
+      if (!objectIs(version, maybeNewVersion)) {
+        var maybeNewSnapshot = getSnapshot(source._source);
+
+        {
+          if (typeof maybeNewSnapshot === "function") {
+            error(
+              "Mutable source should not return a function as the snapshot value. " +
+                "Functions may close over mutable values and cause tearing."
+            );
+          }
+        }
+
+        if (!objectIs(snapshot, maybeNewSnapshot)) {
+          setSnapshot(maybeNewSnapshot);
+          var suspenseConfig = requestCurrentSuspenseConfig();
+          var lane = requestUpdateLane(fiber, suspenseConfig);
+          markRootMutableRead(root, lane);
+        } // If the source mutated between render and now,
+        // there may be state updates already scheduled from the old source.
+        // Entangle the updates so that they render in the same batch.
+
+        markRootEntangled(root, root.mutableReadLanes);
+      }
+    },
+    [getSnapshot, source, subscribe]
+  ); // If we got a new source or subscribe function, re-subscribe in a passive effect.
+
+  dispatcher.useEffect(
+    function() {
+      var handleChange = function() {
+        var latestGetSnapshot = refs.getSnapshot;
+        var latestSetSnapshot = refs.setSnapshot;
+
+        try {
+          latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.
+
+          var suspenseConfig = requestCurrentSuspenseConfig();
+          var lane = requestUpdateLane(fiber, suspenseConfig);
+          markRootMutableRead(root, lane);
+        } catch (error) {
+          // A selector might throw after a source mutation.
+          // e.g. it might try to read from a part of the store that no longer exists.
+          // In this case we should still schedule an update with React.
+          // Worst case the selector will throw again and then an error boundary will handle it.
+          latestSetSnapshot(function() {
+            throw error;
+          });
+        }
+      };
+
+      var unsubscribe = subscribe(source._source, handleChange);
+
+      {
+        if (typeof unsubscribe !== "function") {
+          error(
+            "Mutable source subscribe function must return an unsubscribe function."
+          );
+        }
+      }
+
+      return unsubscribe;
+    },
+    [source, subscribe]
+  ); // If any of the inputs to useMutableSource change, reading is potentially unsafe.
+  //
+  // If either the source or the subscription have changed we can't can't trust the update queue.
+  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.
+  //
+  // If the getSnapshot function changed, we also shouldn't rely on the update queue.
+  // It's possible that the underlying source was mutated between the when the last "change" event fired,
+  // and when the current render (with the new getSnapshot function) is processed.
+  //
+  // In both cases, we need to throw away pending updates (since they are no longer relevant)
+  // and treat reading from the source as we do in the mount case.
+
+  if (
+    !objectIs(prevGetSnapshot, getSnapshot) ||
+    !objectIs(prevSource, source) ||
+    !objectIs(prevSubscribe, subscribe)
+  ) {
+    // Create a new queue and setState method,
+    // So if there are interleaved updates, they get pushed to the older queue.
+    // When this becomes current, the previous queue and dispatch method will be discarded,
+    // including any interleaving updates that occur.
+    var newQueue = {
+      pending: null,
+      dispatch: null,
+      lastRenderedReducer: basicStateReducer,
+      lastRenderedState: snapshot
+    };
+    newQueue.dispatch = setSnapshot = dispatchAction.bind(
+      null,
+      currentlyRenderingFiber$1,
+      newQueue
+    );
+    stateHook.queue = newQueue;
+    stateHook.baseQueue = null;
+    snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot);
+    stateHook.memoizedState = stateHook.baseState = snapshot;
+  }
+
+  return snapshot;
+}
+
+function mountMutableSource(source, getSnapshot, subscribe) {
+  var hook = mountWorkInProgressHook();
+  hook.memoizedState = {
+    refs: {
+      getSnapshot: getSnapshot,
+      setSnapshot: null
+    },
+    source: source,
+    subscribe: subscribe
+  };
+  return useMutableSource(hook, source, getSnapshot, subscribe);
+}
+
+function updateMutableSource(source, getSnapshot, subscribe) {
+  var hook = updateWorkInProgressHook();
+  return useMutableSource(hook, source, getSnapshot, subscribe);
+}
+
 function mountState(initialState) {
   var hook = mountWorkInProgressHook();
 
@@ -10836,13 +11355,15 @@ function rerenderDeferredValue(value, config) {
 function startTransition(setPending, config, callback) {
   var priorityLevel = getCurrentPriorityLevel();
   runWithPriority(
-    priorityLevel < UserBlockingPriority ? UserBlockingPriority : priorityLevel,
+    priorityLevel < UserBlockingPriority$1
+      ? UserBlockingPriority$1
+      : priorityLevel,
     function() {
       setPending(true);
     }
-  );
+  ); // If there's no SuspenseConfig set, we'll use the DefaultLanePriority for this transition.
   runWithPriority(
-    priorityLevel > NormalPriority ? NormalPriority : priorityLevel,
+    priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel,
     function() {
       var previousConfig = ReactCurrentBatchConfig$1.suspense;
       ReactCurrentBatchConfig$1.suspense = config === undefined ? null : config;
@@ -10869,28 +11390,76 @@ function mountTransition(config) {
   return [start, isPending];
 }
 
-function updateTransition(config) {
-  var _updateState2 = updateState(),
-    isPending = _updateState2[0],
-    setPending = _updateState2[1];
+function updateTransition(config) {
+  var _updateState2 = updateState(),
+    isPending = _updateState2[0],
+    setPending = _updateState2[1];
+
+  var start = updateCallback(startTransition.bind(null, setPending, config), [
+    setPending,
+    config
+  ]);
+  return [start, isPending];
+}
+
+function rerenderTransition(config) {
+  var _rerenderState2 = rerenderState(),
+    isPending = _rerenderState2[0],
+    setPending = _rerenderState2[1];
+
+  var start = updateCallback(startTransition.bind(null, setPending, config), [
+    setPending,
+    config
+  ]);
+  return [start, isPending];
+}
+
+var isUpdatingOpaqueValueInRenderPhase = false;
+function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
+  {
+    return isUpdatingOpaqueValueInRenderPhase;
+  }
+}
+
+function warnOnOpaqueIdentifierAccessInDEV(fiber) {
+  {
+    // TODO: Should warn in effects and callbacks, too
+    var name = getComponentName(fiber.type) || "Unknown";
+
+    if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
+      error(
+        "The object passed back from useOpaqueIdentifier is meant to be " +
+          "passed through to attributes only. Do not read the " +
+          "value directly."
+      );
+
+      didWarnAboutUseOpaqueIdentifier[name] = true;
+    }
+  }
+}
+
+function mountOpaqueIdentifier() {
+  var makeId = makeClientIdInDEV.bind(
+    null,
+    warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1)
+  );
 
-  var start = updateCallback(startTransition.bind(null, setPending, config), [
-    setPending,
-    config
-  ]);
-  return [start, isPending];
+  {
+    var _id = makeId();
+
+    mountState(_id);
+    return _id;
+  }
 }
 
-function rerenderTransition(config) {
-  var _rerenderState2 = rerenderState(),
-    isPending = _rerenderState2[0],
-    setPending = _rerenderState2[1];
+function updateOpaqueIdentifier() {
+  var id = updateState()[0];
+  return id;
+}
 
-  var start = updateCallback(startTransition.bind(null, setPending, config), [
-    setPending,
-    config
-  ]);
-  return [start, isPending];
+function rerenderOpaqueIdentifier() {
+  var id = rerenderState()[0];
+  return id;
 }
 
 function dispatchAction(fiber, queue, action) {
@@ -10904,25 +11473,18 @@ function dispatchAction(fiber, queue, action) {
     }
   }
 
-  var currentTime = requestCurrentTimeForUpdate();
+  var eventTime = requestEventTime();
   var suspenseConfig = requestCurrentSuspenseConfig();
-  var expirationTime = computeExpirationForFiber(
-    currentTime,
-    fiber,
-    suspenseConfig
-  );
+  var lane = requestUpdateLane(fiber, suspenseConfig);
   var update = {
-    expirationTime: expirationTime,
+    eventTime: eventTime,
+    lane: lane,
     suspenseConfig: suspenseConfig,
     action: action,
     eagerReducer: null,
     eagerState: null,
     next: null
-  };
-
-  {
-    update.priority = getCurrentPriorityLevel();
-  } // Append the update to the end of the list.
+  }; // Append the update to the end of the list.
 
   var pending = queue.pending;
 
@@ -10944,13 +11506,11 @@ function dispatchAction(fiber, queue, action) {
     // This is a render phase update. Stash it in a lazily-created map of
     // queue -> linked list of updates. After this render pass, we'll restart
     // and apply the stashed updates on top of the work-in-progress hook.
-    didScheduleRenderPhaseUpdate = true;
-    update.expirationTime = renderExpirationTime;
-    currentlyRenderingFiber$1.expirationTime = renderExpirationTime;
+    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
   } else {
     if (
-      fiber.expirationTime === NoWork &&
-      (alternate === null || alternate.expirationTime === NoWork)
+      fiber.lanes === NoLanes &&
+      (alternate === null || alternate.lanes === NoLanes)
     ) {
       // The queue is currently empty, which means we can eagerly compute the
       // next state before entering the render phase. If the new state is the
@@ -10961,8 +11521,8 @@ function dispatchAction(fiber, queue, action) {
         var prevDispatcher;
 
         {
-          prevDispatcher = ReactCurrentDispatcher.current;
-          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+          prevDispatcher = ReactCurrentDispatcher$1.current;
+          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
         }
 
         try {
@@ -10986,7 +11546,7 @@ function dispatchAction(fiber, queue, action) {
           // Suppress the error. It will throw again in the render phase.
         } finally {
           {
-            ReactCurrentDispatcher.current = prevDispatcher;
+            ReactCurrentDispatcher$1.current = prevDispatcher;
           }
         }
       }
@@ -11000,18 +11560,10 @@ function dispatchAction(fiber, queue, action) {
       }
     }
 
-    scheduleWork(fiber, expirationTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   }
 }
 
-function mountEventListener(event) {
-  return undefined;
-}
-
-function updateEventListener(event) {
-  return undefined;
-}
-
 var ContextOnlyDispatcher = {
   readContext: readContext,
   useCallback: throwInvalidHookError,
@@ -11024,10 +11576,11 @@ var ContextOnlyDispatcher = {
   useRef: throwInvalidHookError,
   useState: throwInvalidHookError,
   useDebugValue: throwInvalidHookError,
-  useResponder: throwInvalidHookError,
   useDeferredValue: throwInvalidHookError,
   useTransition: throwInvalidHookError,
-  useEvent: throwInvalidHookError
+  useMutableSource: throwInvalidHookError,
+  useOpaqueIdentifier: throwInvalidHookError,
+  unstable_isNewReconciler: enableNewReconciler
 };
 var HooksDispatcherOnMountInDEV = null;
 var HooksDispatcherOnMountWithHookTypesInDEV = null;
@@ -11093,25 +11646,25 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useMemo";
       mountHookTypesDev();
       checkDepsAreArrayDev(deps);
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11122,13 +11675,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useState: function(initialState) {
       currentHookNameInDev = "useState";
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11136,11 +11689,6 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       mountHookTypesDev();
       return mountDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      mountHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
     useDeferredValue: function(value, config) {
       currentHookNameInDev = "useDeferredValue";
       mountHookTypesDev();
@@ -11151,11 +11699,17 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       mountHookTypesDev();
       return mountTransition(config);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       mountHookTypesDev();
-      return mountEventListener();
-    }
+      return mountMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      mountHookTypesDev();
+      return mountOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   HooksDispatcherOnMountWithHookTypesInDEV = {
     readContext: function(context, observedBits) {
@@ -11189,25 +11743,25 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useMemo: function(create, deps) {
       currentHookNameInDev = "useMemo";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11218,13 +11772,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useState: function(initialState) {
       currentHookNameInDev = "useState";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11232,11 +11786,6 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return mountDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
     useDeferredValue: function(value, config) {
       currentHookNameInDev = "useDeferredValue";
       updateHookTypesDev();
@@ -11247,11 +11796,17 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return mountTransition(config);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       updateHookTypesDev();
-      return mountEventListener();
-    }
+      return mountMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      updateHookTypesDev();
+      return mountOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   HooksDispatcherOnUpdateInDEV = {
     readContext: function(context, observedBits) {
@@ -11285,25 +11840,25 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useMemo: function(create, deps) {
       currentHookNameInDev = "useMemo";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11314,13 +11869,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useState: function(initialState) {
       currentHookNameInDev = "useState";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11328,11 +11883,6 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
     useDeferredValue: function(value, config) {
       currentHookNameInDev = "useDeferredValue";
       updateHookTypesDev();
@@ -11343,11 +11893,17 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateTransition(config);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       updateHookTypesDev();
-      return updateEventListener();
-    }
+      return updateMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      updateHookTypesDev();
+      return updateOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   HooksDispatcherOnRerenderInDEV = {
     readContext: function(context, observedBits) {
@@ -11381,25 +11937,25 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useMemo: function(create, deps) {
       currentHookNameInDev = "useMemo";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
 
       try {
         return updateMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
 
       try {
         return rerenderReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11410,13 +11966,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
     useState: function(initialState) {
       currentHookNameInDev = "useState";
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
 
       try {
         return rerenderState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11424,11 +11980,6 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
     useDeferredValue: function(value, config) {
       currentHookNameInDev = "useDeferredValue";
       updateHookTypesDev();
@@ -11439,11 +11990,17 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return rerenderTransition(config);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       updateHookTypesDev();
-      return updateEventListener();
-    }
+      return updateMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      updateHookTypesDev();
+      return rerenderOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   InvalidNestedHooksDispatcherOnMountInDEV = {
     readContext: function(context, observedBits) {
@@ -11484,26 +12041,26 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useMemo";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11516,13 +12073,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useState";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
 
       try {
         return mountState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11531,12 +12088,6 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       mountHookTypesDev();
       return mountDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      warnInvalidHookAccess();
-      mountHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
     useDeferredValue: function(value, config) {
       currentHookNameInDev = "useDeferredValue";
       warnInvalidHookAccess();
@@ -11549,12 +12100,19 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       mountHookTypesDev();
       return mountTransition(config);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       warnInvalidHookAccess();
       mountHookTypesDev();
-      return mountEventListener();
-    }
+      return mountMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      warnInvalidHookAccess();
+      mountHookTypesDev();
+      return mountOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   InvalidNestedHooksDispatcherOnUpdateInDEV = {
     readContext: function(context, observedBits) {
@@ -11595,26 +12153,26 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useMemo";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11627,13 +12185,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useState";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11642,12 +12200,6 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      warnInvalidHookAccess();
-      updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
     useDeferredValue: function(value, config) {
       currentHookNameInDev = "useDeferredValue";
       warnInvalidHookAccess();
@@ -11660,12 +12212,19 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateTransition(config);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return updateEventListener();
-    }
+      return updateMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      warnInvalidHookAccess();
+      updateHookTypesDev();
+      return updateOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
   InvalidNestedHooksDispatcherOnRerenderInDEV = {
     readContext: function(context, observedBits) {
@@ -11706,26 +12265,26 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useMemo";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return updateMemo(create, deps);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useReducer: function(reducer, initialArg, init) {
       currentHookNameInDev = "useReducer";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return rerenderReducer(reducer, initialArg, init);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useRef: function(initialValue) {
@@ -11738,13 +12297,13 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       currentHookNameInDev = "useState";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      var prevDispatcher = ReactCurrentDispatcher.current;
-      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
+      var prevDispatcher = ReactCurrentDispatcher$1.current;
+      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
 
       try {
         return rerenderState(initialState);
       } finally {
-        ReactCurrentDispatcher.current = prevDispatcher;
+        ReactCurrentDispatcher$1.current = prevDispatcher;
       }
     },
     useDebugValue: function(value, formatterFn) {
@@ -11753,12 +12312,6 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return updateDebugValue();
     },
-    useResponder: function(responder, props) {
-      currentHookNameInDev = "useResponder";
-      warnInvalidHookAccess();
-      updateHookTypesDev();
-      return createDeprecatedResponderListener(responder, props);
-    },
     useDeferredValue: function(value, config) {
       currentHookNameInDev = "useDeferredValue";
       warnInvalidHookAccess();
@@ -11771,12 +12324,19 @@ var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
       updateHookTypesDev();
       return rerenderTransition(config);
     },
-    useEvent: function(event) {
-      currentHookNameInDev = "useEvent";
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      currentHookNameInDev = "useMutableSource";
       warnInvalidHookAccess();
       updateHookTypesDev();
-      return updateEventListener();
-    }
+      return updateMutableSource(source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      currentHookNameInDev = "useOpaqueIdentifier";
+      warnInvalidHookAccess();
+      updateHookTypesDev();
+      return rerenderOpaqueIdentifier();
+    },
+    unstable_isNewReconciler: enableNewReconciler
   };
 }
 
@@ -11817,40 +12377,15 @@ function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
   }
 }
 
-function enterHydrationState(fiber) {
-  {
-    return false;
-  }
-}
-
-function prepareToHydrateHostInstance(
-  fiber,
-  rootContainerInstance,
-  hostContext
-) {
-  {
-    {
-      throw Error(
-        "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-  }
-}
-
-function prepareToHydrateHostTextInstance(fiber) {
-  {
-    {
-      throw Error(
-        "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-  }
-  var shouldUpdate = hydrateTextInstance();
-}
+function transferActualDuration(fiber) {
+  // Transfer time spent rendering these children so we don't lose it
+  // after we rerender. This is used as a helper in special cases
+  // where we should count the work of multiple passes.
+  var child = fiber.child;
 
-function popHydrationState(fiber) {
-  {
-    return false;
+  while (child) {
+    fiber.actualDuration += child.actualDuration;
+    child = child.sibling;
   }
 }
 
@@ -11876,12 +12411,7 @@ var didWarnAboutTailOptions;
   didWarnAboutTailOptions = {};
 }
 
-function reconcileChildren(
-  current,
-  workInProgress,
-  nextChildren,
-  renderExpirationTime
-) {
+function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
   if (current === null) {
     // If this is a fresh new component that hasn't been rendered yet, we
     // won't update its child set by applying minimal side-effects. Instead,
@@ -11891,7 +12421,7 @@ function reconcileChildren(
       workInProgress,
       null,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
   } else {
     // If the current child is the same as the work in progress, it means that
@@ -11903,7 +12433,7 @@ function reconcileChildren(
       workInProgress,
       current.child,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
   }
 }
@@ -11912,7 +12442,7 @@ function forceUnmountCurrentAndReconcile(
   current,
   workInProgress,
   nextChildren,
-  renderExpirationTime
+  renderLanes
 ) {
   // This function is fork of reconcileChildren. It's used in cases where we
   // want to reconcile without matching against the existing set. This has the
@@ -11926,7 +12456,7 @@ function forceUnmountCurrentAndReconcile(
     workInProgress,
     current.child,
     null,
-    renderExpirationTime
+    renderLanes
   ); // In the second pass, we mount the new children. The trick here is that we
   // pass null in place of where we usually pass the current child set. This has
   // the effect of remounting all children regardless of whether their
@@ -11936,7 +12466,7 @@ function forceUnmountCurrentAndReconcile(
     workInProgress,
     null,
     nextChildren,
-    renderExpirationTime
+    renderLanes
   );
 }
 
@@ -11945,7 +12475,7 @@ function updateForwardRef(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   // TODO: current can be non-null here even if the component
   // hasn't yet mounted. This happens after the first render suspends.
@@ -11971,7 +12501,7 @@ function updateForwardRef(
   var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent
 
   var nextChildren;
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
 
   {
     ReactCurrentOwner$1.current = workInProgress;
@@ -11982,28 +12512,36 @@ function updateForwardRef(
       render,
       nextProps,
       ref,
-      renderExpirationTime
+      renderLanes
     );
 
+    if (workInProgress.mode & StrictMode) {
+      disableLogs();
+
+      try {
+        nextChildren = renderWithHooks(
+          current,
+          workInProgress,
+          render,
+          nextProps,
+          ref,
+          renderLanes
+        );
+      } finally {
+        reenableLogs();
+      }
+    }
+
     setIsRendering(false);
   }
 
   if (current !== null && !didReceiveUpdate) {
-    bailoutHooks(current, workInProgress, renderExpirationTime);
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    bailoutHooks(current, workInProgress, renderLanes);
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   } // React DevTools reads this flag.
 
   workInProgress.effectTag |= PerformedWork;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -12012,8 +12550,8 @@ function updateMemoComponent(
   workInProgress,
   Component,
   nextProps,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
   if (current === null) {
     var type = Component.type;
@@ -12043,8 +12581,8 @@ function updateMemoComponent(
         workInProgress,
         resolvedType,
         nextProps,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     }
 
@@ -12069,7 +12607,7 @@ function updateMemoComponent(
       nextProps,
       null,
       workInProgress.mode,
-      renderExpirationTime
+      renderLanes
     );
     child.ref = workInProgress.ref;
     child.return = workInProgress;
@@ -12095,7 +12633,7 @@ function updateMemoComponent(
 
   var currentChild = current.child; // This is always exactly one child
 
-  if (updateExpirationTime < renderExpirationTime) {
+  if (!includesSomeLane(updateLanes, renderLanes)) {
     // This will be the props with resolved defaultProps,
     // unlike current.memoizedProps which will be the unresolved ones.
     var prevProps = currentChild.memoizedProps; // Default to shallow comparison
@@ -12104,11 +12642,7 @@ function updateMemoComponent(
     compare = compare !== null ? compare : shallowEqual;
 
     if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
-      return bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
     }
   } // React DevTools reads this flag.
 
@@ -12125,8 +12659,8 @@ function updateSimpleMemoComponent(
   workInProgress,
   Component,
   nextProps,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
   // TODO: current can be non-null here even if the component
   // hasn't yet mounted. This happens when the inner render suspends.
@@ -12141,19 +12675,27 @@ function updateSimpleMemoComponent(
         // We warn when you define propTypes on lazy()
         // so let's just skip over it to find memo() outer wrapper.
         // Inner props for memo are validated later.
-        outerMemoType = refineResolvedLazyComponent(outerMemoType);
-      }
-
-      var outerPropTypes = outerMemoType && outerMemoType.propTypes;
+        var lazyComponent = outerMemoType;
+        var payload = lazyComponent._payload;
+        var init = lazyComponent._init;
 
-      if (outerPropTypes) {
-        checkPropTypes(
-          outerPropTypes,
-          nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
-          "prop",
-          getComponentName(outerMemoType)
-        );
-      } // Inner propTypes will be validated in the function component path.
+        try {
+          outerMemoType = init(payload);
+        } catch (x) {
+          outerMemoType = null;
+        } // Inner propTypes will be validated in the function component path.
+
+        var outerPropTypes = outerMemoType && outerMemoType.propTypes;
+
+        if (outerPropTypes) {
+          checkPropTypes(
+            outerPropTypes,
+            nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
+            "prop",
+            getComponentName(outerMemoType)
+          );
+        }
+      }
     }
   }
 
@@ -12167,10 +12709,10 @@ function updateSimpleMemoComponent(
     ) {
       didReceiveUpdate = false;
 
-      if (updateExpirationTime < renderExpirationTime) {
-        // The pending update priority was cleared at the beginning of
-        // beginWork. We're about to bail out, but there might be additional
-        // updates at a lower priority. Usually, the priority level of the
+      if (!includesSomeLane(renderLanes, updateLanes)) {
+        // The pending lanes were cleared at the beginning of beginWork. We're
+        // about to bail out, but there might be other lanes that weren't
+        // included in the current render. Usually, the priority level of the
         // remaining updates is accumlated during the evaluation of the
         // component (i.e. when processing the update queue). But since since
         // we're bailing out early *without* evaluating the component, we need
@@ -12181,12 +12723,19 @@ function updateSimpleMemoComponent(
         // contains hooks.
         // TODO: Move the reset at in beginWork out of the common path so that
         // this is no longer necessary.
-        workInProgress.expirationTime = current.expirationTime;
+        workInProgress.lanes = current.lanes;
         return bailoutOnAlreadyFinishedWork(
           current,
           workInProgress,
-          renderExpirationTime
+          renderLanes
         );
+      } else if (
+        (current.effectTag & ForceUpdateForLegacySuspense) !==
+        NoEffect
+      ) {
+        // This is a special case that only exists for legacy mode.
+        // See https://github.com/facebook/react/pull/19216.
+        didReceiveUpdate = true;
       }
     }
   }
@@ -12196,33 +12745,101 @@ function updateSimpleMemoComponent(
     workInProgress,
     Component,
     nextProps,
-    renderExpirationTime
+    renderLanes
   );
 }
 
-function updateFragment(current, workInProgress, renderExpirationTime) {
+function updateOffscreenComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps;
+  var nextChildren = nextProps.children;
+  var prevState = current !== null ? current.memoizedState : null;
+
+  if (
+    nextProps.mode === "hidden" ||
+    nextProps.mode === "unstable-defer-without-hiding"
+  ) {
+    if ((workInProgress.mode & ConcurrentMode) === NoMode) {
+      // In legacy sync mode, don't defer the subtree. Render it now.
+      // TODO: Figure out what we should do in Blocking mode.
+      var nextState = {
+        baseLanes: NoLanes
+      };
+      workInProgress.memoizedState = nextState;
+      pushRenderLanes(workInProgress, renderLanes);
+    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {
+      var nextBaseLanes;
+
+      if (prevState !== null) {
+        var prevBaseLanes = prevState.baseLanes;
+        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
+      } else {
+        nextBaseLanes = renderLanes;
+      } // Schedule this fiber to re-render at offscreen priority. Then bailout.
+
+      {
+        markSpawnedWork(OffscreenLane);
+      }
+
+      workInProgress.lanes = workInProgress.childLanes = laneToLanes(
+        OffscreenLane
+      );
+      var _nextState = {
+        baseLanes: nextBaseLanes
+      };
+      workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway
+      // to avoid a push/pop misalignment.
+
+      pushRenderLanes(workInProgress, nextBaseLanes);
+      return null;
+    } else {
+      // Rendering at offscreen, so we can clear the base lanes.
+      var _nextState2 = {
+        baseLanes: NoLanes
+      };
+      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.
+
+      var subtreeRenderLanes =
+        prevState !== null ? prevState.baseLanes : renderLanes;
+      pushRenderLanes(workInProgress, subtreeRenderLanes);
+    }
+  } else {
+    var _subtreeRenderLanes;
+
+    if (prevState !== null) {
+      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes); // Since we're not hidden anymore, reset the state
+
+      workInProgress.memoizedState = null;
+    } else {
+      // We weren't previously hidden, and we still aren't, so there's nothing
+      // special to do. Need to push to the stack regardless, though, to avoid
+      // a push/pop misalignment.
+      _subtreeRenderLanes = renderLanes;
+    }
+
+    pushRenderLanes(workInProgress, _subtreeRenderLanes);
+  }
+
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+  return workInProgress.child;
+} // Note: These happen to have identical begin phases, for now. We shouldn't hold
+// ourselves to this constraint, though. If the behavior diverges, we should
+// fork the function.
+
+var updateLegacyHiddenComponent = updateOffscreenComponent;
+
+function updateFragment(current, workInProgress, renderLanes) {
   var nextChildren = workInProgress.pendingProps;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
-function updateMode(current, workInProgress, renderExpirationTime) {
+function updateMode(current, workInProgress, renderLanes) {
   var nextChildren = workInProgress.pendingProps.children;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
-function updateProfiler(current, workInProgress, renderExpirationTime) {
+function updateProfiler(current, workInProgress, renderLanes) {
   {
     workInProgress.effectTag |= Update; // Reset effect durations for the next eventual effect phase.
     // These are reset during render to allow the DevTools commit hook a chance to read them,
@@ -12234,12 +12851,7 @@ function updateProfiler(current, workInProgress, renderExpirationTime) {
 
   var nextProps = workInProgress.pendingProps;
   var nextChildren = nextProps.children;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -12260,7 +12872,7 @@ function updateFunctionComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   {
     if (workInProgress.type !== workInProgress.elementType) {
@@ -12287,7 +12899,7 @@ function updateFunctionComponent(
   }
 
   var nextChildren;
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
 
   {
     ReactCurrentOwner$1.current = workInProgress;
@@ -12298,28 +12910,36 @@ function updateFunctionComponent(
       Component,
       nextProps,
       context,
-      renderExpirationTime
+      renderLanes
     );
 
+    if (workInProgress.mode & StrictMode) {
+      disableLogs();
+
+      try {
+        nextChildren = renderWithHooks(
+          current,
+          workInProgress,
+          Component,
+          nextProps,
+          context,
+          renderLanes
+        );
+      } finally {
+        reenableLogs();
+      }
+    }
+
     setIsRendering(false);
   }
 
   if (current !== null && !didReceiveUpdate) {
-    bailoutHooks(current, workInProgress, renderExpirationTime);
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    bailoutHooks(current, workInProgress, renderLanes);
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   } // React DevTools reads this flag.
 
   workInProgress.effectTag |= PerformedWork;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -12328,7 +12948,7 @@ function updateClassComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   {
     if (workInProgress.type !== workInProgress.elementType) {
@@ -12358,7 +12978,7 @@ function updateClassComponent(
     hasContext = false;
   }
 
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   var instance = workInProgress.stateNode;
   var shouldUpdate;
 
@@ -12375,12 +12995,7 @@ function updateClassComponent(
     } // In the initial pass we might need to construct the instance.
 
     constructClassInstance(workInProgress, Component, nextProps);
-    mountClassInstance(
-      workInProgress,
-      Component,
-      nextProps,
-      renderExpirationTime
-    );
+    mountClassInstance(workInProgress, Component, nextProps, renderLanes);
     shouldUpdate = true;
   } else if (current === null) {
     // In a resume, we'll already have an instance we can reuse.
@@ -12388,7 +13003,7 @@ function updateClassComponent(
       workInProgress,
       Component,
       nextProps,
-      renderExpirationTime
+      renderLanes
     );
   } else {
     shouldUpdate = updateClassInstance(
@@ -12396,7 +13011,7 @@ function updateClassComponent(
       workInProgress,
       Component,
       nextProps,
-      renderExpirationTime
+      renderLanes
     );
   }
 
@@ -12406,13 +13021,13 @@ function updateClassComponent(
     Component,
     shouldUpdate,
     hasContext,
-    renderExpirationTime
+    renderLanes
   );
 
   {
     var inst = workInProgress.stateNode;
 
-    if (inst.props !== nextProps) {
+    if (shouldUpdate && inst.props !== nextProps) {
       if (!didWarnAboutReassigningProps) {
         error(
           "It looks like %s is reassigning its own `this.props` while rendering. " +
@@ -12434,7 +13049,7 @@ function finishClassComponent(
   Component,
   shouldUpdate,
   hasContext,
-  renderExpirationTime
+  renderLanes
 ) {
   // Refs should update even if shouldComponentUpdate returns false
   markRef(current, workInProgress);
@@ -12446,11 +13061,7 @@ function finishClassComponent(
       invalidateContextProvider(workInProgress, Component, false);
     }
 
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   }
 
   var instance = workInProgress.stateNode; // Rerender
@@ -12477,6 +13088,16 @@ function finishClassComponent(
       setIsRendering(true);
       nextChildren = instance.render();
 
+      if (workInProgress.mode & StrictMode) {
+        disableLogs();
+
+        try {
+          instance.render();
+        } finally {
+          reenableLogs();
+        }
+      }
+
       setIsRendering(false);
     }
   } // React DevTools reads this flag.
@@ -12492,15 +13113,10 @@ function finishClassComponent(
       current,
       workInProgress,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
   } else {
-    reconcileChildren(
-      current,
-      workInProgress,
-      nextChildren,
-      renderExpirationTime
-    );
+    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   } // Memoize state using the values we just used to render.
   // TODO: Restructure so we never read values from the instance.
 
@@ -12530,7 +13146,7 @@ function pushHostRootContext(workInProgress) {
   pushHostContainer(workInProgress, root.containerInfo);
 }
 
-function updateHostRoot(current, workInProgress, renderExpirationTime) {
+function updateHostRoot(current, workInProgress, renderLanes) {
   pushHostRootContext(workInProgress);
   var updateQueue = workInProgress.updateQueue;
 
@@ -12544,32 +13160,24 @@ function updateHostRoot(current, workInProgress, renderExpirationTime) {
   var prevState = workInProgress.memoizedState;
   var prevChildren = prevState !== null ? prevState.element : null;
   cloneUpdateQueue(current, workInProgress);
-  processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);
+  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
   var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property
   // being called "element".
 
   var nextChildren = nextState.element;
 
   if (nextChildren === prevChildren) {
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   }
 
   var root = workInProgress.stateNode;
 
   if (root.hydrate && enterHydrationState()) {
-    // If we don't have any current children this might be the first pass.
-    // We always try to hydrate. If this isn't a hydration pass there won't
-    // be any children to hydrate which is effectively the same thing as
-    // not hydrating.
     var child = mountChildFibers(
       workInProgress,
       null,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
     workInProgress.child = child;
     var node = child;
@@ -12587,18 +13195,13 @@ function updateHostRoot(current, workInProgress, renderExpirationTime) {
   } else {
     // Otherwise reset hydration state in case we aborted and resumed another
     // root.
-    reconcileChildren(
-      current,
-      workInProgress,
-      nextChildren,
-      renderExpirationTime
-    );
+    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   }
 
   return workInProgress.child;
 }
 
-function updateHostComponent(current, workInProgress, renderExpirationTime) {
+function updateHostComponent(current, workInProgress, renderLanes) {
   pushHostContext(workInProgress);
 
   var type = workInProgress.type;
@@ -12612,27 +13215,8 @@ function updateHostComponent(current, workInProgress, renderExpirationTime) {
     workInProgress.effectTag |= ContentReset;
   }
 
-  markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.
-
-  if (
-    workInProgress.mode & ConcurrentMode &&
-    renderExpirationTime !== Never &&
-    shouldDeprioritizeSubtree()
-  ) {
-    {
-      markSpawnedWork(Never);
-    } // Schedule this fiber to re-render at offscreen priority. Then bailout.
-
-    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
-    return null;
-  }
-
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextChildren,
-    renderExpirationTime
-  );
+  markRef(current, workInProgress);
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -12646,8 +13230,8 @@ function mountLazyComponent(
   _current,
   workInProgress,
   elementType,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
   if (_current !== null) {
     // A lazy component only mounts if it suspended inside a non-
@@ -12660,15 +13244,14 @@ function mountLazyComponent(
     workInProgress.effectTag |= Placement;
   }
 
-  var props = workInProgress.pendingProps; // We can't start a User Timing measurement with correct label yet.
-  // Cancel and resume right after we know the tag.
-
-  cancelWorkTimer(workInProgress);
-  var Component = readLazyComponentType(elementType); // Store the unwrapped component in the type.
+  var props = workInProgress.pendingProps;
+  var lazyComponent = elementType;
+  var payload = lazyComponent._payload;
+  var init = lazyComponent._init;
+  var Component = init(payload); // Store the unwrapped component in the type.
 
   workInProgress.type = Component;
   var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));
-  startWorkTimer(workInProgress);
   var resolvedProps = resolveDefaultProps(Component, props);
   var child;
 
@@ -12686,7 +13269,7 @@ function mountLazyComponent(
         workInProgress,
         Component,
         resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
       return child;
     }
@@ -12703,7 +13286,7 @@ function mountLazyComponent(
         workInProgress,
         Component,
         resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
       return child;
     }
@@ -12720,7 +13303,7 @@ function mountLazyComponent(
         workInProgress,
         Component,
         resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
       return child;
     }
@@ -12746,8 +13329,8 @@ function mountLazyComponent(
         workInProgress,
         Component,
         resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
       return child;
     }
@@ -12782,7 +13365,7 @@ function mountIncompleteClassComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   if (_current !== null) {
     // An incomplete component only mounts if it suspended inside a non-
@@ -12809,21 +13392,16 @@ function mountIncompleteClassComponent(
     hasContext = false;
   }
 
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  constructClassInstance(workInProgress, Component, nextProps);
-  mountClassInstance(
-    workInProgress,
-    Component,
-    nextProps,
-    renderExpirationTime
-  );
+  prepareToReadContext(workInProgress, renderLanes);
+  constructClassInstance(workInProgress, Component, nextProps);
+  mountClassInstance(workInProgress, Component, nextProps, renderLanes);
   return finishClassComponent(
     null,
     workInProgress,
     Component,
     true,
     hasContext,
-    renderExpirationTime
+    renderLanes
   );
 }
 
@@ -12831,7 +13409,7 @@ function mountIndeterminateComponent(
   _current,
   workInProgress,
   Component,
-  renderExpirationTime
+  renderLanes
 ) {
   if (_current !== null) {
     // An indeterminate component only mounts if it suspended inside a non-
@@ -12852,7 +13430,7 @@ function mountIndeterminateComponent(
     context = getMaskedContext(workInProgress, unmaskedContext);
   }
 
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   var value;
 
   {
@@ -12878,6 +13456,7 @@ function mountIndeterminateComponent(
       ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
     }
 
+    setIsRendering(true);
     ReactCurrentOwner$1.current = workInProgress;
     value = renderWithHooks(
       null,
@@ -12885,34 +13464,65 @@ function mountIndeterminateComponent(
       Component,
       props,
       context,
-      renderExpirationTime
+      renderLanes
     );
+    setIsRendering(false);
   } // React DevTools reads this flag.
 
   workInProgress.effectTag |= PerformedWork;
 
+  {
+    // Support for module components is deprecated and is removed behind a flag.
+    // Whether or not it would crash later, we want to show a good message in DEV first.
+    if (
+      typeof value === "object" &&
+      value !== null &&
+      typeof value.render === "function" &&
+      value.$$typeof === undefined
+    ) {
+      var _componentName = getComponentName(Component) || "Unknown";
+
+      if (!didWarnAboutModulePatternComponent[_componentName]) {
+        error(
+          "The <%s /> component appears to be a function component that returns a class instance. " +
+            "Change %s to a class that extends React.Component instead. " +
+            "If you can't use a class try assigning the prototype on the function as a workaround. " +
+            "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " +
+            "cannot be called with `new` by React.",
+          _componentName,
+          _componentName,
+          _componentName
+        );
+
+        didWarnAboutModulePatternComponent[_componentName] = true;
+      }
+    }
+  }
+
   if (
+    // Run these checks in production only if the flag is off.
+    // Eventually we'll delete this branch altogether.
     typeof value === "object" &&
     value !== null &&
     typeof value.render === "function" &&
     value.$$typeof === undefined
   ) {
     {
-      var _componentName = getComponentName(Component) || "Unknown";
+      var _componentName2 = getComponentName(Component) || "Unknown";
 
-      if (!didWarnAboutModulePatternComponent[_componentName]) {
+      if (!didWarnAboutModulePatternComponent[_componentName2]) {
         error(
           "The <%s /> component appears to be a function component that returns a class instance. " +
             "Change %s to a class that extends React.Component instead. " +
             "If you can't use a class try assigning the prototype on the function as a workaround. " +
             "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " +
             "cannot be called with `new` by React.",
-          _componentName,
-          _componentName,
-          _componentName
+          _componentName2,
+          _componentName2,
+          _componentName2
         );
 
-        didWarnAboutModulePatternComponent[_componentName] = true;
+        didWarnAboutModulePatternComponent[_componentName2] = true;
       }
     } // Proceed under the assumption that this is a class instance
 
@@ -12947,20 +13557,39 @@ function mountIndeterminateComponent(
     }
 
     adoptClassInstance(workInProgress, value);
-    mountClassInstance(workInProgress, Component, props, renderExpirationTime);
+    mountClassInstance(workInProgress, Component, props, renderLanes);
     return finishClassComponent(
       null,
       workInProgress,
       Component,
       true,
       hasContext,
-      renderExpirationTime
+      renderLanes
     );
   } else {
     // Proceed under the assumption that this is a function component
     workInProgress.tag = FunctionComponent;
 
-    reconcileChildren(null, workInProgress, value, renderExpirationTime);
+    {
+      if (workInProgress.mode & StrictMode) {
+        disableLogs();
+
+        try {
+          value = renderWithHooks(
+            null,
+            workInProgress,
+            Component,
+            props,
+            context,
+            renderLanes
+          );
+        } finally {
+          reenableLogs();
+        }
+      }
+    }
+
+    reconcileChildren(null, workInProgress, value, renderLanes);
 
     {
       validateFunctionComponentInDev(workInProgress, Component);
@@ -13009,15 +13638,15 @@ function validateFunctionComponentInDev(workInProgress, Component) {
     }
 
     if (typeof Component.getDerivedStateFromProps === "function") {
-      var _componentName2 = getComponentName(Component) || "Unknown";
+      var _componentName3 = getComponentName(Component) || "Unknown";
 
-      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {
+      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
         error(
           "%s: Function components do not support getDerivedStateFromProps.",
-          _componentName2
+          _componentName3
         );
 
-        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true;
+        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
       }
     }
 
@@ -13025,15 +13654,15 @@ function validateFunctionComponentInDev(workInProgress, Component) {
       typeof Component.contextType === "object" &&
       Component.contextType !== null
     ) {
-      var _componentName3 = getComponentName(Component) || "Unknown";
+      var _componentName4 = getComponentName(Component) || "Unknown";
 
-      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {
+      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
         error(
           "%s: Function components do not support contextType.",
-          _componentName3
+          _componentName4
         );
 
-        didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true;
+        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
       }
     }
   }
@@ -13041,24 +13670,51 @@ function validateFunctionComponentInDev(workInProgress, Component) {
 
 var SUSPENDED_MARKER = {
   dehydrated: null,
-  retryTime: NoWork
+  retryLane: NoLane
 };
 
-function shouldRemainOnFallback(suspenseContext, current, workInProgress) {
-  // If the context is telling us that we should show a fallback, and we're not
-  // already showing content, then we should show the fallback instead.
-  return (
-    hasSuspenseContext(suspenseContext, ForceSuspenseFallback) &&
-    (current === null || current.memoizedState !== null)
-  );
+function mountSuspenseOffscreenState(renderLanes) {
+  return {
+    baseLanes: renderLanes
+  };
+}
+
+function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
+  return {
+    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes)
+  };
 }
 
-function updateSuspenseComponent(
+function shouldRemainOnFallback(
+  suspenseContext,
   current,
   workInProgress,
-  renderExpirationTime
+  renderLanes
 ) {
-  var mode = workInProgress.mode;
+  // If we're already showing a fallback, there are cases where we need to
+  // remain on that fallback regardless of whether the content has resolved.
+  // For example, SuspenseList coordinates when nested content appears.
+  if (current !== null) {
+    var suspenseState = current.memoizedState;
+
+    if (suspenseState === null) {
+      // Currently showing content. Don't hide it, even if ForceSuspenseFallack
+      // is true. More precise name might be "ForceRemainSuspenseFallback".
+      // Note: This is a factoring smell. Can't remain on a fallback if there's
+      // no fallback to remain on.
+      return false;
+    }
+  } // Not currently showing content. Consult the Suspense context.
+
+  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
+}
+
+function getRemainingWorkInPrimaryTree(current, renderLanes) {
+  // TODO: Should not remove render lanes that were pinged during this render
+  return removeLanes(current.childLanes, renderLanes);
+}
+
+function updateSuspenseComponent(current, workInProgress, renderLanes) {
   var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.
 
   {
@@ -13068,13 +13724,13 @@ function updateSuspenseComponent(
   }
 
   var suspenseContext = suspenseStackCursor.current;
-  var nextDidTimeout = false;
+  var showFallback = false;
   var didSuspend = (workInProgress.effectTag & DidCapture) !== NoEffect;
 
   if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
     // Something in this boundary's subtree already suspended. Switch to
     // rendering the fallback children.
-    nextDidTimeout = true;
+    showFallback = true;
     workInProgress.effectTag &= ~DidCapture;
   } else {
     // Attempting the main content
@@ -13097,290 +13753,380 @@ function updateSuspenseComponent(
   }
 
   suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
-  pushSuspenseContext(workInProgress, suspenseContext); // This next part is a bit confusing. If the children timeout, we switch to
-  // showing the fallback children in place of the "primary" children.
-  // However, we don't want to delete the primary children because then their
-  // state will be lost (both the React state and the host state, e.g.
-  // uncontrolled form inputs). Instead we keep them mounted and hide them.
-  // Both the fallback children AND the primary children are rendered at the
-  // same time. Once the primary children are un-suspended, we can delete
-  // the fallback children  don't need to preserve their state.
+  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
+  // boundary's children. This involves some custom reconcilation logic. Two
+  // main reasons this is so complicated.
   //
-  // The two sets of children are siblings in the host environment, but
-  // semantically, for purposes of reconciliation, they are two separate sets.
-  // So we store them using two fragment fibers.
+  // First, Legacy Mode has different semantics for backwards compatibility. The
+  // primary tree will commit in an inconsistent state, so when we do the
+  // second pass to render the fallback, we do some exceedingly, uh, clever
+  // hacks to make that not totally break. Like transferring effects and
+  // deletions from hidden tree. In Concurrent Mode, it's much simpler,
+  // because we bailout on the primary tree completely and leave it in its old
+  // state, no effects. Same as what we do for Offscreen (except that
+  // Offscreen doesn't have the first render pass).
   //
-  // However, we want to avoid allocating extra fibers for every placeholder.
-  // They're only necessary when the children time out, because that's the
-  // only time when both sets are mounted.
+  // Second is hydration. During hydration, the Suspense fiber has a slightly
+  // different layout, where the child points to a dehydrated fragment, which
+  // contains the DOM rendered by the server.
   //
-  // So, the extra fragment fibers are only used if the children time out.
-  // Otherwise, we render the primary children directly. This requires some
-  // custom reconciliation logic to preserve the state of the primary
-  // children. It's essentially a very basic form of re-parenting.
+  // Third, even if you set all that aside, Suspense is like error boundaries in
+  // that we first we try to render one tree, and if that fails, we render again
+  // and switch to a different tree. Like a try/catch block. So we have to track
+  // which branch we're currently rendering. Ideally we would model this using
+  // a stack.
 
   if (current === null) {
+    // Initial mount
     // If we're currently hydrating, try to hydrate this boundary.
     // But only if this has a fallback.
-    if (nextProps.fallback !== undefined); // This is the initial mount. This branch is pretty simple because there's
-    // no previous state that needs to be preserved.
+    if (nextProps.fallback !== undefined);
 
-    if (nextDidTimeout) {
-      // Mount separate fragments for primary and fallback children.
+    if (showFallback) {
+      var nextPrimaryChildren = nextProps.children;
       var nextFallbackChildren = nextProps.fallback;
-      var primaryChildFragment = createFiberFromFragment(
-        null,
-        mode,
-        NoWork,
-        null
-      );
-      primaryChildFragment.return = workInProgress;
-
-      if ((workInProgress.mode & BlockingMode) === NoMode) {
-        // Outside of blocking mode, we commit the effects from the
-        // partially completed, timed-out tree, too.
-        var progressedState = workInProgress.memoizedState;
-        var progressedPrimaryChild =
-          progressedState !== null
-            ? workInProgress.child.child
-            : workInProgress.child;
-        primaryChildFragment.child = progressedPrimaryChild;
-        var progressedChild = progressedPrimaryChild;
-
-        while (progressedChild !== null) {
-          progressedChild.return = primaryChildFragment;
-          progressedChild = progressedChild.sibling;
-        }
-      }
-
-      var fallbackChildFragment = createFiberFromFragment(
+      var fallbackFragment = mountSuspenseFallbackChildren(
+        workInProgress,
+        nextPrimaryChildren,
         nextFallbackChildren,
-        mode,
-        renderExpirationTime,
-        null
+        renderLanes
+      );
+      var primaryChildFragment = workInProgress.child;
+      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(
+        renderLanes
       );
-      fallbackChildFragment.return = workInProgress;
-      primaryChildFragment.sibling = fallbackChildFragment; // Skip the primary children, and continue working on the
-      // fallback children.
-
       workInProgress.memoizedState = SUSPENDED_MARKER;
-      workInProgress.child = primaryChildFragment;
-      return fallbackChildFragment;
+      return fallbackFragment;
     } else {
-      // Mount the primary children without an intermediate fragment fiber.
-      var nextPrimaryChildren = nextProps.children;
-      workInProgress.memoizedState = null;
-      return (workInProgress.child = mountChildFibers(
+      var _nextPrimaryChildren = nextProps.children;
+      return mountSuspensePrimaryChildren(
         workInProgress,
-        null,
-        nextPrimaryChildren,
-        renderExpirationTime
-      ));
+        _nextPrimaryChildren,
+        renderLanes
+      );
     }
   } else {
-    // This is an update. This branch is more complicated because we need to
-    // ensure the state of the primary children is preserved.
+    // This is an update.
+    // If the current fiber has a SuspenseState, that means it's already showing
+    // a fallback.
     var prevState = current.memoizedState;
 
     if (prevState !== null) {
-      // wrapped in a fragment fiber.
-
-      var currentPrimaryChildFragment = current.child;
-      var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
-
-      if (nextDidTimeout) {
-        // Still timed out. Reuse the current primary children by cloning
-        // its fragment. We're going to skip over these entirely.
+      if (showFallback) {
         var _nextFallbackChildren2 = nextProps.fallback;
+        var _nextPrimaryChildren3 = nextProps.children;
 
-        var _primaryChildFragment2 = createWorkInProgress(
-          currentPrimaryChildFragment,
-          currentPrimaryChildFragment.pendingProps
+        var _fallbackChildFragment = updateSuspenseFallbackChildren(
+          current,
+          workInProgress,
+          _nextPrimaryChildren3,
+          _nextFallbackChildren2,
+          renderLanes
         );
 
-        _primaryChildFragment2.return = workInProgress;
-
-        if ((workInProgress.mode & BlockingMode) === NoMode) {
-          // Outside of blocking mode, we commit the effects from the
-          // partially completed, timed-out tree, too.
-          var _progressedState = workInProgress.memoizedState;
-
-          var _progressedPrimaryChild =
-            _progressedState !== null
-              ? workInProgress.child.child
-              : workInProgress.child;
-
-          if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
-            _primaryChildFragment2.child = _progressedPrimaryChild;
-            var _progressedChild2 = _progressedPrimaryChild;
-
-            while (_progressedChild2 !== null) {
-              _progressedChild2.return = _primaryChildFragment2;
-              _progressedChild2 = _progressedChild2.sibling;
-            }
-          }
-        } // Because primaryChildFragment is a new fiber that we're inserting as the
-        // parent of a new tree, we need to set its treeBaseDuration.
-
-        if (workInProgress.mode & ProfileMode) {
-          // treeBaseDuration is the sum of all the child tree base durations.
-          var _treeBaseDuration = 0;
-          var _hiddenChild = _primaryChildFragment2.child;
+        var _primaryChildFragment2 = workInProgress.child;
+        var prevOffscreenState = current.child.memoizedState;
+        _primaryChildFragment2.memoizedState =
+          prevOffscreenState === null
+            ? mountSuspenseOffscreenState(renderLanes)
+            : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
+        _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(
+          current,
+          renderLanes
+        );
+        workInProgress.memoizedState = SUSPENDED_MARKER;
+        return _fallbackChildFragment;
+      } else {
+        var _nextPrimaryChildren4 = nextProps.children;
 
-          while (_hiddenChild !== null) {
-            _treeBaseDuration += _hiddenChild.treeBaseDuration;
-            _hiddenChild = _hiddenChild.sibling;
-          }
+        var _primaryChildFragment3 = updateSuspensePrimaryChildren(
+          current,
+          workInProgress,
+          _nextPrimaryChildren4,
+          renderLanes
+        );
 
-          _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
-        } // Clone the fallback child fragment, too. These we'll continue
-        // working on.
+        workInProgress.memoizedState = null;
+        return _primaryChildFragment3;
+      }
+    } else {
+      // The current tree is not already showing a fallback.
+      if (showFallback) {
+        // Timed out.
+        var _nextFallbackChildren3 = nextProps.fallback;
+        var _nextPrimaryChildren5 = nextProps.children;
 
-        var _fallbackChildFragment2 = createWorkInProgress(
-          currentFallbackChildFragment,
-          _nextFallbackChildren2
+        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(
+          current,
+          workInProgress,
+          _nextPrimaryChildren5,
+          _nextFallbackChildren3,
+          renderLanes
         );
 
-        _fallbackChildFragment2.return = workInProgress;
-        _primaryChildFragment2.sibling = _fallbackChildFragment2;
-        _primaryChildFragment2.childExpirationTime = NoWork; // Skip the primary children, and continue working on the
+        var _primaryChildFragment4 = workInProgress.child;
+        var _prevOffscreenState = current.child.memoizedState;
+        _primaryChildFragment4.memoizedState =
+          _prevOffscreenState === null
+            ? mountSuspenseOffscreenState(renderLanes)
+            : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);
+        _primaryChildFragment4.childLanes = getRemainingWorkInPrimaryTree(
+          current,
+          renderLanes
+        ); // Skip the primary children, and continue working on the
         // fallback children.
 
         workInProgress.memoizedState = SUSPENDED_MARKER;
-        workInProgress.child = _primaryChildFragment2;
         return _fallbackChildFragment2;
       } else {
-        // No longer suspended. Switch back to showing the primary children,
-        // and remove the intermediate fragment fiber.
-        var _nextPrimaryChildren = nextProps.children;
-        var currentPrimaryChild = currentPrimaryChildFragment.child;
-        var primaryChild = reconcileChildFibers(
+        // Still haven't timed out. Continue rendering the children, like we
+        // normally do.
+        var _nextPrimaryChildren6 = nextProps.children;
+
+        var _primaryChildFragment5 = updateSuspensePrimaryChildren(
+          current,
           workInProgress,
-          currentPrimaryChild,
-          _nextPrimaryChildren,
-          renderExpirationTime
-        ); // If this render doesn't suspend, we need to delete the fallback
-        // children. Wait until the complete phase, after we've confirmed the
-        // fallback is no longer needed.
-        // TODO: Would it be better to store the fallback fragment on
-        // the stateNode?
-        // Continue rendering the children, like we normally do.
+          _nextPrimaryChildren6,
+          renderLanes
+        );
 
         workInProgress.memoizedState = null;
-        return (workInProgress.child = primaryChild);
+        return _primaryChildFragment5;
       }
-    } else {
-      // The current tree has not already timed out. That means the primary
-      // children are not wrapped in a fragment fiber.
-      var _currentPrimaryChild = current.child;
+    }
+  }
+}
 
-      if (nextDidTimeout) {
-        // Timed out. Wrap the children in a fragment fiber to keep them
-        // separate from the fallback children.
-        var _nextFallbackChildren3 = nextProps.fallback;
+function mountSuspensePrimaryChildren(
+  workInProgress,
+  primaryChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  var primaryChildProps = {
+    mode: "visible",
+    children: primaryChildren
+  };
+  var primaryChildFragment = createFiberFromOffscreen(
+    primaryChildProps,
+    mode,
+    renderLanes,
+    null
+  );
+  primaryChildFragment.return = workInProgress;
+  workInProgress.child = primaryChildFragment;
+  return primaryChildFragment;
+}
 
-        var _primaryChildFragment3 = createFiberFromFragment(
-          // It shouldn't matter what the pending props are because we aren't
-          // going to render this fragment.
-          null,
-          mode,
-          NoWork,
-          null
-        );
+function mountSuspenseFallbackChildren(
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  var progressedPrimaryFragment = workInProgress.child;
+  var primaryChildProps = {
+    mode: "hidden",
+    children: primaryChildren
+  };
+  var primaryChildFragment;
+  var fallbackChildFragment;
+
+  if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
+    // In legacy mode, we commit the primary tree as if it successfully
+    // completed, even though it's in an inconsistent state.
+    primaryChildFragment = progressedPrimaryFragment;
+    primaryChildFragment.childLanes = NoLanes;
+    primaryChildFragment.pendingProps = primaryChildProps;
+
+    if (workInProgress.mode & ProfileMode) {
+      // Reset the durations from the first pass so they aren't included in the
+      // final amounts. This seems counterintuitive, since we're intentionally
+      // not measuring part of the render phase, but this makes it match what we
+      // do in Concurrent Mode.
+      primaryChildFragment.actualDuration = 0;
+      primaryChildFragment.actualStartTime = -1;
+      primaryChildFragment.selfBaseDuration = 0;
+      primaryChildFragment.treeBaseDuration = 0;
+    }
+
+    fallbackChildFragment = createFiberFromFragment(
+      fallbackChildren,
+      mode,
+      renderLanes,
+      null
+    );
+  } else {
+    primaryChildFragment = createFiberFromOffscreen(
+      primaryChildProps,
+      mode,
+      NoLanes,
+      null
+    );
+    fallbackChildFragment = createFiberFromFragment(
+      fallbackChildren,
+      mode,
+      renderLanes,
+      null
+    );
+  }
 
-        _primaryChildFragment3.return = workInProgress;
-        _primaryChildFragment3.child = _currentPrimaryChild;
+  primaryChildFragment.return = workInProgress;
+  fallbackChildFragment.return = workInProgress;
+  primaryChildFragment.sibling = fallbackChildFragment;
+  workInProgress.child = primaryChildFragment;
+  return fallbackChildFragment;
+}
 
-        if (_currentPrimaryChild !== null) {
-          _currentPrimaryChild.return = _primaryChildFragment3;
-        } // Even though we're creating a new fiber, there are no new children,
-        // because we're reusing an already mounted tree. So we don't need to
-        // schedule a placement.
-        // primaryChildFragment.effectTag |= Placement;
+function createWorkInProgressOffscreenFiber(current, offscreenProps) {
+  // The props argument to `createWorkInProgress` is `any` typed, so we use this
+  // wrapper function to constrain it.
+  return createWorkInProgress(current, offscreenProps);
+}
 
-        if ((workInProgress.mode & BlockingMode) === NoMode) {
-          // Outside of blocking mode, we commit the effects from the
-          // partially completed, timed-out tree, too.
-          var _progressedState2 = workInProgress.memoizedState;
+function updateSuspensePrimaryChildren(
+  current,
+  workInProgress,
+  primaryChildren,
+  renderLanes
+) {
+  var currentPrimaryChildFragment = current.child;
+  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
+  var primaryChildFragment = createWorkInProgressOffscreenFiber(
+    currentPrimaryChildFragment,
+    {
+      mode: "visible",
+      children: primaryChildren
+    }
+  );
 
-          var _progressedPrimaryChild2 =
-            _progressedState2 !== null
-              ? workInProgress.child.child
-              : workInProgress.child;
+  if ((workInProgress.mode & BlockingMode) === NoMode) {
+    primaryChildFragment.lanes = renderLanes;
+  }
 
-          _primaryChildFragment3.child = _progressedPrimaryChild2;
-          var _progressedChild3 = _progressedPrimaryChild2;
+  primaryChildFragment.return = workInProgress;
+  primaryChildFragment.sibling = null;
 
-          while (_progressedChild3 !== null) {
-            _progressedChild3.return = _primaryChildFragment3;
-            _progressedChild3 = _progressedChild3.sibling;
-          }
-        } // Because primaryChildFragment is a new fiber that we're inserting as the
-        // parent of a new tree, we need to set its treeBaseDuration.
+  if (currentFallbackChildFragment !== null) {
+    // Delete the fallback child fragment
+    currentFallbackChildFragment.nextEffect = null;
+    currentFallbackChildFragment.effectTag = Deletion;
+    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;
+  }
 
-        if (workInProgress.mode & ProfileMode) {
-          // treeBaseDuration is the sum of all the child tree base durations.
-          var _treeBaseDuration2 = 0;
-          var _hiddenChild2 = _primaryChildFragment3.child;
+  workInProgress.child = primaryChildFragment;
+  return primaryChildFragment;
+}
 
-          while (_hiddenChild2 !== null) {
-            _treeBaseDuration2 += _hiddenChild2.treeBaseDuration;
-            _hiddenChild2 = _hiddenChild2.sibling;
-          }
+function updateSuspenseFallbackChildren(
+  current,
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  var currentPrimaryChildFragment = current.child;
+  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
+  var primaryChildProps = {
+    mode: "hidden",
+    children: primaryChildren
+  };
+  var primaryChildFragment;
 
-          _primaryChildFragment3.treeBaseDuration = _treeBaseDuration2;
-        } // Create a fragment from the fallback children, too.
+  if (
+    // In legacy mode, we commit the primary tree as if it successfully
+    // completed, even though it's in an inconsistent state.
+    (mode & BlockingMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
+    // already cloned. In legacy mode, the only case where this isn't true is
+    // when DevTools forces us to display a fallback; we skip the first render
+    // pass entirely and go straight to rendering the fallback. (In Concurrent
+    // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
+    // only codepath.)
+    workInProgress.child !== currentPrimaryChildFragment
+  ) {
+    var progressedPrimaryFragment = workInProgress.child;
+    primaryChildFragment = progressedPrimaryFragment;
+    primaryChildFragment.childLanes = NoLanes;
+    primaryChildFragment.pendingProps = primaryChildProps;
+
+    if (workInProgress.mode & ProfileMode) {
+      // Reset the durations from the first pass so they aren't included in the
+      // final amounts. This seems counterintuitive, since we're intentionally
+      // not measuring part of the render phase, but this makes it match what we
+      // do in Concurrent Mode.
+      primaryChildFragment.actualDuration = 0;
+      primaryChildFragment.actualStartTime = -1;
+      primaryChildFragment.selfBaseDuration =
+        currentPrimaryChildFragment.selfBaseDuration;
+      primaryChildFragment.treeBaseDuration =
+        currentPrimaryChildFragment.treeBaseDuration;
+    } // The fallback fiber was added as a deletion effect during the first pass.
+    // However, since we're going to remain on the fallback, we no longer want
+    // to delete it. So we need to remove it from the list. Deletions are stored
+    // on the same list as effects. We want to keep the effects from the primary
+    // tree. So we copy the primary child fragment's effect list, which does not
+    // include the fallback deletion effect.
+
+    var progressedLastEffect = primaryChildFragment.lastEffect;
+
+    if (progressedLastEffect !== null) {
+      workInProgress.firstEffect = primaryChildFragment.firstEffect;
+      workInProgress.lastEffect = progressedLastEffect;
+      progressedLastEffect.nextEffect = null;
+    } else {
+      // TODO: Reset this somewhere else? Lol legacy mode is so weird.
+      workInProgress.firstEffect = workInProgress.lastEffect = null;
+    }
+  } else {
+    primaryChildFragment = createWorkInProgressOffscreenFiber(
+      currentPrimaryChildFragment,
+      primaryChildProps
+    );
+  }
 
-        var _fallbackChildFragment3 = createFiberFromFragment(
-          _nextFallbackChildren3,
-          mode,
-          renderExpirationTime,
-          null
-        );
+  var fallbackChildFragment;
 
-        _fallbackChildFragment3.return = workInProgress;
-        _primaryChildFragment3.sibling = _fallbackChildFragment3;
-        _fallbackChildFragment3.effectTag |= Placement;
-        _primaryChildFragment3.childExpirationTime = NoWork; // Skip the primary children, and continue working on the
-        // fallback children.
+  if (currentFallbackChildFragment !== null) {
+    fallbackChildFragment = createWorkInProgress(
+      currentFallbackChildFragment,
+      fallbackChildren
+    );
+  } else {
+    fallbackChildFragment = createFiberFromFragment(
+      fallbackChildren,
+      mode,
+      renderLanes,
+      null
+    ); // Needs a placement effect because the parent (the Suspense boundary) already
+    // mounted but this is a new fiber.
 
-        workInProgress.memoizedState = SUSPENDED_MARKER;
-        workInProgress.child = _primaryChildFragment3;
-        return _fallbackChildFragment3;
-      } else {
-        // Still haven't timed out. Continue rendering the children, like we
-        // normally do.
-        workInProgress.memoizedState = null;
-        var _nextPrimaryChildren2 = nextProps.children;
-        return (workInProgress.child = reconcileChildFibers(
-          workInProgress,
-          _currentPrimaryChild,
-          _nextPrimaryChildren2,
-          renderExpirationTime
-        ));
-      }
-    }
+    fallbackChildFragment.effectTag |= Placement;
   }
-}
 
-function scheduleWorkOnFiber(fiber, renderExpirationTime) {
-  if (fiber.expirationTime < renderExpirationTime) {
-    fiber.expirationTime = renderExpirationTime;
-  }
+  fallbackChildFragment.return = workInProgress;
+  primaryChildFragment.return = workInProgress;
+  primaryChildFragment.sibling = fallbackChildFragment;
+  workInProgress.child = primaryChildFragment;
+  return fallbackChildFragment;
+}
 
+function scheduleWorkOnFiber(fiber, renderLanes) {
+  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
   var alternate = fiber.alternate;
 
-  if (alternate !== null && alternate.expirationTime < renderExpirationTime) {
-    alternate.expirationTime = renderExpirationTime;
+  if (alternate !== null) {
+    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
   }
 
-  scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
+  scheduleWorkOnParentPath(fiber.return, renderLanes);
 }
 
 function propagateSuspenseContextChange(
   workInProgress,
   firstChild,
-  renderExpirationTime
+  renderLanes
 ) {
   // Mark any Suspense boundaries with fallbacks as having work to do.
   // If they were previously forced into fallbacks, they may now be able
@@ -13392,7 +14138,7 @@ function propagateSuspenseContextChange(
       var state = node.memoizedState;
 
       if (state !== null) {
-        scheduleWorkOnFiber(node, renderExpirationTime);
+        scheduleWorkOnFiber(node, renderLanes);
       }
     } else if (node.tag === SuspenseListComponent) {
       // If the tail is hidden there might not be an Suspense boundaries
@@ -13400,7 +14146,7 @@ function propagateSuspenseContextChange(
       // list itself.
       // We don't have to traverse to the children of the list since
       // the list will propagate the change when it rerenders.
-      scheduleWorkOnFiber(node, renderExpirationTime);
+      scheduleWorkOnFiber(node, renderLanes);
     } else if (node.child !== null) {
       node.child.return = node;
       node = node.child;
@@ -13642,11 +14388,7 @@ function initSuspenseListRenderState(
 // in fallback state. Then we render each row in the tail one-by-one.
 // That happens in the completeWork phase without going back to beginWork.
 
-function updateSuspenseListComponent(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
+function updateSuspenseListComponent(current, workInProgress, renderLanes) {
   var nextProps = workInProgress.pendingProps;
   var revealOrder = nextProps.revealOrder;
   var tailMode = nextProps.tail;
@@ -13654,7 +14396,7 @@ function updateSuspenseListComponent(
   validateRevealOrder(revealOrder);
   validateTailOptions(tailMode, revealOrder);
   validateSuspenseListChildren(newChildren, revealOrder);
-  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
+  reconcileChildren(current, workInProgress, newChildren, renderLanes);
   var suspenseContext = suspenseStackCursor.current;
   var shouldForceFallback = hasSuspenseContext(
     suspenseContext,
@@ -13678,7 +14420,7 @@ function updateSuspenseListComponent(
       propagateSuspenseContextChange(
         workInProgress,
         workInProgress.child,
-        renderExpirationTime
+        renderLanes
       );
     }
 
@@ -13688,7 +14430,7 @@ function updateSuspenseListComponent(
   pushSuspenseContext(workInProgress, suspenseContext);
 
   if ((workInProgress.mode & BlockingMode) === NoMode) {
-    // Outside of blocking mode, SuspenseList doesn't work so we just
+    // In legacy mode, SuspenseList doesn't work so we just
     // use make it a noop by treating it as the default revealOrder.
     workInProgress.memoizedState = null;
   } else {
@@ -13778,7 +14520,7 @@ function updateSuspenseListComponent(
   return workInProgress.child;
 }
 
-function updatePortalComponent(current, workInProgress, renderExpirationTime) {
+function updatePortalComponent(current, workInProgress, renderLanes) {
   pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
   var nextChildren = workInProgress.pendingProps;
 
@@ -13792,21 +14534,18 @@ function updatePortalComponent(current, workInProgress, renderExpirationTime) {
       workInProgress,
       null,
       nextChildren,
-      renderExpirationTime
+      renderLanes
     );
   } else {
-    reconcileChildren(
-      current,
-      workInProgress,
-      nextChildren,
-      renderExpirationTime
-    );
+    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   }
 
   return workInProgress.child;
 }
 
-function updateContextProvider(current, workInProgress, renderExpirationTime) {
+var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
+
+function updateContextProvider(current, workInProgress, renderLanes) {
   var providerType = workInProgress.type;
   var context = providerType._context;
   var newProps = workInProgress.pendingProps;
@@ -13814,6 +14553,16 @@ function updateContextProvider(current, workInProgress, renderExpirationTime) {
   var newValue = newProps.value;
 
   {
+    if (!("value" in newProps)) {
+      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
+        hasWarnedAboutUsingNoValuePropOnContextProvider = true;
+
+        error(
+          "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
+        );
+      }
+    }
+
     var providerPropTypes = workInProgress.type.propTypes;
 
     if (providerPropTypes) {
@@ -13833,29 +14582,24 @@ function updateContextProvider(current, workInProgress, renderExpirationTime) {
         return bailoutOnAlreadyFinishedWork(
           current,
           workInProgress,
-          renderExpirationTime
+          renderLanes
         );
       }
     } else {
       // The context value changed. Search for matching consumers and schedule
       // them to update.
-      propagateContextChange(
-        workInProgress,
-        context,
-        changedBits,
-        renderExpirationTime
-      );
+      propagateContextChange(workInProgress, context, changedBits, renderLanes);
     }
   }
 
   var newChildren = newProps.children;
-  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
+  reconcileChildren(current, workInProgress, newChildren, renderLanes);
   return workInProgress.child;
 }
 
 var hasWarnedAboutUsingContextAsConsumer = false;
 
-function updateContextConsumer(current, workInProgress, renderExpirationTime) {
+function updateContextConsumer(current, workInProgress, renderLanes) {
   var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
   // DEV mode, we create a separate object for Context.Consumer that acts
   // like a proxy to Context. This proxy object adds unnecessary code in PROD
@@ -13898,7 +14642,7 @@ function updateContextConsumer(current, workInProgress, renderExpirationTime) {
     }
   }
 
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   var newValue = readContext(context, newProps.unstable_observedBits);
   var newChildren;
 
@@ -13910,7 +14654,7 @@ function updateContextConsumer(current, workInProgress, renderExpirationTime) {
   } // React DevTools reads this flag.
 
   workInProgress.effectTag |= PerformedWork;
-  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
+  reconcileChildren(current, workInProgress, newChildren, renderLanes);
   return workInProgress.child;
 }
 
@@ -13918,13 +14662,7 @@ function markWorkInProgressReceivedUpdate() {
   didReceiveUpdate = true;
 }
 
-function bailoutOnAlreadyFinishedWork(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
-  cancelWorkTimer(workInProgress);
-
+function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
   if (current !== null) {
     // Reuse previous dependencies
     workInProgress.dependencies = current.dependencies;
@@ -13935,15 +14673,9 @@ function bailoutOnAlreadyFinishedWork(
     stopProfilerTimerIfRunning();
   }
 
-  var updateExpirationTime = workInProgress.expirationTime;
+  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.
 
-  if (updateExpirationTime !== NoWork) {
-    markUnprocessedUpdateTime(updateExpirationTime);
-  } // Check if the children have any pending work.
-
-  var childExpirationTime = workInProgress.childExpirationTime;
-
-  if (childExpirationTime < renderExpirationTime) {
+  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
     // The children don't have any work either. We can skip them.
     // TODO: Once we add back resuming, we should check if the children are
     // a work-in-progress set. If so, we need to transfer their effects.
@@ -14011,8 +14743,8 @@ function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
   }
 }
 
-function beginWork(current, workInProgress, renderExpirationTime) {
-  var updateExpirationTime = workInProgress.expirationTime;
+function beginWork(current, workInProgress, renderLanes) {
+  var updateLanes = workInProgress.lanes;
 
   {
     if (workInProgress._debugNeedsRemount && current !== null) {
@@ -14026,7 +14758,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
           workInProgress.pendingProps,
           workInProgress._debugOwner || null,
           workInProgress.mode,
-          workInProgress.expirationTime
+          workInProgress.lanes
         )
       );
     }
@@ -14044,7 +14776,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
       // If props or context changed, mark the fiber as having performed work.
       // This may be unset if the props are determined to be equal later (memo).
       didReceiveUpdate = true;
-    } else if (updateExpirationTime < renderExpirationTime) {
+    } else if (!includesSomeLane(renderLanes, updateLanes)) {
       didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
       // the begin phase. There's still some bookkeeping we that needs to be done
       // in this optimized path, mostly pushing stuff onto the stack.
@@ -14056,20 +14788,6 @@ function beginWork(current, workInProgress, renderExpirationTime) {
 
         case HostComponent:
           pushHostContext(workInProgress);
-
-          if (
-            workInProgress.mode & ConcurrentMode &&
-            renderExpirationTime !== Never &&
-            shouldDeprioritizeSubtree(workInProgress.type)
-          ) {
-            {
-              markSpawnedWork(Never);
-            } // Schedule this fiber to re-render at offscreen priority. Then bailout.
-
-            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
-            return null;
-          }
-
           break;
 
         case ClassComponent: {
@@ -14098,8 +14816,10 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         case Profiler:
           {
             // Profiler should only call onRender when one of its descendants actually rendered.
-            var hasChildWork =
-              workInProgress.childExpirationTime >= renderExpirationTime;
+            var hasChildWork = includesSomeLane(
+              renderLanes,
+              workInProgress.childLanes
+            );
 
             if (hasChildWork) {
               workInProgress.effectTag |= Update;
@@ -14122,21 +14842,19 @@ function beginWork(current, workInProgress, renderExpirationTime) {
             // child fragment.
 
             var primaryChildFragment = workInProgress.child;
-            var primaryChildExpirationTime =
-              primaryChildFragment.childExpirationTime;
+            var primaryChildLanes = primaryChildFragment.childLanes;
 
-            if (
-              primaryChildExpirationTime !== NoWork &&
-              primaryChildExpirationTime >= renderExpirationTime
-            ) {
+            if (includesSomeLane(renderLanes, primaryChildLanes)) {
               // The primary children have pending work. Use the normal path
               // to attempt to render the primary children again.
               return updateSuspenseComponent(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
             } else {
+              // The primary child fragment does not have pending work marked
+              // on it
               pushSuspenseContext(
                 workInProgress,
                 setDefaultShallowSuspenseContext(suspenseStackCursor.current)
@@ -14146,7 +14864,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
               var child = bailoutOnAlreadyFinishedWork(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
 
               if (child !== null) {
@@ -14170,8 +14888,10 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         case SuspenseListComponent: {
           var didSuspendBefore = (current.effectTag & DidCapture) !== NoEffect;
 
-          var _hasChildWork =
-            workInProgress.childExpirationTime >= renderExpirationTime;
+          var _hasChildWork = includesSomeLane(
+            renderLanes,
+            workInProgress.childLanes
+          );
 
           if (didSuspendBefore) {
             if (_hasChildWork) {
@@ -14183,7 +14903,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
               return updateSuspenseListComponent(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
             } // If none of the children had any work, that means that none of
             // them got retried so they'll still be blocked in the same way
@@ -14201,6 +14921,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
             // update in the past but didn't complete it.
             renderState.rendering = null;
             renderState.tail = null;
+            renderState.lastEffect = null;
           }
 
           pushSuspenseContext(workInProgress, suspenseStackCursor.current);
@@ -14214,19 +14935,35 @@ function beginWork(current, workInProgress, renderExpirationTime) {
             return null;
           }
         }
+
+        case OffscreenComponent:
+        case LegacyHiddenComponent: {
+          // Need to check if the tree still needs to be deferred. This is
+          // almost identical to the logic used in the normal update path,
+          // so we'll just enter that. The only difference is we'll bail out
+          // at the next level instead of this one, because the child props
+          // have not changed. Which is fine.
+          // TODO: Probably should refactor `beginWork` to split the bailout
+          // path from the normal path. I'm tempted to do a labeled break here
+          // but I won't :)
+          workInProgress.lanes = NoLanes;
+          return updateOffscreenComponent(current, workInProgress, renderLanes);
+        }
       }
 
-      return bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
     } else {
-      // An update was scheduled on this fiber, but there are no new props
-      // nor legacy context. Set this to false. If an update queue or context
-      // consumer produces a changed value, it will set this to true. Otherwise,
-      // the component will assume the children have not changed and bail out.
-      didReceiveUpdate = false;
+      if ((current.effectTag & ForceUpdateForLegacySuspense) !== NoEffect) {
+        // This is a special case that only exists for legacy mode.
+        // See https://github.com/facebook/react/pull/19216.
+        didReceiveUpdate = true;
+      } else {
+        // An update was scheduled on this fiber, but there are no new props
+        // nor legacy context. Set this to false. If an update queue or context
+        // consumer produces a changed value, it will set this to true. Otherwise,
+        // the component will assume the children have not changed and bail out.
+        didReceiveUpdate = false;
+      }
     }
   } else {
     didReceiveUpdate = false;
@@ -14236,7 +14973,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
   // sometimes bails out later in the begin phase. This indicates that we should
   // move this assignment out of the common path and into each branch.
 
-  workInProgress.expirationTime = NoWork;
+  workInProgress.lanes = NoLanes;
 
   switch (workInProgress.tag) {
     case IndeterminateComponent: {
@@ -14244,7 +14981,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         current,
         workInProgress,
         workInProgress.type,
-        renderExpirationTime
+        renderLanes
       );
     }
 
@@ -14254,8 +14991,8 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         current,
         workInProgress,
         elementType,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     }
 
@@ -14271,7 +15008,7 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         _Component,
         resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
     }
 
@@ -14289,32 +15026,24 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         _Component2,
         _resolvedProps,
-        renderExpirationTime
+        renderLanes
       );
     }
 
     case HostRoot:
-      return updateHostRoot(current, workInProgress, renderExpirationTime);
+      return updateHostRoot(current, workInProgress, renderLanes);
 
     case HostComponent:
-      return updateHostComponent(current, workInProgress, renderExpirationTime);
+      return updateHostComponent(current, workInProgress, renderLanes);
 
     case HostText:
       return updateHostText();
 
     case SuspenseComponent:
-      return updateSuspenseComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
 
     case HostPortal:
-      return updatePortalComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updatePortalComponent(current, workInProgress, renderLanes);
 
     case ForwardRef: {
       var type = workInProgress.type;
@@ -14330,32 +15059,24 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         type,
         _resolvedProps2,
-        renderExpirationTime
+        renderLanes
       );
     }
 
     case Fragment:
-      return updateFragment(current, workInProgress, renderExpirationTime);
+      return updateFragment(current, workInProgress, renderLanes);
 
     case Mode:
-      return updateMode(current, workInProgress, renderExpirationTime);
+      return updateMode(current, workInProgress, renderLanes);
 
     case Profiler:
-      return updateProfiler(current, workInProgress, renderExpirationTime);
+      return updateProfiler(current, workInProgress, renderLanes);
 
     case ContextProvider:
-      return updateContextProvider(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateContextProvider(current, workInProgress, renderLanes);
 
     case ContextConsumer:
-      return updateContextConsumer(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateContextConsumer(current, workInProgress, renderLanes);
 
     case MemoComponent: {
       var _type2 = workInProgress.type;
@@ -14384,8 +15105,8 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         _type2,
         _resolvedProps3,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     }
 
@@ -14395,8 +15116,8 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         workInProgress.type,
         workInProgress.pendingProps,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     }
 
@@ -14414,16 +15135,32 @@ function beginWork(current, workInProgress, renderExpirationTime) {
         workInProgress,
         _Component3,
         _resolvedProps4,
-        renderExpirationTime
+        renderLanes
       );
     }
 
-    case SuspenseListComponent: {
-      return updateSuspenseListComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+    case SuspenseListComponent: {
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+    }
+
+    case FundamentalComponent: {
+      break;
+    }
+
+    case ScopeComponent: {
+      break;
+    }
+
+    case Block: {
+      break;
+    }
+
+    case OffscreenComponent: {
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
+    }
+
+    case LegacyHiddenComponent: {
+      return updateLegacyHiddenComponent(current, workInProgress, renderLanes);
     }
   }
 
@@ -14607,7 +15344,7 @@ function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
   }
 }
 
-function completeWork(current, workInProgress, renderExpirationTime) {
+function completeWork(current, workInProgress, renderLanes) {
   var newProps = workInProgress.pendingProps;
 
   switch (workInProgress.tag) {
@@ -14636,6 +15373,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelContextObject(workInProgress);
+      resetWorkInProgressVersions();
       var fiberRoot = workInProgress.stateNode;
 
       if (fiberRoot.pendingContext) {
@@ -14652,6 +15390,12 @@ function completeWork(current, workInProgress, renderExpirationTime) {
           // If we hydrated, then we'll need to schedule an update for
           // the commit side-effects on the root.
           markUpdate(workInProgress);
+        } else if (!fiberRoot.hydrate) {
+          // Schedule an effect to clear this container at the start of the next commit.
+          // This handles the case of React rendering into a container with previous children.
+          // It's also safe to do for updates too, because current.child would only be null
+          // if the previous render was null (so the the container would already be empty).
+          workInProgress.effectTag |= Snapshot;
         }
       }
 
@@ -14710,9 +15454,8 @@ function completeWork(current, workInProgress, renderExpirationTime) {
             currentHostContext,
             workInProgress
           );
-          appendAllChildren(instance, workInProgress, false, false); // This needs to be set before we mount Flare event listeners
-
-          workInProgress.stateNode = instance;
+          appendAllChildren(instance, workInProgress, false, false);
+          workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
           // (eg DOM renderer supports auto-focus for certain elements).
           // Make sure such renderers get scheduled for later work.
 
@@ -14776,7 +15519,11 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
       if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
         // Something suspended. Re-render with the fallback children.
-        workInProgress.expirationTime = renderExpirationTime; // Do not reset the effect list.
+        workInProgress.lanes = renderLanes; // Do not reset the effect list.
+
+        if ((workInProgress.mode & ProfileMode) !== NoMode) {
+          transferActualDuration(workInProgress);
+        }
 
         return workInProgress;
       }
@@ -14789,29 +15536,6 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       } else {
         var prevState = current.memoizedState;
         prevDidTimeout = prevState !== null;
-
-        if (!nextDidTimeout && prevState !== null) {
-          // We just switched from the fallback to the normal children.
-          // Delete the fallback.
-          // TODO: Would it be better to store the fallback fragment on
-          // the stateNode during the begin phase?
-          var currentFallbackChild = current.child.sibling;
-
-          if (currentFallbackChild !== null) {
-            // Deletions go at the beginning of the return fiber's effect list
-            var first = workInProgress.firstEffect;
-
-            if (first !== null) {
-              workInProgress.firstEffect = currentFallbackChild;
-              currentFallbackChild.nextEffect = first;
-            } else {
-              workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
-              currentFallbackChild.nextEffect = null;
-            }
-
-            currentFallbackChild.effectTag = Deletion;
-          }
-        }
       }
 
       if (nextDidTimeout && !prevDidTimeout) {
@@ -14868,6 +15592,11 @@ function completeWork(current, workInProgress, renderExpirationTime) {
     case HostPortal:
       popHostContainer(workInProgress);
       updateHostContainer(workInProgress);
+
+      if (current === null) {
+        preparePortalMount(workInProgress.stateNode.containerInfo);
+      }
+
       return null;
 
     case ContextProvider:
@@ -14954,7 +15683,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
                 workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.
 
-                resetChildFibers(workInProgress, renderExpirationTime); // Set up the Suspense Context to force suspense and immediately
+                resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately
                 // rerender the children.
 
                 pushSuspenseContext(
@@ -14995,7 +15724,8 @@ function completeWork(current, workInProgress, renderExpirationTime) {
             if (
               renderState.tail === null &&
               renderState.tailMode === "hidden" &&
-              !renderedTail.alternate
+              !renderedTail.alternate &&
+              !getIsHydrating() // We don't cut it if we're hydrating.
             ) {
               // We need to delete the row we just rendered.
               // Reset the effect list to what it was before we rendered this
@@ -15014,7 +15744,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
             // the expiration.
             now() * 2 - renderState.renderingStartTime >
               renderState.tailExpiration &&
-            renderExpirationTime > Never
+            renderLanes !== OffscreenLane
           ) {
             // We have now passed our CPU deadline and we'll just give up further
             // attempts to render the main content and only render fallbacks.
@@ -15027,11 +15757,10 @@ function completeWork(current, workInProgress, renderExpirationTime) {
             // So we'll pick it back up the very next render pass once we've had
             // an opportunity to yield for paint.
 
-            var nextPriority = renderExpirationTime - 1;
-            workInProgress.expirationTime = workInProgress.childExpirationTime = nextPriority;
+            workInProgress.lanes = renderLanes;
 
             {
-              markSpawnedWork(nextPriority);
+              markSpawnedWork(renderLanes);
             }
           }
         }
@@ -15098,6 +15827,38 @@ function completeWork(current, workInProgress, renderExpirationTime) {
 
       return null;
     }
+
+    case FundamentalComponent: {
+      break;
+    }
+
+    case ScopeComponent: {
+      break;
+    }
+
+    case Block:
+      break;
+
+    case OffscreenComponent:
+    case LegacyHiddenComponent: {
+      popRenderLanes(workInProgress);
+
+      if (current !== null) {
+        var _nextState = workInProgress.memoizedState;
+        var _prevState = current.memoizedState;
+        var prevIsHidden = _prevState !== null;
+        var nextIsHidden = _nextState !== null;
+
+        if (
+          prevIsHidden !== nextIsHidden &&
+          newProps.mode !== "unstable-defer-without-hiding"
+        ) {
+          workInProgress.effectTag |= Update;
+        }
+      }
+
+      return null;
+    }
   }
 
   {
@@ -15109,7 +15870,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
   }
 }
 
-function unwindWork(workInProgress, renderExpirationTime) {
+function unwindWork(workInProgress, renderLanes) {
   switch (workInProgress.tag) {
     case ClassComponent: {
       var Component = workInProgress.type;
@@ -15122,6 +15883,11 @@ function unwindWork(workInProgress, renderExpirationTime) {
 
       if (effectTag & ShouldCapture) {
         workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+
+        if ((workInProgress.mode & ProfileMode) !== NoMode) {
+          transferActualDuration(workInProgress);
+        }
+
         return workInProgress;
       }
 
@@ -15131,6 +15897,7 @@ function unwindWork(workInProgress, renderExpirationTime) {
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelContextObject(workInProgress);
+      resetWorkInProgressVersions();
       var _effectTag = workInProgress.effectTag;
 
       if (!((_effectTag & DidCapture) === NoEffect)) {
@@ -15157,6 +15924,10 @@ function unwindWork(workInProgress, renderExpirationTime) {
       if (_effectTag2 & ShouldCapture) {
         workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture; // Captured a suspense effect. Re-render the boundary.
 
+        if ((workInProgress.mode & ProfileMode) !== NoMode) {
+          transferActualDuration(workInProgress);
+        }
+
         return workInProgress;
       }
 
@@ -15167,219 +15938,529 @@ function unwindWork(workInProgress, renderExpirationTime) {
       popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
       // caught by a nested boundary. If not, it should bubble through.
 
-      return null;
+      return null;
+    }
+
+    case HostPortal:
+      popHostContainer(workInProgress);
+      return null;
+
+    case ContextProvider:
+      popProvider(workInProgress);
+      return null;
+
+    case OffscreenComponent:
+    case LegacyHiddenComponent:
+      popRenderLanes(workInProgress);
+      return null;
+
+    default:
+      return null;
+  }
+}
+
+function unwindInterruptedWork(interruptedWork) {
+  switch (interruptedWork.tag) {
+    case ClassComponent: {
+      var childContextTypes = interruptedWork.type.childContextTypes;
+
+      if (childContextTypes !== null && childContextTypes !== undefined) {
+        popContext(interruptedWork);
+      }
+
+      break;
+    }
+
+    case HostRoot: {
+      popHostContainer(interruptedWork);
+      popTopLevelContextObject(interruptedWork);
+      resetWorkInProgressVersions();
+      break;
+    }
+
+    case HostComponent: {
+      popHostContext(interruptedWork);
+      break;
+    }
+
+    case HostPortal:
+      popHostContainer(interruptedWork);
+      break;
+
+    case SuspenseComponent:
+      popSuspenseContext(interruptedWork);
+      break;
+
+    case SuspenseListComponent:
+      popSuspenseContext(interruptedWork);
+      break;
+
+    case ContextProvider:
+      popProvider(interruptedWork);
+      break;
+
+    case OffscreenComponent:
+    case LegacyHiddenComponent:
+      popRenderLanes(interruptedWork);
+      break;
+  }
+}
+
+function createCapturedValue(value, source) {
+  // If the value is an error, call this function immediately after it is thrown
+  // so the stack is accurate.
+  return {
+    value: value,
+    source: source,
+    stack: getStackByFiberInDevAndProd(source)
+  };
+}
+
+if (
+  !(
+    typeof ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog ===
+    "function"
+  )
+) {
+  throw Error(
+    "Expected ReactFiberErrorDialog.showErrorDialog to be a function."
+  );
+}
+
+function showErrorDialog(boundary, errorInfo) {
+  var capturedError = {
+    componentStack: errorInfo.stack !== null ? errorInfo.stack : "",
+    error: errorInfo.value,
+    errorBoundary:
+      boundary !== null && boundary.tag === ClassComponent
+        ? boundary.stateNode
+        : null
+  };
+  return ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog(
+    capturedError
+  );
+}
+
+function logCapturedError(boundary, errorInfo) {
+  try {
+    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
+    // This enables renderers like ReactNative to better manage redbox behavior.
+
+    if (logError === false) {
+      return;
+    }
+
+    var error = errorInfo.value;
+
+    if (true) {
+      var source = errorInfo.source;
+      var stack = errorInfo.stack;
+      var componentStack = stack !== null ? stack : ""; // Browsers support silencing uncaught errors by calling
+      // `preventDefault()` in window `error` handler.
+      // We record this information as an expando on the error.
+
+      if (error != null && error._suppressLogging) {
+        if (boundary.tag === ClassComponent) {
+          // The error is recoverable and was silenced.
+          // Ignore it and don't print the stack addendum.
+          // This is handy for testing error boundaries without noise.
+          return;
+        } // The error is fatal. Since the silencing might have
+        // been accidental, we'll surface it anyway.
+        // However, the browser would have silenced the original error
+        // so we'll print it first, and then print the stack addendum.
+
+        console["error"](error); // Don't transform to our wrapper
+        // For a more detailed description of this block, see:
+        // https://github.com/facebook/react/pull/13384
+      }
+
+      var componentName = source ? getComponentName(source.type) : null;
+      var componentNameMessage = componentName
+        ? "The above error occurred in the <" + componentName + "> component:"
+        : "The above error occurred in one of your React components:";
+      var errorBoundaryMessage;
+      var errorBoundaryName = getComponentName(boundary.type);
+
+      if (errorBoundaryName) {
+        errorBoundaryMessage =
+          "React will try to recreate this component tree from scratch " +
+          ("using the error boundary you provided, " + errorBoundaryName + ".");
+      } else {
+        errorBoundaryMessage =
+          "Consider adding an error boundary to your tree to customize error handling behavior.\n" +
+          "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
+      }
+
+      var combinedMessage =
+        componentNameMessage +
+        "\n" +
+        componentStack +
+        "\n\n" +
+        ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
+      // We don't include the original error message and JS stack because the browser
+      // has already printed it. Even if the application swallows the error, it is still
+      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
+
+      console["error"](combinedMessage); // Don't transform to our wrapper
+    } else {
+      // In production, we print the error directly.
+      // This will include the message, the JS stack, and anything the browser wants to show.
+      // We pass the error object instead of custom message so that the browser displays the error natively.
+      console["error"](error); // Don't transform to our wrapper
+    }
+  } catch (e) {
+    // This method must not throw, or React internal state will get messed up.
+    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
+    // we want to report this error outside of the normal stack as a last resort.
+    // https://github.com/facebook/react/issues/13188
+    setTimeout(function() {
+      throw e;
+    });
+  }
+}
+
+var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
+
+function createRootErrorUpdate(fiber, errorInfo, lane) {
+  var update = createUpdate(NoTimestamp, lane, null); // Unmount the root by rendering null.
+
+  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
+  // being called "element".
+
+  update.payload = {
+    element: null
+  };
+  var error = errorInfo.value;
+
+  update.callback = function() {
+    onUncaughtError(error);
+    logCapturedError(fiber, errorInfo);
+  };
+
+  return update;
+}
+
+function createClassErrorUpdate(fiber, errorInfo, lane) {
+  var update = createUpdate(NoTimestamp, lane, null);
+  update.tag = CaptureUpdate;
+  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+
+  if (typeof getDerivedStateFromError === "function") {
+    var error$1 = errorInfo.value;
+
+    update.payload = function() {
+      logCapturedError(fiber, errorInfo);
+      return getDerivedStateFromError(error$1);
+    };
+  }
+
+  var inst = fiber.stateNode;
+
+  if (inst !== null && typeof inst.componentDidCatch === "function") {
+    update.callback = function callback() {
+      {
+        markFailedErrorBoundaryForHotReloading(fiber);
+      }
+
+      if (typeof getDerivedStateFromError !== "function") {
+        // To preserve the preexisting retry behavior of error boundaries,
+        // we keep track of which ones already failed during this batch.
+        // This gets reset before we yield back to the browser.
+        // TODO: Warn in strict mode if getDerivedStateFromError is
+        // not defined.
+        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined
+
+        logCapturedError(fiber, errorInfo);
+      }
+
+      var error$1 = errorInfo.value;
+      var stack = errorInfo.stack;
+      this.componentDidCatch(error$1, {
+        componentStack: stack !== null ? stack : ""
+      });
+
+      {
+        if (typeof getDerivedStateFromError !== "function") {
+          // If componentDidCatch is the only error boundary method defined,
+          // then it needs to call setState to recover from errors.
+          // If no state update is scheduled then the boundary will swallow the error.
+          if (!includesSomeLane(fiber.lanes, SyncLane)) {
+            error(
+              "%s: Error boundaries should implement getDerivedStateFromError(). " +
+                "In that method, return a state update to display an error message or fallback UI.",
+              getComponentName(fiber.type) || "Unknown"
+            );
+          }
+        }
+      }
+    };
+  } else {
+    update.callback = function() {
+      markFailedErrorBoundaryForHotReloading(fiber);
+    };
+  }
+
+  return update;
+}
+
+function attachPingListener(root, wakeable, lanes) {
+  // Attach a listener to the promise to "ping" the root and retry. But only if
+  // one does not already exist for the lanes we're currently rendering (which
+  // acts like a "thread ID" here).
+  var pingCache = root.pingCache;
+  var threadIDs;
+
+  if (pingCache === null) {
+    pingCache = root.pingCache = new PossiblyWeakMap$1();
+    threadIDs = new Set();
+    pingCache.set(wakeable, threadIDs);
+  } else {
+    threadIDs = pingCache.get(wakeable);
+
+    if (threadIDs === undefined) {
+      threadIDs = new Set();
+      pingCache.set(wakeable, threadIDs);
     }
+  }
 
-    case HostPortal:
-      popHostContainer(workInProgress);
-      return null;
-
-    case ContextProvider:
-      popProvider(workInProgress);
-      return null;
-
-    default:
-      return null;
+  if (!threadIDs.has(lanes)) {
+    // Memoize using the thread ID to prevent redundant listeners.
+    threadIDs.add(lanes);
+    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
+    wakeable.then(ping, ping);
   }
 }
 
-function unwindInterruptedWork(interruptedWork) {
-  switch (interruptedWork.tag) {
-    case ClassComponent: {
-      var childContextTypes = interruptedWork.type.childContextTypes;
+function throwException(
+  root,
+  returnFiber,
+  sourceFiber,
+  value,
+  rootRenderLanes
+) {
+  // The source fiber did not complete.
+  sourceFiber.effectTag |= Incomplete; // Its effect list is no longer valid.
 
-      if (childContextTypes !== null && childContextTypes !== undefined) {
-        popContext(interruptedWork);
-      }
+  sourceFiber.firstEffect = sourceFiber.lastEffect = null;
 
-      break;
-    }
+  if (
+    value !== null &&
+    typeof value === "object" &&
+    typeof value.then === "function"
+  ) {
+    // This is a wakeable.
+    var wakeable = value;
 
-    case HostRoot: {
-      popHostContainer(interruptedWork);
-      popTopLevelContextObject(interruptedWork);
-      break;
-    }
+    if ((sourceFiber.mode & BlockingMode) === NoMode) {
+      // Reset the memoizedState to what it was before we attempted
+      // to render it.
+      var currentSource = sourceFiber.alternate;
 
-    case HostComponent: {
-      popHostContext(interruptedWork);
-      break;
+      if (currentSource) {
+        sourceFiber.updateQueue = currentSource.updateQueue;
+        sourceFiber.memoizedState = currentSource.memoizedState;
+        sourceFiber.lanes = currentSource.lanes;
+      } else {
+        sourceFiber.updateQueue = null;
+        sourceFiber.memoizedState = null;
+      }
     }
 
-    case HostPortal:
-      popHostContainer(interruptedWork);
-      break;
-
-    case SuspenseComponent:
-      popSuspenseContext(interruptedWork);
-      break;
+    var hasInvisibleParentBoundary = hasSuspenseContext(
+      suspenseStackCursor.current,
+      InvisibleParentSuspenseContext
+    ); // Schedule the nearest Suspense to re-render the timed out view.
 
-    case SuspenseListComponent:
-      popSuspenseContext(interruptedWork);
-      break;
+    var _workInProgress = returnFiber;
 
-    case ContextProvider:
-      popProvider(interruptedWork);
-      break;
-  }
-}
+    do {
+      if (
+        _workInProgress.tag === SuspenseComponent &&
+        shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)
+      ) {
+        // Found the nearest boundary.
+        // Stash the promise on the boundary fiber. If the boundary times out, we'll
+        // attach another listener to flip the boundary back to its normal state.
+        var wakeables = _workInProgress.updateQueue;
 
-function createCapturedValue(value, source) {
-  // If the value is an error, call this function immediately after it is thrown
-  // so the stack is accurate.
-  return {
-    value: value,
-    source: source,
-    stack: getStackByFiberInDevAndProd(source)
-  };
-}
+        if (wakeables === null) {
+          var updateQueue = new Set();
+          updateQueue.add(wakeable);
+          _workInProgress.updateQueue = updateQueue;
+        } else {
+          wakeables.add(wakeable);
+        } // If the boundary is outside of blocking mode, we should *not*
+        // suspend the commit. Pretend as if the suspended component rendered
+        // null and keep rendering. In the commit phase, we'll schedule a
+        // subsequent synchronous update to re-render the Suspense.
+        //
+        // Note: It doesn't matter whether the component that suspended was
+        // inside a blocking mode tree. If the Suspense is outside of it, we
+        // should *not* suspend the commit.
 
-// Module provided by RN:
+        if ((_workInProgress.mode & BlockingMode) === NoMode) {
+          _workInProgress.effectTag |= DidCapture;
+          sourceFiber.effectTag |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
+          // But we shouldn't call any lifecycle methods or callbacks. Remove
+          // all lifecycle effect tags.
 
-if (
-  !(
-    typeof ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog ===
-    "function"
-  )
-) {
-  throw Error(
-    "Expected ReactFiberErrorDialog.showErrorDialog to be a function."
-  );
-}
+          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
 
-function showErrorDialog(capturedError) {
-  return ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog(
-    capturedError
-  );
-}
+          if (sourceFiber.tag === ClassComponent) {
+            var currentSourceFiber = sourceFiber.alternate;
 
-function logCapturedError(capturedError) {
-  var logError = showErrorDialog(capturedError); // Allow injected showErrorDialog() to prevent default console.error logging.
-  // This enables renderers like ReactNative to better manage redbox behavior.
+            if (currentSourceFiber === null) {
+              // This is a new mount. Change the tag so it's not mistaken for a
+              // completed class component. For example, we should not call
+              // componentWillUnmount if it is deleted.
+              sourceFiber.tag = IncompleteClassComponent;
+            } else {
+              // When we try rendering again, we should not reuse the current fiber,
+              // since it's known to be in an inconsistent state. Use a force update to
+              // prevent a bail out.
+              var update = createUpdate(NoTimestamp, SyncLane, null);
+              update.tag = ForceUpdate;
+              enqueueUpdate(sourceFiber, update);
+            }
+          } // The source fiber did not complete. Mark it with Sync priority to
+          // indicate that it still has pending work.
 
-  if (logError === false) {
-    return;
-  }
+          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.
 
-  var error = capturedError.error;
+          return;
+        } // Confirmed that the boundary is in a concurrent mode tree. Continue
+        // with the normal suspend path.
+        //
+        // After this we'll use a set of heuristics to determine whether this
+        // render pass will run to completion or restart or "suspend" the commit.
+        // The actual logic for this is spread out in different places.
+        //
+        // This first principle is that if we're going to suspend when we complete
+        // a root, then we should also restart if we get an update or ping that
+        // might unsuspend it, and vice versa. The only reason to suspend is
+        // because you think you might want to restart before committing. However,
+        // it doesn't make sense to restart only while in the period we're suspended.
+        //
+        // Restarting too aggressively is also not good because it starves out any
+        // intermediate loading state. So we use heuristics to determine when.
+        // Suspense Heuristics
+        //
+        // If nothing threw a Promise or all the same fallbacks are already showing,
+        // then don't suspend/restart.
+        //
+        // If this is an initial render of a new tree of Suspense boundaries and
+        // those trigger a fallback, then don't suspend/restart. We want to ensure
+        // that we can show the initial loading state as quickly as possible.
+        //
+        // If we hit a "Delayed" case, such as when we'd switch from content back into
+        // a fallback, then we should always suspend/restart. SuspenseConfig applies to
+        // this case. If none is defined, JND is used instead.
+        //
+        // If we're already showing a fallback and it gets "retried", allowing us to show
+        // another level, but there's still an inner boundary that would show a fallback,
+        // then we suspend/restart for 500ms since the last time we showed a fallback
+        // anywhere in the tree. This effectively throttles progressive loading into a
+        // consistent train of commits. This also gives us an opportunity to restart to
+        // get to the completed state slightly earlier.
+        //
+        // If there's ambiguity due to batching it's resolved in preference of:
+        // 1) "delayed", 2) "initial render", 3) "retry".
+        //
+        // We want to ensure that a "busy" state doesn't get force committed. We want to
+        // ensure that new initial loading states can commit as soon as possible.
 
-  {
-    var componentName = capturedError.componentName,
-      componentStack = capturedError.componentStack,
-      errorBoundaryName = capturedError.errorBoundaryName,
-      errorBoundaryFound = capturedError.errorBoundaryFound,
-      willRetry = capturedError.willRetry; // Browsers support silencing uncaught errors by calling
-    // `preventDefault()` in window `error` handler.
-    // We record this information as an expando on the error.
-
-    if (error != null && error._suppressLogging) {
-      if (errorBoundaryFound && willRetry) {
-        // The error is recoverable and was silenced.
-        // Ignore it and don't print the stack addendum.
-        // This is handy for testing error boundaries without noise.
+        attachPingListener(root, wakeable, rootRenderLanes);
+        _workInProgress.effectTag |= ShouldCapture;
+        _workInProgress.lanes = rootRenderLanes;
         return;
-      } // The error is fatal. Since the silencing might have
-      // been accidental, we'll surface it anyway.
-      // However, the browser would have silenced the original error
-      // so we'll print it first, and then print the stack addendum.
+      } // This boundary already captured during this render. Continue to the next
+      // boundary.
 
-      console["error"](error); // Don't transform to our wrapper
-      // For a more detailed description of this block, see:
-      // https://github.com/facebook/react/pull/13384
-    }
+      _workInProgress = _workInProgress.return;
+    } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.
+    // TODO: Use invariant so the message is stripped in prod?
 
-    var componentNameMessage = componentName
-      ? "The above error occurred in the <" + componentName + "> component:"
-      : "The above error occurred in one of your React components:";
-    var errorBoundaryMessage; // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
+    value = new Error(
+      (getComponentName(sourceFiber.type) || "A React component") +
+        " suspended while rendering, but no fallback UI was specified.\n" +
+        "\n" +
+        "Add a <Suspense fallback=...> component higher in the tree to " +
+        "provide a loading indicator or placeholder to display."
+    );
+  } // We didn't find a boundary that could handle this type of exception. Start
+  // over and traverse parent path again, this time treating the exception
+  // as an error.
 
-    if (errorBoundaryFound && errorBoundaryName) {
-      if (willRetry) {
-        errorBoundaryMessage =
-          "React will try to recreate this component tree from scratch " +
-          ("using the error boundary you provided, " + errorBoundaryName + ".");
-      } else {
-        errorBoundaryMessage =
-          "This error was initially handled by the error boundary " +
-          errorBoundaryName +
-          ".\n" +
-          "Recreating the tree from scratch failed so React will unmount the tree.";
+  renderDidError();
+  value = createCapturedValue(value, sourceFiber);
+  var workInProgress = returnFiber;
+
+  do {
+    switch (workInProgress.tag) {
+      case HostRoot: {
+        var _errorInfo = value;
+        workInProgress.effectTag |= ShouldCapture;
+        var lane = pickArbitraryLane(rootRenderLanes);
+        workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);
+
+        var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);
+
+        enqueueCapturedUpdate(workInProgress, _update);
+        return;
       }
-    } else {
-      errorBoundaryMessage =
-        "Consider adding an error boundary to your tree to customize error handling behavior.\n" +
-        "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
-    }
 
-    var combinedMessage =
-      "" +
-      componentNameMessage +
-      componentStack +
-      "\n\n" +
-      ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
-    // We don't include the original error message and JS stack because the browser
-    // has already printed it. Even if the application swallows the error, it is still
-    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
+      case ClassComponent:
+        // Capture and retry
+        var errorInfo = value;
+        var ctor = workInProgress.type;
+        var instance = workInProgress.stateNode;
+
+        if (
+          (workInProgress.effectTag & DidCapture) === NoEffect &&
+          (typeof ctor.getDerivedStateFromError === "function" ||
+            (instance !== null &&
+              typeof instance.componentDidCatch === "function" &&
+              !isAlreadyFailedLegacyErrorBoundary(instance)))
+        ) {
+          workInProgress.effectTag |= ShouldCapture;
 
-    console["error"](combinedMessage); // Don't transform to our wrapper
-  }
-}
+          var _lane = pickArbitraryLane(rootRenderLanes);
 
-var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
+          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state
 
-{
-  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
-}
+          var _update2 = createClassErrorUpdate(
+            workInProgress,
+            errorInfo,
+            _lane
+          );
 
-var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
-function logError(boundary, errorInfo) {
-  var source = errorInfo.source;
-  var stack = errorInfo.stack;
+          enqueueCapturedUpdate(workInProgress, _update2);
+          return;
+        }
 
-  if (stack === null && source !== null) {
-    stack = getStackByFiberInDevAndProd(source);
-  }
+        break;
+    }
 
-  var capturedError = {
-    componentName: source !== null ? getComponentName(source.type) : null,
-    componentStack: stack !== null ? stack : "",
-    error: errorInfo.value,
-    errorBoundary: null,
-    errorBoundaryName: null,
-    errorBoundaryFound: false,
-    willRetry: false
-  };
+    workInProgress = workInProgress.return;
+  } while (workInProgress !== null);
+}
 
-  if (boundary !== null && boundary.tag === ClassComponent) {
-    capturedError.errorBoundary = boundary.stateNode;
-    capturedError.errorBoundaryName = getComponentName(boundary.type);
-    capturedError.errorBoundaryFound = true;
-    capturedError.willRetry = true;
-  }
+var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
 
-  try {
-    logCapturedError(capturedError);
-  } catch (e) {
-    // This method must not throw, or React internal state will get messed up.
-    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
-    // we want to report this error outside of the normal stack as a last resort.
-    // https://github.com/facebook/react/issues/13188
-    setTimeout(function() {
-      throw e;
-    });
-  }
+{
+  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
 }
 
+var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
+
 var callComponentWillUnmountWithTimer = function(current, instance) {
-  startPhaseTimer(current, "componentWillUnmount");
   instance.props = current.memoizedProps;
   instance.state = current.memoizedState;
 
   {
     instance.componentWillUnmount();
   }
-
-  stopPhaseTimer();
 }; // Capture errors so they don't interrupt unmounting.
 
 function safelyCallComponentWillUnmount(current, instance) {
@@ -15443,7 +16524,6 @@ function commitBeforeMutationLifeCycles(current, finishedWork) {
         if (current !== null) {
           var prevProps = current.memoizedProps;
           var prevState = current.memoizedState;
-          startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
           var instance = finishedWork.stateNode; // We could update instance props and state here,
           // but instead we rely on them being set during last render.
           // TODO: revisit this when we implement resuming.
@@ -15499,14 +16579,23 @@ function commitBeforeMutationLifeCycles(current, finishedWork) {
           }
 
           instance.__reactInternalSnapshotBeforeUpdate = snapshot;
-          stopPhaseTimer();
         }
       }
 
       return;
     }
 
-    case HostRoot:
+    case HostRoot: {
+      {
+        if (finishedWork.effectTag & Snapshot) {
+          var root = finishedWork.stateNode;
+          clearContainer(root.containerInfo);
+        }
+      }
+
+      return;
+    }
+
     case HostComponent:
     case HostText:
     case HostPortal:
@@ -15590,9 +16679,8 @@ function commitHookEffectListMount(tag, finishedWork) {
 
             error(
               "An effect function must not return anything besides a function, " +
-                "which is used for clean-up.%s%s",
-              addendum,
-              getStackByFiberInDevAndProd(finishedWork)
+                "which is used for clean-up.%s",
+              addendum
             );
           }
         }
@@ -15603,33 +16691,33 @@ function commitHookEffectListMount(tag, finishedWork) {
   }
 }
 
-function commitPassiveHookEffects(finishedWork) {
-  if ((finishedWork.effectTag & Passive) !== NoEffect) {
-    switch (finishedWork.tag) {
-      case FunctionComponent:
-      case ForwardRef:
-      case SimpleMemoComponent:
-      case Block: {
-        // TODO (#17945) We should call all passive destroy functions (for all fibers)
-        // before calling any create functions. The current approach only serializes
-        // these for a single fiber.
-        {
-          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork);
-          commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
-        }
+function schedulePassiveEffects(finishedWork) {
+  var updateQueue = finishedWork.updateQueue;
+  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
 
-        break;
+  if (lastEffect !== null) {
+    var firstEffect = lastEffect.next;
+    var effect = firstEffect;
+
+    do {
+      var _effect = effect,
+        next = _effect.next,
+        tag = _effect.tag;
+
+      if (
+        (tag & Passive$1) !== NoEffect$1 &&
+        (tag & HasEffect) !== NoEffect$1
+      ) {
+        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
+        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
       }
-    }
+
+      effect = next;
+    } while (effect !== firstEffect);
   }
 }
 
-function commitLifeCycles(
-  finishedRoot,
-  current,
-  finishedWork,
-  committedExpirationTime
-) {
+function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
   switch (finishedWork.tag) {
     case FunctionComponent:
     case ForwardRef:
@@ -15643,6 +16731,7 @@ function commitLifeCycles(
         commitHookEffectListMount(Layout | HasEffect, finishedWork);
       }
 
+      schedulePassiveEffects(finishedWork);
       return;
     }
 
@@ -15651,10 +16740,9 @@ function commitLifeCycles(
 
       if (finishedWork.effectTag & Update) {
         if (current === null) {
-          startPhaseTimer(finishedWork, "componentDidMount"); // We could update instance props and state here,
+          // We could update instance props and state here,
           // but instead we rely on them being set during last render.
           // TODO: revisit this when we implement resuming.
-
           {
             if (
               finishedWork.type === finishedWork.elementType &&
@@ -15687,15 +16775,12 @@ function commitLifeCycles(
           {
             instance.componentDidMount();
           }
-
-          stopPhaseTimer();
         } else {
           var prevProps =
             finishedWork.elementType === finishedWork.type
               ? current.memoizedProps
               : resolveDefaultProps(finishedWork.type, current.memoizedProps);
-          var prevState = current.memoizedState;
-          startPhaseTimer(finishedWork, "componentDidUpdate"); // We could update instance props and state here,
+          var prevState = current.memoizedState; // We could update instance props and state here,
           // but instead we rely on them being set during last render.
           // TODO: revisit this when we implement resuming.
 
@@ -15735,10 +16820,9 @@ function commitLifeCycles(
               instance.__reactInternalSnapshotBeforeUpdate
             );
           }
-
-          stopPhaseTimer();
         }
-      }
+      } // TODO: I think this is now always non-null by the time it reaches the
+      // commit phase. Consider removing the type check.
 
       var updateQueue = finishedWork.updateQueue;
 
@@ -15781,6 +16865,8 @@ function commitLifeCycles(
     }
 
     case HostRoot: {
+      // TODO: I think this is now always non-null by the time it reaches the
+      // commit phase. Consider removing the type check.
       var _updateQueue = finishedWork.updateQueue;
 
       if (_updateQueue !== null) {
@@ -15862,6 +16948,8 @@ function commitLifeCycles(
     case IncompleteClassComponent:
     case FundamentalComponent:
     case ScopeComponent:
+    case OffscreenComponent:
+    case LegacyHiddenComponent:
       return;
   }
 
@@ -15896,17 +16984,12 @@ function hideOrUnhideAllChildren(finishedWork, isHidden) {
           unhideTextInstance(_instance3, node.memoizedProps);
         }
       } else if (
-        node.tag === SuspenseComponent &&
+        (node.tag === OffscreenComponent ||
+          node.tag === LegacyHiddenComponent) &&
         node.memoizedState !== null &&
-        node.memoizedState.dehydrated === null
-      ) {
-        // Found a nested Suspense component that timed out. Skip over the
-        // primary child fragment, which should remain hidden.
-        var fallbackChildFragment = node.child.sibling;
-        fallbackChildFragment.return = node;
-        node = fallbackChildFragment;
-        continue;
-      } else if (node.child !== null) {
+        node !== finishedWork
+      );
+      else if (node.child !== null) {
         node.child.return = node;
         node = node.child;
         continue;
@@ -15953,9 +17036,8 @@ function commitAttachRef(finishedWork) {
         if (!ref.hasOwnProperty("current")) {
           error(
             "Unexpected ref object provided for %s. " +
-              "Use either a ref-setter function or React.createRef().%s",
-            getComponentName(finishedWork.type),
-            getStackByFiberInDevAndProd(finishedWork)
+              "Use either a ref-setter function or React.createRef().",
+            getComponentName(finishedWork.type)
           );
         }
       }
@@ -15995,42 +17077,25 @@ function commitUnmount(finishedRoot, current, renderPriorityLevel) {
 
         if (lastEffect !== null) {
           var firstEffect = lastEffect.next;
+          var effect = firstEffect;
 
-          {
-            // When the owner fiber is deleted, the destroy function of a passive
-            // effect hook is called during the synchronous commit phase. This is
-            // a concession to implementation complexity. Calling it in the
-            // passive effect phase (like they usually are, when dependencies
-            // change during an update) would require either traversing the
-            // children of the deleted fiber again, or including unmount effects
-            // as part of the fiber effect list.
-            //
-            // Because this is during the sync commit phase, we need to change
-            // the priority.
-            //
-            // TODO: Reconsider this implementation trade off.
-            var priorityLevel =
-              renderPriorityLevel > NormalPriority
-                ? NormalPriority
-                : renderPriorityLevel;
-            runWithPriority(priorityLevel, function() {
-              var effect = firstEffect;
-
-              do {
-                var _effect3 = effect,
-                  _destroy = _effect3.destroy,
-                  _tag = _effect3.tag;
-
-                if (_destroy !== undefined) {
-                  {
-                    safelyCallDestroy(current, _destroy);
-                  }
+          do {
+            var _effect2 = effect,
+              destroy = _effect2.destroy,
+              tag = _effect2.tag;
+
+            if (destroy !== undefined) {
+              if ((tag & Passive$1) !== NoEffect$1) {
+                enqueuePendingPassiveHookEffectUnmount(current, effect);
+              } else {
+                {
+                  safelyCallDestroy(current, destroy);
                 }
+              }
+            }
 
-                effect = effect.next;
-              } while (effect !== firstEffect);
-            });
-          }
+            effect = effect.next;
+          } while (effect !== firstEffect);
         }
       }
 
@@ -16058,7 +17123,7 @@ function commitUnmount(finishedRoot, current, renderPriorityLevel) {
       // We are also not using this parent because
       // the portal will get pushed immediately.
       {
-        unmountHostComponents(finishedRoot, current, renderPriorityLevel);
+        unmountHostComponents(finishedRoot, current);
       }
 
       return;
@@ -16087,7 +17152,7 @@ function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
   var node = root;
 
   while (true) {
-    commitUnmount(finishedRoot, node, renderPriorityLevel); // Visit children because they may contain more composite or host nodes.
+    commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.
     // Skip portals because commitUnmount() currently visits them recursively.
 
     if (
@@ -16117,27 +17182,33 @@ function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
   }
 }
 
-function detachFiber(current) {
-  var alternate = current.alternate; // Cut off the return pointers to disconnect it from the tree. Ideally, we
+function detachFiberMutation(fiber) {
+  // Cut off the return pointers to disconnect it from the tree. Ideally, we
   // should clear the child pointer of the parent alternate to let this
   // get GC:ed but we don't know which for sure which parent is the current
   // one so we'll settle for GC:ing the subtree of this child. This child
   // itself will be GC:ed when the parent updates the next time.
+  // Note: we cannot null out sibling here, otherwise it can cause issues
+  // with findDOMNode and how it requires the sibling field to carry out
+  // traversal in a later effect. See PR #16820. We now clear the sibling
+  // field after effects, see: detachFiberAfterEffects.
+  //
+  // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
+  // It may be required if the current component is an error boundary,
+  // and one of its descendants throws while unmounting a passive effect.
+  fiber.alternate = null;
+  fiber.child = null;
+  fiber.dependencies = null;
+  fiber.firstEffect = null;
+  fiber.lastEffect = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.return = null;
+  fiber.updateQueue = null;
 
-  current.return = null;
-  current.child = null;
-  current.memoizedState = null;
-  current.updateQueue = null;
-  current.dependencies = null;
-  current.alternate = null;
-  current.firstEffect = null;
-  current.lastEffect = null;
-  current.pendingProps = null;
-  current.memoizedProps = null;
-  current.stateNode = null;
-
-  if (alternate !== null) {
-    detachFiber(alternate);
+  {
+    fiber._debugOwner = null;
   }
 }
 
@@ -16369,7 +17440,7 @@ function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
     }
 
     if (node.tag === HostComponent || node.tag === HostText) {
-      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel); // After all the children have unmounted, it is now safe to remove the
+      commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the
       // node from the tree.
 
       if (currentParentIsContainer) {
@@ -16389,7 +17460,7 @@ function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
         continue;
       }
     } else {
-      commitUnmount(finishedRoot, node, renderPriorityLevel); // Visit children because we may find more host components below.
+      commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.
 
       if (node.child !== null) {
         node.child.return = node;
@@ -16425,10 +17496,15 @@ function commitDeletion(finishedRoot, current, renderPriorityLevel) {
   {
     // Recursively delete all host nodes from the parent.
     // Detach refs and call componentWillUnmount() on the whole subtree.
-    unmountHostComponents(finishedRoot, current, renderPriorityLevel);
+    unmountHostComponents(finishedRoot, current);
   }
 
-  detachFiber(current);
+  var alternate = current.alternate;
+  detachFiberMutation(current);
+
+  if (alternate !== null) {
+    detachFiberMutation(alternate);
+  }
 }
 
 function commitWork(current, finishedWork) {
@@ -16516,6 +17592,22 @@ function commitWork(current, finishedWork) {
     case IncompleteClassComponent: {
       return;
     }
+
+    case FundamentalComponent: {
+      break;
+    }
+
+    case ScopeComponent: {
+      break;
+    }
+
+    case OffscreenComponent:
+    case LegacyHiddenComponent: {
+      var newState = finishedWork.memoizedState;
+      var isHidden = newState !== null;
+      hideOrUnhideAllChildren(finishedWork, isHidden);
+      return;
+    }
   }
 
   {
@@ -16527,29 +17619,33 @@ function commitWork(current, finishedWork) {
 
 function commitSuspenseComponent(finishedWork) {
   var newState = finishedWork.memoizedState;
-  var newDidTimeout;
-  var primaryChildParent = finishedWork;
 
-  if (newState === null) {
-    newDidTimeout = false;
-  } else {
-    newDidTimeout = true;
-    primaryChildParent = finishedWork.child;
+  if (newState !== null) {
     markCommitTimeOfFallback();
-  }
 
-  if (primaryChildParent !== null) {
-    hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
+    {
+      // Hide the Offscreen component that contains the primary children. TODO:
+      // Ideally, this effect would have been scheduled on the Offscreen fiber
+      // itself. That's how unhiding works: the Offscreen component schedules an
+      // effect on itself. However, in this case, the component didn't complete,
+      // so the fiber was never added to the effect list in the normal path. We
+      // could have appended it to the effect list in the Suspense component's
+      // second pass, but doing it this way is less complicated. This would be
+      // simpler if we got rid of the effect list and traversed the tree, like
+      // we're planning to do.
+      var primaryChildParent = finishedWork.child;
+      hideOrUnhideAllChildren(primaryChildParent, true);
+    }
   }
 }
 
 function attachSuspenseRetryListeners(finishedWork) {
-  // If this boundary just timed out, then it will have a set of thenables.
-  // For each thenable, attach a listener so that when it resolves, React
+  // If this boundary just timed out, then it will have a set of wakeables.
+  // For each wakeable, attach a listener so that when it resolves, React
   // attempts to re-render the boundary in the primary (pre-timeout) state.
-  var thenables = finishedWork.updateQueue;
+  var wakeables = finishedWork.updateQueue;
 
-  if (thenables !== null) {
+  if (wakeables !== null) {
     finishedWork.updateQueue = null;
     var retryCache = finishedWork.stateNode;
 
@@ -16557,3069 +17653,3325 @@ function attachSuspenseRetryListeners(finishedWork) {
       retryCache = finishedWork.stateNode = new PossiblyWeakSet();
     }
 
-    thenables.forEach(function(thenable) {
+    wakeables.forEach(function(wakeable) {
       // Memoize using the boundary fiber to prevent redundant listeners.
-      var retry = resolveRetryThenable.bind(null, finishedWork, thenable);
+      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
 
-      if (!retryCache.has(thenable)) {
+      if (!retryCache.has(wakeable)) {
         {
-          if (thenable.__reactDoNotTraceInteractions !== true) {
+          if (wakeable.__reactDoNotTraceInteractions !== true) {
             retry = tracing.unstable_wrap(retry);
           }
         }
 
-        retryCache.add(thenable);
-        thenable.then(retry, retry);
+        retryCache.add(wakeable);
+        wakeable.then(retry, retry);
       }
     });
   }
+} // This function detects when a Suspense boundary goes from visible to hidden.
+// It returns false if the boundary is already hidden.
+// TODO: Use an effect tag.
+
+function isSuspenseBoundaryBeingHidden(current, finishedWork) {
+  if (current !== null) {
+    var oldState = current.memoizedState;
+
+    if (oldState === null || oldState.dehydrated !== null) {
+      var newState = finishedWork.memoizedState;
+      return newState !== null && newState.dehydrated === null;
+    }
+  }
+
+  return false;
 }
 
 function commitResetTextContent(current) {
   resetTextContent(current.stateNode);
 }
 
-var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
+var COMPONENT_TYPE = 0;
+var HAS_PSEUDO_CLASS_TYPE = 1;
+var ROLE_TYPE = 2;
+var TEST_NAME_TYPE = 3;
+var TEXT_TYPE = 4;
 
-function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
-  var update = createUpdate(expirationTime, null); // Unmount the root by rendering null.
+if (typeof Symbol === "function" && Symbol.for) {
+  var symbolFor$1 = Symbol.for;
+  COMPONENT_TYPE = symbolFor$1("selector.component");
+  HAS_PSEUDO_CLASS_TYPE = symbolFor$1("selector.has_pseudo_class");
+  ROLE_TYPE = symbolFor$1("selector.role");
+  TEST_NAME_TYPE = symbolFor$1("selector.test_id");
+  TEXT_TYPE = symbolFor$1("selector.text");
+}
 
-  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
-  // being called "element".
+var ceil = Math.ceil;
+var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
+  ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
+  IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
+var NoContext =
+  /*             */
+  0;
+var BatchedContext =
+  /*               */
+  1;
+var DiscreteEventContext =
+  /*         */
+  4;
+var LegacyUnbatchedContext =
+  /*       */
+  8;
+var RenderContext =
+  /*                */
+  16;
+var CommitContext =
+  /*                */
+  32;
+var RetryAfterError =
+  /*       */
+  64;
+var RootIncomplete = 0;
+var RootFatalErrored = 1;
+var RootErrored = 2;
+var RootSuspended = 3;
+var RootSuspendedWithDelay = 4;
+var RootCompleted = 5; // Describes where we are in the React execution stack
 
-  update.payload = {
-    element: null
-  };
-  var error = errorInfo.value;
+var executionContext = NoContext; // The root we're working on
 
-  update.callback = function() {
-    onUncaughtError(error);
-    logError(fiber, errorInfo);
-  };
+var workInProgressRoot = null; // The fiber we're working on
 
-  return update;
+var workInProgress = null; // The lanes we're rendering
+
+var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
+// This is a superset of the lanes we started working on at the root. The only
+// case where it's different from `workInProgressRootRenderLanes` is when we
+// enter a subtree that is hidden and needs to be unhidden: Suspense and
+// Offscreen component.
+//
+// Most things in the work loop should deal with workInProgressRootRenderLanes.
+// Most things in begin/complete phases should deal with subtreeRenderLanes.
+
+var subtreeRenderLanes = NoLanes;
+var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.
+
+var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown
+
+var workInProgressRootFatalError = null;
+var workInProgressRootLatestSuspenseTimeout = NoTimestamp;
+var workInProgressRootCanSuspendUsingConfig = null; // "Included" lanes refer to lanes that were worked on during this render. It's
+// slightly different than `renderLanes` because `renderLanes` can change as you
+// enter and exit an Offscreen tree. This value is the combination of all render
+// lanes for the entire render phase.
+
+var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only
+// includes unprocessed updates, not work in bailed out children.
+
+var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.
+
+var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.
+
+var workInProgressRootPingedLanes = NoLanes;
+var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train
+// model where we don't commit new loading states in too quick succession.
+
+var globalMostRecentFallbackTime = 0;
+var FALLBACK_THROTTLE_MS = 500;
+var DEFAULT_TIMEOUT_MS = 5000;
+var nextEffect = null;
+var hasUncaughtError = false;
+var firstUncaughtError = null;
+var legacyErrorBoundariesThatAlreadyFailed = null;
+var rootDoesHavePassiveEffects = false;
+var rootWithPendingPassiveEffects = null;
+var pendingPassiveEffectsRenderPriority = NoPriority$1;
+var pendingPassiveEffectsLanes = NoLanes;
+var pendingPassiveHookEffectsMount = [];
+var pendingPassiveHookEffectsUnmount = [];
+var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates
+
+var NESTED_UPDATE_LIMIT = 50;
+var nestedUpdateCount = 0;
+var rootWithNestedUpdates = null;
+var NESTED_PASSIVE_UPDATE_LIMIT = 50;
+var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes
+// during the commit phase. This enables them to be traced across components
+// that spawn new work during render. E.g. hidden boundaries, suspended SSR
+// hydration or SuspenseList.
+// TODO: Can use a bitmask instead of an array
+
+var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their
+// event times as simultaneous, even if the actual clock time has advanced
+// between the first and second call.
+
+var currentEventTime = NoTimestamp;
+var currentEventWipLanes = NoLanes;
+var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.
+// We warn about state updates for unmounted components differently in this case.
+
+var isFlushingPassiveEffects = false;
+var focusedInstanceHandle = null;
+var shouldFireAfterActiveInstanceBlur = false;
+function getWorkInProgressRoot() {
+  return workInProgressRoot;
+}
+function requestEventTime() {
+  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
+    // We're inside React, so it's fine to read the actual time.
+    return now();
+  } // We're not inside React, so we may be in the middle of a browser event.
+
+  if (currentEventTime !== NoTimestamp) {
+    // Use the same start time for all updates until we enter React again.
+    return currentEventTime;
+  } // This is the first update since React yielded. Compute a new start time.
+
+  currentEventTime = now();
+  return currentEventTime;
 }
+function requestUpdateLane(fiber, suspenseConfig) {
+  // Special cases
+  var mode = fiber.mode;
 
-function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
-  var update = createUpdate(expirationTime, null);
-  update.tag = CaptureUpdate;
-  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+  if ((mode & BlockingMode) === NoMode) {
+    return SyncLane;
+  } else if ((mode & ConcurrentMode) === NoMode) {
+    return getCurrentPriorityLevel() === ImmediatePriority$1
+      ? SyncLane
+      : SyncBatchedLane;
+  } // The algorithm for assigning an update to a lane should be stable for all
+  // updates at the same priority within the same event. To do this, the inputs
+  // to the algorithm must be the same. For example, we use the `renderLanes`
+  // to avoid choosing a lane that is already in the middle of rendering.
+  //
+  // However, the "included" lanes could be mutated in between updates in the
+  // same event, like if you perform an update inside `flushSync`. Or any other
+  // code path that might call `prepareFreshStack`.
+  //
+  // The trick we use is to cache the first of each of these inputs within an
+  // event. Then reset the cached values once we can be sure the event is over.
+  // Our heuristic for that is whenever we enter a concurrent work loop.
+  //
+  // We'll do the same for `currentEventPendingLanes` below.
+
+  if (currentEventWipLanes === NoLanes) {
+    currentEventWipLanes = workInProgressRootIncludedLanes;
+  }
+
+  if (suspenseConfig !== null) {
+    // Use the size of the timeout as a heuristic to prioritize shorter
+    // transitions over longer ones.
+    // TODO: This will coerce numbers larger than 31 bits to 0.
+    var timeoutMs = suspenseConfig.timeoutMs;
+    var transitionLanePriority =
+      timeoutMs === undefined || (timeoutMs | 0) < 10000
+        ? TransitionShortLanePriority
+        : TransitionLongLanePriority;
+
+    if (currentEventPendingLanes !== NoLanes) {
+      currentEventPendingLanes =
+        mostRecentlyUpdatedRoot !== null
+          ? mostRecentlyUpdatedRoot.pendingLanes
+          : NoLanes;
+    }
+
+    return findTransitionLane(
+      transitionLanePriority,
+      currentEventWipLanes,
+      currentEventPendingLanes
+    );
+  } // TODO: Remove this dependency on the Scheduler priority.
+  // To do that, we're replacing it with an update lane priority.
+
+  var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.
+  // This couples React to the Scheduler internals, so we're replacing it
+  // with the currentUpdateLanePriority above. As an example of how this
+  // could be problematic, if we're not inside `Scheduler.runWithPriority`,
+  // then we'll get the priority of the current running Scheduler task,
+  // which is probably not what we want.
+
+  var lane;
+
+  if (
+    // TODO: Temporary. We're removing the concept of discrete updates.
+    (executionContext & DiscreteEventContext) !== NoContext &&
+    schedulerPriority === UserBlockingPriority$1
+  ) {
+    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
+  } else {
+    var schedulerLanePriority = schedulerPriorityToLanePriority(
+      schedulerPriority
+    );
+
+    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
+  }
+
+  return lane;
+}
+
+function requestRetryLane(fiber) {
+  // This is a fork of `requestUpdateLane` designed specifically for Suspense
+  // "retries"  a special update that attempts to flip a Suspense boundary
+  // from its placeholder state to its primary/resolved state.
+  // Special cases
+  var mode = fiber.mode;
+
+  if ((mode & BlockingMode) === NoMode) {
+    return SyncLane;
+  } else if ((mode & ConcurrentMode) === NoMode) {
+    return getCurrentPriorityLevel() === ImmediatePriority$1
+      ? SyncLane
+      : SyncBatchedLane;
+  } // See `requestUpdateLane` for explanation of `currentEventWipLanes`
+
+  if (currentEventWipLanes === NoLanes) {
+    currentEventWipLanes = workInProgressRootIncludedLanes;
+  }
+
+  return findRetryLane(currentEventWipLanes);
+}
+
+function scheduleUpdateOnFiber(fiber, lane, eventTime) {
+  checkForNestedUpdates();
+  warnAboutRenderPhaseUpdatesInDEV(fiber);
+  var root = markUpdateLaneFromFiberToRoot(fiber, lane);
+
+  if (root === null) {
+    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
+    return null;
+  } // Mark that the root has a pending update.
+
+  markRootUpdated(root, lane, eventTime);
+
+  if (root === workInProgressRoot) {
+    // Received an update to a tree that's in the middle of rendering. Mark
+    // that there was an interleaved update work on this root. Unless the
+    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
+    // phase update. In that case, we don't treat render phase updates as if
+    // they were interleaved, for backwards compat reasons.
+    {
+      workInProgressRootUpdatedLanes = mergeLanes(
+        workInProgressRootUpdatedLanes,
+        lane
+      );
+    }
+
+    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
+      // The root already suspended with a delay, which means this render
+      // definitely won't finish. Since we have a new update, let's mark it as
+      // suspended now, right before marking the incoming update. This has the
+      // effect of interrupting the current render and switching to the update.
+      // TODO: Make sure this doesn't override pings that happen while we've
+      // already started rendering.
+      markRootSuspended$1(root, workInProgressRootRenderLanes);
+    }
+  } // TODO: requestUpdateLanePriority also reads the priority. Pass the
+  // priority as an argument to that function and this one.
+
+  var priorityLevel = getCurrentPriorityLevel();
+
+  if (lane === SyncLane) {
+    if (
+      // Check if we're inside unbatchedUpdates
+      (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering
+      (executionContext & (RenderContext | CommitContext)) === NoContext
+    ) {
+      // Register pending interactions on the root to avoid losing traced interaction data.
+      schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
+      // root inside of batchedUpdates should be synchronous, but layout updates
+      // should be deferred until the end of the batch.
+
+      performSyncWorkOnRoot(root);
+    } else {
+      ensureRootIsScheduled(root, eventTime);
+      schedulePendingInteractions(root, lane);
+
+      if (executionContext === NoContext) {
+        // Flush the synchronous work now, unless we're already working or inside
+        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
+        // scheduleCallbackForFiber to preserve the ability to schedule a callback
+        // without immediately flushing it. We only do this for user-initiated
+        // updates, to preserve historical behavior of legacy mode.
+        flushSyncCallbackQueue();
+      }
+    }
+  } else {
+    // Schedule a discrete update but only if it's not Sync.
+    if (
+      (executionContext & DiscreteEventContext) !== NoContext && // Only updates at user-blocking priority or greater are considered
+      // discrete, even inside a discrete event.
+      (priorityLevel === UserBlockingPriority$1 ||
+        priorityLevel === ImmediatePriority$1)
+    ) {
+      // This is the result of a discrete event. Track the lowest priority
+      // discrete update per root so we can flush them early, if needed.
+      if (rootsWithPendingDiscreteUpdates === null) {
+        rootsWithPendingDiscreteUpdates = new Set([root]);
+      } else {
+        rootsWithPendingDiscreteUpdates.add(root);
+      }
+    } // Schedule other updates after in case the callback is sync.
 
-  if (typeof getDerivedStateFromError === "function") {
-    var error$1 = errorInfo.value;
+    ensureRootIsScheduled(root, eventTime);
+    schedulePendingInteractions(root, lane);
+  } // We use this when assigning a lane for a transition inside
+  // `requestUpdateLane`. We assume it's the same as the root being updated,
+  // since in the common case of a single root app it probably is. If it's not
+  // the same root, then it's not a huge deal, we just might batch more stuff
+  // together more than necessary.
 
-    update.payload = function() {
-      logError(fiber, errorInfo);
-      return getDerivedStateFromError(error$1);
-    };
-  }
+  mostRecentlyUpdatedRoot = root;
+} // This is split into a separate function so we can mark a fiber with pending
+// work without treating it as a typical update that originates from an event;
+// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
+// on a fiber.
 
-  var inst = fiber.stateNode;
+function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
+  // Update the source fiber's lanes
+  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
+  var alternate = sourceFiber.alternate;
 
-  if (inst !== null && typeof inst.componentDidCatch === "function") {
-    update.callback = function callback() {
-      {
-        markFailedErrorBoundaryForHotReloading(fiber);
-      }
+  if (alternate !== null) {
+    alternate.lanes = mergeLanes(alternate.lanes, lane);
+  }
 
-      if (typeof getDerivedStateFromError !== "function") {
-        // To preserve the preexisting retry behavior of error boundaries,
-        // we keep track of which ones already failed during this batch.
-        // This gets reset before we yield back to the browser.
-        // TODO: Warn in strict mode if getDerivedStateFromError is
-        // not defined.
-        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined
+  {
+    if (
+      alternate === null &&
+      (sourceFiber.effectTag & (Placement | Hydrating)) !== NoEffect
+    ) {
+      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
+    }
+  } // Walk the parent path to the root and update the child expiration time.
 
-        logError(fiber, errorInfo);
-      }
+  var node = sourceFiber;
+  var parent = sourceFiber.return;
 
-      var error$1 = errorInfo.value;
-      var stack = errorInfo.stack;
-      this.componentDidCatch(error$1, {
-        componentStack: stack !== null ? stack : ""
-      });
+  while (parent !== null) {
+    parent.childLanes = mergeLanes(parent.childLanes, lane);
+    alternate = parent.alternate;
 
+    if (alternate !== null) {
+      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
+    } else {
       {
-        if (typeof getDerivedStateFromError !== "function") {
-          // If componentDidCatch is the only error boundary method defined,
-          // then it needs to call setState to recover from errors.
-          // If no state update is scheduled then the boundary will swallow the error.
-          if (fiber.expirationTime !== Sync) {
-            error(
-              "%s: Error boundaries should implement getDerivedStateFromError(). " +
-                "In that method, return a state update to display an error message or fallback UI.",
-              getComponentName(fiber.type) || "Unknown"
-            );
-          }
+        if ((parent.effectTag & (Placement | Hydrating)) !== NoEffect) {
+          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
         }
       }
-    };
+    }
+
+    node = parent;
+    parent = parent.return;
+  }
+
+  if (node.tag === HostRoot) {
+    var root = node.stateNode;
+    return root;
   } else {
-    update.callback = function() {
-      markFailedErrorBoundaryForHotReloading(fiber);
-    };
+    return null;
   }
+} // Use this function to schedule a task for a root. There's only one task per
+// root; if a task was already scheduled, we'll check to make sure the priority
+// of the existing task is the same as the priority of the next level that the
+// root has work on. This function is called on every update, and right before
+// exiting a task.
 
-  return update;
-}
+function ensureRootIsScheduled(root, currentTime) {
+  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
+  // expired so we know to work on those next.
 
-function attachPingListener(root, renderExpirationTime, thenable) {
-  // Attach a listener to the promise to "ping" the root and retry. But
-  // only if one does not already exist for the current render expiration
-  // time (which acts like a "thread ID" here).
-  var pingCache = root.pingCache;
-  var threadIDs;
+  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.
 
-  if (pingCache === null) {
-    pingCache = root.pingCache = new PossiblyWeakMap();
-    threadIDs = new Set();
-    pingCache.set(thenable, threadIDs);
-  } else {
-    threadIDs = pingCache.get(thenable);
+  var nextLanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes
+  ); // This returns the priority level computed during the `getNextLanes` call.
 
-    if (threadIDs === undefined) {
-      threadIDs = new Set();
-      pingCache.set(thenable, threadIDs);
+  var newCallbackPriority = returnNextLanesPriority();
+
+  if (nextLanes === NoLanes) {
+    // Special case: There's nothing to work on.
+    if (existingCallbackNode !== null) {
+      cancelCallback(existingCallbackNode);
+      root.callbackNode = null;
+      root.callbackPriority = NoLanePriority;
     }
-  }
 
-  if (!threadIDs.has(renderExpirationTime)) {
-    // Memoize using the thread ID to prevent redundant listeners.
-    threadIDs.add(renderExpirationTime);
-    var ping = pingSuspendedRoot.bind(
-      null,
-      root,
-      thenable,
-      renderExpirationTime
+    return;
+  } // Check if there's an existing task. We may be able to reuse it.
+
+  if (existingCallbackNode !== null) {
+    var existingCallbackPriority = root.callbackPriority;
+
+    if (existingCallbackPriority === newCallbackPriority) {
+      // The priority hasn't changed. We can reuse the existing task. Exit.
+      return;
+    } // The priority changed. Cancel the existing callback. We'll schedule a new
+    // one below.
+
+    cancelCallback(existingCallbackNode);
+  } // Schedule a new callback.
+
+  var newCallbackNode;
+
+  if (newCallbackPriority === SyncLanePriority) {
+    // Special case: Sync React callbacks are scheduled on a special
+    // internal queue
+    newCallbackNode = scheduleSyncCallback(
+      performSyncWorkOnRoot.bind(null, root)
+    );
+  } else if (newCallbackPriority === SyncBatchedLanePriority) {
+    newCallbackNode = scheduleCallback(
+      ImmediatePriority$1,
+      performSyncWorkOnRoot.bind(null, root)
+    );
+  } else {
+    var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
+      newCallbackPriority
+    );
+    newCallbackNode = scheduleCallback(
+      schedulerPriorityLevel,
+      performConcurrentWorkOnRoot.bind(null, root)
     );
-    thenable.then(ping, ping);
   }
-}
-
-function throwException(
-  root,
-  returnFiber,
-  sourceFiber,
-  value,
-  renderExpirationTime
-) {
-  // The source fiber did not complete.
-  sourceFiber.effectTag |= Incomplete; // Its effect list is no longer valid.
 
-  sourceFiber.firstEffect = sourceFiber.lastEffect = null;
+  root.callbackPriority = newCallbackPriority;
+  root.callbackNode = newCallbackNode;
+} // This is the entry point for every concurrent task, i.e. anything that
+// goes through Scheduler.
 
-  if (
-    value !== null &&
-    typeof value === "object" &&
-    typeof value.then === "function"
-  ) {
-    // This is a thenable.
-    var thenable = value;
+function performConcurrentWorkOnRoot(root, didTimeout) {
+  // Since we know we're in a React event, we can clear the current
+  // event time. The next update will compute a new event time.
+  currentEventTime = NoTimestamp;
+  currentEventWipLanes = NoLanes;
+  currentEventPendingLanes = NoLanes;
 
-    if ((sourceFiber.mode & BlockingMode) === NoMode) {
-      // Reset the memoizedState to what it was before we attempted
-      // to render it.
-      var currentSource = sourceFiber.alternate;
+  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
+    throw Error("Should not already be working.");
+  } // Flush any pending passive effects before deciding which lanes to work on,
+  // in case they schedule additional work.
 
-      if (currentSource) {
-        sourceFiber.updateQueue = currentSource.updateQueue;
-        sourceFiber.memoizedState = currentSource.memoizedState;
-        sourceFiber.expirationTime = currentSource.expirationTime;
-      } else {
-        sourceFiber.updateQueue = null;
-        sourceFiber.memoizedState = null;
-      }
+  var originalCallbackNode = root.callbackNode;
+  var didFlushPassiveEffects = flushPassiveEffects();
+
+  if (didFlushPassiveEffects) {
+    // Something in the passive effect phase may have canceled the current task.
+    // Check if the task node for this root was changed.
+    if (root.callbackNode !== originalCallbackNode) {
+      // The current task was canceled. Exit. We don't need to call
+      // `ensureRootIsScheduled` because the check above implies either that
+      // there's a new task, or that there's no remaining work on this root.
+      return null;
     }
+  } // Determine the next expiration time to work on, using the fields stored
+  // on the root.
 
-    var hasInvisibleParentBoundary = hasSuspenseContext(
-      suspenseStackCursor.current,
-      InvisibleParentSuspenseContext
-    ); // Schedule the nearest Suspense to re-render the timed out view.
+  var lanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes
+  );
 
-    var _workInProgress = returnFiber;
+  if (lanes === NoLanes) {
+    // Defensive coding. This is never expected to happen.
+    return null;
+  } // TODO: We only check `didTimeout` defensively, to account for a Scheduler
+  // bug where `shouldYield` sometimes returns `true` even if `didTimeout` is
+  // true, which leads to an infinite loop. Once the bug in Scheduler is
+  // fixed, we can remove this, since we track expiration ourselves.
 
-    do {
-      if (
-        _workInProgress.tag === SuspenseComponent &&
-        shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)
-      ) {
-        // Found the nearest boundary.
-        // Stash the promise on the boundary fiber. If the boundary times out, we'll
-        // attach another listener to flip the boundary back to its normal state.
-        var thenables = _workInProgress.updateQueue;
+  if (didTimeout) {
+    // Something expired. Flush synchronously until there's no expired
+    // work left.
+    markRootExpired(root, lanes); // This will schedule a synchronous callback.
 
-        if (thenables === null) {
-          var updateQueue = new Set();
-          updateQueue.add(thenable);
-          _workInProgress.updateQueue = updateQueue;
-        } else {
-          thenables.add(thenable);
-        } // If the boundary is outside of blocking mode, we should *not*
-        // suspend the commit. Pretend as if the suspended component rendered
-        // null and keep rendering. In the commit phase, we'll schedule a
-        // subsequent synchronous update to re-render the Suspense.
-        //
-        // Note: It doesn't matter whether the component that suspended was
-        // inside a blocking mode tree. If the Suspense is outside of it, we
-        // should *not* suspend the commit.
+    ensureRootIsScheduled(root, now());
+    return null;
+  }
 
-        if ((_workInProgress.mode & BlockingMode) === NoMode) {
-          _workInProgress.effectTag |= DidCapture; // We're going to commit this fiber even though it didn't complete.
-          // But we shouldn't call any lifecycle methods or callbacks. Remove
-          // all lifecycle effect tags.
+  var exitStatus = renderRootConcurrent(root, lanes);
 
-          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
+  if (
+    includesSomeLane(
+      workInProgressRootIncludedLanes,
+      workInProgressRootUpdatedLanes
+    )
+  ) {
+    // The render included lanes that were updated during the render phase.
+    // For example, when unhiding a hidden tree, we include all the lanes
+    // that were previously skipped when the tree was hidden. That set of
+    // lanes is a superset of the lanes we started rendering with.
+    //
+    // So we'll throw out the current work and restart.
+    prepareFreshStack(root, NoLanes);
+  } else if (exitStatus !== RootIncomplete) {
+    if (exitStatus === RootErrored) {
+      executionContext |= RetryAfterError; // If an error occurred during hydration,
+      // discard server response and fall back to client side render.
 
-          if (sourceFiber.tag === ClassComponent) {
-            var currentSourceFiber = sourceFiber.alternate;
+      if (root.hydrate) {
+        root.hydrate = false;
+        clearContainer(root.containerInfo);
+      } // If something threw an error, try rendering one more time. We'll render
+      // synchronously to block concurrent data mutations, and we'll includes
+      // all pending updates are included. If it still fails after the second
+      // attempt, we'll give up and commit the resulting tree.
 
-            if (currentSourceFiber === null) {
-              // This is a new mount. Change the tag so it's not mistaken for a
-              // completed class component. For example, we should not call
-              // componentWillUnmount if it is deleted.
-              sourceFiber.tag = IncompleteClassComponent;
-            } else {
-              // When we try rendering again, we should not reuse the current fiber,
-              // since it's known to be in an inconsistent state. Use a force update to
-              // prevent a bail out.
-              var update = createUpdate(Sync, null);
-              update.tag = ForceUpdate;
-              enqueueUpdate(sourceFiber, update);
-            }
-          } // The source fiber did not complete. Mark it with Sync priority to
-          // indicate that it still has pending work.
+      lanes = getLanesToRetrySynchronouslyOnError(root);
 
-          sourceFiber.expirationTime = Sync; // Exit without suspending.
+      if (lanes !== NoLanes) {
+        exitStatus = renderRootSync(root, lanes);
+      }
+    }
 
-          return;
-        } // Confirmed that the boundary is in a concurrent mode tree. Continue
-        // with the normal suspend path.
-        //
-        // After this we'll use a set of heuristics to determine whether this
-        // render pass will run to completion or restart or "suspend" the commit.
-        // The actual logic for this is spread out in different places.
-        //
-        // This first principle is that if we're going to suspend when we complete
-        // a root, then we should also restart if we get an update or ping that
-        // might unsuspend it, and vice versa. The only reason to suspend is
-        // because you think you might want to restart before committing. However,
-        // it doesn't make sense to restart only while in the period we're suspended.
-        //
-        // Restarting too aggressively is also not good because it starves out any
-        // intermediate loading state. So we use heuristics to determine when.
-        // Suspense Heuristics
-        //
-        // If nothing threw a Promise or all the same fallbacks are already showing,
-        // then don't suspend/restart.
-        //
-        // If this is an initial render of a new tree of Suspense boundaries and
-        // those trigger a fallback, then don't suspend/restart. We want to ensure
-        // that we can show the initial loading state as quickly as possible.
-        //
-        // If we hit a "Delayed" case, such as when we'd switch from content back into
-        // a fallback, then we should always suspend/restart. SuspenseConfig applies to
-        // this case. If none is defined, JND is used instead.
-        //
-        // If we're already showing a fallback and it gets "retried", allowing us to show
-        // another level, but there's still an inner boundary that would show a fallback,
-        // then we suspend/restart for 500ms since the last time we showed a fallback
-        // anywhere in the tree. This effectively throttles progressive loading into a
-        // consistent train of commits. This also gives us an opportunity to restart to
-        // get to the completed state slightly earlier.
-        //
-        // If there's ambiguity due to batching it's resolved in preference of:
-        // 1) "delayed", 2) "initial render", 3) "retry".
-        //
-        // We want to ensure that a "busy" state doesn't get force committed. We want to
-        // ensure that new initial loading states can commit as soon as possible.
+    if (exitStatus === RootFatalErrored) {
+      var fatalError = workInProgressRootFatalError;
+      prepareFreshStack(root, NoLanes);
+      markRootSuspended$1(root, lanes);
+      ensureRootIsScheduled(root, now());
+      throw fatalError;
+    } // We now have a consistent tree. The next step is either to commit it,
+    // or, if something suspended, wait to commit it after a timeout.
 
-        attachPingListener(root, renderExpirationTime, thenable);
-        _workInProgress.effectTag |= ShouldCapture;
-        _workInProgress.expirationTime = renderExpirationTime;
-        return;
-      } // This boundary already captured during this render. Continue to the next
-      // boundary.
+    var finishedWork = root.current.alternate;
+    root.finishedWork = finishedWork;
+    root.finishedLanes = lanes;
+    finishConcurrentRender(root, finishedWork, exitStatus, lanes);
+  }
 
-      _workInProgress = _workInProgress.return;
-    } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.
-    // TODO: Use invariant so the message is stripped in prod?
+  ensureRootIsScheduled(root, now());
+
+  if (root.callbackNode === originalCallbackNode) {
+    // The task node scheduled for this root is the same one that's
+    // currently executed. Need to return a continuation.
+    return performConcurrentWorkOnRoot.bind(null, root);
+  }
+
+  return null;
+}
+
+function finishConcurrentRender(root, finishedWork, exitStatus, lanes) {
+  switch (exitStatus) {
+    case RootIncomplete:
+    case RootFatalErrored: {
+      {
+        throw Error("Root did not complete. This is a bug in React.");
+      }
+    }
+    // Flow knows about invariant, so it complains if I add a break
+    // statement, but eslint doesn't know about invariant, so it complains
+    // if I do. eslint-disable-next-line no-fallthrough
 
-    value = new Error(
-      (getComponentName(sourceFiber.type) || "A React component") +
-        " suspended while rendering, but no fallback UI was specified.\n" +
-        "\n" +
-        "Add a <Suspense fallback=...> component higher in the tree to " +
-        "provide a loading indicator or placeholder to display." +
-        getStackByFiberInDevAndProd(sourceFiber)
-    );
-  } // We didn't find a boundary that could handle this type of exception. Start
-  // over and traverse parent path again, this time treating the exception
-  // as an error.
+    case RootErrored: {
+      // We should have already attempted to retry this tree. If we reached
+      // this point, it errored again. Commit it.
+      commitRoot(root);
+      break;
+    }
 
-  renderDidError();
-  value = createCapturedValue(value, sourceFiber);
-  var workInProgress = returnFiber;
+    case RootSuspended: {
+      markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we
+      // should immediately commit it or wait a bit.
 
-  do {
-    switch (workInProgress.tag) {
-      case HostRoot: {
-        var _errorInfo = value;
-        workInProgress.effectTag |= ShouldCapture;
-        workInProgress.expirationTime = renderExpirationTime;
+      if (
+        includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
+        !shouldForceFlushFallbacksInDEV()
+      ) {
+        // This render only included retries, no updates. Throttle committing
+        // retries so that we don't show too many loading states too quickly.
+        var msUntilTimeout =
+          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.
 
-        var _update = createRootErrorUpdate(
-          workInProgress,
-          _errorInfo,
-          renderExpirationTime
-        );
+        if (msUntilTimeout > 10) {
+          var nextLanes = getNextLanes(root, NoLanes);
 
-        enqueueCapturedUpdate(workInProgress, _update);
-        return;
-      }
+          if (nextLanes !== NoLanes) {
+            // There's additional work on this root.
+            break;
+          }
 
-      case ClassComponent:
-        // Capture and retry
-        var errorInfo = value;
-        var ctor = workInProgress.type;
-        var instance = workInProgress.stateNode;
+          var suspendedLanes = root.suspendedLanes;
 
-        if (
-          (workInProgress.effectTag & DidCapture) === NoEffect &&
-          (typeof ctor.getDerivedStateFromError === "function" ||
-            (instance !== null &&
-              typeof instance.componentDidCatch === "function" &&
-              !isAlreadyFailedLegacyErrorBoundary(instance)))
-        ) {
-          workInProgress.effectTag |= ShouldCapture;
-          workInProgress.expirationTime = renderExpirationTime; // Schedule the error boundary to re-render using updated state
+          if (!isSubsetOfLanes(suspendedLanes, lanes)) {
+            // We should prefer to render the fallback of at the last
+            // suspended level. Ping the last suspended level to try
+            // rendering it again.
+            // FIXME: What if the suspended lanes are Idle? Should not restart.
+            var eventTime = requestEventTime();
+            markRootPinged(root, suspendedLanes);
+            break;
+          } // The render is suspended, it hasn't timed out, and there's no
+          // lower priority work to do. Instead of committing the fallback
+          // immediately, wait for more data to arrive.
 
-          var _update2 = createClassErrorUpdate(
-            workInProgress,
-            errorInfo,
-            renderExpirationTime
+          root.timeoutHandle = scheduleTimeout(
+            commitRoot.bind(null, root),
+            msUntilTimeout
           );
-
-          enqueueCapturedUpdate(workInProgress, _update2);
-          return;
+          break;
         }
+      } // The work expired. Commit immediately.
 
-        break;
+      commitRoot(root);
+      break;
     }
 
-    workInProgress = workInProgress.return;
-  } while (workInProgress !== null);
-}
+    case RootSuspendedWithDelay: {
+      markRootSuspended$1(root, lanes);
 
-var ceil = Math.ceil;
-var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
-  ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
-  IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
-var NoContext =
-  /*                    */
-  0;
-var BatchedContext =
-  /*               */
-  1;
-var DiscreteEventContext =
-  /*         */
-  4;
-var LegacyUnbatchedContext =
-  /*       */
-  8;
-var RenderContext =
-  /*                */
-  16;
-var CommitContext =
-  /*                */
-  32;
-var RootIncomplete = 0;
-var RootFatalErrored = 1;
-var RootErrored = 2;
-var RootSuspended = 3;
-var RootSuspendedWithDelay = 4;
-var RootCompleted = 5;
-// Describes where we are in the React execution stack
-var executionContext = NoContext; // The root we're working on
+      if (
+        // do not delay if we're inside an act() scope
+        !shouldForceFlushFallbacksInDEV()
+      ) {
+        // We're suspended in a state that should be avoided. We'll try to
+        // avoid committing it for as long as the timeouts let us.
+        var _nextLanes = getNextLanes(root, NoLanes);
 
-var workInProgressRoot = null; // The fiber we're working on
+        if (_nextLanes !== NoLanes) {
+          // There's additional work on this root.
+          break;
+        }
 
-var workInProgress = null; // The expiration time we're rendering
+        var _suspendedLanes = root.suspendedLanes;
 
-var renderExpirationTime$1 = NoWork; // Whether to root completed, errored, suspended, etc.
+        if (!isSubsetOfLanes(_suspendedLanes, lanes)) {
+          // We should prefer to render the fallback of at the last
+          // suspended level. Ping the last suspended level to try
+          // rendering it again.
+          // FIXME: What if the suspended lanes are Idle? Should not restart.
+          var _eventTime = requestEventTime();
 
-var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown
+          markRootPinged(root, _suspendedLanes);
+          break;
+        }
 
-var workInProgressRootFatalError = null; // Most recent event time among processed updates during this render.
-// This is conceptually a time stamp but expressed in terms of an ExpirationTime
-// because we deal mostly with expiration times in the hot path, so this avoids
-// the conversion happening in the hot path.
+        var mostRecentEventTime = getMostRecentEventTime(root, lanes);
 
-var workInProgressRootLatestProcessedExpirationTime = Sync;
-var workInProgressRootLatestSuspenseTimeout = Sync;
-var workInProgressRootCanSuspendUsingConfig = null; // The work left over by components that were visited during this render. Only
-// includes unprocessed updates, not work in bailed out children.
+        var _msUntilTimeout;
 
-var workInProgressRootNextUnprocessedUpdateTime = NoWork; // If we're pinged while rendering we don't always restart immediately.
-// This flag determines if it might be worthwhile to restart if an opportunity
-// happens latere.
+        if (workInProgressRootLatestSuspenseTimeout !== NoTimestamp) {
+          // We have processed a suspense config whose expiration time we
+          // can use as the timeout.
+          _msUntilTimeout = workInProgressRootLatestSuspenseTimeout - now();
+        } else if (mostRecentEventTime === NoTimestamp) {
+          // This should never normally happen because only new updates
+          // cause delayed states, so we should have processed something.
+          // However, this could also happen in an offscreen tree.
+          _msUntilTimeout = 0;
+        } else {
+          // If we didn't process a suspense config, compute a JND based on
+          // the amount of time elapsed since the most recent event time.
+          var eventTimeMs = mostRecentEventTime;
+          var timeElapsedMs = now() - eventTimeMs;
+          _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
+        } // Don't bother with a very short suspense time.
 
-var workInProgressRootHasPendingPing = false; // The most recent time we committed a fallback. This lets us ensure a train
-// model where we don't commit new loading states in too quick succession.
+        if (_msUntilTimeout > 10) {
+          // The render is suspended, it hasn't timed out, and there's no
+          // lower priority work to do. Instead of committing the fallback
+          // immediately, wait for more data to arrive.
+          root.timeoutHandle = scheduleTimeout(
+            commitRoot.bind(null, root),
+            _msUntilTimeout
+          );
+          break;
+        }
+      } // The work expired. Commit immediately.
 
-var globalMostRecentFallbackTime = 0;
-var FALLBACK_THROTTLE_MS = 500;
-var nextEffect = null;
-var hasUncaughtError = false;
-var firstUncaughtError = null;
-var legacyErrorBoundariesThatAlreadyFailed = null;
-var rootDoesHavePassiveEffects = false;
-var rootWithPendingPassiveEffects = null;
-var pendingPassiveEffectsRenderPriority = NoPriority;
-var pendingPassiveEffectsExpirationTime = NoWork;
-var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates
+      commitRoot(root);
+      break;
+    }
 
-var NESTED_UPDATE_LIMIT = 50;
-var nestedUpdateCount = 0;
-var rootWithNestedUpdates = null;
-var NESTED_PASSIVE_UPDATE_LIMIT = 50;
-var nestedPassiveUpdateCount = 0;
-var interruptedBy = null; // Marks the need to reschedule pending interactions at these expiration times
-// during the commit phase. This enables them to be traced across components
-// that spawn new work during render. E.g. hidden boundaries, suspended SSR
-// hydration or SuspenseList.
+    case RootCompleted: {
+      // The work completed. Ready to commit.
+      var _mostRecentEventTime = getMostRecentEventTime(root, lanes);
 
-var spawnedWorkDuringRender = null; // Expiration times are computed by adding to the current time (the start
-// time). However, if two updates are scheduled within the same event, we
-// should treat their start times as simultaneous, even if the actual clock
-// time has advanced between the first and second call.
-// In other words, because expiration times determine how updates are batched,
-// we want all updates of like priority that occur within the same event to
-// receive the same expiration time. Otherwise we get tearing.
+      if (
+        // do not delay if we're inside an act() scope
+        !shouldForceFlushFallbacksInDEV() &&
+        _mostRecentEventTime !== NoTimestamp &&
+        workInProgressRootCanSuspendUsingConfig !== null
+      ) {
+        // If we have exceeded the minimum loading delay, which probably
+        // means we have shown a spinner already, we might have to suspend
+        // a bit longer to ensure that the spinner is shown for
+        // enough time.
+        var _msUntilTimeout2 = computeMsUntilSuspenseLoadingDelay(
+          _mostRecentEventTime,
+          workInProgressRootCanSuspendUsingConfig
+        );
 
-var currentEventTime = NoWork;
-function requestCurrentTimeForUpdate() {
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
-    // We're inside React, so it's fine to read the actual time.
-    return msToExpirationTime(now());
-  } // We're not inside React, so we may be in the middle of a browser event.
+        if (_msUntilTimeout2 > 10) {
+          markRootSuspended$1(root, lanes);
+          root.timeoutHandle = scheduleTimeout(
+            commitRoot.bind(null, root),
+            _msUntilTimeout2
+          );
+          break;
+        }
+      }
 
-  if (currentEventTime !== NoWork) {
-    // Use the same start time for all updates until we enter React again.
-    return currentEventTime;
-  } // This is the first update since React yielded. Compute a new start time.
+      commitRoot(root);
+      break;
+    }
 
-  currentEventTime = msToExpirationTime(now());
-  return currentEventTime;
-}
-function getCurrentTime() {
-  return msToExpirationTime(now());
+    default: {
+      {
+        throw Error("Unknown root exit status.");
+      }
+    }
+  }
 }
-function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {
-  var mode = fiber.mode;
 
-  if ((mode & BlockingMode) === NoMode) {
-    return Sync;
+function markRootSuspended$1(root, suspendedLanes) {
+  // When suspending, we should always exclude lanes that were pinged or (more
+  // rarely, since we try to avoid it) updated during the render phase.
+  // TODO: Lol maybe there's a better way to factor this besides this
+  // obnoxiously named function :)
+  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
+  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
+  markRootSuspended(root, suspendedLanes);
+} // This is the entry point for synchronous tasks that don't go
+// through Scheduler
+
+function performSyncWorkOnRoot(root) {
+  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
+    throw Error("Should not already be working.");
   }
 
-  var priorityLevel = getCurrentPriorityLevel();
+  flushPassiveEffects();
+  var lanes;
+  var exitStatus;
+
+  if (
+    root === workInProgressRoot &&
+    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)
+  ) {
+    // There's a partial tree, and at least one of its lanes has expired. Finish
+    // rendering it before rendering the rest of the expired work.
+    lanes = workInProgressRootRenderLanes;
+    exitStatus = renderRootSync(root, lanes);
 
-  if ((mode & ConcurrentMode) === NoMode) {
-    return priorityLevel === ImmediatePriority ? Sync : Batched;
+    if (
+      includesSomeLane(
+        workInProgressRootIncludedLanes,
+        workInProgressRootUpdatedLanes
+      )
+    ) {
+      // The render included lanes that were updated during the render phase.
+      // For example, when unhiding a hidden tree, we include all the lanes
+      // that were previously skipped when the tree was hidden. That set of
+      // lanes is a superset of the lanes we started rendering with.
+      //
+      // Note that this only happens when part of the tree is rendered
+      // concurrently. If the whole tree is rendered synchronously, then there
+      // are no interleaved events.
+      lanes = getNextLanes(root, lanes);
+      exitStatus = renderRootSync(root, lanes);
+    }
+  } else {
+    lanes = getNextLanes(root, NoLanes);
+    exitStatus = renderRootSync(root, lanes);
   }
 
-  if ((executionContext & RenderContext) !== NoContext) {
-    // Use whatever time we're already rendering
-    // TODO: Should there be a way to opt out, like with `runWithPriority`?
-    return renderExpirationTime$1;
+  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
+    executionContext |= RetryAfterError; // If an error occurred during hydration,
+    // discard server response and fall back to client side render.
+
+    if (root.hydrate) {
+      root.hydrate = false;
+      clearContainer(root.containerInfo);
+    } // If something threw an error, try rendering one more time. We'll render
+    // synchronously to block concurrent data mutations, and we'll includes
+    // all pending updates are included. If it still fails after the second
+    // attempt, we'll give up and commit the resulting tree.
+
+    lanes = getLanesToRetrySynchronouslyOnError(root);
+
+    if (lanes !== NoLanes) {
+      exitStatus = renderRootSync(root, lanes);
+    }
   }
 
-  var expirationTime;
+  if (exitStatus === RootFatalErrored) {
+    var fatalError = workInProgressRootFatalError;
+    prepareFreshStack(root, NoLanes);
+    markRootSuspended$1(root, lanes);
+    ensureRootIsScheduled(root, now());
+    throw fatalError;
+  } // We now have a consistent tree. Because this is a sync render, we
+  // will commit it even if something suspended.
+
+  var finishedWork = root.current.alternate;
+  root.finishedWork = finishedWork;
+  root.finishedLanes = lanes;
+  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
+  // pending level.
+
+  ensureRootIsScheduled(root, now());
+  return null;
+}
+
+function batchedUpdates$1(fn, a) {
+  var prevExecutionContext = executionContext;
+  executionContext |= BatchedContext;
+
+  try {
+    return fn(a);
+  } finally {
+    executionContext = prevExecutionContext;
+
+    if (executionContext === NoContext) {
+      // Flush the immediate callbacks that were scheduled during this batch
+      flushSyncCallbackQueue();
+    }
+  }
+}
+function flushSync(fn, a) {
+  var prevExecutionContext = executionContext;
 
-  if (suspenseConfig !== null) {
-    // Compute an expiration time based on the Suspense timeout.
-    expirationTime = computeSuspenseExpiration(
-      currentTime,
-      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION
-    );
-  } else {
-    // Compute an expiration time based on the Scheduler priority.
-    switch (priorityLevel) {
-      case ImmediatePriority:
-        expirationTime = Sync;
-        break;
+  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
+    {
+      error(
+        "flushSync was called from inside a lifecycle method. React cannot " +
+          "flush when React is already rendering. Consider moving this call to " +
+          "a scheduler task or micro task."
+      );
+    }
 
-      case UserBlockingPriority:
-        // TODO: Rename this to computeUserBlockingExpiration
-        expirationTime = computeInteractiveExpiration(currentTime);
-        break;
+    return fn(a);
+  }
 
-      case NormalPriority:
-      case LowPriority:
-        // TODO: Handle LowPriority
-        // TODO: Rename this to... something better.
-        expirationTime = computeAsyncExpiration(currentTime);
-        break;
+  executionContext |= BatchedContext;
 
-      case IdlePriority:
-        expirationTime = Idle;
-        break;
+  try {
+    setCurrentUpdateLanePriority(SyncLanePriority);
 
-      default: {
-        throw Error("Expected a valid priority level");
-      }
+    if (fn) {
+      return runWithPriority(ImmediatePriority$1, fn.bind(null, a));
+    } else {
+      return undefined;
     }
-  } // If we're in the middle of rendering a tree, do not update at the same
-  // expiration time that is already rendering.
-  // TODO: We shouldn't have to do this if the update is on a different root.
-  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to
-  // the root when we check for this condition.
+  } finally {
+    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
+    // Note that this will happen even if batchedUpdates is higher up
+    // the stack.
 
-  if (
-    workInProgressRoot !== null &&
-    expirationTime === renderExpirationTime$1
-  ) {
-    // This is a trick to move this update into a separate batch
-    expirationTime -= 1;
+    flushSyncCallbackQueue();
   }
-
-  return expirationTime;
 }
-function scheduleUpdateOnFiber(fiber, expirationTime) {
-  checkForNestedUpdates();
-  warnAboutRenderPhaseUpdatesInDEV(fiber);
-  var root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
-
-  if (root === null) {
-    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
-    return;
-  }
+function pushRenderLanes(fiber, lanes) {
+  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
+  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
+  workInProgressRootIncludedLanes = mergeLanes(
+    workInProgressRootIncludedLanes,
+    lanes
+  );
+}
+function popRenderLanes(fiber) {
+  subtreeRenderLanes = subtreeRenderLanesCursor.current;
+  pop(subtreeRenderLanesCursor, fiber);
+}
 
-  checkForInterruption(fiber, expirationTime);
-  recordScheduleUpdate(); // TODO: computeExpirationForFiber also reads the priority. Pass the
-  // priority as an argument to that function and this one.
+function prepareFreshStack(root, lanes) {
+  root.finishedWork = null;
+  root.finishedLanes = NoLanes;
+  var timeoutHandle = root.timeoutHandle;
 
-  var priorityLevel = getCurrentPriorityLevel();
+  if (timeoutHandle !== noTimeout) {
+    // The root previous suspended and scheduled a timeout to commit a fallback
+    // state. Now that we have additional work, cancel the timeout.
+    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
 
-  if (expirationTime === Sync) {
-    if (
-      // Check if we're inside unbatchedUpdates
-      (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering
-      (executionContext & (RenderContext | CommitContext)) === NoContext
-    ) {
-      // Register pending interactions on the root to avoid losing traced interaction data.
-      schedulePendingInteractions(root, expirationTime); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
-      // root inside of batchedUpdates should be synchronous, but layout updates
-      // should be deferred until the end of the batch.
+    cancelTimeout(timeoutHandle);
+  }
 
-      performSyncWorkOnRoot(root);
-    } else {
-      ensureRootIsScheduled(root);
-      schedulePendingInteractions(root, expirationTime);
+  if (workInProgress !== null) {
+    var interruptedWork = workInProgress.return;
 
-      if (executionContext === NoContext) {
-        // Flush the synchronous work now, unless we're already working or inside
-        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
-        // scheduleCallbackForFiber to preserve the ability to schedule a callback
-        // without immediately flushing it. We only do this for user-initiated
-        // updates, to preserve historical behavior of legacy mode.
-        flushSyncCallbackQueue();
-      }
+    while (interruptedWork !== null) {
+      unwindInterruptedWork(interruptedWork);
+      interruptedWork = interruptedWork.return;
     }
-  } else {
-    ensureRootIsScheduled(root);
-    schedulePendingInteractions(root, expirationTime);
   }
 
-  if (
-    (executionContext & DiscreteEventContext) !== NoContext && // Only updates at user-blocking priority or greater are considered
-    // discrete, even inside a discrete event.
-    (priorityLevel === UserBlockingPriority ||
-      priorityLevel === ImmediatePriority)
-  ) {
-    // This is the result of a discrete event. Track the lowest priority
-    // discrete update per root so we can flush them early, if needed.
-    if (rootsWithPendingDiscreteUpdates === null) {
-      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);
-    } else {
-      var lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);
+  workInProgressRoot = root;
+  workInProgress = createWorkInProgress(root.current, null);
+  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
+  workInProgressRootExitStatus = RootIncomplete;
+  workInProgressRootFatalError = null;
+  workInProgressRootLatestSuspenseTimeout = NoTimestamp;
+  workInProgressRootCanSuspendUsingConfig = null;
+  workInProgressRootSkippedLanes = NoLanes;
+  workInProgressRootUpdatedLanes = NoLanes;
+  workInProgressRootPingedLanes = NoLanes;
 
-      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {
-        rootsWithPendingDiscreteUpdates.set(root, expirationTime);
-      }
-    }
+  {
+    spawnedWorkDuringRender = null;
   }
-}
-var scheduleWork = scheduleUpdateOnFiber; // This is split into a separate function so we can mark a fiber with pending
-// work without treating it as a typical update that originates from an event;
-// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
-// on a fiber.
 
-function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
-  // Update the source fiber's expiration time
-  if (fiber.expirationTime < expirationTime) {
-    fiber.expirationTime = expirationTime;
+  {
+    ReactStrictModeWarnings.discardPendingWarnings();
   }
+}
 
-  var alternate = fiber.alternate;
+function handleError(root, thrownValue) {
+  do {
+    var erroredWork = workInProgress;
 
-  if (alternate !== null && alternate.expirationTime < expirationTime) {
-    alternate.expirationTime = expirationTime;
-  } // Walk the parent path to the root and update the child expiration time.
+    try {
+      // Reset module-level state that was set during the render phase.
+      resetContextDependencies();
+      resetHooksAfterThrow();
+      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
+      // separate issue. Write a regression test using string refs.
 
-  var node = fiber.return;
-  var root = null;
+      ReactCurrentOwner$2.current = null;
 
-  if (node === null && fiber.tag === HostRoot) {
-    root = fiber.stateNode;
-  } else {
-    while (node !== null) {
-      alternate = node.alternate;
+      if (erroredWork === null || erroredWork.return === null) {
+        // Expected to be working on a non-root fiber. This is a fatal error
+        // because there's no ancestor that can handle it; the root is
+        // supposed to capture all errors that weren't caught by an error
+        // boundary.
+        workInProgressRootExitStatus = RootFatalErrored;
+        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
+        // sibling, or the parent if there are no siblings. But since the root
+        // has no siblings nor a parent, we set it to null. Usually this is
+        // handled by `completeUnitOfWork` or `unwindWork`, but since we're
+        // intentionally not calling those, we need set it here.
+        // TODO: Consider calling `unwindWork` to pop the contexts.
 
-      if (node.childExpirationTime < expirationTime) {
-        node.childExpirationTime = expirationTime;
+        workInProgress = null;
+        return;
+      }
 
-        if (
-          alternate !== null &&
-          alternate.childExpirationTime < expirationTime
-        ) {
-          alternate.childExpirationTime = expirationTime;
-        }
-      } else if (
-        alternate !== null &&
-        alternate.childExpirationTime < expirationTime
-      ) {
-        alternate.childExpirationTime = expirationTime;
+      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
+        // Record the time spent rendering before an error was thrown. This
+        // avoids inaccurate Profiler durations in the case of a
+        // suspended render.
+        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
       }
 
-      if (node.return === null && node.tag === HostRoot) {
-        root = node.stateNode;
-        break;
+      throwException(
+        root,
+        erroredWork.return,
+        erroredWork,
+        thrownValue,
+        workInProgressRootRenderLanes
+      );
+      completeUnitOfWork(erroredWork);
+    } catch (yetAnotherThrownValue) {
+      // Something in the return path also threw.
+      thrownValue = yetAnotherThrownValue;
+
+      if (workInProgress === erroredWork && erroredWork !== null) {
+        // If this boundary has already errored, then we had trouble processing
+        // the error. Bubble it to the next boundary.
+        erroredWork = erroredWork.return;
+        workInProgress = erroredWork;
+      } else {
+        erroredWork = workInProgress;
       }
 
-      node = node.return;
-    }
-  }
+      continue;
+    } // Return to the normal work loop.
 
-  if (root !== null) {
-    if (workInProgressRoot === root) {
-      // Received an update to a tree that's in the middle of rendering. Mark
-      // that's unprocessed work on this root.
-      markUnprocessedUpdateTime(expirationTime);
-
-      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
-        // The root already suspended with a delay, which means this render
-        // definitely won't finish. Since we have a new update, let's mark it as
-        // suspended now, right before marking the incoming update. This has the
-        // effect of interrupting the current render and switching to the update.
-        // TODO: This happens to work when receiving an update during the render
-        // phase, because of the trick inside computeExpirationForFiber to
-        // subtract 1 from `renderExpirationTime` to move it into a
-        // separate bucket. But we should probably model it with an exception,
-        // using the same mechanism we use to force hydration of a subtree.
-        // TODO: This does not account for low pri updates that were already
-        // scheduled before the root started rendering. Need to track the next
-        // pending expiration time (perhaps by backtracking the return path) and
-        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.
-        markRootSuspendedAtTime(root, renderExpirationTime$1);
-      }
-    } // Mark that the root has a pending update.
-
-    markRootUpdatedAtTime(root, expirationTime);
+    return;
+  } while (true);
+}
+
+function pushDispatcher(root) {
+  var prevDispatcher = ReactCurrentDispatcher$2.current;
+  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
+
+  if (prevDispatcher === null) {
+    // The React isomorphic package does not include a default dispatcher.
+    // Instead the first renderer will lazily attach one, in order to give
+    // nicer error messages.
+    return ContextOnlyDispatcher;
+  } else {
+    return prevDispatcher;
   }
+}
 
-  return root;
+function popDispatcher(prevDispatcher) {
+  ReactCurrentDispatcher$2.current = prevDispatcher;
 }
 
-function getNextRootExpirationTimeToWorkOn(root) {
-  // Determines the next expiration time that the root should render, taking
-  // into account levels that may be suspended, or levels that may have
-  // received a ping.
-  var lastExpiredTime = root.lastExpiredTime;
+function pushInteractions(root) {
+  {
+    var prevInteractions = tracing.__interactionsRef.current;
+    tracing.__interactionsRef.current = root.memoizedInteractions;
+    return prevInteractions;
+  }
+}
 
-  if (lastExpiredTime !== NoWork) {
-    return lastExpiredTime;
-  } // "Pending" refers to any update that hasn't committed yet, including if it
-  // suspended. The "suspended" range is therefore a subset.
+function popInteractions(prevInteractions) {
+  {
+    tracing.__interactionsRef.current = prevInteractions;
+  }
+}
 
-  var firstPendingTime = root.firstPendingTime;
+function markCommitTimeOfFallback() {
+  globalMostRecentFallbackTime = now();
+}
+function markRenderEventTimeAndConfig(eventTime, suspenseConfig) {
+  // Track the largest/latest timeout deadline in this batch.
+  // TODO: If there are two transitions in the same batch, shouldn't we
+  // choose the smaller one? Maybe this is because when an intermediate
+  // transition is superseded, we should ignore its suspense config, but
+  // we don't currently.
+  if (suspenseConfig !== null) {
+    // If `timeoutMs` is not specified, we default to 5 seconds. We have to
+    // resolve this default here because `suspenseConfig` is owned
+    // by userspace.
+    // TODO: Store this on the root instead (transition -> timeoutMs)
+    // TODO: Should this default to a JND instead?
+    var timeoutMs = suspenseConfig.timeoutMs | 0 || DEFAULT_TIMEOUT_MS;
+    var timeoutTime = eventTime + timeoutMs;
+
+    if (timeoutTime > workInProgressRootLatestSuspenseTimeout) {
+      workInProgressRootLatestSuspenseTimeout = timeoutTime;
+      workInProgressRootCanSuspendUsingConfig = suspenseConfig;
+    }
+  }
+}
+function markSkippedUpdateLanes(lane) {
+  workInProgressRootSkippedLanes = mergeLanes(
+    lane,
+    workInProgressRootSkippedLanes
+  );
+}
+function renderDidSuspend() {
+  if (workInProgressRootExitStatus === RootIncomplete) {
+    workInProgressRootExitStatus = RootSuspended;
+  }
+}
+function renderDidSuspendDelayIfPossible() {
+  if (
+    workInProgressRootExitStatus === RootIncomplete ||
+    workInProgressRootExitStatus === RootSuspended
+  ) {
+    workInProgressRootExitStatus = RootSuspendedWithDelay;
+  } // Check if there are updates that we skipped tree that might have unblocked
+  // this render.
 
-  if (!isRootSuspendedAtTime(root, firstPendingTime)) {
-    // The highest priority pending time is not suspended. Let's work on that.
-    return firstPendingTime;
-  } // If the first pending time is suspended, check if there's a lower priority
-  // pending level that we know about. Or check if we received a ping. Work
-  // on whichever is higher priority.
+  if (
+    workInProgressRoot !== null &&
+    (includesNonIdleWork(workInProgressRootSkippedLanes) ||
+      includesNonIdleWork(workInProgressRootUpdatedLanes))
+  ) {
+    // Mark the current render as suspended so that we switch to working on
+    // the updates that were skipped. Usually we only suspend at the end of
+    // the render phase.
+    // TODO: We should probably always mark the root as suspended immediately
+    // (inside this function), since by suspending at the end of the render
+    // phase introduces a potential mistake where we suspend lanes that were
+    // pinged or updated while we were rendering.
+    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
+  }
+}
+function renderDidError() {
+  if (workInProgressRootExitStatus !== RootCompleted) {
+    workInProgressRootExitStatus = RootErrored;
+  }
+} // Called during render to determine if anything has suspended.
+// Returns false if we're not sure.
 
-  var lastPingedTime = root.lastPingedTime;
-  var nextKnownPendingLevel = root.nextKnownPendingLevel;
-  var nextLevel =
-    lastPingedTime > nextKnownPendingLevel
-      ? lastPingedTime
-      : nextKnownPendingLevel;
+function renderHasNotSuspendedYet() {
+  // If something errored or completed, we can't really be sure,
+  // so those are false.
+  return workInProgressRootExitStatus === RootIncomplete;
+}
 
-  if (nextLevel <= Idle && firstPendingTime !== nextLevel) {
-    // Don't work on Idle/Never priority unless everything else is committed.
-    return NoWork;
-  }
+function renderRootSync(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= RenderContext;
+  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
+  // and prepare a fresh one. Otherwise we'll continue where we left off.
 
-  return nextLevel;
-} // Use this function to schedule a task for a root. There's only one task per
-// root; if a task was already scheduled, we'll check to make sure the
-// expiration time of the existing task is the same as the expiration time of
-// the next level that the root has work on. This function is called on every
-// update, and right before exiting a task.
-
-function ensureRootIsScheduled(root) {
-  var lastExpiredTime = root.lastExpiredTime;
-
-  if (lastExpiredTime !== NoWork) {
-    // Special case: Expired work should flush synchronously.
-    root.callbackExpirationTime = Sync;
-    root.callbackPriority = ImmediatePriority;
-    root.callbackNode = scheduleSyncCallback(
-      performSyncWorkOnRoot.bind(null, root)
-    );
-    return;
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
+    prepareFreshStack(root, lanes);
+    startWorkOnPendingInteractions(root, lanes);
   }
 
-  var expirationTime = getNextRootExpirationTimeToWorkOn(root);
-  var existingCallbackNode = root.callbackNode;
+  var prevInteractions = pushInteractions(root);
 
-  if (expirationTime === NoWork) {
-    // There's nothing to work on.
-    if (existingCallbackNode !== null) {
-      root.callbackNode = null;
-      root.callbackExpirationTime = NoWork;
-      root.callbackPriority = NoPriority;
+  do {
+    try {
+      workLoopSync();
+      break;
+    } catch (thrownValue) {
+      handleError(root, thrownValue);
     }
+  } while (true);
 
-    return;
-  } // TODO: If this is an update, we already read the current time. Pass the
-  // time as an argument.
-
-  var currentTime = requestCurrentTimeForUpdate();
-  var priorityLevel = inferPriorityFromExpirationTime(
-    currentTime,
-    expirationTime
-  ); // If there's an existing render task, confirm it has the correct priority and
-  // expiration time. Otherwise, we'll cancel it and schedule a new one.
+  resetContextDependencies();
 
-  if (existingCallbackNode !== null) {
-    var existingCallbackPriority = root.callbackPriority;
-    var existingCallbackExpirationTime = root.callbackExpirationTime;
+  {
+    popInteractions(prevInteractions);
+  }
 
-    if (
-      // Callback must have the exact same expiration time.
-      existingCallbackExpirationTime === expirationTime && // Callback must have greater or equal priority.
-      existingCallbackPriority >= priorityLevel
-    ) {
-      // Existing callback is sufficient.
-      return;
-    } // Need to schedule a new task.
-    // TODO: Instead of scheduling a new task, we should be able to change the
-    // priority of the existing one.
+  executionContext = prevExecutionContext;
+  popDispatcher(prevDispatcher);
 
-    cancelCallback(existingCallbackNode);
+  if (workInProgress !== null) {
+    // This is a sync render, so we should have finished the whole tree.
+    {
+      throw Error(
+        "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
+      );
+    }
   }
 
-  root.callbackExpirationTime = expirationTime;
-  root.callbackPriority = priorityLevel;
-  var callbackNode;
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = NoLanes;
+  return workInProgressRootExitStatus;
+} // The work loop is an extremely hot path. Tell Closure not to inline it.
 
-  if (expirationTime === Sync) {
-    // Sync React callbacks are scheduled on a special internal queue
-    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
-  } else {
-    callbackNode = scheduleCallback(
-      priorityLevel,
-      performConcurrentWorkOnRoot.bind(null, root), // Compute a task timeout based on the expiration time. This also affects
-      // ordering because tasks are processed in timeout order.
-      {
-        timeout: expirationTimeToMs(expirationTime) - now()
-      }
-    );
+/** @noinline */
+
+function workLoopSync() {
+  // Already timed out, so perform work without checking if we need to yield.
+  while (workInProgress !== null) {
+    performUnitOfWork(workInProgress);
   }
+}
 
-  root.callbackNode = callbackNode;
-} // This is the entry point for every concurrent task, i.e. anything that
-// goes through Scheduler.
+function renderRootConcurrent(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= RenderContext;
+  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
+  // and prepare a fresh one. Otherwise we'll continue where we left off.
 
-function performConcurrentWorkOnRoot(root, didTimeout) {
-  // Since we know we're in a React event, we can clear the current
-  // event time. The next update will compute a new event time.
-  currentEventTime = NoWork; // Check if the render expired.
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
+    prepareFreshStack(root, lanes);
+    startWorkOnPendingInteractions(root, lanes);
+  }
 
-  if (didTimeout) {
-    // The render task took too long to complete. Mark the current time as
-    // expired to synchronously render all expired work in a single batch.
-    var currentTime = requestCurrentTimeForUpdate();
-    markRootExpiredAtTime(root, currentTime); // This will schedule a synchronous callback.
+  var prevInteractions = pushInteractions(root);
 
-    ensureRootIsScheduled(root);
-    return null;
-  } // Determine the next expiration time to work on, using the fields stored
-  // on the root.
+  do {
+    try {
+      workLoopConcurrent();
+      break;
+    } catch (thrownValue) {
+      handleError(root, thrownValue);
+    }
+  } while (true);
 
-  var expirationTime = getNextRootExpirationTimeToWorkOn(root);
+  resetContextDependencies();
 
-  if (expirationTime === NoWork) {
-    return null;
+  {
+    popInteractions(prevInteractions);
   }
 
-  var originalCallbackNode = root.callbackNode;
+  popDispatcher(prevDispatcher);
+  executionContext = prevExecutionContext;
 
-  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
-    throw Error("Should not already be working.");
-  }
+  if (workInProgress !== null) {
+    return RootIncomplete;
+  } else {
+    workInProgressRoot = null;
+    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.
 
-  flushPassiveEffects();
-  var exitStatus = renderRootConcurrent(root, expirationTime);
+    return workInProgressRootExitStatus;
+  }
+}
+/** @noinline */
 
-  if (exitStatus !== RootIncomplete) {
-    if (exitStatus === RootErrored) {
-      // If something threw an error, try rendering one more time. We'll
-      // render synchronously to block concurrent data mutations, and we'll
-      // render at Idle (or lower) so that all pending updates are included.
-      // If it still fails after the second attempt, we'll give up and commit
-      // the resulting tree.
-      expirationTime = expirationTime > Idle ? Idle : expirationTime;
-      exitStatus = renderRootSync(root, expirationTime);
-    }
+function workLoopConcurrent() {
+  // Perform work until Scheduler asks us to yield
+  while (workInProgress !== null && !shouldYield()) {
+    performUnitOfWork(workInProgress);
+  }
+}
 
-    if (exitStatus === RootFatalErrored) {
-      var fatalError = workInProgressRootFatalError;
-      prepareFreshStack(root, expirationTime);
-      markRootSuspendedAtTime(root, expirationTime);
-      ensureRootIsScheduled(root);
-      throw fatalError;
-    } // We now have a consistent tree. The next step is either to commit it,
-    // or, if something suspended, wait to commit it after a timeout.
+function performUnitOfWork(unitOfWork) {
+  // The current, flushed, state of this fiber is the alternate. Ideally
+  // nothing should rely on this, but relying on it here means that we don't
+  // need an additional field on the work in progress.
+  var current = unitOfWork.alternate;
+  setCurrentFiber(unitOfWork);
+  var next;
 
-    var finishedWork = (root.finishedWork = root.current.alternate);
-    root.finishedExpirationTime = expirationTime;
-    finishConcurrentRender(root, finishedWork, exitStatus, expirationTime);
+  if ((unitOfWork.mode & ProfileMode) !== NoMode) {
+    startProfilerTimer(unitOfWork);
+    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
+    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
+  } else {
+    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
   }
 
-  ensureRootIsScheduled(root);
+  resetCurrentFiber();
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
 
-  if (root.callbackNode === originalCallbackNode) {
-    // The task node scheduled for this root is the same one that's
-    // currently executed. Need to return a continuation.
-    return performConcurrentWorkOnRoot.bind(null, root);
+  if (next === null) {
+    // If this doesn't spawn new work, complete the current work.
+    completeUnitOfWork(unitOfWork);
+  } else {
+    workInProgress = next;
   }
 
-  return null;
+  ReactCurrentOwner$2.current = null;
 }
 
-function finishConcurrentRender(
-  root,
-  finishedWork,
-  exitStatus,
-  expirationTime
-) {
-  switch (exitStatus) {
-    case RootIncomplete:
-    case RootFatalErrored: {
-      {
-        throw Error("Root did not complete. This is a bug in React.");
-      }
-    }
-    // Flow knows about invariant, so it complains if I add a break
-    // statement, but eslint doesn't know about invariant, so it complains
-    // if I do. eslint-disable-next-line no-fallthrough
+function completeUnitOfWork(unitOfWork) {
+  // Attempt to complete the current unit of work, then move to the next
+  // sibling. If there are no more siblings, return to the parent fiber.
+  var completedWork = unitOfWork;
 
-    case RootErrored: {
-      // We should have already attempted to retry this tree. If we reached
-      // this point, it errored again. Commit it.
-      commitRoot(root);
-      break;
-    }
+  do {
+    // The current, flushed, state of this fiber is the alternate. Ideally
+    // nothing should rely on this, but relying on it here means that we don't
+    // need an additional field on the work in progress.
+    var current = completedWork.alternate;
+    var returnFiber = completedWork.return; // Check if the work completed or if something threw.
 
-    case RootSuspended: {
-      markRootSuspendedAtTime(root, expirationTime);
-      var lastSuspendedTime = root.lastSuspendedTime;
+    if ((completedWork.effectTag & Incomplete) === NoEffect) {
+      setCurrentFiber(completedWork);
+      var next = void 0;
 
-      if (expirationTime === lastSuspendedTime) {
-        root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
-      } // We have an acceptable loading state. We need to figure out if we
-      // should immediately commit it or wait a bit.
-      // If we have processed new updates during this render, we may now
-      // have a new loading state ready. We want to ensure that we commit
-      // that as soon as possible.
+      if ((completedWork.mode & ProfileMode) === NoMode) {
+        next = completeWork(current, completedWork, subtreeRenderLanes);
+      } else {
+        startProfilerTimer(completedWork);
+        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.
+
+        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
+      }
+
+      resetCurrentFiber();
+
+      if (next !== null) {
+        // Completing this fiber spawned new work. Work on that next.
+        workInProgress = next;
+        return;
+      }
 
-      var hasNotProcessedNewUpdates =
-        workInProgressRootLatestProcessedExpirationTime === Sync;
+      resetChildLanes(completedWork);
 
       if (
-        hasNotProcessedNewUpdates && // do not delay if we're inside an act() scope
-        !IsThisRendererActing.current
+        returnFiber !== null && // Do not append effects to parents if a sibling failed to complete
+        (returnFiber.effectTag & Incomplete) === NoEffect
       ) {
-        // If we have not processed any new updates during this pass, then
-        // this is either a retry of an existing fallback state or a
-        // hidden tree. Hidden trees shouldn't be batched with other work
-        // and after that's fixed it can only be a retry. We're going to
-        // throttle committing retries so that we don't show too many
-        // loading states too quickly.
-        var msUntilTimeout =
-          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.
+        // Append all the effects of the subtree and this fiber onto the effect
+        // list of the parent. The completion order of the children affects the
+        // side-effect order.
+        if (returnFiber.firstEffect === null) {
+          returnFiber.firstEffect = completedWork.firstEffect;
+        }
 
-        if (msUntilTimeout > 10) {
-          if (workInProgressRootHasPendingPing) {
-            var lastPingedTime = root.lastPingedTime;
-
-            if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {
-              // This render was pinged but we didn't get to restart
-              // earlier so try restarting now instead.
-              root.lastPingedTime = expirationTime;
-              prepareFreshStack(root, expirationTime);
-              break;
-            }
+        if (completedWork.lastEffect !== null) {
+          if (returnFiber.lastEffect !== null) {
+            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
           }
 
-          var nextTime = getNextRootExpirationTimeToWorkOn(root);
+          returnFiber.lastEffect = completedWork.lastEffect;
+        } // If this fiber had side-effects, we append it AFTER the children's
+        // side-effects. We can perform certain side-effects earlier if needed,
+        // by doing multiple passes over the effect list. We don't want to
+        // schedule our own side-effect on our own list because if end up
+        // reusing children we'll schedule this effect onto itself since we're
+        // at the end.
+
+        var effectTag = completedWork.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect
+        // list. PerformedWork effect is read by React DevTools but shouldn't be
+        // committed.
 
-          if (nextTime !== NoWork && nextTime !== expirationTime) {
-            // There's additional work on this root.
-            break;
+        if (effectTag > PerformedWork) {
+          if (returnFiber.lastEffect !== null) {
+            returnFiber.lastEffect.nextEffect = completedWork;
+          } else {
+            returnFiber.firstEffect = completedWork;
           }
 
-          if (
-            lastSuspendedTime !== NoWork &&
-            lastSuspendedTime !== expirationTime
-          ) {
-            // We should prefer to render the fallback of at the last
-            // suspended level. Ping the last suspended level to try
-            // rendering it again.
-            root.lastPingedTime = lastSuspendedTime;
-            break;
-          } // The render is suspended, it hasn't timed out, and there's no
-          // lower priority work to do. Instead of committing the fallback
-          // immediately, wait for more data to arrive.
-
-          root.timeoutHandle = scheduleTimeout(
-            commitRoot.bind(null, root),
-            msUntilTimeout
-          );
-          break;
+          returnFiber.lastEffect = completedWork;
         }
-      } // The work expired. Commit immediately.
+      }
+    } else {
+      // This fiber did not complete because something threw. Pop values off
+      // the stack without entering the complete phase. If this is a boundary,
+      // capture values if possible.
+      var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.
 
-      commitRoot(root);
-      break;
-    }
+      if (_next !== null) {
+        // If completing this work spawned new work, do that next. We'll come
+        // back here again.
+        // Since we're restarting, remove anything that is not a host effect
+        // from the effect tag.
+        _next.effectTag &= HostEffectMask;
+        workInProgress = _next;
+        return;
+      }
 
-    case RootSuspendedWithDelay: {
-      markRootSuspendedAtTime(root, expirationTime);
-      var _lastSuspendedTime = root.lastSuspendedTime;
+      if ((completedWork.mode & ProfileMode) !== NoMode) {
+        // Record the render duration for the fiber that errored.
+        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.
 
-      if (expirationTime === _lastSuspendedTime) {
-        root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
-      }
+        var actualDuration = completedWork.actualDuration;
+        var child = completedWork.child;
 
-      {
-        // We're suspended in a state that should be avoided. We'll try to
-        // avoid committing it for as long as the timeouts let us.
-        if (workInProgressRootHasPendingPing) {
-          var _lastPingedTime = root.lastPingedTime;
-
-          if (_lastPingedTime === NoWork || _lastPingedTime >= expirationTime) {
-            // This render was pinged but we didn't get to restart earlier
-            // so try restarting now instead.
-            root.lastPingedTime = expirationTime;
-            prepareFreshStack(root, expirationTime);
-            break;
-          }
+        while (child !== null) {
+          actualDuration += child.actualDuration;
+          child = child.sibling;
         }
 
-        var _nextTime = getNextRootExpirationTimeToWorkOn(root);
+        completedWork.actualDuration = actualDuration;
+      }
 
-        if (_nextTime !== NoWork && _nextTime !== expirationTime) {
-          // There's additional work on this root.
-          break;
-        }
+      if (returnFiber !== null) {
+        // Mark the parent fiber as incomplete and clear its effect list.
+        returnFiber.firstEffect = returnFiber.lastEffect = null;
+        returnFiber.effectTag |= Incomplete;
+      }
+    }
 
-        if (
-          _lastSuspendedTime !== NoWork &&
-          _lastSuspendedTime !== expirationTime
-        ) {
-          // We should prefer to render the fallback of at the last
-          // suspended level. Ping the last suspended level to try
-          // rendering it again.
-          root.lastPingedTime = _lastSuspendedTime;
-          break;
-        }
+    var siblingFiber = completedWork.sibling;
 
-        var _msUntilTimeout;
+    if (siblingFiber !== null) {
+      // If there is more work to do in this returnFiber, do that next.
+      workInProgress = siblingFiber;
+      return;
+    } // Otherwise, return to the parent
 
-        if (workInProgressRootLatestSuspenseTimeout !== Sync) {
-          // We have processed a suspense config whose expiration time we
-          // can use as the timeout.
-          _msUntilTimeout =
-            expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();
-        } else if (workInProgressRootLatestProcessedExpirationTime === Sync) {
-          // This should never normally happen because only new updates
-          // cause delayed states, so we should have processed something.
-          // However, this could also happen in an offscreen tree.
-          _msUntilTimeout = 0;
-        } else {
-          // If we don't have a suspense config, we're going to use a
-          // heuristic to determine how long we can suspend.
-          var eventTimeMs = inferTimeFromExpirationTime(
-            workInProgressRootLatestProcessedExpirationTime
-          );
-          var currentTimeMs = now();
-          var timeUntilExpirationMs =
-            expirationTimeToMs(expirationTime) - currentTimeMs;
-          var timeElapsed = currentTimeMs - eventTimeMs;
-
-          if (timeElapsed < 0) {
-            // We get this wrong some time since we estimate the time.
-            timeElapsed = 0;
-          }
+    completedWork = returnFiber; // Update the next thing we're working on in case something throws.
 
-          _msUntilTimeout = jnd(timeElapsed) - timeElapsed; // Clamp the timeout to the expiration time. TODO: Once the
-          // event time is exact instead of inferred from expiration time
-          // we don't need this.
+    workInProgress = completedWork;
+  } while (completedWork !== null); // We've reached the root.
 
-          if (timeUntilExpirationMs < _msUntilTimeout) {
-            _msUntilTimeout = timeUntilExpirationMs;
-          }
-        } // Don't bother with a very short suspense time.
+  if (workInProgressRootExitStatus === RootIncomplete) {
+    workInProgressRootExitStatus = RootCompleted;
+  }
+}
 
-        if (_msUntilTimeout > 10) {
-          // The render is suspended, it hasn't timed out, and there's no
-          // lower priority work to do. Instead of committing the fallback
-          // immediately, wait for more data to arrive.
-          root.timeoutHandle = scheduleTimeout(
-            commitRoot.bind(null, root),
-            _msUntilTimeout
-          );
-          break;
-        }
-      } // The work expired. Commit immediately.
+function resetChildLanes(completedWork) {
+  if (
+    // TODO: Move this check out of the hot path by moving `resetChildLanes`
+    // to switch statement in `completeWork`.
+    (completedWork.tag === LegacyHiddenComponent ||
+      completedWork.tag === OffscreenComponent) &&
+    completedWork.memoizedState !== null &&
+    !includesSomeLane(subtreeRenderLanes, OffscreenLane) &&
+    (completedWork.mode & ConcurrentMode) !== NoLanes
+  ) {
+    // The children of this component are hidden. Don't bubble their
+    // expiration times.
+    return;
+  }
 
-      commitRoot(root);
-      break;
-    }
+  var newChildLanes = NoLanes; // Bubble up the earliest expiration time.
 
-    case RootCompleted: {
-      // The work completed. Ready to commit.
-      if (
-        // do not delay if we're inside an act() scope
-        workInProgressRootLatestProcessedExpirationTime !== Sync &&
-        workInProgressRootCanSuspendUsingConfig !== null
-      ) {
-        // If we have exceeded the minimum loading delay, which probably
-        // means we have shown a spinner already, we might have to suspend
-        // a bit longer to ensure that the spinner is shown for
-        // enough time.
-        var _msUntilTimeout2 = computeMsUntilSuspenseLoadingDelay(
-          workInProgressRootLatestProcessedExpirationTime,
-          expirationTime,
-          workInProgressRootCanSuspendUsingConfig
-        );
+  if ((completedWork.mode & ProfileMode) !== NoMode) {
+    // In profiling mode, resetChildExpirationTime is also used to reset
+    // profiler durations.
+    var actualDuration = completedWork.actualDuration;
+    var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
+    // only be updated if work is done on the fiber (i.e. it doesn't bailout).
+    // When work is done, it should bubble to the parent's actualDuration. If
+    // the fiber has not been cloned though, (meaning no work was done), then
+    // this value will reflect the amount of time spent working on a previous
+    // render. In that case it should not bubble. We determine whether it was
+    // cloned by comparing the child pointer.
 
-        if (_msUntilTimeout2 > 10) {
-          markRootSuspendedAtTime(root, expirationTime);
-          root.timeoutHandle = scheduleTimeout(
-            commitRoot.bind(null, root),
-            _msUntilTimeout2
-          );
-          break;
-        }
-      }
+    var shouldBubbleActualDurations =
+      completedWork.alternate === null ||
+      completedWork.child !== completedWork.alternate.child;
+    var child = completedWork.child;
 
-      commitRoot(root);
-      break;
-    }
+    while (child !== null) {
+      newChildLanes = mergeLanes(
+        newChildLanes,
+        mergeLanes(child.lanes, child.childLanes)
+      );
 
-    default: {
-      {
-        throw Error("Unknown root exit status.");
+      if (shouldBubbleActualDurations) {
+        actualDuration += child.actualDuration;
       }
+
+      treeBaseDuration += child.treeBaseDuration;
+      child = child.sibling;
     }
-  }
-} // This is the entry point for synchronous tasks that don't go
-// through Scheduler
 
-function performSyncWorkOnRoot(root) {
-  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
-    throw Error("Should not already be working.");
-  }
+    var isTimedOutSuspense =
+      completedWork.tag === SuspenseComponent &&
+      completedWork.memoizedState !== null;
 
-  flushPassiveEffects();
-  var lastExpiredTime = root.lastExpiredTime;
-  var expirationTime;
+    if (isTimedOutSuspense) {
+      // Don't count time spent in a timed out Suspense subtree as part of the base duration.
+      var primaryChildFragment = completedWork.child;
 
-  if (lastExpiredTime !== NoWork) {
-    // There's expired work on this root. Check if we have a partial tree
-    // that we can reuse.
-    if (
-      root === workInProgressRoot &&
-      renderExpirationTime$1 >= lastExpiredTime
-    ) {
-      // There's a partial tree with equal or greater than priority than the
-      // expired level. Finish rendering it before rendering the rest of the
-      // expired work.
-      expirationTime = renderExpirationTime$1;
-    } else {
-      // Start a fresh tree.
-      expirationTime = lastExpiredTime;
+      if (primaryChildFragment !== null) {
+        treeBaseDuration -= primaryChildFragment.treeBaseDuration;
+      }
     }
-  } else {
-    // There's no expired work. This must be a new, synchronous render.
-    expirationTime = Sync;
-  }
 
-  var exitStatus = renderRootSync(root, expirationTime);
+    completedWork.actualDuration = actualDuration;
+    completedWork.treeBaseDuration = treeBaseDuration;
+  } else {
+    var _child = completedWork.child;
 
-  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
-    // If something threw an error, try rendering one more time. We'll
-    // render synchronously to block concurrent data mutations, and we'll
-    // render at Idle (or lower) so that all pending updates are included.
-    // If it still fails after the second attempt, we'll give up and commit
-    // the resulting tree.
-    expirationTime = expirationTime > Idle ? Idle : expirationTime;
-    exitStatus = renderRootSync(root, expirationTime);
+    while (_child !== null) {
+      newChildLanes = mergeLanes(
+        newChildLanes,
+        mergeLanes(_child.lanes, _child.childLanes)
+      );
+      _child = _child.sibling;
+    }
   }
 
-  if (exitStatus === RootFatalErrored) {
-    var fatalError = workInProgressRootFatalError;
-    prepareFreshStack(root, expirationTime);
-    markRootSuspendedAtTime(root, expirationTime);
-    ensureRootIsScheduled(root);
-    throw fatalError;
-  } // We now have a consistent tree. Because this is a sync render, we
-  // will commit it even if something suspended.
-
-  root.finishedWork = root.current.alternate;
-  root.finishedExpirationTime = expirationTime;
-  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
-  // pending level.
+  completedWork.childLanes = newChildLanes;
+}
 
-  ensureRootIsScheduled(root);
+function commitRoot(root) {
+  var renderPriorityLevel = getCurrentPriorityLevel();
+  runWithPriority(
+    ImmediatePriority$1,
+    commitRootImpl.bind(null, root, renderPriorityLevel)
+  );
   return null;
 }
-function syncUpdates(fn, a, b, c) {
-  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));
-}
 
-function batchedUpdates$1(fn, a) {
-  var prevExecutionContext = executionContext;
-  executionContext |= BatchedContext;
+function commitRootImpl(root, renderPriorityLevel) {
+  do {
+    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
+    // means `flushPassiveEffects` will sometimes result in additional
+    // passive effects. So we need to keep flushing in a loop until there are
+    // no more pending effects.
+    // TODO: Might be better if `flushPassiveEffects` did not automatically
+    // flush synchronous work at the end, to avoid factoring hazards like this.
+    flushPassiveEffects();
+  } while (rootWithPendingPassiveEffects !== null);
 
-  try {
-    return fn(a);
-  } finally {
-    executionContext = prevExecutionContext;
+  flushRenderPhaseStrictModeWarningsInDEV();
 
-    if (executionContext === NoContext) {
-      // Flush the immediate callbacks that were scheduled during this batch
-      flushSyncCallbackQueue();
-    }
-  }
-}
-function flushSync(fn, a) {
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
-    {
-      throw Error(
-        "flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering."
-      );
-    }
+  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
+    throw Error("Should not already be working.");
   }
 
-  var prevExecutionContext = executionContext;
-  executionContext |= BatchedContext;
-
-  try {
-    return runWithPriority(ImmediatePriority, fn.bind(null, a));
-  } finally {
-    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
-    // Note that this will happen even if batchedUpdates is higher up
-    // the stack.
+  var finishedWork = root.finishedWork;
+  var lanes = root.finishedLanes;
 
-    flushSyncCallbackQueue();
+  if (finishedWork === null) {
+    return null;
   }
-}
 
-function prepareFreshStack(root, expirationTime) {
   root.finishedWork = null;
-  root.finishedExpirationTime = NoWork;
-  var timeoutHandle = root.timeoutHandle;
+  root.finishedLanes = NoLanes;
 
-  if (timeoutHandle !== noTimeout) {
-    // The root previous suspended and scheduled a timeout to commit a fallback
-    // state. Now that we have additional work, cancel the timeout.
-    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
+  if (!(finishedWork !== root.current)) {
+    throw Error(
+      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
+    );
+  } // commitRoot never returns a continuation; it always finishes synchronously.
+  // So we can clear these now to allow a new callback to be scheduled.
 
-    cancelTimeout(timeoutHandle);
-  }
+  root.callbackNode = null; // Update the first and last pending times on this root. The new first
+  // pending time is whatever is left on the root fiber.
 
-  if (workInProgress !== null) {
-    var interruptedWork = workInProgress.return;
+  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
+  markRootFinished(root, remainingLanes); // Clear already finished discrete updates in case that a later call of
+  // `flushDiscreteUpdates` starts a useless render pass which may cancels
+  // a scheduled timeout.
 
-    while (interruptedWork !== null) {
-      unwindInterruptedWork(interruptedWork);
-      interruptedWork = interruptedWork.return;
+  if (rootsWithPendingDiscreteUpdates !== null) {
+    if (
+      !hasDiscreteLanes(remainingLanes) &&
+      rootsWithPendingDiscreteUpdates.has(root)
+    ) {
+      rootsWithPendingDiscreteUpdates.delete(root);
     }
   }
 
-  workInProgressRoot = root;
-  workInProgress = createWorkInProgress(root.current, null);
-  renderExpirationTime$1 = expirationTime;
-  workInProgressRootExitStatus = RootIncomplete;
-  workInProgressRootFatalError = null;
-  workInProgressRootLatestProcessedExpirationTime = Sync;
-  workInProgressRootLatestSuspenseTimeout = Sync;
-  workInProgressRootCanSuspendUsingConfig = null;
-  workInProgressRootNextUnprocessedUpdateTime = NoWork;
-  workInProgressRootHasPendingPing = false;
+  if (root === workInProgressRoot) {
+    // We can reset these now that they are finished.
+    workInProgressRoot = null;
+    workInProgress = null;
+    workInProgressRootRenderLanes = NoLanes;
+  } // This indicates that the last root we worked on is not the same one that
+  // we're committing now. This most commonly happens when a suspended root
+  // times out.
+  // Get the list of effects.
 
-  {
-    spawnedWorkDuringRender = null;
-  }
+  var firstEffect;
 
-  {
-    ReactStrictModeWarnings.discardPendingWarnings();
+  if (finishedWork.effectTag > PerformedWork) {
+    // A fiber's effect list consists only of its children, not itself. So if
+    // the root has an effect, we need to add it to the end of the list. The
+    // resulting list is the set that would belong to the root's parent, if it
+    // had one; that is, all the effects in the tree including the root.
+    if (finishedWork.lastEffect !== null) {
+      finishedWork.lastEffect.nextEffect = finishedWork;
+      firstEffect = finishedWork.firstEffect;
+    } else {
+      firstEffect = finishedWork;
+    }
+  } else {
+    // There is no effect on the root.
+    firstEffect = finishedWork.firstEffect;
   }
-}
 
-function handleError(root, thrownValue) {
-  do {
-    try {
-      // Reset module-level state that was set during the render phase.
-      resetContextDependencies();
-      resetHooksAfterThrow();
-      resetCurrentFiber();
+  if (firstEffect !== null) {
+    var prevExecutionContext = executionContext;
+    executionContext |= CommitContext;
+    var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles
 
-      if (workInProgress === null || workInProgress.return === null) {
-        // Expected to be working on a non-root fiber. This is a fatal error
-        // because there's no ancestor that can handle it; the root is
-        // supposed to capture all errors that weren't caught by an error
-        // boundary.
-        workInProgressRootExitStatus = RootFatalErrored;
-        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
-        // sibling, or the parent if there are no siblings. But since the root
-        // has no siblings nor a parent, we set it to null. Usually this is
-        // handled by `completeUnitOfWork` or `unwindWork`, but since we're
-        // interntionally not calling those, we need set it here.
-        // TODO: Consider calling `unwindWork` to pop the contexts.
+    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
+    // of the effect list for each phase: all mutation effects come before all
+    // layout effects, and so on.
+    // The first phase a "before mutation" phase. We use this phase to read the
+    // state of the host tree right before we mutate it. This is where
+    // getSnapshotBeforeUpdate is called.
 
-        workInProgress = null;
-        return null;
+    focusedInstanceHandle = prepareForCommit(root.containerInfo);
+    shouldFireAfterActiveInstanceBlur = false;
+    nextEffect = firstEffect;
+
+    do {
+      {
+        invokeGuardedCallback(null, commitBeforeMutationEffects, null);
+
+        if (hasCaughtError()) {
+          if (!(nextEffect !== null)) {
+            throw Error("Should be working on an effect.");
+          }
+
+          var error = clearCaughtError();
+          captureCommitPhaseError(nextEffect, error);
+          nextEffect = nextEffect.nextEffect;
+        }
       }
+    } while (nextEffect !== null); // We no longer need to track the active instance fiber
 
-      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
-        // Record the time spent rendering before an error was thrown. This
-        // avoids inaccurate Profiler durations in the case of a
-        // suspended render.
-        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
+    focusedInstanceHandle = null;
+
+    {
+      // Mark the current commit time to be shared by all Profilers in this
+      // batch. This enables them to be grouped later.
+      recordCommitTime();
+    } // The next phase is the mutation phase, where we mutate the host tree.
+
+    nextEffect = firstEffect;
+
+    do {
+      {
+        invokeGuardedCallback(
+          null,
+          commitMutationEffects,
+          null,
+          root,
+          renderPriorityLevel
+        );
+
+        if (hasCaughtError()) {
+          if (!(nextEffect !== null)) {
+            throw Error("Should be working on an effect.");
+          }
+
+          var _error = clearCaughtError();
+
+          captureCommitPhaseError(nextEffect, _error);
+          nextEffect = nextEffect.nextEffect;
+        }
       }
+    } while (nextEffect !== null);
+
+    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
+    // the mutation phase, so that the previous tree is still current during
+    // componentWillUnmount, but before the layout phase, so that the finished
+    // work is current during componentDidMount/Update.
+
+    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
+    // the host tree after it's been mutated. The idiomatic use case for this is
+    // layout, but class component lifecycles also fire here for legacy reasons.
 
-      throwException(
-        root,
-        workInProgress.return,
-        workInProgress,
-        thrownValue,
-        renderExpirationTime$1
-      );
-      workInProgress = completeUnitOfWork(workInProgress);
-    } catch (yetAnotherThrownValue) {
-      // Something in the return path also threw.
-      thrownValue = yetAnotherThrownValue;
-      continue;
-    } // Return to the normal work loop.
+    nextEffect = firstEffect;
 
-    return;
-  } while (true);
-}
+    do {
+      {
+        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);
 
-function pushDispatcher(root) {
-  var prevDispatcher = ReactCurrentDispatcher$1.current;
-  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+        if (hasCaughtError()) {
+          if (!(nextEffect !== null)) {
+            throw Error("Should be working on an effect.");
+          }
 
-  if (prevDispatcher === null) {
-    // The React isomorphic package does not include a default dispatcher.
-    // Instead the first renderer will lazily attach one, in order to give
-    // nicer error messages.
-    return ContextOnlyDispatcher;
-  } else {
-    return prevDispatcher;
-  }
-}
+          var _error2 = clearCaughtError();
 
-function popDispatcher(prevDispatcher) {
-  ReactCurrentDispatcher$1.current = prevDispatcher;
-}
+          captureCommitPhaseError(nextEffect, _error2);
+          nextEffect = nextEffect.nextEffect;
+        }
+      }
+    } while (nextEffect !== null);
 
-function pushInteractions(root) {
-  {
-    var prevInteractions = tracing.__interactionsRef.current;
-    tracing.__interactionsRef.current = root.memoizedInteractions;
-    return prevInteractions;
-  }
-}
+    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
+    // opportunity to paint.
 
-function popInteractions(prevInteractions) {
-  {
-    tracing.__interactionsRef.current = prevInteractions;
-  }
-}
+    requestPaint();
 
-function markCommitTimeOfFallback() {
-  globalMostRecentFallbackTime = now();
-}
-function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {
-  if (
-    expirationTime < workInProgressRootLatestProcessedExpirationTime &&
-    expirationTime > Idle
-  ) {
-    workInProgressRootLatestProcessedExpirationTime = expirationTime;
-  }
+    {
+      popInteractions(prevInteractions);
+    }
 
-  if (suspenseConfig !== null) {
-    if (
-      expirationTime < workInProgressRootLatestSuspenseTimeout &&
-      expirationTime > Idle
-    ) {
-      workInProgressRootLatestSuspenseTimeout = expirationTime; // Most of the time we only have one config and getting wrong is not bad.
+    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.
+  } else {
+    // No effects.
+    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
+    // no effects.
+    // TODO: Maybe there's a better way to report this.
 
-      workInProgressRootCanSuspendUsingConfig = suspenseConfig;
+    {
+      recordCommitTime();
     }
   }
-}
-function markUnprocessedUpdateTime(expirationTime) {
-  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {
-    workInProgressRootNextUnprocessedUpdateTime = expirationTime;
-  }
-}
-function renderDidSuspend() {
-  if (workInProgressRootExitStatus === RootIncomplete) {
-    workInProgressRootExitStatus = RootSuspended;
-  }
-}
-function renderDidSuspendDelayIfPossible() {
-  if (
-    workInProgressRootExitStatus === RootIncomplete ||
-    workInProgressRootExitStatus === RootSuspended
-  ) {
-    workInProgressRootExitStatus = RootSuspendedWithDelay;
-  } // Check if there's a lower priority update somewhere else in the tree.
 
-  if (
-    workInProgressRootNextUnprocessedUpdateTime !== NoWork &&
-    workInProgressRoot !== null
-  ) {
-    // Mark the current render as suspended, and then mark that there's a
-    // pending update.
-    // TODO: This should immediately interrupt the current render, instead
-    // of waiting until the next time we yield.
-    markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime$1);
-    markRootUpdatedAtTime(
-      workInProgressRoot,
-      workInProgressRootNextUnprocessedUpdateTime
-    );
-  }
-}
-function renderDidError() {
-  if (workInProgressRootExitStatus !== RootCompleted) {
-    workInProgressRootExitStatus = RootErrored;
-  }
-} // Called during render to determine if anything has suspended.
-// Returns false if we're not sure.
+  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
 
-function renderHasNotSuspendedYet() {
-  // If something errored or completed, we can't really be sure,
-  // so those are false.
-  return workInProgressRootExitStatus === RootIncomplete;
-}
+  if (rootDoesHavePassiveEffects) {
+    // This commit has passive effects. Stash a reference to them. But don't
+    // schedule a callback until after flushing layout work.
+    rootDoesHavePassiveEffects = false;
+    rootWithPendingPassiveEffects = root;
+    pendingPassiveEffectsLanes = lanes;
+    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
+  } else {
+    // We are done with the effect chain at this point so let's clear the
+    // nextEffect pointers to assist with GC. If we have passive effects, we'll
+    // clear this in flushPassiveEffects.
+    nextEffect = firstEffect;
 
-function inferTimeFromExpirationTime(expirationTime) {
-  // We don't know exactly when the update was scheduled, but we can infer an
-  // approximate start time from the expiration time.
-  var earliestExpirationTimeMs = expirationTimeToMs(expirationTime);
-  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
-}
+    while (nextEffect !== null) {
+      var nextNextEffect = nextEffect.nextEffect;
+      nextEffect.nextEffect = null;
 
-function inferTimeFromExpirationTimeWithSuspenseConfig(
-  expirationTime,
-  suspenseConfig
-) {
-  // We don't know exactly when the update was scheduled, but we can infer an
-  // approximate start time from the expiration time by subtracting the timeout
-  // that was added to the event time.
-  var earliestExpirationTimeMs = expirationTimeToMs(expirationTime);
-  return (
-    earliestExpirationTimeMs -
-    (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION)
-  );
-}
+      if (nextEffect.effectTag & Deletion) {
+        detachFiberAfterEffects(nextEffect);
+      }
 
-function renderRootSync(root, expirationTime) {
-  var prevExecutionContext = executionContext;
-  executionContext |= RenderContext;
-  var prevDispatcher = pushDispatcher(); // If the root or expiration time have changed, throw out the existing stack
-  // and prepare a fresh one. Otherwise we'll continue where we left off.
+      nextEffect = nextNextEffect;
+    }
+  } // Read this again, since an effect might have updated it
 
-  if (
-    root !== workInProgressRoot ||
-    expirationTime !== renderExpirationTime$1
-  ) {
-    prepareFreshStack(root, expirationTime);
-    startWorkOnPendingInteractions(root, expirationTime);
-  }
+  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root
 
-  var prevInteractions = pushInteractions(root);
-  startWorkLoopTimer(workInProgress);
+  if (remainingLanes !== NoLanes) {
+    {
+      if (spawnedWorkDuringRender !== null) {
+        var expirationTimes = spawnedWorkDuringRender;
+        spawnedWorkDuringRender = null;
 
-  do {
-    try {
-      workLoopSync();
-      break;
-    } catch (thrownValue) {
-      handleError(root, thrownValue);
-    }
-  } while (true);
+        for (var i = 0; i < expirationTimes.length; i++) {
+          scheduleInteractions(
+            root,
+            expirationTimes[i],
+            root.memoizedInteractions
+          );
+        }
+      }
 
-  resetContextDependencies();
+      schedulePendingInteractions(root, remainingLanes);
+    }
+  } else {
+    // If there's no remaining work, we can clear the set of already failed
+    // error boundaries.
+    legacyErrorBoundariesThatAlreadyFailed = null;
+  }
 
   {
-    popInteractions(prevInteractions);
+    if (!rootDidHavePassiveEffects) {
+      // If there are no passive effects, then we can complete the pending interactions.
+      // Otherwise, we'll wait until after the passive effects are flushed.
+      // Wait to do this until after remaining work has been scheduled,
+      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
+      finishPendingInteractions(root, lanes);
+    }
   }
 
-  executionContext = prevExecutionContext;
-  popDispatcher(prevDispatcher);
-
-  if (workInProgress !== null) {
-    // This is a sync render, so we should have finished the whole tree.
-    {
-      throw Error(
-        "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
-      );
+  if (remainingLanes === SyncLane) {
+    // Count the number of times the root synchronously re-renders without
+    // finishing. If there are too many, it indicates an infinite update loop.
+    if (root === rootWithNestedUpdates) {
+      nestedUpdateCount++;
+    } else {
+      nestedUpdateCount = 0;
+      rootWithNestedUpdates = root;
     }
+  } else {
+    nestedUpdateCount = 0;
   }
 
-  stopFinishedWorkLoopTimer(); // Set this to null to indicate there's no in-progress render.
-
-  workInProgressRoot = null;
-  return workInProgressRootExitStatus;
-} // The work loop is an extremely hot path. Tell Closure not to inline it.
-
-/** @noinline */
-
-function workLoopSync() {
-  // Already timed out, so perform work without checking if we need to yield.
-  while (workInProgress !== null) {
-    workInProgress = performUnitOfWork(workInProgress);
-  }
-}
+  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
+  // additional work on this root is scheduled.
 
-function renderRootConcurrent(root, expirationTime) {
-  var prevExecutionContext = executionContext;
-  executionContext |= RenderContext;
-  var prevDispatcher = pushDispatcher(); // If the root or expiration time have changed, throw out the existing stack
-  // and prepare a fresh one. Otherwise we'll continue where we left off.
+  ensureRootIsScheduled(root, now());
 
-  if (
-    root !== workInProgressRoot ||
-    expirationTime !== renderExpirationTime$1
-  ) {
-    prepareFreshStack(root, expirationTime);
-    startWorkOnPendingInteractions(root, expirationTime);
+  if (hasUncaughtError) {
+    hasUncaughtError = false;
+    var _error3 = firstUncaughtError;
+    firstUncaughtError = null;
+    throw _error3;
   }
 
-  var prevInteractions = pushInteractions(root);
-  startWorkLoopTimer(workInProgress);
+  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
+    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
+    // synchronously, but layout updates should be deferred until the end
+    // of the batch.
 
-  do {
-    try {
-      workLoopConcurrent();
-      break;
-    } catch (thrownValue) {
-      handleError(root, thrownValue);
-    }
-  } while (true);
+    return null;
+  } // If layout work was scheduled, flush it now.
 
-  resetContextDependencies();
+  flushSyncCallbackQueue();
 
-  {
-    popInteractions(prevInteractions);
-  }
+  return null;
+}
 
-  popDispatcher(prevDispatcher);
-  executionContext = prevExecutionContext; // Check if the tree has completed.
+function commitBeforeMutationEffects() {
+  while (nextEffect !== null) {
+    var current = nextEffect.alternate;
 
-  if (workInProgress !== null) {
-    // Still work remaining.
-    stopInterruptedWorkLoopTimer();
-    return RootIncomplete;
-  } else {
-    // Completed the tree.
-    stopFinishedWorkLoopTimer(); // Set this to null to indicate there's no in-progress render.
+    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
+      if ((nextEffect.effectTag & Deletion) !== NoEffect) {
+        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
+          shouldFireAfterActiveInstanceBlur = true;
+        }
+      } else {
+        // TODO: Move this out of the hot path using a dedicated effect tag.
+        if (
+          nextEffect.tag === SuspenseComponent &&
+          isSuspenseBoundaryBeingHidden(current, nextEffect) &&
+          doesFiberContain(nextEffect, focusedInstanceHandle)
+        ) {
+          shouldFireAfterActiveInstanceBlur = true;
+        }
+      }
+    }
 
-    workInProgressRoot = null; // Return the final exit status.
+    var effectTag = nextEffect.effectTag;
 
-    return workInProgressRootExitStatus;
-  }
-}
-/** @noinline */
+    if ((effectTag & Snapshot) !== NoEffect) {
+      setCurrentFiber(nextEffect);
+      commitBeforeMutationLifeCycles(current, nextEffect);
+      resetCurrentFiber();
+    }
 
-function workLoopConcurrent() {
-  // Perform work until Scheduler asks us to yield
-  while (workInProgress !== null && !shouldYield()) {
-    workInProgress = performUnitOfWork(workInProgress);
+    if ((effectTag & Passive) !== NoEffect) {
+      // If there are passive effects, schedule a callback to flush at
+      // the earliest opportunity.
+      if (!rootDoesHavePassiveEffects) {
+        rootDoesHavePassiveEffects = true;
+        scheduleCallback(NormalPriority$1, function() {
+          flushPassiveEffects();
+          return null;
+        });
+      }
+    }
+
+    nextEffect = nextEffect.nextEffect;
   }
 }
 
-function performUnitOfWork(unitOfWork) {
-  // The current, flushed, state of this fiber is the alternate. Ideally
-  // nothing should rely on this, but relying on it here means that we don't
-  // need an additional field on the work in progress.
-  var current = unitOfWork.alternate;
-  startWorkTimer(unitOfWork);
-  setCurrentFiber(unitOfWork);
-  var next;
+function commitMutationEffects(root, renderPriorityLevel) {
+  // TODO: Should probably move the bulk of this function to commitWork.
+  while (nextEffect !== null) {
+    setCurrentFiber(nextEffect);
+    var effectTag = nextEffect.effectTag;
 
-  if ((unitOfWork.mode & ProfileMode) !== NoMode) {
-    startProfilerTimer(unitOfWork);
-    next = beginWork$1(current, unitOfWork, renderExpirationTime$1);
-    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
-  } else {
-    next = beginWork$1(current, unitOfWork, renderExpirationTime$1);
-  }
+    if (effectTag & ContentReset) {
+      commitResetTextContent(nextEffect);
+    }
 
-  resetCurrentFiber();
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+    if (effectTag & Ref) {
+      var current = nextEffect.alternate;
 
-  if (next === null) {
-    // If this doesn't spawn new work, complete the current work.
-    next = completeUnitOfWork(unitOfWork);
-  }
+      if (current !== null) {
+        commitDetachRef(current);
+      }
+    } // The following switch statement is only concerned about placement,
+    // updates, and deletions. To avoid needing to add a case for every possible
+    // bitmap value, we remove the secondary effects from the effect tag and
+    // switch on that value.
 
-  ReactCurrentOwner$2.current = null;
-  return next;
-}
+    var primaryEffectTag =
+      effectTag & (Placement | Update | Deletion | Hydrating);
 
-function completeUnitOfWork(unitOfWork) {
-  // Attempt to complete the current unit of work, then move to the next
-  // sibling. If there are no more siblings, return to the parent fiber.
-  workInProgress = unitOfWork;
+    switch (primaryEffectTag) {
+      case Placement: {
+        commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
+        // inserted, before any life-cycles like componentDidMount gets called.
+        // TODO: findDOMNode doesn't rely on this any more but isMounted does
+        // and isMounted is deprecated anyway so we should be able to kill this.
 
-  do {
-    // The current, flushed, state of this fiber is the alternate. Ideally
-    // nothing should rely on this, but relying on it here means that we don't
-    // need an additional field on the work in progress.
-    var current = workInProgress.alternate;
-    var returnFiber = workInProgress.return; // Check if the work completed or if something threw.
+        nextEffect.effectTag &= ~Placement;
+        break;
+      }
 
-    if ((workInProgress.effectTag & Incomplete) === NoEffect) {
-      setCurrentFiber(workInProgress);
-      var next = void 0;
+      case PlacementAndUpdate: {
+        // Placement
+        commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
+        // inserted, before any life-cycles like componentDidMount gets called.
 
-      if ((workInProgress.mode & ProfileMode) === NoMode) {
-        next = completeWork(current, workInProgress, renderExpirationTime$1);
-      } else {
-        startProfilerTimer(workInProgress);
-        next = completeWork(current, workInProgress, renderExpirationTime$1); // Update render duration assuming we didn't error.
+        nextEffect.effectTag &= ~Placement; // Update
 
-        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
+        var _current = nextEffect.alternate;
+        commitWork(_current, nextEffect);
+        break;
       }
 
-      stopWorkTimer(workInProgress);
-      resetCurrentFiber();
-      resetChildExpirationTime(workInProgress);
-
-      if (next !== null) {
-        // Completing this fiber spawned new work. Work on that next.
-        return next;
+      case Hydrating: {
+        nextEffect.effectTag &= ~Hydrating;
+        break;
       }
 
-      if (
-        returnFiber !== null && // Do not append effects to parents if a sibling failed to complete
-        (returnFiber.effectTag & Incomplete) === NoEffect
-      ) {
-        // Append all the effects of the subtree and this fiber onto the effect
-        // list of the parent. The completion order of the children affects the
-        // side-effect order.
-        if (returnFiber.firstEffect === null) {
-          returnFiber.firstEffect = workInProgress.firstEffect;
-        }
-
-        if (workInProgress.lastEffect !== null) {
-          if (returnFiber.lastEffect !== null) {
-            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
-          }
-
-          returnFiber.lastEffect = workInProgress.lastEffect;
-        } // If this fiber had side-effects, we append it AFTER the children's
-        // side-effects. We can perform certain side-effects earlier if needed,
-        // by doing multiple passes over the effect list. We don't want to
-        // schedule our own side-effect on our own list because if end up
-        // reusing children we'll schedule this effect onto itself since we're
-        // at the end.
+      case HydratingAndUpdate: {
+        nextEffect.effectTag &= ~Hydrating; // Update
 
-        var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect
-        // list. PerformedWork effect is read by React DevTools but shouldn't be
-        // committed.
+        var _current2 = nextEffect.alternate;
+        commitWork(_current2, nextEffect);
+        break;
+      }
 
-        if (effectTag > PerformedWork) {
-          if (returnFiber.lastEffect !== null) {
-            returnFiber.lastEffect.nextEffect = workInProgress;
-          } else {
-            returnFiber.firstEffect = workInProgress;
-          }
+      case Update: {
+        var _current3 = nextEffect.alternate;
+        commitWork(_current3, nextEffect);
+        break;
+      }
 
-          returnFiber.lastEffect = workInProgress;
-        }
+      case Deletion: {
+        commitDeletion(root, nextEffect);
+        break;
       }
-    } else {
-      // This fiber did not complete because something threw. Pop values off
-      // the stack without entering the complete phase. If this is a boundary,
-      // capture values if possible.
-      var _next = unwindWork(workInProgress); // Because this fiber did not complete, don't reset its expiration time.
+    }
 
-      if ((workInProgress.mode & ProfileMode) !== NoMode) {
-        // Record the render duration for the fiber that errored.
-        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false); // Include the time spent working on failed children before continuing.
+    resetCurrentFiber();
+    nextEffect = nextEffect.nextEffect;
+  }
+}
 
-        var actualDuration = workInProgress.actualDuration;
-        var child = workInProgress.child;
+function commitLayoutEffects(root, committedLanes) {
+  while (nextEffect !== null) {
+    setCurrentFiber(nextEffect);
+    var effectTag = nextEffect.effectTag;
 
-        while (child !== null) {
-          actualDuration += child.actualDuration;
-          child = child.sibling;
-        }
+    if (effectTag & (Update | Callback)) {
+      var current = nextEffect.alternate;
+      commitLifeCycles(root, current, nextEffect);
+    }
 
-        workInProgress.actualDuration = actualDuration;
+    {
+      if (effectTag & Ref) {
+        commitAttachRef(nextEffect);
       }
+    }
 
-      if (_next !== null) {
-        // If completing this work spawned new work, do that next. We'll come
-        // back here again.
-        // Since we're restarting, remove anything that is not a host effect
-        // from the effect tag.
-        // TODO: The name stopFailedWorkTimer is misleading because Suspense
-        // also captures and restarts.
-        stopFailedWorkTimer(workInProgress);
-        _next.effectTag &= HostEffectMask;
-        return _next;
-      }
+    resetCurrentFiber();
+    nextEffect = nextEffect.nextEffect;
+  }
+}
 
-      stopWorkTimer(workInProgress);
+function flushPassiveEffects() {
+  // Returns whether passive effects were flushed.
+  if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
+    var priorityLevel =
+      pendingPassiveEffectsRenderPriority > NormalPriority$1
+        ? NormalPriority$1
+        : pendingPassiveEffectsRenderPriority;
+    pendingPassiveEffectsRenderPriority = NoPriority$1;
 
-      if (returnFiber !== null) {
-        // Mark the parent fiber as incomplete and clear its effect list.
-        returnFiber.firstEffect = returnFiber.lastEffect = null;
-        returnFiber.effectTag |= Incomplete;
-      }
+    try {
+      setCurrentUpdateLanePriority(
+        schedulerPriorityToLanePriority(priorityLevel)
+      );
+      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
+    } finally {
     }
+  }
 
-    var siblingFiber = workInProgress.sibling;
+  return false;
+}
+function enqueuePendingPassiveHookEffectMount(fiber, effect) {
+  pendingPassiveHookEffectsMount.push(effect, fiber);
 
-    if (siblingFiber !== null) {
-      // If there is more work to do in this returnFiber, do that next.
-      return siblingFiber;
-    } // Otherwise, return to the parent
+  if (!rootDoesHavePassiveEffects) {
+    rootDoesHavePassiveEffects = true;
+    scheduleCallback(NormalPriority$1, function() {
+      flushPassiveEffects();
+      return null;
+    });
+  }
+}
+function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
+  pendingPassiveHookEffectsUnmount.push(effect, fiber);
 
-    workInProgress = returnFiber;
-  } while (workInProgress !== null); // We've reached the root.
+  {
+    fiber.effectTag |= PassiveUnmountPendingDev;
+    var alternate = fiber.alternate;
 
-  if (workInProgressRootExitStatus === RootIncomplete) {
-    workInProgressRootExitStatus = RootCompleted;
+    if (alternate !== null) {
+      alternate.effectTag |= PassiveUnmountPendingDev;
+    }
   }
 
-  return null;
+  if (!rootDoesHavePassiveEffects) {
+    rootDoesHavePassiveEffects = true;
+    scheduleCallback(NormalPriority$1, function() {
+      flushPassiveEffects();
+      return null;
+    });
+  }
 }
 
-function getRemainingExpirationTime(fiber) {
-  var updateExpirationTime = fiber.expirationTime;
-  var childExpirationTime = fiber.childExpirationTime;
-  return updateExpirationTime > childExpirationTime
-    ? updateExpirationTime
-    : childExpirationTime;
+function invokePassiveEffectCreate(effect) {
+  var create = effect.create;
+  effect.destroy = create();
 }
 
-function resetChildExpirationTime(completedWork) {
-  if (
-    renderExpirationTime$1 !== Never &&
-    completedWork.childExpirationTime === Never
-  ) {
-    // The children of this component are hidden. Don't bubble their
-    // expiration times.
-    return;
+function flushPassiveEffectsImpl() {
+  if (rootWithPendingPassiveEffects === null) {
+    return false;
   }
 
-  var newChildExpirationTime = NoWork; // Bubble up the earliest expiration time.
+  var root = rootWithPendingPassiveEffects;
+  var lanes = pendingPassiveEffectsLanes;
+  rootWithPendingPassiveEffects = null;
+  pendingPassiveEffectsLanes = NoLanes;
 
-  if ((completedWork.mode & ProfileMode) !== NoMode) {
-    // In profiling mode, resetChildExpirationTime is also used to reset
-    // profiler durations.
-    var actualDuration = completedWork.actualDuration;
-    var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
-    // only be updated if work is done on the fiber (i.e. it doesn't bailout).
-    // When work is done, it should bubble to the parent's actualDuration. If
-    // the fiber has not been cloned though, (meaning no work was done), then
-    // this value will reflect the amount of time spent working on a previous
-    // render. In that case it should not bubble. We determine whether it was
-    // cloned by comparing the child pointer.
+  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
+    throw Error("Cannot flush passive effects while already rendering.");
+  }
 
-    var shouldBubbleActualDurations =
-      completedWork.alternate === null ||
-      completedWork.child !== completedWork.alternate.child;
-    var child = completedWork.child;
+  {
+    isFlushingPassiveEffects = true;
+  }
 
-    while (child !== null) {
-      var childUpdateExpirationTime = child.expirationTime;
-      var childChildExpirationTime = child.childExpirationTime;
+  var prevExecutionContext = executionContext;
+  executionContext |= CommitContext;
+  var prevInteractions = pushInteractions(root); // It's important that ALL pending passive effect destroy functions are called
+  // before ANY passive effect create functions are called.
+  // Otherwise effects in sibling components might interfere with each other.
+  // e.g. a destroy function in one component may unintentionally override a ref
+  // value set by a create function in another component.
+  // Layout effects have the same constraint.
+  // First pass: Destroy stale passive effects.
+
+  var unmountEffects = pendingPassiveHookEffectsUnmount;
+  pendingPassiveHookEffectsUnmount = [];
+
+  for (var i = 0; i < unmountEffects.length; i += 2) {
+    var _effect = unmountEffects[i];
+    var fiber = unmountEffects[i + 1];
+    var destroy = _effect.destroy;
+    _effect.destroy = undefined;
 
-      if (childUpdateExpirationTime > newChildExpirationTime) {
-        newChildExpirationTime = childUpdateExpirationTime;
-      }
+    {
+      fiber.effectTag &= ~PassiveUnmountPendingDev;
+      var alternate = fiber.alternate;
 
-      if (childChildExpirationTime > newChildExpirationTime) {
-        newChildExpirationTime = childChildExpirationTime;
+      if (alternate !== null) {
+        alternate.effectTag &= ~PassiveUnmountPendingDev;
       }
+    }
 
-      if (shouldBubbleActualDurations) {
-        actualDuration += child.actualDuration;
-      }
+    if (typeof destroy === "function") {
+      {
+        setCurrentFiber(fiber);
 
-      treeBaseDuration += child.treeBaseDuration;
-      child = child.sibling;
+        {
+          invokeGuardedCallback(null, destroy, null);
+        }
+
+        if (hasCaughtError()) {
+          if (!(fiber !== null)) {
+            throw Error("Should be working on an effect.");
+          }
+
+          var error = clearCaughtError();
+          captureCommitPhaseError(fiber, error);
+        }
+
+        resetCurrentFiber();
+      }
     }
+  } // Second pass: Create new passive effects.
 
-    completedWork.actualDuration = actualDuration;
-    completedWork.treeBaseDuration = treeBaseDuration;
-  } else {
-    var _child = completedWork.child;
+  var mountEffects = pendingPassiveHookEffectsMount;
+  pendingPassiveHookEffectsMount = [];
 
-    while (_child !== null) {
-      var _childUpdateExpirationTime = _child.expirationTime;
-      var _childChildExpirationTime = _child.childExpirationTime;
+  for (var _i = 0; _i < mountEffects.length; _i += 2) {
+    var _effect2 = mountEffects[_i];
+    var _fiber = mountEffects[_i + 1];
+
+    {
+      setCurrentFiber(_fiber);
+
+      {
+        invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
+      }
+
+      if (hasCaughtError()) {
+        if (!(_fiber !== null)) {
+          throw Error("Should be working on an effect.");
+        }
 
-      if (_childUpdateExpirationTime > newChildExpirationTime) {
-        newChildExpirationTime = _childUpdateExpirationTime;
-      }
+        var _error4 = clearCaughtError();
 
-      if (_childChildExpirationTime > newChildExpirationTime) {
-        newChildExpirationTime = _childChildExpirationTime;
+        captureCommitPhaseError(_fiber, _error4);
       }
 
-      _child = _child.sibling;
+      resetCurrentFiber();
     }
-  }
+  } // Note: This currently assumes there are no passive effects on the root fiber
+  // because the root is not part of its own effect list.
+  // This could change in the future.
 
-  completedWork.childExpirationTime = newChildExpirationTime;
-}
+  var effect = root.current.firstEffect;
 
-function commitRoot(root) {
-  var renderPriorityLevel = getCurrentPriorityLevel();
-  runWithPriority(
-    ImmediatePriority,
-    commitRootImpl.bind(null, root, renderPriorityLevel)
-  );
-  return null;
-}
+  while (effect !== null) {
+    var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC
 
-function commitRootImpl(root, renderPriorityLevel) {
-  do {
-    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
-    // means `flushPassiveEffects` will sometimes result in additional
-    // passive effects. So we need to keep flushing in a loop until there are
-    // no more pending effects.
-    // TODO: Might be better if `flushPassiveEffects` did not automatically
-    // flush synchronous work at the end, to avoid factoring hazards like this.
-    flushPassiveEffects();
-  } while (rootWithPendingPassiveEffects !== null);
+    effect.nextEffect = null;
 
-  flushRenderPhaseStrictModeWarningsInDEV();
+    if (effect.effectTag & Deletion) {
+      detachFiberAfterEffects(effect);
+    }
 
-  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
-    throw Error("Should not already be working.");
+    effect = nextNextEffect;
   }
 
-  var finishedWork = root.finishedWork;
-  var expirationTime = root.finishedExpirationTime;
-
-  if (finishedWork === null) {
-    return null;
+  {
+    popInteractions(prevInteractions);
+    finishPendingInteractions(root, lanes);
   }
 
-  root.finishedWork = null;
-  root.finishedExpirationTime = NoWork;
+  {
+    isFlushingPassiveEffects = false;
+  }
 
-  if (!(finishedWork !== root.current)) {
-    throw Error(
-      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
-    );
-  } // commitRoot never returns a continuation; it always finishes synchronously.
-  // So we can clear these now to allow a new callback to be scheduled.
+  executionContext = prevExecutionContext;
+  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
+  // exceeds the limit, we'll fire a warning.
 
-  root.callbackNode = null;
-  root.callbackExpirationTime = NoWork;
-  root.callbackPriority = NoPriority;
-  root.nextKnownPendingLevel = NoWork;
-  startCommitTimer(); // Update the first and last pending times on this root. The new first
-  // pending time is whatever is left on the root fiber.
+  nestedPassiveUpdateCount =
+    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
+  return true;
+}
 
-  var remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(
-    finishedWork
-  );
-  markRootFinishedAtTime(
-    root,
-    expirationTime,
-    remainingExpirationTimeBeforeCommit
+function isAlreadyFailedLegacyErrorBoundary(instance) {
+  return (
+    legacyErrorBoundariesThatAlreadyFailed !== null &&
+    legacyErrorBoundariesThatAlreadyFailed.has(instance)
   );
+}
+function markLegacyErrorBoundaryAsFailed(instance) {
+  if (legacyErrorBoundariesThatAlreadyFailed === null) {
+    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
+  } else {
+    legacyErrorBoundariesThatAlreadyFailed.add(instance);
+  }
+}
 
-  if (root === workInProgressRoot) {
-    // We can reset these now that they are finished.
-    workInProgressRoot = null;
-    workInProgress = null;
-    renderExpirationTime$1 = NoWork;
-  } // This indicates that the last root we worked on is not the same one that
-  // we're committing now. This most commonly happens when a suspended root
-  // times out.
-  // Get the list of effects.
+function prepareToThrowUncaughtError(error) {
+  if (!hasUncaughtError) {
+    hasUncaughtError = true;
+    firstUncaughtError = error;
+  }
+}
 
-  var firstEffect;
+var onUncaughtError = prepareToThrowUncaughtError;
 
-  if (finishedWork.effectTag > PerformedWork) {
-    // A fiber's effect list consists only of its children, not itself. So if
-    // the root has an effect, we need to add it to the end of the list. The
-    // resulting list is the set that would belong to the root's parent, if it
-    // had one; that is, all the effects in the tree including the root.
-    if (finishedWork.lastEffect !== null) {
-      finishedWork.lastEffect.nextEffect = finishedWork;
-      firstEffect = finishedWork.firstEffect;
-    } else {
-      firstEffect = finishedWork;
-    }
-  } else {
-    // There is no effect on the root.
-    firstEffect = finishedWork.firstEffect;
-  }
+function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
+  var errorInfo = createCapturedValue(error, sourceFiber);
+  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
+  enqueueUpdate(rootFiber, update);
+  var eventTime = requestEventTime();
+  var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
 
-  if (firstEffect !== null) {
-    var prevExecutionContext = executionContext;
-    executionContext |= CommitContext;
-    var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles
+  if (root !== null) {
+    markRootUpdated(root, SyncLane, eventTime);
+    ensureRootIsScheduled(root, eventTime);
+    schedulePendingInteractions(root, SyncLane);
+  }
+}
 
-    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
-    // of the effect list for each phase: all mutation effects come before all
-    // layout effects, and so on.
-    // The first phase a "before mutation" phase. We use this phase to read the
-    // state of the host tree right before we mutate it. This is where
-    // getSnapshotBeforeUpdate is called.
+function captureCommitPhaseError(sourceFiber, error) {
+  if (sourceFiber.tag === HostRoot) {
+    // Error was thrown at the root. There is no parent, so the root
+    // itself should capture it.
+    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
+    return;
+  }
 
-    startCommitSnapshotEffectsTimer();
-    prepareForCommit(root.containerInfo);
-    nextEffect = firstEffect;
+  var fiber = sourceFiber.return;
 
-    do {
-      {
-        invokeGuardedCallback(null, commitBeforeMutationEffects, null);
+  while (fiber !== null) {
+    if (fiber.tag === HostRoot) {
+      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
+      return;
+    } else if (fiber.tag === ClassComponent) {
+      var ctor = fiber.type;
+      var instance = fiber.stateNode;
 
-        if (hasCaughtError()) {
-          if (!(nextEffect !== null)) {
-            throw Error("Should be working on an effect.");
-          }
+      if (
+        typeof ctor.getDerivedStateFromError === "function" ||
+        (typeof instance.componentDidCatch === "function" &&
+          !isAlreadyFailedLegacyErrorBoundary(instance))
+      ) {
+        var errorInfo = createCapturedValue(error, sourceFiber);
+        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
+        enqueueUpdate(fiber, update);
+        var eventTime = requestEventTime();
+        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
 
-          var error = clearCaughtError();
-          captureCommitPhaseError(nextEffect, error);
-          nextEffect = nextEffect.nextEffect;
+        if (root !== null) {
+          markRootUpdated(root, SyncLane, eventTime);
+          ensureRootIsScheduled(root, eventTime);
+          schedulePendingInteractions(root, SyncLane);
         }
+
+        return;
       }
-    } while (nextEffect !== null);
+    }
 
-    stopCommitSnapshotEffectsTimer();
+    fiber = fiber.return;
+  }
+}
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
+  var pingCache = root.pingCache;
 
-    {
-      // Mark the current commit time to be shared by all Profilers in this
-      // batch. This enables them to be grouped later.
-      recordCommitTime();
-    } // The next phase is the mutation phase, where we mutate the host tree.
+  if (pingCache !== null) {
+    // The wakeable resolved, so we no longer need to memoize, because it will
+    // never be thrown again.
+    pingCache.delete(wakeable);
+  }
 
-    startCommitHostEffectsTimer();
-    nextEffect = firstEffect;
+  var eventTime = requestEventTime();
+  markRootPinged(root, pingedLanes);
 
-    do {
-      {
-        invokeGuardedCallback(
-          null,
-          commitMutationEffects,
-          null,
-          root,
-          renderPriorityLevel
-        );
+  if (
+    workInProgressRoot === root &&
+    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)
+  ) {
+    // Received a ping at the same priority level at which we're currently
+    // rendering. We might want to restart this render. This should mirror
+    // the logic of whether or not a root suspends once it completes.
+    // TODO: If we're rendering sync either due to Sync, Batched or expired,
+    // we should probably never restart.
+    // If we're suspended with delay, or if it's a retry, we'll always suspend
+    // so we can always restart.
+    if (
+      workInProgressRootExitStatus === RootSuspendedWithDelay ||
+      (workInProgressRootExitStatus === RootSuspended &&
+        includesOnlyRetries(workInProgressRootRenderLanes) &&
+        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
+    ) {
+      // Restart from the root.
+      prepareFreshStack(root, NoLanes);
+    } else {
+      // Even though we can't restart right now, we might get an
+      // opportunity later. So we mark this render as having a ping.
+      workInProgressRootPingedLanes = mergeLanes(
+        workInProgressRootPingedLanes,
+        pingedLanes
+      );
+    }
+  }
 
-        if (hasCaughtError()) {
-          if (!(nextEffect !== null)) {
-            throw Error("Should be working on an effect.");
-          }
+  ensureRootIsScheduled(root, eventTime);
+  schedulePendingInteractions(root, pingedLanes);
+}
 
-          var _error = clearCaughtError();
+function retryTimedOutBoundary(boundaryFiber, retryLane) {
+  // The boundary fiber (a Suspense component or SuspenseList component)
+  // previously was rendered in its fallback state. One of the promises that
+  // suspended it has resolved, which means at least part of the tree was
+  // likely unblocked. Try rendering again, at a new expiration time.
+  if (retryLane === NoLane) {
+    retryLane = requestRetryLane(boundaryFiber);
+  } // TODO: Special case idle priority?
 
-          captureCommitPhaseError(nextEffect, _error);
-          nextEffect = nextEffect.nextEffect;
-        }
-      }
-    } while (nextEffect !== null);
+  var eventTime = requestEventTime();
+  var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
 
-    stopCommitHostEffectsTimer();
-    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
-    // the mutation phase, so that the previous tree is still current during
-    // componentWillUnmount, but before the layout phase, so that the finished
-    // work is current during componentDidMount/Update.
+  if (root !== null) {
+    markRootUpdated(root, retryLane, eventTime);
+    ensureRootIsScheduled(root, eventTime);
+    schedulePendingInteractions(root, retryLane);
+  }
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
+  var retryLane = NoLane; // Default
 
-    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
-    // the host tree after it's been mutated. The idiomatic use case for this is
-    // layout, but class component lifecycles also fire here for legacy reasons.
+  var retryCache;
 
-    startCommitLifeCyclesTimer();
-    nextEffect = firstEffect;
+  {
+    retryCache = boundaryFiber.stateNode;
+  }
 
-    do {
-      {
-        invokeGuardedCallback(
-          null,
-          commitLayoutEffects,
-          null,
-          root,
-          expirationTime
-        );
+  if (retryCache !== null) {
+    // The wakeable resolved, so we no longer need to memoize, because it will
+    // never be thrown again.
+    retryCache.delete(wakeable);
+  }
+
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+} // Computes the next Just Noticeable Difference (JND) boundary.
+// The theory is that a person can't tell the difference between small differences in time.
+// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
+// difference in the experience. However, waiting for longer might mean that we can avoid
+// showing an intermediate loading state. The longer we have already waited, the harder it
+// is to tell small differences in time. Therefore, the longer we've already waited,
+// the longer we can wait additionally. At some point we have to give up though.
+// We pick a train model where the next boundary commits at a consistent schedule.
+// These particular numbers are vague estimates. We expect to adjust them based on research.
+
+function jnd(timeElapsed) {
+  return timeElapsed < 120
+    ? 120
+    : timeElapsed < 480
+    ? 480
+    : timeElapsed < 1080
+    ? 1080
+    : timeElapsed < 1920
+    ? 1920
+    : timeElapsed < 3000
+    ? 3000
+    : timeElapsed < 4320
+    ? 4320
+    : ceil(timeElapsed / 1960) * 1960;
+}
 
-        if (hasCaughtError()) {
-          if (!(nextEffect !== null)) {
-            throw Error("Should be working on an effect.");
-          }
+function computeMsUntilSuspenseLoadingDelay(
+  mostRecentEventTime,
+  suspenseConfig
+) {
+  var busyMinDurationMs = suspenseConfig.busyMinDurationMs | 0;
 
-          var _error2 = clearCaughtError();
+  if (busyMinDurationMs <= 0) {
+    return 0;
+  }
 
-          captureCommitPhaseError(nextEffect, _error2);
-          nextEffect = nextEffect.nextEffect;
-        }
-      }
-    } while (nextEffect !== null);
+  var busyDelayMs = suspenseConfig.busyDelayMs | 0; // Compute the time until this render pass would expire.
 
-    stopCommitLifeCyclesTimer();
-    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
-    // opportunity to paint.
+  var currentTimeMs = now();
+  var eventTimeMs = mostRecentEventTime;
+  var timeElapsed = currentTimeMs - eventTimeMs;
 
-    requestPaint();
+  if (timeElapsed <= busyDelayMs) {
+    // If we haven't yet waited longer than the initial delay, we don't
+    // have to wait any additional time.
+    return 0;
+  }
 
-    {
-      popInteractions(prevInteractions);
-    }
+  var msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed; // This is the value that is passed to `setTimeout`.
 
-    executionContext = prevExecutionContext;
-  } else {
-    // No effects.
-    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
-    // no effects.
-    // TODO: Maybe there's a better way to report this.
+  return msUntilTimeout;
+}
 
-    startCommitSnapshotEffectsTimer();
-    stopCommitSnapshotEffectsTimer();
+function checkForNestedUpdates() {
+  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
+    nestedUpdateCount = 0;
+    rootWithNestedUpdates = null;
 
     {
-      recordCommitTime();
+      throw Error(
+        "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
+      );
     }
-
-    startCommitHostEffectsTimer();
-    stopCommitHostEffectsTimer();
-    startCommitLifeCyclesTimer();
-    stopCommitLifeCyclesTimer();
   }
 
-  stopCommitTimer();
-  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
-
-  if (rootDoesHavePassiveEffects) {
-    // This commit has passive effects. Stash a reference to them. But don't
-    // schedule a callback until after flushing layout work.
-    rootDoesHavePassiveEffects = false;
-    rootWithPendingPassiveEffects = root;
-    pendingPassiveEffectsExpirationTime = expirationTime;
-    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
-  } else {
-    // We are done with the effect chain at this point so let's clear the
-    // nextEffect pointers to assist with GC. If we have passive effects, we'll
-    // clear this in flushPassiveEffects.
-    nextEffect = firstEffect;
+  {
+    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
+      nestedPassiveUpdateCount = 0;
 
-    while (nextEffect !== null) {
-      var nextNextEffect = nextEffect.nextEffect;
-      nextEffect.nextEffect = null;
-      nextEffect = nextNextEffect;
+      error(
+        "Maximum update depth exceeded. This can happen when a component " +
+          "calls setState inside useEffect, but useEffect either doesn't " +
+          "have a dependency array, or one of the dependencies changes on " +
+          "every render."
+      );
     }
-  } // Check if there's remaining work on this root
+  }
+}
 
-  var remainingExpirationTime = root.firstPendingTime;
+function flushRenderPhaseStrictModeWarningsInDEV() {
+  {
+    ReactStrictModeWarnings.flushLegacyContextWarning();
 
-  if (remainingExpirationTime !== NoWork) {
     {
-      if (spawnedWorkDuringRender !== null) {
-        var expirationTimes = spawnedWorkDuringRender;
-        spawnedWorkDuringRender = null;
-
-        for (var i = 0; i < expirationTimes.length; i++) {
-          scheduleInteractions(
-            root,
-            expirationTimes[i],
-            root.memoizedInteractions
-          );
-        }
-      }
-
-      schedulePendingInteractions(root, remainingExpirationTime);
+      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
     }
-  } else {
-    // If there's no remaining work, we can clear the set of already failed
-    // error boundaries.
-    legacyErrorBoundariesThatAlreadyFailed = null;
   }
+}
 
+var didWarnStateUpdateForNotYetMountedComponent = null;
+
+function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
   {
-    if (!rootDidHavePassiveEffects) {
-      // If there are no passive effects, then we can complete the pending interactions.
-      // Otherwise, we'll wait until after the passive effects are flushed.
-      // Wait to do this until after remaining work has been scheduled,
-      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
-      finishPendingInteractions(root, expirationTime);
+    if ((executionContext & RenderContext) !== NoContext) {
+      // We let the other warning about render phase updates deal with this one.
+      return;
     }
-  }
 
-  if (remainingExpirationTime === Sync) {
-    // Count the number of times the root synchronously re-renders without
-    // finishing. If there are too many, it indicates an infinite update loop.
-    if (root === rootWithNestedUpdates) {
-      nestedUpdateCount++;
-    } else {
-      nestedUpdateCount = 0;
-      rootWithNestedUpdates = root;
+    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
+      return;
     }
-  } else {
-    nestedUpdateCount = 0;
-  }
 
-  onCommitRoot(finishedWork.stateNode, expirationTime); // Always call this before exiting `commitRoot`, to ensure that any
-  // additional work on this root is scheduled.
+    var tag = fiber.tag;
 
-  ensureRootIsScheduled(root);
+    if (
+      tag !== IndeterminateComponent &&
+      tag !== HostRoot &&
+      tag !== ClassComponent &&
+      tag !== FunctionComponent &&
+      tag !== ForwardRef &&
+      tag !== MemoComponent &&
+      tag !== SimpleMemoComponent &&
+      tag !== Block
+    ) {
+      // Only warn for user-defined components, not internal ones like Suspense.
+      return;
+    } // We show the whole stack but dedupe on the top component's name because
+    // the problematic code almost always lies inside that component.
 
-  if (hasUncaughtError) {
-    hasUncaughtError = false;
-    var _error3 = firstUncaughtError;
-    firstUncaughtError = null;
-    throw _error3;
-  }
+    var componentName = getComponentName(fiber.type) || "ReactComponent";
 
-  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
-    // This is a legacy edge case. We just committed the initial mount of
-    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
-    // synchronously, but layout updates should be deferred until the end
-    // of the batch.
-    return null;
-  } // If layout work was scheduled, flush it now.
+    if (didWarnStateUpdateForNotYetMountedComponent !== null) {
+      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
+        return;
+      }
 
-  flushSyncCallbackQueue();
-  return null;
-}
+      didWarnStateUpdateForNotYetMountedComponent.add(componentName);
+    } else {
+      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
+    }
 
-function commitBeforeMutationEffects() {
-  while (nextEffect !== null) {
-    var effectTag = nextEffect.effectTag;
+    var previousFiber = current;
 
-    if ((effectTag & Snapshot) !== NoEffect) {
-      setCurrentFiber(nextEffect);
-      recordEffect();
-      var current = nextEffect.alternate;
-      commitBeforeMutationLifeCycles(current, nextEffect);
-      resetCurrentFiber();
-    }
+    try {
+      setCurrentFiber(fiber);
 
-    if ((effectTag & Passive) !== NoEffect) {
-      // If there are passive effects, schedule a callback to flush at
-      // the earliest opportunity.
-      if (!rootDoesHavePassiveEffects) {
-        rootDoesHavePassiveEffects = true;
-        scheduleCallback(NormalPriority, function() {
-          flushPassiveEffects();
-          return null;
-        });
+      error(
+        "Can't perform a React state update on a component that hasn't mounted yet. " +
+          "This indicates that you have a side-effect in your render function that " +
+          "asynchronously later calls tries to update the component. Move this work to " +
+          "useEffect instead."
+      );
+    } finally {
+      if (previousFiber) {
+        setCurrentFiber(fiber);
+      } else {
+        resetCurrentFiber();
       }
     }
-
-    nextEffect = nextEffect.nextEffect;
   }
 }
 
-function commitMutationEffects(root, renderPriorityLevel) {
-  // TODO: Should probably move the bulk of this function to commitWork.
-  while (nextEffect !== null) {
-    setCurrentFiber(nextEffect);
-    var effectTag = nextEffect.effectTag;
-
-    if (effectTag & ContentReset) {
-      commitResetTextContent(nextEffect);
-    }
-
-    if (effectTag & Ref) {
-      var current = nextEffect.alternate;
-
-      if (current !== null) {
-        commitDetachRef(current);
-      }
-    } // The following switch statement is only concerned about placement,
-    // updates, and deletions. To avoid needing to add a case for every possible
-    // bitmap value, we remove the secondary effects from the effect tag and
-    // switch on that value.
-
-    var primaryEffectTag =
-      effectTag & (Placement | Update | Deletion | Hydrating);
-
-    switch (primaryEffectTag) {
-      case Placement: {
-        commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
-        // inserted, before any life-cycles like componentDidMount gets called.
-        // TODO: findDOMNode doesn't rely on this any more but isMounted does
-        // and isMounted is deprecated anyway so we should be able to kill this.
+var didWarnStateUpdateForUnmountedComponent = null;
 
-        nextEffect.effectTag &= ~Placement;
-        break;
-      }
+function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
+  {
+    var tag = fiber.tag;
 
-      case PlacementAndUpdate: {
-        // Placement
-        commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
-        // inserted, before any life-cycles like componentDidMount gets called.
+    if (
+      tag !== HostRoot &&
+      tag !== ClassComponent &&
+      tag !== FunctionComponent &&
+      tag !== ForwardRef &&
+      tag !== MemoComponent &&
+      tag !== SimpleMemoComponent &&
+      tag !== Block
+    ) {
+      // Only warn for user-defined components, not internal ones like Suspense.
+      return;
+    } // If there are pending passive effects unmounts for this Fiber,
+    // we can assume that they would have prevented this update.
 
-        nextEffect.effectTag &= ~Placement; // Update
+    if ((fiber.effectTag & PassiveUnmountPendingDev) !== NoEffect) {
+      return;
+    } // We show the whole stack but dedupe on the top component's name because
+    // the problematic code almost always lies inside that component.
 
-        var _current = nextEffect.alternate;
-        commitWork(_current, nextEffect);
-        break;
-      }
+    var componentName = getComponentName(fiber.type) || "ReactComponent";
 
-      case Hydrating: {
-        nextEffect.effectTag &= ~Hydrating;
-        break;
+    if (didWarnStateUpdateForUnmountedComponent !== null) {
+      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
+        return;
       }
 
-      case HydratingAndUpdate: {
-        nextEffect.effectTag &= ~Hydrating; // Update
-
-        var _current2 = nextEffect.alternate;
-        commitWork(_current2, nextEffect);
-        break;
-      }
+      didWarnStateUpdateForUnmountedComponent.add(componentName);
+    } else {
+      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
+    }
 
-      case Update: {
-        var _current3 = nextEffect.alternate;
-        commitWork(_current3, nextEffect);
-        break;
-      }
+    if (isFlushingPassiveEffects);
+    else {
+      var previousFiber = current;
 
-      case Deletion: {
-        commitDeletion(root, nextEffect, renderPriorityLevel);
-        break;
-      }
-    } // TODO: Only record a mutation effect if primaryEffectTag is non-zero.
+      try {
+        setCurrentFiber(fiber);
 
-    recordEffect();
-    resetCurrentFiber();
-    nextEffect = nextEffect.nextEffect;
+        error(
+          "Can't perform a React state update on an unmounted component. This " +
+            "is a no-op, but it indicates a memory leak in your application. To " +
+            "fix, cancel all subscriptions and asynchronous tasks in %s.",
+          tag === ClassComponent
+            ? "the componentWillUnmount method"
+            : "a useEffect cleanup function"
+        );
+      } finally {
+        if (previousFiber) {
+          setCurrentFiber(fiber);
+        } else {
+          resetCurrentFiber();
+        }
+      }
+    }
   }
 }
 
-function commitLayoutEffects(root, committedExpirationTime) {
-  // TODO: Should probably move the bulk of this function to commitWork.
-  while (nextEffect !== null) {
-    setCurrentFiber(nextEffect);
-    var effectTag = nextEffect.effectTag;
+var beginWork$1;
 
-    if (effectTag & (Update | Callback)) {
-      recordEffect();
-      var current = nextEffect.alternate;
-      commitLifeCycles(root, current, nextEffect);
-    }
+{
+  var dummyFiber = null;
 
-    if (effectTag & Ref) {
-      recordEffect();
-      commitAttachRef(nextEffect);
-    }
+  beginWork$1 = function(current, unitOfWork, lanes) {
+    // If a component throws an error, we replay it again in a synchronously
+    // dispatched event, so that the debugger will treat it as an uncaught
+    // error See ReactErrorUtils for more information.
+    // Before entering the begin phase, copy the work-in-progress onto a dummy
+    // fiber. If beginWork throws, we'll use this to reset the state.
+    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(
+      dummyFiber,
+      unitOfWork
+    );
 
-    resetCurrentFiber();
-    nextEffect = nextEffect.nextEffect;
-  }
-}
+    try {
+      return beginWork(current, unitOfWork, lanes);
+    } catch (originalError) {
+      if (
+        originalError !== null &&
+        typeof originalError === "object" &&
+        typeof originalError.then === "function"
+      ) {
+        // Don't replay promises. Treat everything else like an error.
+        throw originalError;
+      } // Keep this code in sync with handleError; any changes here must have
+      // corresponding changes there.
 
-function flushPassiveEffects() {
-  if (pendingPassiveEffectsRenderPriority !== NoPriority) {
-    var priorityLevel =
-      pendingPassiveEffectsRenderPriority > NormalPriority
-        ? NormalPriority
-        : pendingPassiveEffectsRenderPriority;
-    pendingPassiveEffectsRenderPriority = NoPriority;
-    return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
-  }
-}
+      resetContextDependencies();
+      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
+      // same fiber again.
+      // Unwind the failed stack frame
 
-function flushPassiveEffectsImpl() {
-  if (rootWithPendingPassiveEffects === null) {
-    return false;
-  }
+      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.
 
-  var root = rootWithPendingPassiveEffects;
-  var expirationTime = pendingPassiveEffectsExpirationTime;
-  rootWithPendingPassiveEffects = null;
-  pendingPassiveEffectsExpirationTime = NoWork;
+      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
 
-  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
-    throw Error("Cannot flush passive effects while already rendering.");
-  }
+      if (unitOfWork.mode & ProfileMode) {
+        // Reset the profiler timer.
+        startProfilerTimer(unitOfWork);
+      } // Run beginWork again.
 
-  var prevExecutionContext = executionContext;
-  executionContext |= CommitContext;
-  var prevInteractions = pushInteractions(root);
+      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);
+
+      if (hasCaughtError()) {
+        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
+        // Rethrow this error instead of the original one.
+
+        throw replayError;
+      } else {
+        // This branch is reachable if the render phase is impure.
+        throw originalError;
+      }
+    }
+  };
+}
+
+var didWarnAboutUpdateInRender = false;
+var didWarnAboutUpdateInRenderForAnotherComponent;
+
+{
+  didWarnAboutUpdateInRenderForAnotherComponent = new Set();
+}
 
+function warnAboutRenderPhaseUpdatesInDEV(fiber) {
   {
-    // Note: This currently assumes there are no passive effects on the root fiber
-    // because the root is not part of its own effect list.
-    // This could change in the future.
-    var _effect2 = root.current.firstEffect;
+    if (
+      isRendering &&
+      (executionContext & RenderContext) !== NoContext &&
+      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()
+    ) {
+      switch (fiber.tag) {
+        case FunctionComponent:
+        case ForwardRef:
+        case SimpleMemoComponent: {
+          var renderingComponentName =
+            (workInProgress && getComponentName(workInProgress.type)) ||
+            "Unknown"; // Dedupe by the rendering component because it's the one that needs to be fixed.
 
-    while (_effect2 !== null) {
-      {
-        setCurrentFiber(_effect2);
-        invokeGuardedCallback(null, commitPassiveHookEffects, null, _effect2);
+          var dedupeKey = renderingComponentName;
 
-        if (hasCaughtError()) {
-          if (!(_effect2 !== null)) {
-            throw Error("Should be working on an effect.");
-          }
+          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
+            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
+            var setStateComponentName =
+              getComponentName(fiber.type) || "Unknown";
 
-          var _error5 = clearCaughtError();
+            error(
+              "Cannot update a component (`%s`) while rendering a " +
+                "different component (`%s`). To locate the bad setState() call inside `%s`, " +
+                "follow the stack trace as described in https://fb.me/setstate-in-render",
+              setStateComponentName,
+              renderingComponentName,
+              renderingComponentName
+            );
+          }
 
-          captureCommitPhaseError(_effect2, _error5);
+          break;
         }
 
-        resetCurrentFiber();
-      }
+        case ClassComponent: {
+          if (!didWarnAboutUpdateInRender) {
+            error(
+              "Cannot update during an existing state transition (such as " +
+                "within `render`). Render methods should be a pure " +
+                "function of props and state."
+            );
 
-      var nextNextEffect = _effect2.nextEffect; // Remove nextEffect pointer to assist GC
+            didWarnAboutUpdateInRender = true;
+          }
 
-      _effect2.nextEffect = null;
-      _effect2 = nextNextEffect;
+          break;
+        }
+      }
     }
   }
+} // a 'shared' variable that changes when act() opens/closes in tests.
 
+var IsThisRendererActing = {
+  current: false
+};
+function warnIfNotScopedWithMatchingAct(fiber) {
   {
-    popInteractions(prevInteractions);
-    finishPendingInteractions(root, expirationTime);
-  }
-
-  executionContext = prevExecutionContext;
-  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
-  // exceeds the limit, we'll fire a warning.
+    if (
+      IsSomeRendererActing.current === true &&
+      IsThisRendererActing.current !== true
+    ) {
+      var previousFiber = current;
 
-  nestedPassiveUpdateCount =
-    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
-  return true;
-}
+      try {
+        setCurrentFiber(fiber);
 
-function isAlreadyFailedLegacyErrorBoundary(instance) {
-  return (
-    legacyErrorBoundariesThatAlreadyFailed !== null &&
-    legacyErrorBoundariesThatAlreadyFailed.has(instance)
-  );
-}
-function markLegacyErrorBoundaryAsFailed(instance) {
-  if (legacyErrorBoundariesThatAlreadyFailed === null) {
-    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
-  } else {
-    legacyErrorBoundariesThatAlreadyFailed.add(instance);
+        error(
+          "It looks like you're using the wrong act() around your test interactions.\n" +
+          "Be sure to use the matching version of act() corresponding to your renderer:\n\n" +
+          "// for react-dom:\n" + // Break up imports to avoid accidentally parsing them as dependencies.
+          "import {act} fr" +
+          "om 'react-dom/test-utils';\n" +
+          "// ...\n" +
+          "act(() => ...);\n\n" +
+          "// for react-test-renderer:\n" + // Break up imports to avoid accidentally parsing them as dependencies.
+            "import TestRenderer fr" +
+            "om react-test-renderer';\n" +
+            "const {act} = TestRenderer;\n" +
+            "// ...\n" +
+            "act(() => ...);"
+        );
+      } finally {
+        if (previousFiber) {
+          setCurrentFiber(fiber);
+        } else {
+          resetCurrentFiber();
+        }
+      }
+    }
   }
 }
-
-function prepareToThrowUncaughtError(error) {
-  if (!hasUncaughtError) {
-    hasUncaughtError = true;
-    firstUncaughtError = error;
+function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
+  {
+    if (
+      (fiber.mode & StrictMode) !== NoMode &&
+      IsSomeRendererActing.current === false &&
+      IsThisRendererActing.current === false
+    ) {
+      error(
+        "An update to %s ran an effect, but was not wrapped in act(...).\n\n" +
+          "When testing, code that causes React state updates should be " +
+          "wrapped into act(...):\n\n" +
+          "act(() => {\n" +
+          "  /* fire events that update state */\n" +
+          "});\n" +
+          "/* assert on the output */\n\n" +
+          "This ensures that you're testing the behavior the user would see " +
+          "in the browser." +
+          " Learn more at https://fb.me/react-wrap-tests-with-act",
+        getComponentName(fiber.type)
+      );
+    }
   }
 }
 
-var onUncaughtError = prepareToThrowUncaughtError;
+function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
+  {
+    if (
+      executionContext === NoContext &&
+      IsSomeRendererActing.current === false &&
+      IsThisRendererActing.current === false
+    ) {
+      var previousFiber = current;
 
-function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
-  var errorInfo = createCapturedValue(error, sourceFiber);
-  var update = createRootErrorUpdate(rootFiber, errorInfo, Sync);
-  enqueueUpdate(rootFiber, update);
-  var root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);
+      try {
+        setCurrentFiber(fiber);
 
-  if (root !== null) {
-    ensureRootIsScheduled(root);
-    schedulePendingInteractions(root, Sync);
+        error(
+          "An update to %s inside a test was not wrapped in act(...).\n\n" +
+            "When testing, code that causes React state updates should be " +
+            "wrapped into act(...):\n\n" +
+            "act(() => {\n" +
+            "  /* fire events that update state */\n" +
+            "});\n" +
+            "/* assert on the output */\n\n" +
+            "This ensures that you're testing the behavior the user would see " +
+            "in the browser." +
+            " Learn more at https://fb.me/react-wrap-tests-with-act",
+          getComponentName(fiber.type)
+        );
+      } finally {
+        if (previousFiber) {
+          setCurrentFiber(fiber);
+        } else {
+          resetCurrentFiber();
+        }
+      }
+    }
   }
 }
 
-function captureCommitPhaseError(sourceFiber, error) {
-  if (sourceFiber.tag === HostRoot) {
-    // Error was thrown at the root. There is no parent, so the root
-    // itself should capture it.
-    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
-    return;
-  }
-
-  var fiber = sourceFiber.return;
+var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.
 
-  while (fiber !== null) {
-    if (fiber.tag === HostRoot) {
-      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
-      return;
-    } else if (fiber.tag === ClassComponent) {
-      var ctor = fiber.type;
-      var instance = fiber.stateNode;
+var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
+// scheduler is the actual recommendation. The alternative could be a testing build,
+// a new lib, or whatever; we dunno just yet. This message is for early adopters
+// to get their tests right.
 
-      if (
-        typeof ctor.getDerivedStateFromError === "function" ||
-        (typeof instance.componentDidCatch === "function" &&
-          !isAlreadyFailedLegacyErrorBoundary(instance))
-      ) {
-        var errorInfo = createCapturedValue(error, sourceFiber);
-        var update = createClassErrorUpdate(
-          fiber,
-          errorInfo, // TODO: This is always sync
-          Sync
-        );
-        enqueueUpdate(fiber, update);
-        var root = markUpdateTimeFromFiberToRoot(fiber, Sync);
+function warnIfUnmockedScheduler(fiber) {
+  {
+    if (
+      didWarnAboutUnmockedScheduler === false &&
+      Scheduler.unstable_flushAllWithoutAsserting === undefined
+    ) {
+      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
+        didWarnAboutUnmockedScheduler = true;
 
-        if (root !== null) {
-          ensureRootIsScheduled(root);
-          schedulePendingInteractions(root, Sync);
-        }
+        error(
+          'In Concurrent or Sync modes, the "scheduler" module needs to be mocked ' +
+          "to guarantee consistent behaviour across tests and browsers. " +
+          "For example, with jest: \n" + // Break up requires to avoid accidentally parsing them as dependencies.
+            "jest.mock('scheduler', () => require" +
+            "('scheduler/unstable_mock'));\n\n" +
+            "For more info, visit https://fb.me/react-mock-scheduler"
+        );
+      } else {
+        didWarnAboutUnmockedScheduler = true;
 
-        return;
+        error(
+          'Starting from React v18, the "scheduler" module will need to be mocked ' +
+          "to guarantee consistent behaviour across tests and browsers. " +
+          "For example, with jest: \n" + // Break up requires to avoid accidentally parsing them as dependencies.
+            "jest.mock('scheduler', () => require" +
+            "('scheduler/unstable_mock'));\n\n" +
+            "For more info, visit https://fb.me/react-mock-scheduler"
+        );
       }
     }
-
-    fiber = fiber.return;
   }
 }
-function pingSuspendedRoot(root, thenable, suspendedTime) {
-  var pingCache = root.pingCache;
-
-  if (pingCache !== null) {
-    // The thenable resolved, so we no longer need to memoize, because it will
-    // never be thrown again.
-    pingCache.delete(thenable);
-  }
-
-  if (workInProgressRoot === root && renderExpirationTime$1 === suspendedTime) {
-    // Received a ping at the same priority level at which we're currently
-    // rendering. We might want to restart this render. This should mirror
-    // the logic of whether or not a root suspends once it completes.
-    // TODO: If we're rendering sync either due to Sync, Batched or expired,
-    // we should probably never restart.
-    // If we're suspended with delay, we'll always suspend so we can always
-    // restart. If we're suspended without any updates, it might be a retry.
-    // If it's early in the retry we can restart. We can't know for sure
-    // whether we'll eventually process an update during this render pass,
-    // but it's somewhat unlikely that we get to a ping before that, since
-    // getting to the root most update is usually very fast.
-    if (
-      workInProgressRootExitStatus === RootSuspendedWithDelay ||
-      (workInProgressRootExitStatus === RootSuspended &&
-        workInProgressRootLatestProcessedExpirationTime === Sync &&
-        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
-    ) {
-      // Restart from the root. Don't need to schedule a ping because
-      // we're already working on this tree.
-      prepareFreshStack(root, renderExpirationTime$1);
-    } else {
-      // Even though we can't restart right now, we might get an
-      // opportunity later. So we mark this render as having a ping.
-      workInProgressRootHasPendingPing = true;
-    }
 
-    return;
-  }
+function computeThreadID(root, lane) {
+  // Interaction threads are unique per root and expiration time.
+  // NOTE: Intentionally unsound cast. All that matters is that it's a number
+  // and it represents a batch of work. Could make a helper function instead,
+  // but meh this is fine for now.
+  return lane * 1000 + root.interactionThreadID;
+}
 
-  if (!isRootSuspendedAtTime(root, suspendedTime)) {
-    // The root is no longer suspended at this time.
-    return;
+function markSpawnedWork(lane) {
+  if (spawnedWorkDuringRender === null) {
+    spawnedWorkDuringRender = [lane];
+  } else {
+    spawnedWorkDuringRender.push(lane);
   }
+}
 
-  var lastPingedTime = root.lastPingedTime;
+function scheduleInteractions(root, lane, interactions) {
+  if (interactions.size > 0) {
+    var pendingInteractionMap = root.pendingInteractionMap;
+    var pendingInteractions = pendingInteractionMap.get(lane);
 
-  if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {
-    // There's already a lower priority ping scheduled.
-    return;
-  } // Mark the time at which this ping was scheduled.
+    if (pendingInteractions != null) {
+      interactions.forEach(function(interaction) {
+        if (!pendingInteractions.has(interaction)) {
+          // Update the pending async work count for previously unscheduled interaction.
+          interaction.__count++;
+        }
 
-  root.lastPingedTime = suspendedTime;
-  ensureRootIsScheduled(root);
-  schedulePendingInteractions(root, suspendedTime);
-}
+        pendingInteractions.add(interaction);
+      });
+    } else {
+      pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.
 
-function retryTimedOutBoundary(boundaryFiber, retryTime) {
-  // The boundary fiber (a Suspense component or SuspenseList component)
-  // previously was rendered in its fallback state. One of the promises that
-  // suspended it has resolved, which means at least part of the tree was
-  // likely unblocked. Try rendering again, at a new expiration time.
-  if (retryTime === NoWork) {
-    var suspenseConfig = null; // Retries don't carry over the already committed update.
-
-    var currentTime = requestCurrentTimeForUpdate();
-    retryTime = computeExpirationForFiber(
-      currentTime,
-      boundaryFiber,
-      suspenseConfig
-    );
-  } // TODO: Special case idle priority?
+      interactions.forEach(function(interaction) {
+        interaction.__count++;
+      });
+    }
 
-  var root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);
+    var subscriber = tracing.__subscriberRef.current;
 
-  if (root !== null) {
-    ensureRootIsScheduled(root);
-    schedulePendingInteractions(root, retryTime);
+    if (subscriber !== null) {
+      var threadID = computeThreadID(root, lane);
+      subscriber.onWorkScheduled(interactions, threadID);
+    }
   }
 }
-function resolveRetryThenable(boundaryFiber, thenable) {
-  var retryTime = NoWork; // Default
 
-  var retryCache;
+function schedulePendingInteractions(root, lane) {
+  scheduleInteractions(root, lane, tracing.__interactionsRef.current);
+}
 
-  {
-    retryCache = boundaryFiber.stateNode;
-  }
+function startWorkOnPendingInteractions(root, lanes) {
+  // we can accurately attribute time spent working on it, And so that cascading
+  // work triggered during the render phase will be associated with it.
 
-  if (retryCache !== null) {
-    // The thenable resolved, so we no longer need to memoize, because it will
-    // never be thrown again.
-    retryCache.delete(thenable);
-  }
+  var interactions = new Set();
+  root.pendingInteractionMap.forEach(function(
+    scheduledInteractions,
+    scheduledLane
+  ) {
+    if (includesSomeLane(lanes, scheduledLane)) {
+      scheduledInteractions.forEach(function(interaction) {
+        return interactions.add(interaction);
+      });
+    }
+  }); // Store the current set of interactions on the FiberRoot for a few reasons:
+  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
+  // without having to recalculate it. We will also use it in commitWork() to
+  // pass to any Profiler onRender() hooks. This also provides DevTools with a
+  // way to access it when the onCommitRoot() hook is called.
 
-  retryTimedOutBoundary(boundaryFiber, retryTime);
-} // Computes the next Just Noticeable Difference (JND) boundary.
-// The theory is that a person can't tell the difference between small differences in time.
-// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
-// difference in the experience. However, waiting for longer might mean that we can avoid
-// showing an intermediate loading state. The longer we have already waited, the harder it
-// is to tell small differences in time. Therefore, the longer we've already waited,
-// the longer we can wait additionally. At some point we have to give up though.
-// We pick a train model where the next boundary commits at a consistent schedule.
-// These particular numbers are vague estimates. We expect to adjust them based on research.
+  root.memoizedInteractions = interactions;
 
-function jnd(timeElapsed) {
-  return timeElapsed < 120
-    ? 120
-    : timeElapsed < 480
-    ? 480
-    : timeElapsed < 1080
-    ? 1080
-    : timeElapsed < 1920
-    ? 1920
-    : timeElapsed < 3000
-    ? 3000
-    : timeElapsed < 4320
-    ? 4320
-    : ceil(timeElapsed / 1960) * 1960;
-}
+  if (interactions.size > 0) {
+    var subscriber = tracing.__subscriberRef.current;
 
-function computeMsUntilSuspenseLoadingDelay(
-  mostRecentEventTime,
-  committedExpirationTime,
-  suspenseConfig
-) {
-  var busyMinDurationMs = suspenseConfig.busyMinDurationMs | 0;
+    if (subscriber !== null) {
+      var threadID = computeThreadID(root, lanes);
 
-  if (busyMinDurationMs <= 0) {
-    return 0;
+      try {
+        subscriber.onWorkStarted(interactions, threadID);
+      } catch (error) {
+        // If the subscriber throws, rethrow it in a separate task
+        scheduleCallback(ImmediatePriority$1, function() {
+          throw error;
+        });
+      }
+    }
   }
+}
 
-  var busyDelayMs = suspenseConfig.busyDelayMs | 0; // Compute the time until this render pass would expire.
+function finishPendingInteractions(root, committedLanes) {
+  var remainingLanesAfterCommit = root.pendingLanes;
+  var subscriber;
 
-  var currentTimeMs = now();
-  var eventTimeMs = inferTimeFromExpirationTimeWithSuspenseConfig(
-    mostRecentEventTime,
-    suspenseConfig
-  );
-  var timeElapsed = currentTimeMs - eventTimeMs;
+  try {
+    subscriber = tracing.__subscriberRef.current;
 
-  if (timeElapsed <= busyDelayMs) {
-    // If we haven't yet waited longer than the initial delay, we don't
-    // have to wait any additional time.
-    return 0;
+    if (subscriber !== null && root.memoizedInteractions.size > 0) {
+      // FIXME: More than one lane can finish in a single commit.
+      var threadID = computeThreadID(root, committedLanes);
+      subscriber.onWorkStopped(root.memoizedInteractions, threadID);
+    }
+  } catch (error) {
+    // If the subscriber throws, rethrow it in a separate task
+    scheduleCallback(ImmediatePriority$1, function() {
+      throw error;
+    });
+  } finally {
+    // Clear completed interactions from the pending Map.
+    // Unless the render was suspended or cascading work was scheduled,
+    // In which case leave pending interactions until the subsequent render.
+    var pendingInteractionMap = root.pendingInteractionMap;
+    pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
+      // Only decrement the pending interaction count if we're done.
+      // If there's still work at the current priority,
+      // That indicates that we are waiting for suspense data.
+      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
+        pendingInteractionMap.delete(lane);
+        scheduledInteractions.forEach(function(interaction) {
+          interaction.__count--;
+
+          if (subscriber !== null && interaction.__count === 0) {
+            try {
+              subscriber.onInteractionScheduledWorkCompleted(interaction);
+            } catch (error) {
+              // If the subscriber throws, rethrow it in a separate task
+              scheduleCallback(ImmediatePriority$1, function() {
+                throw error;
+              });
+            }
+          }
+        });
+      }
+    });
   }
+} // `act` testing API
+//
+// TODO: This is mostly a copy-paste from the legacy `act`, which does not have
+// access to the same internals that we do here. Some trade offs in the
+// implementation no longer make sense.
 
-  var msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed; // This is the value that is passed to `setTimeout`.
+var isFlushingAct = false;
 
-  return msUntilTimeout;
+function shouldForceFlushFallbacksInDEV() {
+  return isFlushingAct;
 }
 
-function checkForNestedUpdates() {
-  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
-    nestedUpdateCount = 0;
-    rootWithNestedUpdates = null;
+function detachFiberAfterEffects(fiber) {
+  fiber.sibling = null;
+  fiber.stateNode = null;
+}
 
-    {
-      throw Error(
-        "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
-      );
-    }
-  }
+var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.
 
+var failedBoundaries = null;
+var setRefreshHandler = function(handler) {
   {
-    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
-      nestedPassiveUpdateCount = 0;
-
-      error(
-        "Maximum update depth exceeded. This can happen when a component " +
-          "calls setState inside useEffect, but useEffect either doesn't " +
-          "have a dependency array, or one of the dependencies changes on " +
-          "every render."
-      );
-    }
+    resolveFamily = handler;
   }
-}
-
-function flushRenderPhaseStrictModeWarningsInDEV() {
+};
+function resolveFunctionForHotReloading(type) {
   {
-    ReactStrictModeWarnings.flushLegacyContextWarning();
-
-    {
-      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return type;
     }
-  }
-}
 
-function stopFinishedWorkLoopTimer() {
-  var didCompleteRoot = true;
-  stopWorkLoopTimer(interruptedBy, didCompleteRoot);
-  interruptedBy = null;
-}
+    var family = resolveFamily(type);
 
-function stopInterruptedWorkLoopTimer() {
-  // TODO: Track which fiber caused the interruption.
-  var didCompleteRoot = false;
-  stopWorkLoopTimer(interruptedBy, didCompleteRoot);
-  interruptedBy = null;
-}
+    if (family === undefined) {
+      return type;
+    } // Use the latest known implementation.
 
-function checkForInterruption(fiberThatReceivedUpdate, updateExpirationTime) {
-  if (
-    workInProgressRoot !== null &&
-    updateExpirationTime > renderExpirationTime$1
-  ) {
-    interruptedBy = fiberThatReceivedUpdate;
+    return family.current;
   }
 }
+function resolveClassForHotReloading(type) {
+  // No implementation differences.
+  return resolveFunctionForHotReloading(type);
+}
+function resolveForwardRefForHotReloading(type) {
+  {
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return type;
+    }
 
-var didWarnStateUpdateForUnmountedComponent = null;
+    var family = resolveFamily(type);
 
-function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
-  {
-    var tag = fiber.tag;
+    if (family === undefined) {
+      // Check if we're dealing with a real forwardRef. Don't want to crash early.
+      if (
+        type !== null &&
+        type !== undefined &&
+        typeof type.render === "function"
+      ) {
+        // ForwardRef is special because its resolved .type is an object,
+        // but it's possible that we only have its inner render function in the map.
+        // If that inner render function is different, we'll build a new forwardRef type.
+        var currentRender = resolveFunctionForHotReloading(type.render);
 
-    if (
-      tag !== HostRoot &&
-      tag !== ClassComponent &&
-      tag !== FunctionComponent &&
-      tag !== ForwardRef &&
-      tag !== MemoComponent &&
-      tag !== SimpleMemoComponent &&
-      tag !== Block
-    ) {
-      // Only warn for user-defined components, not internal ones like Suspense.
-      return;
-    }
-    // the problematic code almost always lies inside that component.
+        if (type.render !== currentRender) {
+          var syntheticType = {
+            $$typeof: REACT_FORWARD_REF_TYPE,
+            render: currentRender
+          };
 
-    var componentName = getComponentName(fiber.type) || "ReactComponent";
+          if (type.displayName !== undefined) {
+            syntheticType.displayName = type.displayName;
+          }
 
-    if (didWarnStateUpdateForUnmountedComponent !== null) {
-      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
-        return;
+          return syntheticType;
+        }
       }
 
-      didWarnStateUpdateForUnmountedComponent.add(componentName);
-    } else {
-      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
-    }
+      return type;
+    } // Use the latest known implementation.
 
-    error(
-      "Can't perform a React state update on an unmounted component. This " +
-        "is a no-op, but it indicates a memory leak in your application. To " +
-        "fix, cancel all subscriptions and asynchronous tasks in %s.%s",
-      tag === ClassComponent
-        ? "the componentWillUnmount method"
-        : "a useEffect cleanup function",
-      getStackByFiberInDevAndProd(fiber)
-    );
+    return family.current;
   }
 }
+function isCompatibleFamilyForHotReloading(fiber, element) {
+  {
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return false;
+    }
 
-var beginWork$1;
-
-{
-  var dummyFiber = null;
-
-  beginWork$1 = function(current, unitOfWork, expirationTime) {
-    // If a component throws an error, we replay it again in a synchronously
-    // dispatched event, so that the debugger will treat it as an uncaught
-    // error See ReactErrorUtils for more information.
-    // Before entering the begin phase, copy the work-in-progress onto a dummy
-    // fiber. If beginWork throws, we'll use this to reset the state.
-    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(
-      dummyFiber,
-      unitOfWork
-    );
-
-    try {
-      return beginWork(current, unitOfWork, expirationTime);
-    } catch (originalError) {
-      if (
-        originalError !== null &&
-        typeof originalError === "object" &&
-        typeof originalError.then === "function"
-      ) {
-        // Don't replay promises. Treat everything else like an error.
-        throw originalError;
-      } // Keep this code in sync with handleError; any changes here must have
-      // corresponding changes there.
+    var prevType = fiber.elementType;
+    var nextType = element.type; // If we got here, we know types aren't === equal.
 
-      resetContextDependencies();
-      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
-      // same fiber again.
-      // Unwind the failed stack frame
+    var needsCompareFamilies = false;
+    var $$typeofNextType =
+      typeof nextType === "object" && nextType !== null
+        ? nextType.$$typeof
+        : null;
 
-      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.
+    switch (fiber.tag) {
+      case ClassComponent: {
+        if (typeof nextType === "function") {
+          needsCompareFamilies = true;
+        }
 
-      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
+        break;
+      }
 
-      if (unitOfWork.mode & ProfileMode) {
-        // Reset the profiler timer.
-        startProfilerTimer(unitOfWork);
-      } // Run beginWork again.
+      case FunctionComponent: {
+        if (typeof nextType === "function") {
+          needsCompareFamilies = true;
+        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
+          // We don't know the inner type yet.
+          // We're going to assume that the lazy inner type is stable,
+          // and so it is sufficient to avoid reconciling it away.
+          // We're not going to unwrap or actually use the new lazy type.
+          needsCompareFamilies = true;
+        }
 
-      invokeGuardedCallback(
-        null,
-        beginWork,
-        null,
-        current,
-        unitOfWork,
-        expirationTime
-      );
+        break;
+      }
 
-      if (hasCaughtError()) {
-        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
-        // Rethrow this error instead of the original one.
+      case ForwardRef: {
+        if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
+          needsCompareFamilies = true;
+        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
+          needsCompareFamilies = true;
+        }
 
-        throw replayError;
-      } else {
-        // This branch is reachable if the render phase is impure.
-        throw originalError;
+        break;
       }
-    }
-  };
-}
 
-var didWarnAboutUpdateInRender = false;
+      case MemoComponent:
+      case SimpleMemoComponent: {
+        if ($$typeofNextType === REACT_MEMO_TYPE) {
+          // TODO: if it was but can no longer be simple,
+          // we shouldn't set this.
+          needsCompareFamilies = true;
+        } else if ($$typeofNextType === REACT_LAZY_TYPE) {
+          needsCompareFamilies = true;
+        }
 
-function warnAboutRenderPhaseUpdatesInDEV(fiber) {
-  {
-    if ((executionContext & RenderContext) !== NoContext) {
-      switch (fiber.tag) {
-        case FunctionComponent:
-        case ForwardRef:
-        case SimpleMemoComponent: {
-          error(
-            "Cannot update a component from inside the function body of a " +
-              "different component."
-          );
+        break;
+      }
 
-          break;
-        }
+      default:
+        return false;
+    } // Check if both types have a family and it's the same one.
 
-        case ClassComponent: {
-          if (isRendering && !didWarnAboutUpdateInRender) {
-            error(
-              "Cannot update during an existing state transition (such as " +
-                "within `render`). Render methods should be a pure " +
-                "function of props and state."
-            );
+    if (needsCompareFamilies) {
+      // Note: memo() and forwardRef() we'll compare outer rather than inner type.
+      // This means both of them need to be registered to preserve state.
+      // If we unwrapped and compared the inner types for wrappers instead,
+      // then we would risk falsely saying two separate memo(Foo)
+      // calls are equivalent because they wrap the same Foo function.
+      var prevFamily = resolveFamily(prevType);
 
-            didWarnAboutUpdateInRender = true;
-            break;
-          }
-        }
+      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
+        return true;
       }
     }
-  }
-} // a 'shared' variable that changes when act() opens/closes in tests.
 
-var IsThisRendererActing = {
-  current: false
-};
-function warnIfNotScopedWithMatchingAct(fiber) {
-  {
-    if (
-      IsSomeRendererActing.current === true &&
-      IsThisRendererActing.current !== true
-    ) {
-      error(
-        "It looks like you're using the wrong act() around your test interactions.\n" +
-        "Be sure to use the matching version of act() corresponding to your renderer:\n\n" +
-        "// for react-dom:\n" + // Break up imports to avoid accidentally parsing them as dependencies.
-        "import {act} fr" +
-        "om 'react-dom/test-utils';\n" +
-        "// ...\n" +
-        "act(() => ...);\n\n" +
-        "// for react-test-renderer:\n" + // Break up imports to avoid accidentally parsing them as dependencies.
-          "import TestRenderer fr" +
-          "om react-test-renderer';\n" +
-          "const {act} = TestRenderer;\n" +
-          "// ...\n" +
-          "act(() => ...);" +
-          "%s",
-        getStackByFiberInDevAndProd(fiber)
-      );
-    }
+    return false;
   }
 }
-function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
+function markFailedErrorBoundaryForHotReloading(fiber) {
   {
-    if (
-      (fiber.mode & StrictMode) !== NoMode &&
-      IsSomeRendererActing.current === false &&
-      IsThisRendererActing.current === false
-    ) {
-      error(
-        "An update to %s ran an effect, but was not wrapped in act(...).\n\n" +
-          "When testing, code that causes React state updates should be " +
-          "wrapped into act(...):\n\n" +
-          "act(() => {\n" +
-          "  /* fire events that update state */\n" +
-          "});\n" +
-          "/* assert on the output */\n\n" +
-          "This ensures that you're testing the behavior the user would see " +
-          "in the browser." +
-          " Learn more at https://fb.me/react-wrap-tests-with-act" +
-          "%s",
-        getComponentName(fiber.type),
-        getStackByFiberInDevAndProd(fiber)
-      );
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return;
     }
-  }
-}
 
-function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
-  {
-    if (
-      executionContext === NoContext &&
-      IsSomeRendererActing.current === false &&
-      IsThisRendererActing.current === false
-    ) {
-      error(
-        "An update to %s inside a test was not wrapped in act(...).\n\n" +
-          "When testing, code that causes React state updates should be " +
-          "wrapped into act(...):\n\n" +
-          "act(() => {\n" +
-          "  /* fire events that update state */\n" +
-          "});\n" +
-          "/* assert on the output */\n\n" +
-          "This ensures that you're testing the behavior the user would see " +
-          "in the browser." +
-          " Learn more at https://fb.me/react-wrap-tests-with-act" +
-          "%s",
-        getComponentName(fiber.type),
-        getStackByFiberInDevAndProd(fiber)
-      );
+    if (typeof WeakSet !== "function") {
+      return;
     }
-  }
-}
-
-var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.
-
-var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
-// scheduler is the actual recommendation. The alternative could be a testing build,
-// a new lib, or whatever; we dunno just yet. This message is for early adopters
-// to get their tests right.
-
-function warnIfUnmockedScheduler(fiber) {
-  {
-    if (
-      didWarnAboutUnmockedScheduler === false &&
-      Scheduler.unstable_flushAllWithoutAsserting === undefined
-    ) {
-      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
-        didWarnAboutUnmockedScheduler = true;
 
-        error(
-          'In Concurrent or Sync modes, the "scheduler" module needs to be mocked ' +
-          "to guarantee consistent behaviour across tests and browsers. " +
-          "For example, with jest: \n" + // Break up requires to avoid accidentally parsing them as dependencies.
-            "jest.mock('scheduler', () => require" +
-            "('scheduler/unstable_mock'));\n\n" +
-            "For more info, visit https://fb.me/react-mock-scheduler"
-        );
-      }
+    if (failedBoundaries === null) {
+      failedBoundaries = new WeakSet();
     }
-  }
-}
 
-function computeThreadID(root, expirationTime) {
-  // Interaction threads are unique per root and expiration time.
-  return expirationTime * 1000 + root.interactionThreadID;
+    failedBoundaries.add(fiber);
+  }
 }
+var scheduleRefresh = function(root, update) {
+  {
+    if (resolveFamily === null) {
+      // Hot reloading is disabled.
+      return;
+    }
 
-function markSpawnedWork(expirationTime) {
-  if (spawnedWorkDuringRender === null) {
-    spawnedWorkDuringRender = [expirationTime];
-  } else {
-    spawnedWorkDuringRender.push(expirationTime);
+    var staleFamilies = update.staleFamilies,
+      updatedFamilies = update.updatedFamilies;
+    flushPassiveEffects();
+    flushSync(function() {
+      scheduleFibersWithFamiliesRecursively(
+        root.current,
+        updatedFamilies,
+        staleFamilies
+      );
+    });
   }
-}
+};
+var scheduleRoot = function(root, element) {
+  {
+    if (root.context !== emptyContextObject) {
+      // Super edge case: root has a legacy _renderSubtree context
+      // but we don't know the parentComponent so we can't pass it.
+      // Just ignore. We'll delete this with _renderSubtree code path later.
+      return;
+    }
 
-function scheduleInteractions(root, expirationTime, interactions) {
-  if (interactions.size > 0) {
-    var pendingInteractionMap = root.pendingInteractionMap;
-    var pendingInteractions = pendingInteractionMap.get(expirationTime);
+    flushPassiveEffects();
+    flushSync(function() {
+      updateContainer(element, root, null, null);
+    });
+  }
+};
 
-    if (pendingInteractions != null) {
-      interactions.forEach(function(interaction) {
-        if (!pendingInteractions.has(interaction)) {
-          // Update the pending async work count for previously unscheduled interaction.
-          interaction.__count++;
-        }
+function scheduleFibersWithFamiliesRecursively(
+  fiber,
+  updatedFamilies,
+  staleFamilies
+) {
+  {
+    var alternate = fiber.alternate,
+      child = fiber.child,
+      sibling = fiber.sibling,
+      tag = fiber.tag,
+      type = fiber.type;
+    var candidateType = null;
 
-        pendingInteractions.add(interaction);
-      });
-    } else {
-      pendingInteractionMap.set(expirationTime, new Set(interactions)); // Update the pending async work count for the current interactions.
+    switch (tag) {
+      case FunctionComponent:
+      case SimpleMemoComponent:
+      case ClassComponent:
+        candidateType = type;
+        break;
 
-      interactions.forEach(function(interaction) {
-        interaction.__count++;
-      });
+      case ForwardRef:
+        candidateType = type.render;
+        break;
     }
 
-    var subscriber = tracing.__subscriberRef.current;
-
-    if (subscriber !== null) {
-      var threadID = computeThreadID(root, expirationTime);
-      subscriber.onWorkScheduled(interactions, threadID);
+    if (resolveFamily === null) {
+      throw new Error("Expected resolveFamily to be set during hot reload.");
     }
-  }
-}
 
-function schedulePendingInteractions(root, expirationTime) {
-  scheduleInteractions(root, expirationTime, tracing.__interactionsRef.current);
-}
+    var needsRender = false;
+    var needsRemount = false;
 
-function startWorkOnPendingInteractions(root, expirationTime) {
-  // we can accurately attribute time spent working on it, And so that cascading
-  // work triggered during the render phase will be associated with it.
+    if (candidateType !== null) {
+      var family = resolveFamily(candidateType);
 
-  var interactions = new Set();
-  root.pendingInteractionMap.forEach(function(
-    scheduledInteractions,
-    scheduledExpirationTime
-  ) {
-    if (scheduledExpirationTime >= expirationTime) {
-      scheduledInteractions.forEach(function(interaction) {
-        return interactions.add(interaction);
-      });
+      if (family !== undefined) {
+        if (staleFamilies.has(family)) {
+          needsRemount = true;
+        } else if (updatedFamilies.has(family)) {
+          if (tag === ClassComponent) {
+            needsRemount = true;
+          } else {
+            needsRender = true;
+          }
+        }
+      }
     }
-  }); // Store the current set of interactions on the FiberRoot for a few reasons:
-  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
-  // without having to recalculate it. We will also use it in commitWork() to
-  // pass to any Profiler onRender() hooks. This also provides DevTools with a
-  // way to access it when the onCommitRoot() hook is called.
 
-  root.memoizedInteractions = interactions;
+    if (failedBoundaries !== null) {
+      if (
+        failedBoundaries.has(fiber) ||
+        (alternate !== null && failedBoundaries.has(alternate))
+      ) {
+        needsRemount = true;
+      }
+    }
 
-  if (interactions.size > 0) {
-    var subscriber = tracing.__subscriberRef.current;
+    if (needsRemount) {
+      fiber._debugNeedsRemount = true;
+    }
 
-    if (subscriber !== null) {
-      var threadID = computeThreadID(root, expirationTime);
+    if (needsRemount || needsRender) {
+      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
+    }
 
-      try {
-        subscriber.onWorkStarted(interactions, threadID);
-      } catch (error) {
-        // If the subscriber throws, rethrow it in a separate task
-        scheduleCallback(ImmediatePriority, function() {
-          throw error;
-        });
-      }
+    if (child !== null && !needsRemount) {
+      scheduleFibersWithFamiliesRecursively(
+        child,
+        updatedFamilies,
+        staleFamilies
+      );
+    }
+
+    if (sibling !== null) {
+      scheduleFibersWithFamiliesRecursively(
+        sibling,
+        updatedFamilies,
+        staleFamilies
+      );
     }
   }
 }
 
-function finishPendingInteractions(root, committedExpirationTime) {
-  var earliestRemainingTimeAfterCommit = root.firstPendingTime;
-  var subscriber;
+var findHostInstancesForRefresh = function(root, families) {
+  {
+    var hostInstances = new Set();
+    var types = new Set(
+      families.map(function(family) {
+        return family.current;
+      })
+    );
+    findHostInstancesForMatchingFibersRecursively(
+      root.current,
+      types,
+      hostInstances
+    );
+    return hostInstances;
+  }
+};
 
-  try {
-    subscriber = tracing.__subscriberRef.current;
+function findHostInstancesForMatchingFibersRecursively(
+  fiber,
+  types,
+  hostInstances
+) {
+  {
+    var child = fiber.child,
+      sibling = fiber.sibling,
+      tag = fiber.tag,
+      type = fiber.type;
+    var candidateType = null;
 
-    if (subscriber !== null && root.memoizedInteractions.size > 0) {
-      var threadID = computeThreadID(root, committedExpirationTime);
-      subscriber.onWorkStopped(root.memoizedInteractions, threadID);
+    switch (tag) {
+      case FunctionComponent:
+      case SimpleMemoComponent:
+      case ClassComponent:
+        candidateType = type;
+        break;
+
+      case ForwardRef:
+        candidateType = type.render;
+        break;
     }
-  } catch (error) {
-    // If the subscriber throws, rethrow it in a separate task
-    scheduleCallback(ImmediatePriority, function() {
-      throw error;
-    });
-  } finally {
-    // Clear completed interactions from the pending Map.
-    // Unless the render was suspended or cascading work was scheduled,
-    // In which case leave pending interactions until the subsequent render.
-    var pendingInteractionMap = root.pendingInteractionMap;
-    pendingInteractionMap.forEach(function(
-      scheduledInteractions,
-      scheduledExpirationTime
-    ) {
-      // Only decrement the pending interaction count if we're done.
-      // If there's still work at the current priority,
-      // That indicates that we are waiting for suspense data.
-      if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
-        pendingInteractionMap.delete(scheduledExpirationTime);
-        scheduledInteractions.forEach(function(interaction) {
-          interaction.__count--;
 
-          if (subscriber !== null && interaction.__count === 0) {
-            try {
-              subscriber.onInteractionScheduledWorkCompleted(interaction);
-            } catch (error) {
-              // If the subscriber throws, rethrow it in a separate task
-              scheduleCallback(ImmediatePriority, function() {
-                throw error;
-              });
-            }
-          }
-        });
+    var didMatch = false;
+
+    if (candidateType !== null) {
+      if (types.has(candidateType)) {
+        didMatch = true;
       }
-    });
-  }
-}
+    }
 
-var onScheduleFiberRoot = null;
-var onCommitFiberRoot = null;
-var onCommitFiberUnmount = null;
-var hasLoggedError = false;
-var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
-function injectInternals(internals) {
-  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
-    // No DevTools
-    return false;
+    if (didMatch) {
+      // We have a match. This only drills down to the closest host components.
+      // There's no need to search deeper because for the purpose of giving
+      // visual feedback, "flashing" outermost parent rectangles is sufficient.
+      findHostInstancesForFiberShallowly(fiber, hostInstances);
+    } else {
+      // If there's no match, maybe there will be one further down in the child tree.
+      if (child !== null) {
+        findHostInstancesForMatchingFibersRecursively(
+          child,
+          types,
+          hostInstances
+        );
+      }
+    }
+
+    if (sibling !== null) {
+      findHostInstancesForMatchingFibersRecursively(
+        sibling,
+        types,
+        hostInstances
+      );
+    }
   }
+}
 
-  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+function findHostInstancesForFiberShallowly(fiber, hostInstances) {
+  {
+    var foundHostInstances = findChildHostInstancesForFiberShallowly(
+      fiber,
+      hostInstances
+    );
 
-  if (hook.isDisabled) {
-    // This isn't a real property on the hook, but it can be set to opt out
-    // of DevTools integration and associated warnings and logs.
-    // https://github.com/facebook/react/issues/3877
-    return true;
-  }
+    if (foundHostInstances) {
+      return;
+    } // If we didn't find any host children, fallback to closest host parent.
 
-  if (!hook.supportsFiber) {
-    {
-      error(
-        "The installed version of React DevTools is too old and will not work " +
-          "with the current version of React. Please update React DevTools. " +
-          "https://fb.me/react-devtools"
-      );
-    } // DevTools exists, even though it doesn't support Fiber.
+    var node = fiber;
 
-    return true;
-  }
+    while (true) {
+      switch (node.tag) {
+        case HostComponent:
+          hostInstances.add(node.stateNode);
+          return;
 
-  try {
-    var rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
+        case HostPortal:
+          hostInstances.add(node.stateNode.containerInfo);
+          return;
 
-    if (true) {
-      // Only used by Fast Refresh
-      if (typeof hook.onScheduleFiberRoot === "function") {
-        onScheduleFiberRoot = function(root, children) {
-          try {
-            hook.onScheduleFiberRoot(rendererID, root, children);
-          } catch (err) {
-            if (true && !hasLoggedError) {
-              hasLoggedError = true;
-
-              error("React instrumentation encountered an error: %s", err);
-            }
-          }
-        };
+        case HostRoot:
+          hostInstances.add(node.stateNode.containerInfo);
+          return;
       }
-    }
 
-    onCommitFiberRoot = function(root, expirationTime) {
-      try {
-        var didError = (root.current.effectTag & DidCapture) === DidCapture;
+      if (node.return === null) {
+        throw new Error("Expected to reach root first.");
+      }
 
-        if (enableProfilerTimer) {
-          var currentTime = getCurrentTime();
-          var priorityLevel = inferPriorityFromExpirationTime(
-            currentTime,
-            expirationTime
-          );
-          hook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
-        } else {
-          hook.onCommitFiberRoot(rendererID, root, undefined, didError);
-        }
-      } catch (err) {
-        if (true) {
-          if (!hasLoggedError) {
-            hasLoggedError = true;
+      node = node.return;
+    }
+  }
+}
 
-            error("React instrumentation encountered an error: %s", err);
-          }
-        }
+function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
+  {
+    var node = fiber;
+    var foundHostInstances = false;
+
+    while (true) {
+      if (node.tag === HostComponent) {
+        // We got a match.
+        foundHostInstances = true;
+        hostInstances.add(node.stateNode); // There may still be more, so keep searching.
+      } else if (node.child !== null) {
+        node.child.return = node;
+        node = node.child;
+        continue;
       }
-    };
 
-    onCommitFiberUnmount = function(fiber) {
-      try {
-        hook.onCommitFiberUnmount(rendererID, fiber);
-      } catch (err) {
-        if (true) {
-          if (!hasLoggedError) {
-            hasLoggedError = true;
+      if (node === fiber) {
+        return foundHostInstances;
+      }
 
-            error("React instrumentation encountered an error: %s", err);
-          }
+      while (node.sibling === null) {
+        if (node.return === null || node.return === fiber) {
+          return foundHostInstances;
         }
+
+        node = node.return;
       }
-    };
-  } catch (err) {
-    // Catch all errors because it is unsafe to throw during initialization.
-    {
-      error("React instrumentation encountered an error: %s.", err);
-    }
-  } // DevTools exists
 
-  return true;
-}
-function onScheduleRoot(root, children) {
-  if (typeof onScheduleFiberRoot === "function") {
-    onScheduleFiberRoot(root, children);
-  }
-}
-function onCommitRoot(root, expirationTime) {
-  if (typeof onCommitFiberRoot === "function") {
-    onCommitFiberRoot(root, expirationTime);
-  }
-}
-function onCommitUnmount(fiber) {
-  if (typeof onCommitFiberUnmount === "function") {
-    onCommitFiberUnmount(fiber);
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
   }
+
+  return false;
 }
 
 var hasBadMapPolyfill;
@@ -19629,13 +20981,11 @@ var hasBadMapPolyfill;
 
   try {
     var nonExtensibleObject = Object.preventExtensions({});
-    var testMap = new Map([[nonExtensibleObject, null]]);
-    var testSet = new Set([nonExtensibleObject]); // This is necessary for Rollup to not consider these unused.
-    // https://github.com/rollup/rollup/issues/1771
-    // TODO: we can remove these if Rollup fixes the bug.
+    /* eslint-disable no-new */
 
-    testMap.set(0, 0);
-    testSet.add(0);
+    new Map([[nonExtensibleObject, null]]);
+    new Set([nonExtensibleObject]);
+    /* eslint-enable no-new */
   } catch (e) {
     // TODO: Consider warning about bad polyfills
     hasBadMapPolyfill = true;
@@ -19668,8 +21018,8 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.nextEffect = null;
   this.firstEffect = null;
   this.lastEffect = null;
-  this.expirationTime = NoWork;
-  this.childExpirationTime = NoWork;
+  this.lanes = NoLanes;
+  this.childLanes = NoLanes;
   this.alternate = null;
 
   {
@@ -19696,15 +21046,11 @@ function FiberNode(tag, pendingProps, key, mode) {
     this.actualStartTime = -1;
     this.selfBaseDuration = 0;
     this.treeBaseDuration = 0;
-  } // This is normally DEV-only except www when it adds listeners.
-  // TODO: remove the User Timing integration in favor of Root Events.
-
-  {
-    this._debugID = debugCounter++;
-    this._debugIsCurrentlyTiming = false;
   }
 
   {
+    // This isn't directly used but is handy for debugging internals:
+    this._debugID = debugCounter++;
     this._debugSource = null;
     this._debugOwner = null;
     this._debugNeedsRemount = false;
@@ -19784,10 +21130,7 @@ function createWorkInProgress(current, pendingProps) {
 
     {
       // DEV-only fields
-      {
-        workInProgress._debugID = current._debugID;
-      }
-
+      workInProgress._debugID = current._debugID;
       workInProgress._debugSource = current._debugSource;
       workInProgress._debugOwner = current._debugOwner;
       workInProgress._debugHookTypes = current._debugHookTypes;
@@ -19796,7 +21139,9 @@ function createWorkInProgress(current, pendingProps) {
     workInProgress.alternate = current;
     current.alternate = workInProgress;
   } else {
-    workInProgress.pendingProps = pendingProps; // We already have an alternate.
+    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.
+
+    workInProgress.type = current.type; // We already have an alternate.
     // Reset the effect tag.
 
     workInProgress.effectTag = NoEffect; // The effect list is no longer valid.
@@ -19815,8 +21160,8 @@ function createWorkInProgress(current, pendingProps) {
     }
   }
 
-  workInProgress.childExpirationTime = current.childExpirationTime;
-  workInProgress.expirationTime = current.expirationTime;
+  workInProgress.childLanes = current.childLanes;
+  workInProgress.lanes = current.lanes;
   workInProgress.child = current.child;
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
@@ -19828,9 +21173,8 @@ function createWorkInProgress(current, pendingProps) {
     currentDependencies === null
       ? null
       : {
-          expirationTime: currentDependencies.expirationTime,
-          firstContext: currentDependencies.firstContext,
-          responders: currentDependencies.responders
+          lanes: currentDependencies.lanes,
+          firstContext: currentDependencies.firstContext
         }; // These will be overridden during the parent's reconciliation
 
   workInProgress.sibling = current.sibling;
@@ -19865,7 +21209,7 @@ function createWorkInProgress(current, pendingProps) {
   return workInProgress;
 } // Used to reuse a Fiber for a second pass.
 
-function resetWorkInProgress(workInProgress, renderExpirationTime) {
+function resetWorkInProgress(workInProgress, renderLanes) {
   // This resets the Fiber to what createFiber or createWorkInProgress would
   // have set the values to before during the first pass. Ideally this wouldn't
   // be necessary but unfortunately many code paths reads from the workInProgress
@@ -19883,13 +21227,14 @@ function resetWorkInProgress(workInProgress, renderExpirationTime) {
 
   if (current === null) {
     // Reset to createFiber's initial values.
-    workInProgress.childExpirationTime = NoWork;
-    workInProgress.expirationTime = renderExpirationTime;
+    workInProgress.childLanes = NoLanes;
+    workInProgress.lanes = renderLanes;
     workInProgress.child = null;
     workInProgress.memoizedProps = null;
     workInProgress.memoizedState = null;
     workInProgress.updateQueue = null;
     workInProgress.dependencies = null;
+    workInProgress.stateNode = null;
 
     {
       // Note: We don't reset the actualTime counts. It's useful to accumulate
@@ -19899,12 +21244,14 @@ function resetWorkInProgress(workInProgress, renderExpirationTime) {
     }
   } else {
     // Reset to the cloned values that createWorkInProgress would've.
-    workInProgress.childExpirationTime = current.childExpirationTime;
-    workInProgress.expirationTime = current.expirationTime;
+    workInProgress.childLanes = current.childLanes;
+    workInProgress.lanes = current.lanes;
     workInProgress.child = current.child;
     workInProgress.memoizedProps = current.memoizedProps;
     workInProgress.memoizedState = current.memoizedState;
-    workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
+    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.
+
+    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so
     // it cannot be shared with the current fiber.
 
     var currentDependencies = current.dependencies;
@@ -19912,9 +21259,8 @@ function resetWorkInProgress(workInProgress, renderExpirationTime) {
       currentDependencies === null
         ? null
         : {
-            expirationTime: currentDependencies.expirationTime,
-            firstContext: currentDependencies.firstContext,
-            responders: currentDependencies.responders
+            lanes: currentDependencies.lanes,
+            firstContext: currentDependencies.firstContext
           };
 
     {
@@ -19953,9 +21299,8 @@ function createFiberFromTypeAndProps(
   pendingProps,
   owner,
   mode,
-  expirationTime
+  lanes
 ) {
-  var fiber;
   var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
 
   var resolvedType = type;
@@ -19977,16 +21322,11 @@ function createFiberFromTypeAndProps(
   } else {
     getTag: switch (type) {
       case REACT_FRAGMENT_TYPE:
-        return createFiberFromFragment(
-          pendingProps.children,
-          mode,
-          expirationTime,
-          key
-        );
+        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
 
-      case REACT_CONCURRENT_MODE_TYPE:
+      case REACT_DEBUG_TRACING_MODE_TYPE:
         fiberTag = Mode;
-        mode |= ConcurrentMode | BlockingMode | StrictMode;
+        mode |= DebugTracingMode;
         break;
 
       case REACT_STRICT_MODE_TYPE:
@@ -19995,18 +21335,23 @@ function createFiberFromTypeAndProps(
         break;
 
       case REACT_PROFILER_TYPE:
-        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
+        return createFiberFromProfiler(pendingProps, mode, lanes, key);
 
       case REACT_SUSPENSE_TYPE:
-        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);
+        return createFiberFromSuspense(pendingProps, mode, lanes, key);
 
       case REACT_SUSPENSE_LIST_TYPE:
-        return createFiberFromSuspenseList(
-          pendingProps,
-          mode,
-          expirationTime,
-          key
-        );
+        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
+
+      case REACT_OFFSCREEN_TYPE:
+        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+
+      case REACT_LEGACY_HIDDEN_TYPE:
+        return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
+
+      case REACT_SCOPE_TYPE:
+
+      // eslint-disable-next-line no-fallthrough
 
       default: {
         if (typeof type === "object" && type !== null) {
@@ -20078,13 +21423,13 @@ function createFiberFromTypeAndProps(
     }
   }
 
-  fiber = createFiber(fiberTag, pendingProps, key, mode);
+  var fiber = createFiber(fiberTag, pendingProps, key, mode);
   fiber.elementType = type;
   fiber.type = resolvedType;
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   return fiber;
 }
-function createFiberFromElement(element, mode, expirationTime) {
+function createFiberFromElement(element, mode, lanes) {
   var owner = null;
 
   {
@@ -20100,7 +21445,7 @@ function createFiberFromElement(element, mode, expirationTime) {
     pendingProps,
     owner,
     mode,
-    expirationTime
+    lanes
   );
 
   {
@@ -20110,13 +21455,13 @@ function createFiberFromElement(element, mode, expirationTime) {
 
   return fiber;
 }
-function createFiberFromFragment(elements, mode, expirationTime, key) {
+function createFiberFromFragment(elements, mode, lanes, key) {
   var fiber = createFiber(Fragment, elements, key, mode);
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   return fiber;
 }
 
-function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
+function createFiberFromProfiler(pendingProps, mode, lanes, key) {
   {
     if (typeof pendingProps.id !== "string") {
       error('Profiler must specify an "id" as a prop');
@@ -20127,7 +21472,7 @@ function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
 
   fiber.elementType = REACT_PROFILER_TYPE;
   fiber.type = REACT_PROFILER_TYPE;
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
 
   {
     fiber.stateNode = {
@@ -20139,17 +21484,17 @@ function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
   return fiber;
 }
 
-function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
+function createFiberFromSuspense(pendingProps, mode, lanes, key) {
   var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
   // This needs to be fixed in getComponentName so that it relies on the tag
   // instead.
 
   fiber.type = REACT_SUSPENSE_TYPE;
   fiber.elementType = REACT_SUSPENSE_TYPE;
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   return fiber;
 }
-function createFiberFromSuspenseList(pendingProps, mode, expirationTime, key) {
+function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
   var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
 
   {
@@ -20160,18 +21505,44 @@ function createFiberFromSuspenseList(pendingProps, mode, expirationTime, key) {
   }
 
   fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
+  return fiber;
+}
+function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
+  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
+  // This needs to be fixed in getComponentName so that it relies on the tag
+  // instead.
+
+  {
+    fiber.type = REACT_OFFSCREEN_TYPE;
+  }
+
+  fiber.elementType = REACT_OFFSCREEN_TYPE;
+  fiber.lanes = lanes;
+  return fiber;
+}
+function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
+  var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
+  // This needs to be fixed in getComponentName so that it relies on the tag
+  // instead.
+
+  {
+    fiber.type = REACT_LEGACY_HIDDEN_TYPE;
+  }
+
+  fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
+  fiber.lanes = lanes;
   return fiber;
 }
-function createFiberFromText(content, mode, expirationTime) {
+function createFiberFromText(content, mode, lanes) {
   var fiber = createFiber(HostText, content, null, mode);
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   return fiber;
 }
-function createFiberFromPortal(portal, mode, expirationTime) {
+function createFiberFromPortal(portal, mode, lanes) {
   var pendingProps = portal.children !== null ? portal.children : [];
   var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
-  fiber.expirationTime = expirationTime;
+  fiber.lanes = lanes;
   fiber.stateNode = {
     containerInfo: portal.containerInfo,
     pendingChildren: null,
@@ -20212,8 +21583,8 @@ function assignFiberPropertiesInDEV(target, source) {
   target.nextEffect = source.nextEffect;
   target.firstEffect = source.firstEffect;
   target.lastEffect = source.lastEffect;
-  target.expirationTime = source.expirationTime;
-  target.childExpirationTime = source.childExpirationTime;
+  target.lanes = source.lanes;
+  target.childLanes = source.childLanes;
   target.alternate = source.alternate;
 
   {
@@ -20223,11 +21594,7 @@ function assignFiberPropertiesInDEV(target, source) {
     target.treeBaseDuration = source.treeBaseDuration;
   }
 
-  {
-    target._debugID = source._debugID;
-    target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
-  }
-
+  target._debugID = source._debugID;
   target._debugSource = source._debugSource;
   target._debugOwner = source._debugOwner;
   target._debugNeedsRemount = source._debugNeedsRemount;
@@ -20237,30 +21604,49 @@ function assignFiberPropertiesInDEV(target, source) {
 
 function FiberRootNode(containerInfo, tag, hydrate) {
   this.tag = tag;
-  this.current = null;
   this.containerInfo = containerInfo;
   this.pendingChildren = null;
+  this.current = null;
   this.pingCache = null;
-  this.finishedExpirationTime = NoWork;
   this.finishedWork = null;
   this.timeoutHandle = noTimeout;
   this.context = null;
   this.pendingContext = null;
   this.hydrate = hydrate;
   this.callbackNode = null;
-  this.callbackPriority = NoPriority;
-  this.firstPendingTime = NoWork;
-  this.firstSuspendedTime = NoWork;
-  this.lastSuspendedTime = NoWork;
-  this.nextKnownPendingLevel = NoWork;
-  this.lastPingedTime = NoWork;
-  this.lastExpiredTime = NoWork;
+  this.callbackPriority = NoLanePriority;
+  this.eventTimes = createLaneMap(NoLanes);
+  this.expirationTimes = createLaneMap(NoTimestamp);
+  this.pendingLanes = NoLanes;
+  this.suspendedLanes = NoLanes;
+  this.pingedLanes = NoLanes;
+  this.expiredLanes = NoLanes;
+  this.mutableReadLanes = NoLanes;
+  this.finishedLanes = NoLanes;
+  this.entangledLanes = NoLanes;
+  this.entanglements = createLaneMap(NoLanes);
 
   {
     this.interactionThreadID = tracing.unstable_getThreadID();
     this.memoizedInteractions = new Set();
     this.pendingInteractionMap = new Map();
   }
+
+  {
+    switch (tag) {
+      case BlockingRoot:
+        this._debugRootType = "createBlockingRoot()";
+        break;
+
+      case ConcurrentRoot:
+        this._debugRootType = "createRoot()";
+        break;
+
+      case LegacyRoot:
+        this._debugRootType = "createLegacyRoot()";
+        break;
+    }
+  }
 }
 
 function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
@@ -20273,95 +21659,22 @@ function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
   initializeUpdateQueue(uninitializedFiber);
   return root;
 }
-function isRootSuspendedAtTime(root, expirationTime) {
-  var firstSuspendedTime = root.firstSuspendedTime;
-  var lastSuspendedTime = root.lastSuspendedTime;
-  return (
-    firstSuspendedTime !== NoWork &&
-    firstSuspendedTime >= expirationTime &&
-    lastSuspendedTime <= expirationTime
-  );
-}
-function markRootSuspendedAtTime(root, expirationTime) {
-  var firstSuspendedTime = root.firstSuspendedTime;
-  var lastSuspendedTime = root.lastSuspendedTime;
-
-  if (firstSuspendedTime < expirationTime) {
-    root.firstSuspendedTime = expirationTime;
-  }
-
-  if (lastSuspendedTime > expirationTime || firstSuspendedTime === NoWork) {
-    root.lastSuspendedTime = expirationTime;
-  }
-
-  if (expirationTime <= root.lastPingedTime) {
-    root.lastPingedTime = NoWork;
-  }
-
-  if (expirationTime <= root.lastExpiredTime) {
-    root.lastExpiredTime = NoWork;
-  }
-}
-function markRootUpdatedAtTime(root, expirationTime) {
-  // Update the range of pending times
-  var firstPendingTime = root.firstPendingTime;
-
-  if (expirationTime > firstPendingTime) {
-    root.firstPendingTime = expirationTime;
-  } // Update the range of suspended times. Treat everything lower priority or
-  // equal to this update as unsuspended.
-
-  var firstSuspendedTime = root.firstSuspendedTime;
-
-  if (firstSuspendedTime !== NoWork) {
-    if (expirationTime >= firstSuspendedTime) {
-      // The entire suspended range is now unsuspended.
-      root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;
-    } else if (expirationTime >= root.lastSuspendedTime) {
-      root.lastSuspendedTime = expirationTime + 1;
-    } // This is a pending level. Check if it's higher priority than the next
-    // known pending level.
 
-    if (expirationTime > root.nextKnownPendingLevel) {
-      root.nextKnownPendingLevel = expirationTime;
-    }
-  }
-}
-function markRootFinishedAtTime(
-  root,
-  finishedExpirationTime,
-  remainingExpirationTime
+function createPortal(
+  children,
+  containerInfo, // TODO: figure out the API for cross-renderer implementation.
+  implementation
 ) {
-  // Update the range of pending times
-  root.firstPendingTime = remainingExpirationTime; // Update the range of suspended times. Treat everything higher priority or
-  // equal to this update as unsuspended.
-
-  if (finishedExpirationTime <= root.lastSuspendedTime) {
-    // The entire suspended range is now unsuspended.
-    root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;
-  } else if (finishedExpirationTime <= root.firstSuspendedTime) {
-    // Part of the suspended range is now unsuspended. Narrow the range to
-    // include everything between the unsuspended time (non-inclusive) and the
-    // last suspended time.
-    root.firstSuspendedTime = finishedExpirationTime - 1;
-  }
-
-  if (finishedExpirationTime <= root.lastPingedTime) {
-    // Clear the pinged time
-    root.lastPingedTime = NoWork;
-  }
-
-  if (finishedExpirationTime <= root.lastExpiredTime) {
-    // Clear the expired time
-    root.lastExpiredTime = NoWork;
-  }
-}
-function markRootExpiredAtTime(root, expirationTime) {
-  var lastExpiredTime = root.lastExpiredTime;
-
-  if (lastExpiredTime === NoWork || lastExpiredTime > expirationTime) {
-    root.lastExpiredTime = expirationTime;
-  }
+  var key =
+    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
+  return {
+    // This tag allow us to uniquely identify this as a React Portal
+    $$typeof: REACT_PORTAL_TYPE,
+    key: key == null ? null : "" + key,
+    children: children,
+    containerInfo: containerInfo,
+    implementation: implementation
+  };
 }
 
 var didWarnAboutNestedUpdates;
@@ -20421,31 +21734,42 @@ function findHostInstanceWithWarning(component, methodName) {
 
       if (!didWarnAboutFindNodeInStrictMode[componentName]) {
         didWarnAboutFindNodeInStrictMode[componentName] = true;
+        var previousFiber = current;
 
-        if (fiber.mode & StrictMode) {
-          error(
-            "%s is deprecated in StrictMode. " +
-              "%s was passed an instance of %s which is inside StrictMode. " +
-              "Instead, add a ref directly to the element you want to reference. " +
-              "Learn more about using refs safely here: " +
-              "https://fb.me/react-strict-mode-find-node%s",
-            methodName,
-            methodName,
-            componentName,
-            getStackByFiberInDevAndProd(hostFiber)
-          );
-        } else {
-          error(
-            "%s is deprecated in StrictMode. " +
-              "%s was passed an instance of %s which renders StrictMode children. " +
-              "Instead, add a ref directly to the element you want to reference. " +
-              "Learn more about using refs safely here: " +
-              "https://fb.me/react-strict-mode-find-node%s",
-            methodName,
-            methodName,
-            componentName,
-            getStackByFiberInDevAndProd(hostFiber)
-          );
+        try {
+          setCurrentFiber(hostFiber);
+
+          if (fiber.mode & StrictMode) {
+            error(
+              "%s is deprecated in StrictMode. " +
+                "%s was passed an instance of %s which is inside StrictMode. " +
+                "Instead, add a ref directly to the element you want to reference. " +
+                "Learn more about using refs safely here: " +
+                "https://fb.me/react-strict-mode-find-node",
+              methodName,
+              methodName,
+              componentName
+            );
+          } else {
+            error(
+              "%s is deprecated in StrictMode. " +
+                "%s was passed an instance of %s which renders StrictMode children. " +
+                "Instead, add a ref directly to the element you want to reference. " +
+                "Learn more about using refs safely here: " +
+                "https://fb.me/react-strict-mode-find-node",
+              methodName,
+              methodName,
+              componentName
+            );
+          }
+        } finally {
+          // Ideally this should reset to previous but this shouldn't be called in
+          // render and there's another warning for that anyway.
+          if (previousFiber) {
+            setCurrentFiber(previousFiber);
+          } else {
+            resetCurrentFiber();
+          }
         }
       }
     }
@@ -20463,7 +21787,7 @@ function updateContainer(element, container, parentComponent, callback) {
   }
 
   var current$1 = container.current;
-  var currentTime = requestCurrentTimeForUpdate();
+  var eventTime = requestEventTime();
 
   {
     // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
@@ -20474,11 +21798,8 @@ function updateContainer(element, container, parentComponent, callback) {
   }
 
   var suspenseConfig = requestCurrentSuspenseConfig();
-  var expirationTime = computeExpirationForFiber(
-    currentTime,
-    current$1,
-    suspenseConfig
-  );
+  var lane = requestUpdateLane(current$1, suspenseConfig);
+
   var context = getContextForSubtree(parentComponent);
 
   if (container.context === null) {
@@ -20501,7 +21822,7 @@ function updateContainer(element, container, parentComponent, callback) {
     }
   }
 
-  var update = createUpdate(expirationTime, suspenseConfig); // Caution: React DevTools currently depends on this property
+  var update = createUpdate(eventTime, lane, suspenseConfig); // Caution: React DevTools currently depends on this property
   // being called "element".
 
   update.payload = {
@@ -20524,8 +21845,8 @@ function updateContainer(element, container, parentComponent, callback) {
   }
 
   enqueueUpdate(current$1, update);
-  scheduleWork(current$1, expirationTime);
-  return expirationTime;
+  scheduleUpdateOnFiber(current$1, lane, eventTime);
+  return lane;
 }
 function getPublicRootInstance(container) {
   var containerFiber = container.current;
@@ -20592,7 +21913,7 @@ var setSuspenseHandler = null;
       // Shallow cloning props works as a workaround for now to bypass the bailout check.
 
       fiber.memoizedProps = Object.assign({}, fiber.memoizedProps);
-      scheduleWork(fiber, Sync);
+      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
     }
   }; // Support DevTools props for function components, forwardRef, memo, host components, etc.
 
@@ -20603,11 +21924,11 @@ var setSuspenseHandler = null;
       fiber.alternate.pendingProps = fiber.pendingProps;
     }
 
-    scheduleWork(fiber, Sync);
+    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
   };
 
   scheduleUpdate = function(fiber) {
-    scheduleWork(fiber, Sync);
+    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
   };
 
   setSuspenseHandler = function(newShouldSuspendImpl) {
@@ -20615,6 +21936,24 @@ var setSuspenseHandler = null;
   };
 }
 
+function findHostInstanceByFiber(fiber) {
+  var hostFiber = findCurrentHostFiber(fiber);
+
+  if (hostFiber === null) {
+    return null;
+  }
+
+  return hostFiber.stateNode;
+}
+
+function emptyFindFiberByHostInstance(instance) {
+  return null;
+}
+
+function getCurrentFiberForDevTools() {
+  return current;
+}
+
 function injectIntoDevTools(devToolsConfig) {
   var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
   var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
@@ -20628,55 +21967,21 @@ function injectIntoDevTools(devToolsConfig) {
     setSuspenseHandler: setSuspenseHandler,
     scheduleUpdate: scheduleUpdate,
     currentDispatcherRef: ReactCurrentDispatcher,
-    findHostInstanceByFiber: function(fiber) {
-      var hostFiber = findCurrentHostFiber(fiber);
-
-      if (hostFiber === null) {
-        return null;
-      }
-
-      return hostFiber.stateNode;
-    },
-    findFiberByHostInstance: function(instance) {
-      if (!findFiberByHostInstance) {
-        // Might not be implemented by the renderer.
-        return null;
-      }
-
-      return findFiberByHostInstance(instance);
-    },
+    findHostInstanceByFiber: findHostInstanceByFiber,
+    findFiberByHostInstance:
+      findFiberByHostInstance || emptyFindFiberByHostInstance,
     // React Refresh
     findHostInstancesForRefresh: findHostInstancesForRefresh,
     scheduleRefresh: scheduleRefresh,
     scheduleRoot: scheduleRoot,
     setRefreshHandler: setRefreshHandler,
     // Enables DevTools to append owner stacks to error messages in DEV mode.
-    getCurrentFiber: function() {
-      return current;
-    }
+    getCurrentFiber: getCurrentFiberForDevTools
   });
 }
-var IsSomeRendererActing$1 = ReactSharedInternals.IsSomeRendererActing;
-
-function createPortal(
-  children,
-  containerInfo, // TODO: figure out the API for cross-renderer implementation.
-  implementation
-) {
-  var key =
-    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
-  return {
-    // This tag allow us to uniquely identify this as a React Portal
-    $$typeof: REACT_PORTAL_TYPE,
-    key: key == null ? null : "" + key,
-    children: children,
-    containerInfo: containerInfo,
-    implementation: implementation
-  };
-}
 
 // TODO: this is special because it gets imported during build.
-var ReactVersion = "16.13.0";
+var ReactVersion = "17.0.0-alpha.0";
 
 var emptyObject$1 = {};
 
@@ -20907,7 +22212,7 @@ var getInspectorDataForViewAtPoint;
       );
     } else {
       error(
-        "getInspectorDataForViewAtPoint expects to receieve a host component"
+        "getInspectorDataForViewAtPoint expects to receive a host component"
       );
 
       return;
diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
index 31b089c..88403db 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
@@ -6,7 +6,6 @@
  *
  * @noflow
  * @nolint
- * @providesModule ReactNativeRenderer-prod
  * @preventMunge
  * @generated
  */
@@ -16,16 +15,6 @@ require("react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore");
 var ReactNativePrivateInterface = require("react-native/Libraries/ReactPrivate/ReactNativePrivateInterface"),
   React = require("react"),
   Scheduler = require("scheduler");
-function getParent(inst) {
-  do inst = inst.return;
-  while (inst && 5 !== inst.tag);
-  return inst ? inst : null;
-}
-function traverseTwoPhase(inst, fn, arg) {
-  for (var path = []; inst; ) path.push(inst), (inst = getParent(inst));
-  for (inst = path.length; 0 < inst--; ) fn(path[inst], "captured", arg);
-  for (inst = 0; inst < path.length; inst++) fn(path[inst], "bubbled", arg);
-}
 function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
   var funcArgs = Array.prototype.slice.call(arguments, 3);
   try {
@@ -96,109 +85,6 @@ function executeDirectDispatch(event) {
   event._dispatchInstances = null;
   return dispatchListener;
 }
-function getListener(inst, registrationName) {
-  var listener = inst.stateNode;
-  if (!listener) return null;
-  var props = getFiberCurrentPropsFromNode(listener);
-  if (!props) return null;
-  listener = props[registrationName];
-  a: switch (registrationName) {
-    case "onClick":
-    case "onClickCapture":
-    case "onDoubleClick":
-    case "onDoubleClickCapture":
-    case "onMouseDown":
-    case "onMouseDownCapture":
-    case "onMouseMove":
-    case "onMouseMoveCapture":
-    case "onMouseUp":
-    case "onMouseUpCapture":
-    case "onMouseEnter":
-      (props = !props.disabled) ||
-        ((inst = inst.type),
-        (props = !(
-          "button" === inst ||
-          "input" === inst ||
-          "select" === inst ||
-          "textarea" === inst
-        )));
-      inst = !props;
-      break a;
-    default:
-      inst = !1;
-  }
-  if (inst) return null;
-  if (listener && "function" !== typeof listener)
-    throw Error(
-      "Expected `" +
-        registrationName +
-        "` listener to be a function, instead got a value of `" +
-        typeof listener +
-        "` type."
-    );
-  return listener;
-}
-function accumulateInto(current, next) {
-  if (null == next)
-    throw Error(
-      "accumulateInto(...): Accumulated items must not be null or undefined."
-    );
-  if (null == current) return next;
-  if (Array.isArray(current)) {
-    if (Array.isArray(next)) return current.push.apply(current, next), current;
-    current.push(next);
-    return current;
-  }
-  return Array.isArray(next) ? [current].concat(next) : [current, next];
-}
-function forEachAccumulated(arr, cb, scope) {
-  Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
-}
-function accumulateDirectionalDispatches(inst, phase, event) {
-  if (
-    (phase = getListener(
-      inst,
-      event.dispatchConfig.phasedRegistrationNames[phase]
-    ))
-  )
-    (event._dispatchListeners = accumulateInto(
-      event._dispatchListeners,
-      phase
-    )),
-      (event._dispatchInstances = accumulateInto(
-        event._dispatchInstances,
-        inst
-      ));
-}
-function accumulateTwoPhaseDispatchesSingle(event) {
-  event &&
-    event.dispatchConfig.phasedRegistrationNames &&
-    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
-}
-function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
-  if (event && event.dispatchConfig.phasedRegistrationNames) {
-    var targetInst = event._targetInst;
-    targetInst = targetInst ? getParent(targetInst) : null;
-    traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
-  }
-}
-function accumulateDirectDispatchesSingle(event) {
-  if (event && event.dispatchConfig.registrationName) {
-    var inst = event._targetInst;
-    if (inst && event && event.dispatchConfig.registrationName) {
-      var listener = getListener(inst, event.dispatchConfig.registrationName);
-      listener &&
-        ((event._dispatchListeners = accumulateInto(
-          event._dispatchListeners,
-          listener
-        )),
-        (event._dispatchInstances = accumulateInto(
-          event._dispatchInstances,
-          inst
-        )));
-    }
-  }
-}
 function functionThatReturnsTrue() {
   return !0;
 }
@@ -214,6 +100,7 @@ function SyntheticEvent(
   this.dispatchConfig = dispatchConfig;
   this._targetInst = targetInst;
   this.nativeEvent = nativeEvent;
+  this._dispatchInstances = this._dispatchListeners = null;
   dispatchConfig = this.constructor.Interface;
   for (var propName in dispatchConfig)
     dispatchConfig.hasOwnProperty(propName) &&
@@ -293,7 +180,12 @@ SyntheticEvent.extend = function(Interface) {
   return Class;
 };
 addEventPoolingTo(SyntheticEvent);
-function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
+function createOrGetPooledEvent(
+  dispatchConfig,
+  targetInst,
+  nativeEvent,
+  nativeInst
+) {
   if (this.eventPool.length) {
     var instance = this.eventPool.pop();
     this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
@@ -310,8 +202,8 @@ function releasePooledEvent(event) {
   10 > this.eventPool.length && this.eventPool.push(event);
 }
 function addEventPoolingTo(EventConstructor) {
+  EventConstructor.getPooled = createOrGetPooledEvent;
   EventConstructor.eventPool = [];
-  EventConstructor.getPooled = getPooledEvent;
   EventConstructor.release = releasePooledEvent;
 }
 var ResponderSyntheticEvent = SyntheticEvent.extend({
@@ -439,6 +331,22 @@ function accumulate(current, next) {
     ? [current].concat(next)
     : [current, next];
 }
+function accumulateInto(current, next) {
+  if (null == next)
+    throw Error(
+      "accumulateInto(...): Accumulated items must not be null or undefined."
+    );
+  if (null == current) return next;
+  if (Array.isArray(current)) {
+    if (Array.isArray(next)) return current.push.apply(current, next), current;
+    current.push(next);
+    return current;
+  }
+  return Array.isArray(next) ? [current].concat(next) : [current, next];
+}
+function forEachAccumulated(arr, cb, scope) {
+  Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
+}
 var responderInst = null,
   trackedTouchCount = 0;
 function changeResponder(nextResponderInst, blockHostResponder) {
@@ -452,65 +360,132 @@ function changeResponder(nextResponderInst, blockHostResponder) {
     );
 }
 var eventTypes = {
-    startShouldSetResponder: {
-      phasedRegistrationNames: {
-        bubbled: "onStartShouldSetResponder",
-        captured: "onStartShouldSetResponderCapture"
-      },
-      dependencies: startDependencies
-    },
-    scrollShouldSetResponder: {
-      phasedRegistrationNames: {
-        bubbled: "onScrollShouldSetResponder",
-        captured: "onScrollShouldSetResponderCapture"
-      },
-      dependencies: ["topScroll"]
-    },
-    selectionChangeShouldSetResponder: {
-      phasedRegistrationNames: {
-        bubbled: "onSelectionChangeShouldSetResponder",
-        captured: "onSelectionChangeShouldSetResponderCapture"
-      },
-      dependencies: ["topSelectionChange"]
-    },
-    moveShouldSetResponder: {
-      phasedRegistrationNames: {
-        bubbled: "onMoveShouldSetResponder",
-        captured: "onMoveShouldSetResponderCapture"
-      },
-      dependencies: moveDependencies
-    },
-    responderStart: {
-      registrationName: "onResponderStart",
-      dependencies: startDependencies
-    },
-    responderMove: {
-      registrationName: "onResponderMove",
-      dependencies: moveDependencies
+  startShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onStartShouldSetResponder",
+      captured: "onStartShouldSetResponderCapture"
     },
-    responderEnd: {
-      registrationName: "onResponderEnd",
-      dependencies: endDependencies
-    },
-    responderRelease: {
-      registrationName: "onResponderRelease",
-      dependencies: endDependencies
+    dependencies: startDependencies
+  },
+  scrollShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onScrollShouldSetResponder",
+      captured: "onScrollShouldSetResponderCapture"
     },
-    responderTerminationRequest: {
-      registrationName: "onResponderTerminationRequest",
-      dependencies: []
+    dependencies: ["topScroll"]
+  },
+  selectionChangeShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onSelectionChangeShouldSetResponder",
+      captured: "onSelectionChangeShouldSetResponderCapture"
     },
-    responderGrant: { registrationName: "onResponderGrant", dependencies: [] },
-    responderReject: {
-      registrationName: "onResponderReject",
-      dependencies: []
+    dependencies: ["topSelectionChange"]
+  },
+  moveShouldSetResponder: {
+    phasedRegistrationNames: {
+      bubbled: "onMoveShouldSetResponder",
+      captured: "onMoveShouldSetResponderCapture"
     },
-    responderTerminate: {
-      registrationName: "onResponderTerminate",
-      dependencies: []
-    }
+    dependencies: moveDependencies
+  },
+  responderStart: {
+    registrationName: "onResponderStart",
+    dependencies: startDependencies
+  },
+  responderMove: {
+    registrationName: "onResponderMove",
+    dependencies: moveDependencies
+  },
+  responderEnd: {
+    registrationName: "onResponderEnd",
+    dependencies: endDependencies
   },
-  ResponderEventPlugin = {
+  responderRelease: {
+    registrationName: "onResponderRelease",
+    dependencies: endDependencies
+  },
+  responderTerminationRequest: {
+    registrationName: "onResponderTerminationRequest",
+    dependencies: []
+  },
+  responderGrant: { registrationName: "onResponderGrant", dependencies: [] },
+  responderReject: { registrationName: "onResponderReject", dependencies: [] },
+  responderTerminate: {
+    registrationName: "onResponderTerminate",
+    dependencies: []
+  }
+};
+function getParent(inst) {
+  do inst = inst.return;
+  while (inst && 5 !== inst.tag);
+  return inst ? inst : null;
+}
+function traverseTwoPhase(inst, fn, arg) {
+  for (var path = []; inst; ) path.push(inst), (inst = getParent(inst));
+  for (inst = path.length; 0 < inst--; ) fn(path[inst], "captured", arg);
+  for (inst = 0; inst < path.length; inst++) fn(path[inst], "bubbled", arg);
+}
+function getListener(inst, registrationName) {
+  inst = inst.stateNode;
+  if (null === inst) return null;
+  inst = getFiberCurrentPropsFromNode(inst);
+  if (null === inst) return null;
+  if ((inst = inst[registrationName]) && "function" !== typeof inst)
+    throw Error(
+      "Expected `" +
+        registrationName +
+        "` listener to be a function, instead got a value of `" +
+        typeof inst +
+        "` type."
+    );
+  return inst;
+}
+function accumulateDirectionalDispatches(inst, phase, event) {
+  if (
+    (phase = getListener(
+      inst,
+      event.dispatchConfig.phasedRegistrationNames[phase]
+    ))
+  )
+    (event._dispatchListeners = accumulateInto(
+      event._dispatchListeners,
+      phase
+    )),
+      (event._dispatchInstances = accumulateInto(
+        event._dispatchInstances,
+        inst
+      ));
+}
+function accumulateDirectDispatchesSingle(event) {
+  if (event && event.dispatchConfig.registrationName) {
+    var inst = event._targetInst;
+    if (inst && event && event.dispatchConfig.registrationName) {
+      var listener = getListener(inst, event.dispatchConfig.registrationName);
+      listener &&
+        ((event._dispatchListeners = accumulateInto(
+          event._dispatchListeners,
+          listener
+        )),
+        (event._dispatchInstances = accumulateInto(
+          event._dispatchInstances,
+          inst
+        )));
+    }
+  }
+}
+function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    var targetInst = event._targetInst;
+    targetInst = targetInst ? getParent(targetInst) : null;
+    traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
+  }
+}
+function accumulateTwoPhaseDispatchesSingle(event) {
+  event &&
+    event.dispatchConfig.phasedRegistrationNames &&
+    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
+}
+var ResponderEventPlugin = {
     _getResponder: function() {
       return responderInst;
     },
@@ -571,68 +546,70 @@ var eventTypes = {
             JSCompiler_temp = null;
           }
         else JSCompiler_temp = targetInst;
-        targetInst = JSCompiler_temp === responderInst;
-        JSCompiler_temp = ResponderSyntheticEvent.getPooled(
+        targetInst = JSCompiler_temp;
+        JSCompiler_temp = targetInst === responderInst;
+        shouldSetEventType = ResponderSyntheticEvent.getPooled(
           shouldSetEventType,
-          JSCompiler_temp,
+          targetInst,
           nativeEvent,
           nativeEventTarget
         );
-        JSCompiler_temp.touchHistory = ResponderTouchHistoryStore.touchHistory;
-        targetInst
+        shouldSetEventType.touchHistory =
+          ResponderTouchHistoryStore.touchHistory;
+        JSCompiler_temp
           ? forEachAccumulated(
-              JSCompiler_temp,
+              shouldSetEventType,
               accumulateTwoPhaseDispatchesSingleSkipTarget
             )
           : forEachAccumulated(
-              JSCompiler_temp,
+              shouldSetEventType,
               accumulateTwoPhaseDispatchesSingle
             );
         b: {
-          shouldSetEventType = JSCompiler_temp._dispatchListeners;
-          targetInst = JSCompiler_temp._dispatchInstances;
-          if (Array.isArray(shouldSetEventType))
+          JSCompiler_temp = shouldSetEventType._dispatchListeners;
+          targetInst = shouldSetEventType._dispatchInstances;
+          if (Array.isArray(JSCompiler_temp))
             for (
               depthA = 0;
-              depthA < shouldSetEventType.length &&
-              !JSCompiler_temp.isPropagationStopped();
+              depthA < JSCompiler_temp.length &&
+              !shouldSetEventType.isPropagationStopped();
               depthA++
             ) {
               if (
-                shouldSetEventType[depthA](JSCompiler_temp, targetInst[depthA])
+                JSCompiler_temp[depthA](shouldSetEventType, targetInst[depthA])
               ) {
-                shouldSetEventType = targetInst[depthA];
+                JSCompiler_temp = targetInst[depthA];
                 break b;
               }
             }
           else if (
-            shouldSetEventType &&
-            shouldSetEventType(JSCompiler_temp, targetInst)
+            JSCompiler_temp &&
+            JSCompiler_temp(shouldSetEventType, targetInst)
           ) {
-            shouldSetEventType = targetInst;
+            JSCompiler_temp = targetInst;
             break b;
           }
-          shouldSetEventType = null;
+          JSCompiler_temp = null;
         }
-        JSCompiler_temp._dispatchInstances = null;
-        JSCompiler_temp._dispatchListeners = null;
-        JSCompiler_temp.isPersistent() ||
-          JSCompiler_temp.constructor.release(JSCompiler_temp);
-        if (shouldSetEventType && shouldSetEventType !== responderInst)
+        shouldSetEventType._dispatchInstances = null;
+        shouldSetEventType._dispatchListeners = null;
+        shouldSetEventType.isPersistent() ||
+          shouldSetEventType.constructor.release(shouldSetEventType);
+        if (JSCompiler_temp && JSCompiler_temp !== responderInst)
           if (
-            ((JSCompiler_temp = ResponderSyntheticEvent.getPooled(
+            ((shouldSetEventType = ResponderSyntheticEvent.getPooled(
               eventTypes.responderGrant,
-              shouldSetEventType,
+              JSCompiler_temp,
               nativeEvent,
               nativeEventTarget
             )),
-            (JSCompiler_temp.touchHistory =
+            (shouldSetEventType.touchHistory =
               ResponderTouchHistoryStore.touchHistory),
             forEachAccumulated(
-              JSCompiler_temp,
+              shouldSetEventType,
               accumulateDirectDispatchesSingle
             ),
-            (targetInst = !0 === executeDirectDispatch(JSCompiler_temp)),
+            (targetInst = !0 === executeDirectDispatch(shouldSetEventType)),
             responderInst)
           )
             if (
@@ -659,13 +636,13 @@ var eventTypes = {
               forEachAccumulated(depthA, accumulateDirectDispatchesSingle);
               var JSCompiler_temp$jscomp$0 = accumulate(
                 JSCompiler_temp$jscomp$0,
-                [JSCompiler_temp, depthA]
+                [shouldSetEventType, depthA]
               );
-              changeResponder(shouldSetEventType, targetInst);
+              changeResponder(JSCompiler_temp, targetInst);
             } else
               (shouldSetEventType = ResponderSyntheticEvent.getPooled(
                 eventTypes.responderReject,
-                shouldSetEventType,
+                JSCompiler_temp,
                 nativeEvent,
                 nativeEventTarget
               )),
@@ -682,9 +659,9 @@ var eventTypes = {
           else
             (JSCompiler_temp$jscomp$0 = accumulate(
               JSCompiler_temp$jscomp$0,
-              JSCompiler_temp
+              shouldSetEventType
             )),
-              changeResponder(shouldSetEventType, targetInst);
+              changeResponder(JSCompiler_temp, targetInst);
         else JSCompiler_temp$jscomp$0 = null;
       } else JSCompiler_temp$jscomp$0 = null;
       shouldSetEventType = responderInst && isStartish(topLevelType);
@@ -812,7 +789,6 @@ function recomputePluginOrdering() {
         for (var eventName in pluginIndex) {
           var JSCompiler_inline_result = void 0;
           var dispatchConfig = pluginIndex[eventName],
-            pluginModule$jscomp$0 = pluginModule,
             eventName$jscomp$0 = eventName;
           if (eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0))
             throw Error(
@@ -829,7 +805,7 @@ function recomputePluginOrdering() {
               ) &&
                 publishRegistrationName(
                   phasedRegistrationNames[JSCompiler_inline_result],
-                  pluginModule$jscomp$0,
+                  pluginModule,
                   eventName$jscomp$0
                 );
             JSCompiler_inline_result = !0;
@@ -837,7 +813,7 @@ function recomputePluginOrdering() {
             dispatchConfig.registrationName
               ? (publishRegistrationName(
                   dispatchConfig.registrationName,
-                  pluginModule$jscomp$0,
+                  pluginModule,
                   eventName$jscomp$0
                 ),
                 (JSCompiler_inline_result = !0))
@@ -865,13 +841,75 @@ function publishRegistrationName(registrationName, pluginModule) {
 }
 var plugins = [],
   eventNameDispatchConfigs = {},
-  registrationNameModules = {},
-  customBubblingEventTypes =
+  registrationNameModules = {};
+function getListener$1(inst, registrationName) {
+  inst = inst.stateNode;
+  if (null === inst) return null;
+  inst = getFiberCurrentPropsFromNode(inst);
+  if (null === inst) return null;
+  if ((inst = inst[registrationName]) && "function" !== typeof inst)
+    throw Error(
+      "Expected `" +
+        registrationName +
+        "` listener to be a function, instead got a value of `" +
+        typeof inst +
+        "` type."
+    );
+  return inst;
+}
+var customBubblingEventTypes =
     ReactNativePrivateInterface.ReactNativeViewConfigRegistry
       .customBubblingEventTypes,
   customDirectEventTypes =
     ReactNativePrivateInterface.ReactNativeViewConfigRegistry
       .customDirectEventTypes;
+function accumulateDirectionalDispatches$1(inst, phase, event) {
+  if (
+    (phase = getListener$1(
+      inst,
+      event.dispatchConfig.phasedRegistrationNames[phase]
+    ))
+  )
+    (event._dispatchListeners = accumulateInto(
+      event._dispatchListeners,
+      phase
+    )),
+      (event._dispatchInstances = accumulateInto(
+        event._dispatchInstances,
+        inst
+      ));
+}
+function accumulateTwoPhaseDispatchesSingle$1(event) {
+  if (event && event.dispatchConfig.phasedRegistrationNames) {
+    for (var inst = event._targetInst, path = []; inst; ) {
+      path.push(inst);
+      do inst = inst.return;
+      while (inst && 5 !== inst.tag);
+      inst = inst ? inst : null;
+    }
+    for (inst = path.length; 0 < inst--; )
+      accumulateDirectionalDispatches$1(path[inst], "captured", event);
+    for (inst = 0; inst < path.length; inst++)
+      accumulateDirectionalDispatches$1(path[inst], "bubbled", event);
+  }
+}
+function accumulateDirectDispatchesSingle$1(event) {
+  if (event && event.dispatchConfig.registrationName) {
+    var inst = event._targetInst;
+    if (inst && event && event.dispatchConfig.registrationName) {
+      var listener = getListener$1(inst, event.dispatchConfig.registrationName);
+      listener &&
+        ((event._dispatchListeners = accumulateInto(
+          event._dispatchListeners,
+          listener
+        )),
+        (event._dispatchInstances = accumulateInto(
+          event._dispatchInstances,
+          inst
+        )));
+    }
+  }
+}
 if (eventPluginOrder)
   throw Error(
     "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React."
@@ -881,7 +919,7 @@ eventPluginOrder = Array.prototype.slice.call([
   "ReactNativeBridgeEventPlugin"
 ]);
 recomputePluginOrdering();
-var injectedNamesToPlugins$jscomp$inline_94 = {
+var injectedNamesToPlugins$jscomp$inline_228 = {
     ResponderEventPlugin: ResponderEventPlugin,
     ReactNativeBridgeEventPlugin: {
       eventTypes: {},
@@ -905,42 +943,45 @@ var injectedNamesToPlugins$jscomp$inline_94 = {
           nativeEventTarget
         );
         if (bubbleDispatchConfig)
-          forEachAccumulated(topLevelType, accumulateTwoPhaseDispatchesSingle);
+          forEachAccumulated(
+            topLevelType,
+            accumulateTwoPhaseDispatchesSingle$1
+          );
         else if (directDispatchConfig)
-          forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle);
+          forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle$1);
         else return null;
         return topLevelType;
       }
     }
   },
-  isOrderingDirty$jscomp$inline_95 = !1,
-  pluginName$jscomp$inline_96;
-for (pluginName$jscomp$inline_96 in injectedNamesToPlugins$jscomp$inline_94)
+  isOrderingDirty$jscomp$inline_229 = !1,
+  pluginName$jscomp$inline_230;
+for (pluginName$jscomp$inline_230 in injectedNamesToPlugins$jscomp$inline_228)
   if (
-    injectedNamesToPlugins$jscomp$inline_94.hasOwnProperty(
-      pluginName$jscomp$inline_96
+    injectedNamesToPlugins$jscomp$inline_228.hasOwnProperty(
+      pluginName$jscomp$inline_230
     )
   ) {
-    var pluginModule$jscomp$inline_97 =
-      injectedNamesToPlugins$jscomp$inline_94[pluginName$jscomp$inline_96];
+    var pluginModule$jscomp$inline_231 =
+      injectedNamesToPlugins$jscomp$inline_228[pluginName$jscomp$inline_230];
     if (
-      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_96) ||
-      namesToPlugins[pluginName$jscomp$inline_96] !==
-        pluginModule$jscomp$inline_97
+      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_230) ||
+      namesToPlugins[pluginName$jscomp$inline_230] !==
+        pluginModule$jscomp$inline_231
     ) {
-      if (namesToPlugins[pluginName$jscomp$inline_96])
+      if (namesToPlugins[pluginName$jscomp$inline_230])
         throw Error(
           "EventPluginRegistry: Cannot inject two different event plugins using the same name, `" +
-            pluginName$jscomp$inline_96 +
+            pluginName$jscomp$inline_230 +
             "`."
         );
       namesToPlugins[
-        pluginName$jscomp$inline_96
-      ] = pluginModule$jscomp$inline_97;
-      isOrderingDirty$jscomp$inline_95 = !0;
+        pluginName$jscomp$inline_230
+      ] = pluginModule$jscomp$inline_231;
+      isOrderingDirty$jscomp$inline_229 = !0;
     }
   }
-isOrderingDirty$jscomp$inline_95 && recomputePluginOrdering();
+isOrderingDirty$jscomp$inline_229 && recomputePluginOrdering();
 var instanceCache = new Map(),
   instanceProps = new Map();
 function getInstanceFromTag(tag) {
@@ -986,34 +1027,41 @@ function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
     target = null;
   null != inst && (target = inst.stateNode);
   batchedUpdates(function() {
-    var events = target;
-    for (var events$jscomp$0 = null, i = 0; i < plugins.length; i++) {
-      var possiblePlugin = plugins[i];
+    var JSCompiler_inline_result = target;
+    for (
+      var events = null, legacyPlugins = plugins, i = 0;
+      i < legacyPlugins.length;
+      i++
+    ) {
+      var possiblePlugin = legacyPlugins[i];
       possiblePlugin &&
         (possiblePlugin = possiblePlugin.extractEvents(
           topLevelType,
           inst,
           nativeEvent,
-          events,
-          1
+          JSCompiler_inline_result
         )) &&
-        (events$jscomp$0 = accumulateInto(events$jscomp$0, possiblePlugin));
+        (events = accumulateInto(events, possiblePlugin));
     }
-    events = events$jscomp$0;
-    null !== events && (eventQueue = accumulateInto(eventQueue, events));
-    events = eventQueue;
+    JSCompiler_inline_result = events;
+    null !== JSCompiler_inline_result &&
+      (eventQueue = accumulateInto(eventQueue, JSCompiler_inline_result));
+    JSCompiler_inline_result = eventQueue;
     eventQueue = null;
-    if (events) {
-      forEachAccumulated(events, executeDispatchesAndReleaseTopLevel);
+    if (JSCompiler_inline_result) {
+      forEachAccumulated(
+        JSCompiler_inline_result,
+        executeDispatchesAndReleaseTopLevel
+      );
       if (eventQueue)
         throw Error(
           "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."
         );
       if (hasRethrowError)
-        throw ((events = rethrowError),
+        throw ((JSCompiler_inline_result = rethrowError),
         (hasRethrowError = !1),
         (rethrowError = null),
-        events);
+        JSCompiler_inline_result);
     }
   });
 }
@@ -1028,13 +1076,13 @@ ReactNativePrivateInterface.RCTEventEmitter.register({
     ) {
       var JSCompiler_temp = [];
       for (var i = 0; i < changedIndices.length; i++) {
-        var index = changedIndices[i];
-        JSCompiler_temp.push(touches[index]);
-        touches[index] = null;
+        var index$0 = changedIndices[i];
+        JSCompiler_temp.push(touches[index$0]);
+        touches[index$0] = null;
       }
       for (i = changedIndices = 0; i < touches.length; i++)
-        (index = touches[i]),
-          null !== index && (touches[changedIndices++] = index);
+        (index$0 = touches[i]),
+          null !== index$0 && (touches[changedIndices++] = index$0);
       touches.length = changedIndices;
     } else
       for (JSCompiler_temp = [], i = 0; i < changedIndices.length; i++)
@@ -1047,10 +1095,10 @@ ReactNativePrivateInterface.RCTEventEmitter.register({
       i = JSCompiler_temp[changedIndices];
       i.changedTouches = JSCompiler_temp;
       i.touches = touches;
-      index = null;
+      index$0 = null;
       var target = i.target;
-      null === target || void 0 === target || 1 > target || (index = target);
-      _receiveRootNodeIDEvent(index, eventTopLevelType, i);
+      null === target || void 0 === target || 1 > target || (index$0 = target);
+      _receiveRootNodeIDEvent(index$0, eventTopLevelType, i);
     }
   }
 });
@@ -1076,31 +1124,44 @@ ResponderEventPlugin.injection.injectGlobalResponderHandler({
   }
 });
 var ReactSharedInternals =
-  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
-ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher") ||
-  (ReactSharedInternals.ReactCurrentDispatcher = { current: null });
-ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig") ||
-  (ReactSharedInternals.ReactCurrentBatchConfig = { suspense: null });
-var hasSymbol = "function" === typeof Symbol && Symbol.for,
-  REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103,
-  REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106,
-  REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107,
-  REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108,
-  REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114,
-  REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109,
-  REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110,
-  REACT_CONCURRENT_MODE_TYPE = hasSymbol
-    ? Symbol.for("react.concurrent_mode")
-    : 60111,
-  REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112,
-  REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
-  REACT_SUSPENSE_LIST_TYPE = hasSymbol
-    ? Symbol.for("react.suspense_list")
-    : 60120,
-  REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
-  REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116,
-  REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121,
-  MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;
+    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
+  REACT_ELEMENT_TYPE = 60103,
+  REACT_PORTAL_TYPE = 60106,
+  REACT_FRAGMENT_TYPE = 60107,
+  REACT_STRICT_MODE_TYPE = 60108,
+  REACT_PROFILER_TYPE = 60114,
+  REACT_PROVIDER_TYPE = 60109,
+  REACT_CONTEXT_TYPE = 60110,
+  REACT_FORWARD_REF_TYPE = 60112,
+  REACT_SUSPENSE_TYPE = 60113,
+  REACT_SUSPENSE_LIST_TYPE = 60120,
+  REACT_MEMO_TYPE = 60115,
+  REACT_LAZY_TYPE = 60116,
+  REACT_BLOCK_TYPE = 60121,
+  REACT_DEBUG_TRACING_MODE_TYPE = 60129,
+  REACT_OFFSCREEN_TYPE = 60130,
+  REACT_LEGACY_HIDDEN_TYPE = 60131;
+if ("function" === typeof Symbol && Symbol.for) {
+  var symbolFor = Symbol.for;
+  REACT_ELEMENT_TYPE = symbolFor("react.element");
+  REACT_PORTAL_TYPE = symbolFor("react.portal");
+  REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
+  REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
+  REACT_PROFILER_TYPE = symbolFor("react.profiler");
+  REACT_PROVIDER_TYPE = symbolFor("react.provider");
+  REACT_CONTEXT_TYPE = symbolFor("react.context");
+  REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
+  REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
+  REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
+  REACT_MEMO_TYPE = symbolFor("react.memo");
+  REACT_LAZY_TYPE = symbolFor("react.lazy");
+  REACT_BLOCK_TYPE = symbolFor("react.block");
+  symbolFor("react.scope");
+  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
+  REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
+  REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
+}
+var MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;
 function getIteratorFn(maybeIterable) {
   if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
   maybeIterable =
@@ -1108,27 +1169,6 @@ function getIteratorFn(maybeIterable) {
     maybeIterable["@@iterator"];
   return "function" === typeof maybeIterable ? maybeIterable : null;
 }
-function initializeLazyComponentType(lazyComponent) {
-  if (-1 === lazyComponent._status) {
-    var ctor = lazyComponent._result;
-    ctor || (ctor = lazyComponent._ctor);
-    ctor = ctor();
-    lazyComponent._status = 0;
-    lazyComponent._result = ctor;
-    ctor.then(
-      function(moduleObject) {
-        0 === lazyComponent._status &&
-          ((moduleObject = moduleObject.default),
-          (lazyComponent._status = 1),
-          (lazyComponent._result = moduleObject));
-      },
-      function(error) {
-        0 === lazyComponent._status &&
-          ((lazyComponent._status = 2), (lazyComponent._result = error));
-      }
-    );
-  }
-}
 function getComponentName(type) {
   if (null == type) return null;
   if ("function" === typeof type) return type.displayName || type.name || null;
@@ -1163,10 +1203,13 @@ function getComponentName(type) {
       case REACT_MEMO_TYPE:
         return getComponentName(type.type);
       case REACT_BLOCK_TYPE:
-        return getComponentName(type.render);
+        return getComponentName(type._render);
       case REACT_LAZY_TYPE:
-        if ((type = 1 === type._status ? type._result : null))
-          return getComponentName(type);
+        innerType = type._payload;
+        type = type._init;
+        try {
+          return getComponentName(type(innerType));
+        } catch (x) {}
     }
   return null;
 }
@@ -1218,36 +1261,36 @@ function findCurrentFiberUsingSlowPath(fiber) {
     }
     if (a.return !== b.return) (a = parentA), (b = parentB);
     else {
-      for (var didFindChild = !1, _child = parentA.child; _child; ) {
-        if (_child === a) {
+      for (var didFindChild = !1, child$1 = parentA.child; child$1; ) {
+        if (child$1 === a) {
           didFindChild = !0;
           a = parentA;
           b = parentB;
           break;
         }
-        if (_child === b) {
+        if (child$1 === b) {
           didFindChild = !0;
           b = parentA;
           a = parentB;
           break;
         }
-        _child = _child.sibling;
+        child$1 = child$1.sibling;
       }
       if (!didFindChild) {
-        for (_child = parentB.child; _child; ) {
-          if (_child === a) {
+        for (child$1 = parentB.child; child$1; ) {
+          if (child$1 === a) {
             didFindChild = !0;
             a = parentB;
             b = parentA;
             break;
           }
-          if (_child === b) {
+          if (child$1 === b) {
             didFindChild = !0;
             b = parentB;
             a = parentA;
             break;
           }
-          _child = _child.sibling;
+          child$1 = child$1.sibling;
         }
         if (!didFindChild)
           throw Error(
@@ -1282,6 +1325,18 @@ function findCurrentHostFiber(parent) {
   }
   return null;
 }
+function doesFiberContain(parentFiber, childFiber) {
+  for (
+    var parentFiberAlternate = parentFiber.alternate;
+    null !== childFiber;
+
+  ) {
+    if (childFiber === parentFiber || childFiber === parentFiberAlternate)
+      return !0;
+    childFiber = childFiber.return;
+  }
+  return !1;
+}
 var emptyObject = {},
   removedKeys = null,
   removedKeyCount = 0,
@@ -1486,19 +1541,19 @@ function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
               ),
               (removedKeys = null));
     }
-  for (var _propKey in prevProps)
-    void 0 === nextProps[_propKey] &&
-      (!(attributeConfig = validAttributes[_propKey]) ||
-        (updatePayload && void 0 !== updatePayload[_propKey]) ||
-        ((prevProp = prevProps[_propKey]),
+  for (var propKey$3 in prevProps)
+    void 0 === nextProps[propKey$3] &&
+      (!(attributeConfig = validAttributes[propKey$3]) ||
+        (updatePayload && void 0 !== updatePayload[propKey$3]) ||
+        ((prevProp = prevProps[propKey$3]),
         void 0 !== prevProp &&
           ("object" !== typeof attributeConfig ||
           "function" === typeof attributeConfig.diff ||
           "function" === typeof attributeConfig.process
-            ? (((updatePayload || (updatePayload = {}))[_propKey] = null),
+            ? (((updatePayload || (updatePayload = {}))[propKey$3] = null),
               removedKeys || (removedKeys = {}),
-              removedKeys[_propKey] ||
-                ((removedKeys[_propKey] = !0), removedKeyCount++))
+              removedKeys[propKey$3] ||
+                ((removedKeys[propKey$3] = !0), removedKeyCount++))
             : (updatePayload = clearNestedProperty(
                 updatePayload,
                 prevProp,
@@ -1607,9 +1662,22 @@ function finalizeInitialChildren(parentInstance) {
   return !1;
 }
 var scheduleTimeout = setTimeout,
-  cancelTimeout = clearTimeout,
-  valueStack = [],
+  cancelTimeout = clearTimeout;
+function describeComponentFrame(name, source, ownerName) {
+  source = "";
+  ownerName && (source = " (created by " + ownerName + ")");
+  return "\n    in " + (name || "Unknown") + source;
+}
+function describeFunctionComponentFrame(fn, source) {
+  return fn
+    ? describeComponentFrame(fn.displayName || fn.name || null, source, null)
+    : "";
+}
+var valueStack = [],
   index = -1;
+function createCursor(defaultValue) {
+  return { current: defaultValue };
+}
 function pop(cursor) {
   0 > index ||
     ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
@@ -1620,8 +1688,8 @@ function push(cursor, value) {
   cursor.current = value;
 }
 var emptyContextObject = {},
-  contextStackCursor = { current: emptyContextObject },
-  didPerformWorkStackCursor = { current: !1 },
+  contextStackCursor = createCursor(emptyContextObject),
+  didPerformWorkStackCursor = createCursor(!1),
   previousContext = emptyContextObject;
 function getMaskedContext(workInProgress, unmaskedContext) {
   var contextTypes = workInProgress.type.contextTypes;
@@ -1701,11 +1769,220 @@ function invalidateContextProvider(workInProgress, type, didChange) {
     : pop(didPerformWorkStackCursor);
   push(didPerformWorkStackCursor, didChange);
 }
+var rendererID = null,
+  injectedHook = null,
+  Scheduler_now = Scheduler.unstable_now;
+Scheduler_now();
+var return_highestLanePriority = 10;
+function getHighestPriorityLanes(lanes) {
+  if (0 !== (1 & lanes)) return (return_highestLanePriority = 17), 1;
+  if (0 !== (2 & lanes)) return (return_highestLanePriority = 16), 2;
+  if (0 !== (4 & lanes)) return (return_highestLanePriority = 15), 4;
+  var inputDiscreteLanes = 24 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 14), inputDiscreteLanes;
+  if (0 !== (lanes & 32)) return (return_highestLanePriority = 13), 32;
+  inputDiscreteLanes = 192 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 12), inputDiscreteLanes;
+  if (0 !== (lanes & 256)) return (return_highestLanePriority = 11), 256;
+  inputDiscreteLanes = 3584 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 10), inputDiscreteLanes;
+  if (0 !== (lanes & 4096)) return (return_highestLanePriority = 9), 4096;
+  inputDiscreteLanes = 122880 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 8), inputDiscreteLanes;
+  if (0 !== (lanes & 131072)) return (return_highestLanePriority = 7), 131072;
+  inputDiscreteLanes = 3932160 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 6), inputDiscreteLanes;
+  inputDiscreteLanes = 62914560 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 5), inputDiscreteLanes;
+  if (lanes & 67108864) return (return_highestLanePriority = 4), 67108864;
+  if (0 !== (lanes & 134217728))
+    return (return_highestLanePriority = 3), 134217728;
+  inputDiscreteLanes = 805306368 & lanes;
+  if (0 !== inputDiscreteLanes)
+    return (return_highestLanePriority = 2), inputDiscreteLanes;
+  if (0 !== (1073741824 & lanes))
+    return (return_highestLanePriority = 1), 1073741824;
+  return_highestLanePriority = 10;
+  return lanes;
+}
+function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
+  switch (schedulerPriorityLevel) {
+    case 99:
+      return 17;
+    case 98:
+      return 12;
+    case 97:
+    case 96:
+      return 10;
+    case 95:
+      return 2;
+    default:
+      return 0;
+  }
+}
+function lanePriorityToSchedulerPriority(lanePriority) {
+  switch (lanePriority) {
+    case 17:
+    case 16:
+      return 99;
+    case 15:
+    case 14:
+    case 13:
+    case 12:
+      return 98;
+    case 11:
+    case 10:
+    case 9:
+    case 8:
+    case 7:
+    case 6:
+    case 4:
+    case 5:
+      return 97;
+    case 3:
+    case 2:
+    case 1:
+      return 95;
+    case 0:
+      return 90;
+    default:
+      throw Error(
+        "Invalid update priority: " + lanePriority + ". This is a bug in React."
+      );
+  }
+}
+function getNextLanes(root, wipLanes) {
+  var pendingLanes = root.pendingLanes;
+  if (0 === pendingLanes) return (return_highestLanePriority = 0);
+  var nextLanes = 0,
+    nextLanePriority = 0,
+    expiredLanes = root.expiredLanes,
+    suspendedLanes = root.suspendedLanes,
+    pingedLanes = root.pingedLanes;
+  if (0 !== expiredLanes)
+    (nextLanes = expiredLanes),
+      (nextLanePriority = return_highestLanePriority = 17);
+  else if (((expiredLanes = pendingLanes & 134217727), 0 !== expiredLanes)) {
+    var nonIdleUnblockedLanes = expiredLanes & ~suspendedLanes;
+    0 !== nonIdleUnblockedLanes
+      ? ((nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes)),
+        (nextLanePriority = return_highestLanePriority))
+      : ((pingedLanes &= expiredLanes),
+        0 !== pingedLanes &&
+          ((nextLanes = getHighestPriorityLanes(pingedLanes)),
+          (nextLanePriority = return_highestLanePriority)));
+  } else
+    (expiredLanes = pendingLanes & ~suspendedLanes),
+      0 !== expiredLanes
+        ? ((nextLanes = getHighestPriorityLanes(expiredLanes)),
+          (nextLanePriority = return_highestLanePriority))
+        : 0 !== pingedLanes &&
+          ((nextLanes = getHighestPriorityLanes(pingedLanes)),
+          (nextLanePriority = return_highestLanePriority));
+  if (0 === nextLanes) return 0;
+  nextLanes = 31 - clz32(nextLanes);
+  nextLanes = pendingLanes & (((0 > nextLanes ? 0 : 1 << nextLanes) << 1) - 1);
+  if (
+    0 !== wipLanes &&
+    wipLanes !== nextLanes &&
+    0 === (wipLanes & suspendedLanes)
+  ) {
+    getHighestPriorityLanes(wipLanes);
+    if (nextLanePriority <= return_highestLanePriority) return wipLanes;
+    return_highestLanePriority = nextLanePriority;
+  }
+  wipLanes = root.entangledLanes;
+  if (0 !== wipLanes)
+    for (root = root.entanglements, wipLanes &= nextLanes; 0 < wipLanes; )
+      (pendingLanes = 31 - clz32(wipLanes)),
+        (nextLanePriority = 1 << pendingLanes),
+        (nextLanes |= root[pendingLanes]),
+        (wipLanes &= ~nextLanePriority);
+  return nextLanes;
+}
+function getMostRecentEventTime(root, lanes) {
+  root = root.eventTimes;
+  for (var mostRecentEventTime = -1; 0 < lanes; ) {
+    var index$6 = 31 - clz32(lanes),
+      lane = 1 << index$6;
+    index$6 = root[index$6];
+    index$6 > mostRecentEventTime && (mostRecentEventTime = index$6);
+    lanes &= ~lane;
+  }
+  return mostRecentEventTime;
+}
+function getLanesToRetrySynchronouslyOnError(root) {
+  root = root.pendingLanes & -1073741825;
+  return 0 !== root ? root : root & 1073741824 ? 1073741824 : 0;
+}
+function findUpdateLane(lanePriority, wipLanes) {
+  switch (lanePriority) {
+    case 17:
+      return 1;
+    case 16:
+      return 2;
+    case 14:
+      return (
+        (lanePriority = getHighestPriorityLane(24 & ~wipLanes)),
+        0 === lanePriority ? findUpdateLane(12, wipLanes) : lanePriority
+      );
+    case 12:
+      return (
+        (lanePriority = getHighestPriorityLane(192 & ~wipLanes)),
+        0 === lanePriority ? findUpdateLane(10, wipLanes) : lanePriority
+      );
+    case 10:
+      return (
+        (lanePriority = getHighestPriorityLane(3584 & ~wipLanes)),
+        0 === lanePriority &&
+          ((lanePriority = getHighestPriorityLane(4055040 & ~wipLanes)),
+          0 === lanePriority && (lanePriority = 512)),
+        lanePriority
+      );
+    case 2:
+      return (
+        (wipLanes = getHighestPriorityLane(805306368 & ~wipLanes)),
+        0 === wipLanes && (wipLanes = 268435456),
+        wipLanes
+      );
+  }
+  throw Error(
+    "Invalid update priority: " + lanePriority + ". This is a bug in React."
+  );
+}
+function getHighestPriorityLane(lanes) {
+  return lanes & -lanes;
+}
+function pickArbitraryLane(lanes) {
+  return lanes & -lanes;
+}
+function markRootUpdated(root, updateLane, eventTime) {
+  root.pendingLanes |= updateLane;
+  var higherPriorityLanes = updateLane - 1;
+  root.suspendedLanes &= higherPriorityLanes;
+  root.pingedLanes &= higherPriorityLanes;
+  root = root.eventTimes;
+  updateLane = 31 - clz32(updateLane);
+  root[updateLane] = eventTime;
+}
+var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
+  log = Math.log,
+  LN2 = Math.LN2;
+function clz32Fallback(lanes) {
+  return 0 === lanes ? 32 : (31 - ((log(lanes) / LN2) | 0)) | 0;
+}
 var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
   Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
   Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
+  Scheduler_shouldYield = Scheduler.unstable_shouldYield,
   Scheduler_requestPaint = Scheduler.unstable_requestPaint,
-  Scheduler_now = Scheduler.unstable_now,
+  Scheduler_now$1 = Scheduler.unstable_now,
   Scheduler_getCurrentPriorityLevel =
     Scheduler.unstable_getCurrentPriorityLevel,
   Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
@@ -1714,18 +1991,17 @@ var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
   Scheduler_LowPriority = Scheduler.unstable_LowPriority,
   Scheduler_IdlePriority = Scheduler.unstable_IdlePriority,
   fakeCallbackNode = {},
-  shouldYield = Scheduler.unstable_shouldYield,
   requestPaint =
     void 0 !== Scheduler_requestPaint ? Scheduler_requestPaint : function() {},
   syncQueue = null,
   immediateQueueCallbackNode = null,
   isFlushingSyncQueue = !1,
-  initialTimeMs = Scheduler_now(),
+  initialTimeMs$1 = Scheduler_now$1(),
   now =
-    1e4 > initialTimeMs
-      ? Scheduler_now
+    1e4 > initialTimeMs$1
+      ? Scheduler_now$1
       : function() {
-          return Scheduler_now() - initialTimeMs;
+          return Scheduler_now$1() - initialTimeMs$1;
         };
 function getCurrentPriorityLevel() {
   switch (Scheduler_getCurrentPriorityLevel()) {
@@ -1767,16 +2043,6 @@ function scheduleCallback(reactPriorityLevel, callback, options) {
   reactPriorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
   return Scheduler_scheduleCallback(reactPriorityLevel, callback, options);
 }
-function scheduleSyncCallback(callback) {
-  null === syncQueue
-    ? ((syncQueue = [callback]),
-      (immediateQueueCallbackNode = Scheduler_scheduleCallback(
-        Scheduler_ImmediatePriority,
-        flushSyncCallbackQueueImpl
-      )))
-    : syncQueue.push(callback);
-  return fakeCallbackNode;
-}
 function flushSyncCallbackQueue() {
   if (null !== immediateQueueCallbackNode) {
     var node = immediateQueueCallbackNode;
@@ -1811,6 +2077,42 @@ function flushSyncCallbackQueueImpl() {
     }
   }
 }
+function describeFiber(fiber) {
+  switch (fiber.tag) {
+    case 5:
+      return describeComponentFrame(fiber.type, null, null);
+    case 16:
+      return describeComponentFrame("Lazy", null, null);
+    case 13:
+      return describeComponentFrame("Suspense", null, null);
+    case 19:
+      return describeComponentFrame("SuspenseList", null, null);
+    case 0:
+    case 2:
+    case 15:
+      return describeFunctionComponentFrame(fiber.type, null);
+    case 11:
+      return describeFunctionComponentFrame(fiber.type.render, null);
+    case 22:
+      return describeFunctionComponentFrame(fiber.type._render, null);
+    case 1:
+      return (fiber = describeFunctionComponentFrame(fiber.type, null)), fiber;
+    default:
+      return "";
+  }
+}
+function getStackByFiberInDevAndProd(workInProgress) {
+  try {
+    var info = "";
+    do
+      (info += describeFiber(workInProgress)),
+        (workInProgress = workInProgress.return);
+    while (workInProgress);
+    return info;
+  } catch (x) {
+    return "\nError generating stack: " + x.message + "\n" + x.stack;
+  }
+}
 function is(x, y) {
   return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
@@ -1836,43 +2138,6 @@ function shallowEqual(objA, objB) {
       return !1;
   return !0;
 }
-var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
-function getStackByFiberInDevAndProd(workInProgress) {
-  var info = "";
-  do {
-    a: switch (workInProgress.tag) {
-      case 3:
-      case 4:
-      case 6:
-      case 7:
-      case 10:
-      case 9:
-        var JSCompiler_inline_result = "";
-        break a;
-      default:
-        var owner = workInProgress._debugOwner,
-          source = workInProgress._debugSource,
-          name = getComponentName(workInProgress.type);
-        JSCompiler_inline_result = null;
-        owner && (JSCompiler_inline_result = getComponentName(owner.type));
-        owner = name;
-        name = "";
-        source
-          ? (name =
-              " (at " +
-              source.fileName.replace(BEFORE_SLASH_RE, "") +
-              ":" +
-              source.lineNumber +
-              ")")
-          : JSCompiler_inline_result &&
-            (name = " (created by " + JSCompiler_inline_result + ")");
-        JSCompiler_inline_result = "\n    in " + (owner || "Unknown") + name;
-    }
-    info += JSCompiler_inline_result;
-    workInProgress = workInProgress.return;
-  } while (workInProgress);
-  return info;
-}
 function resolveDefaultProps(Component, baseProps) {
   if (Component && Component.defaultProps) {
     baseProps = Object.assign({}, baseProps);
@@ -1880,10 +2145,11 @@ function resolveDefaultProps(Component, baseProps) {
     for (var propName in Component)
       void 0 === baseProps[propName] &&
         (baseProps[propName] = Component[propName]);
+    return baseProps;
   }
   return baseProps;
 }
-var valueCursor = { current: null },
+var valueCursor = createCursor(null),
   currentlyRenderingFiber = null,
   lastContextDependency = null,
   lastContextWithAllBitsObserved = null;
@@ -1895,31 +2161,29 @@ function popProvider(providerFiber) {
   pop(valueCursor);
   providerFiber.type._context._currentValue = currentValue;
 }
-function scheduleWorkOnParentPath(parent, renderExpirationTime) {
+function scheduleWorkOnParentPath(parent, renderLanes) {
   for (; null !== parent; ) {
     var alternate = parent.alternate;
-    if (parent.childExpirationTime < renderExpirationTime)
-      (parent.childExpirationTime = renderExpirationTime),
-        null !== alternate &&
-          alternate.childExpirationTime < renderExpirationTime &&
-          (alternate.childExpirationTime = renderExpirationTime);
-    else if (
-      null !== alternate &&
-      alternate.childExpirationTime < renderExpirationTime
-    )
-      alternate.childExpirationTime = renderExpirationTime;
-    else break;
+    if ((parent.childLanes & renderLanes) === renderLanes)
+      if (
+        null === alternate ||
+        (alternate.childLanes & renderLanes) === renderLanes
+      )
+        break;
+      else alternate.childLanes |= renderLanes;
+    else
+      (parent.childLanes |= renderLanes),
+        null !== alternate && (alternate.childLanes |= renderLanes);
     parent = parent.return;
   }
 }
-function prepareToReadContext(workInProgress, renderExpirationTime) {
+function prepareToReadContext(workInProgress, renderLanes) {
   currentlyRenderingFiber = workInProgress;
   lastContextWithAllBitsObserved = lastContextDependency = null;
   workInProgress = workInProgress.dependencies;
   null !== workInProgress &&
     null !== workInProgress.firstContext &&
-    (workInProgress.expirationTime >= renderExpirationTime &&
-      (didReceiveUpdate = !0),
+    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
     (workInProgress.firstContext = null));
 }
 function readContext(context, observedBits) {
@@ -1938,7 +2202,7 @@ function readContext(context, observedBits) {
         );
       lastContextDependency = observedBits;
       currentlyRenderingFiber.dependencies = {
-        expirationTime: 0,
+        lanes: 0,
         firstContext: observedBits,
         responders: null
       };
@@ -1950,7 +2214,8 @@ var hasForceUpdate = !1;
 function initializeUpdateQueue(fiber) {
   fiber.updateQueue = {
     baseState: fiber.memoizedState,
-    baseQueue: null,
+    firstBaseUpdate: null,
+    lastBaseUpdate: null,
     shared: { pending: null },
     effects: null
   };
@@ -1960,21 +2225,22 @@ function cloneUpdateQueue(current, workInProgress) {
   workInProgress.updateQueue === current &&
     (workInProgress.updateQueue = {
       baseState: current.baseState,
-      baseQueue: current.baseQueue,
+      firstBaseUpdate: current.firstBaseUpdate,
+      lastBaseUpdate: current.lastBaseUpdate,
       shared: current.shared,
       effects: current.effects
     });
 }
-function createUpdate(expirationTime, suspenseConfig) {
-  expirationTime = {
-    expirationTime: expirationTime,
+function createUpdate(eventTime, lane, suspenseConfig) {
+  return {
+    eventTime: eventTime,
+    lane: lane,
     suspenseConfig: suspenseConfig,
     tag: 0,
     payload: null,
     callback: null,
     next: null
   };
-  return (expirationTime.next = expirationTime);
 }
 function enqueueUpdate(fiber, update) {
   fiber = fiber.updateQueue;
@@ -1987,132 +2253,185 @@ function enqueueUpdate(fiber, update) {
     fiber.pending = update;
   }
 }
-function enqueueCapturedUpdate(workInProgress, update) {
-  var current = workInProgress.alternate;
-  null !== current && cloneUpdateQueue(current, workInProgress);
-  workInProgress = workInProgress.updateQueue;
-  current = workInProgress.baseQueue;
-  null === current
-    ? ((workInProgress.baseQueue = update.next = update),
-      (update.next = update))
-    : ((update.next = current.next), (current.next = update));
+function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
+  var queue = workInProgress.updateQueue,
+    current = workInProgress.alternate;
+  if (
+    null !== current &&
+    ((current = current.updateQueue), queue === current)
+  ) {
+    var newFirst = null,
+      newLast = null;
+    queue = queue.firstBaseUpdate;
+    if (null !== queue) {
+      do {
+        var clone = {
+          eventTime: queue.eventTime,
+          lane: queue.lane,
+          suspenseConfig: queue.suspenseConfig,
+          tag: queue.tag,
+          payload: queue.payload,
+          callback: queue.callback,
+          next: null
+        };
+        null === newLast
+          ? (newFirst = newLast = clone)
+          : (newLast = newLast.next = clone);
+        queue = queue.next;
+      } while (null !== queue);
+      null === newLast
+        ? (newFirst = newLast = capturedUpdate)
+        : (newLast = newLast.next = capturedUpdate);
+    } else newFirst = newLast = capturedUpdate;
+    queue = {
+      baseState: current.baseState,
+      firstBaseUpdate: newFirst,
+      lastBaseUpdate: newLast,
+      shared: current.shared,
+      effects: current.effects
+    };
+    workInProgress.updateQueue = queue;
+    return;
+  }
+  workInProgress = queue.lastBaseUpdate;
+  null === workInProgress
+    ? (queue.firstBaseUpdate = capturedUpdate)
+    : (workInProgress.next = capturedUpdate);
+  queue.lastBaseUpdate = capturedUpdate;
 }
 function processUpdateQueue(
   workInProgress$jscomp$0,
   props,
   instance,
-  renderExpirationTime
+  renderLanes
 ) {
   var queue = workInProgress$jscomp$0.updateQueue;
   hasForceUpdate = !1;
-  var baseQueue = queue.baseQueue,
+  var firstBaseUpdate = queue.firstBaseUpdate,
+    lastBaseUpdate = queue.lastBaseUpdate,
     pendingQueue = queue.shared.pending;
   if (null !== pendingQueue) {
-    if (null !== baseQueue) {
-      var baseFirst = baseQueue.next;
-      baseQueue.next = pendingQueue.next;
-      pendingQueue.next = baseFirst;
-    }
-    baseQueue = pendingQueue;
     queue.shared.pending = null;
-    baseFirst = workInProgress$jscomp$0.alternate;
-    null !== baseFirst &&
-      ((baseFirst = baseFirst.updateQueue),
-      null !== baseFirst && (baseFirst.baseQueue = pendingQueue));
+    var lastPendingUpdate = pendingQueue,
+      firstPendingUpdate = lastPendingUpdate.next;
+    lastPendingUpdate.next = null;
+    null === lastBaseUpdate
+      ? (firstBaseUpdate = firstPendingUpdate)
+      : (lastBaseUpdate.next = firstPendingUpdate);
+    lastBaseUpdate = lastPendingUpdate;
+    var current = workInProgress$jscomp$0.alternate;
+    if (null !== current) {
+      current = current.updateQueue;
+      var currentLastBaseUpdate = current.lastBaseUpdate;
+      currentLastBaseUpdate !== lastBaseUpdate &&
+        (null === currentLastBaseUpdate
+          ? (current.firstBaseUpdate = firstPendingUpdate)
+          : (currentLastBaseUpdate.next = firstPendingUpdate),
+        (current.lastBaseUpdate = lastPendingUpdate));
+    }
   }
-  if (null !== baseQueue) {
-    baseFirst = baseQueue.next;
-    var newState = queue.baseState,
-      newExpirationTime = 0,
-      newBaseState = null,
-      newBaseQueueFirst = null,
-      newBaseQueueLast = null;
-    if (null !== baseFirst) {
-      var update = baseFirst;
-      do {
-        pendingQueue = update.expirationTime;
-        if (pendingQueue < renderExpirationTime) {
-          var clone = {
-            expirationTime: update.expirationTime,
-            suspenseConfig: update.suspenseConfig,
-            tag: update.tag,
-            payload: update.payload,
-            callback: update.callback,
+  if (null !== firstBaseUpdate) {
+    currentLastBaseUpdate = queue.baseState;
+    lastBaseUpdate = 0;
+    current = firstPendingUpdate = lastPendingUpdate = null;
+    do {
+      pendingQueue = firstBaseUpdate.lane;
+      var updateEventTime = firstBaseUpdate.eventTime;
+      if ((renderLanes & pendingQueue) === pendingQueue) {
+        null !== current &&
+          (current = current.next = {
+            eventTime: updateEventTime,
+            lane: 0,
+            suspenseConfig: firstBaseUpdate.suspenseConfig,
+            tag: firstBaseUpdate.tag,
+            payload: firstBaseUpdate.payload,
+            callback: firstBaseUpdate.callback,
             next: null
-          };
-          null === newBaseQueueLast
-            ? ((newBaseQueueFirst = newBaseQueueLast = clone),
-              (newBaseState = newState))
-            : (newBaseQueueLast = newBaseQueueLast.next = clone);
-          pendingQueue > newExpirationTime &&
-            (newExpirationTime = pendingQueue);
-        } else {
-          null !== newBaseQueueLast &&
-            (newBaseQueueLast = newBaseQueueLast.next = {
-              expirationTime: 1073741823,
-              suspenseConfig: update.suspenseConfig,
-              tag: update.tag,
-              payload: update.payload,
-              callback: update.callback,
-              next: null
-            });
-          markRenderEventTimeAndConfig(pendingQueue, update.suspenseConfig);
-          a: {
-            var workInProgress = workInProgress$jscomp$0,
-              update$jscomp$0 = update;
-            pendingQueue = props;
-            clone = instance;
-            switch (update$jscomp$0.tag) {
-              case 1:
-                workInProgress = update$jscomp$0.payload;
-                if ("function" === typeof workInProgress) {
-                  newState = workInProgress.call(clone, newState, pendingQueue);
-                  break a;
-                }
-                newState = workInProgress;
-                break a;
-              case 3:
-                workInProgress.effectTag =
-                  (workInProgress.effectTag & -4097) | 64;
-              case 0:
-                workInProgress = update$jscomp$0.payload;
-                pendingQueue =
-                  "function" === typeof workInProgress
-                    ? workInProgress.call(clone, newState, pendingQueue)
-                    : workInProgress;
-                if (null === pendingQueue || void 0 === pendingQueue) break a;
-                newState = Object.assign({}, newState, pendingQueue);
+          });
+        markRenderEventTimeAndConfig(
+          updateEventTime,
+          firstBaseUpdate.suspenseConfig
+        );
+        a: {
+          var workInProgress = workInProgress$jscomp$0,
+            update = firstBaseUpdate;
+          pendingQueue = props;
+          updateEventTime = instance;
+          switch (update.tag) {
+            case 1:
+              workInProgress = update.payload;
+              if ("function" === typeof workInProgress) {
+                currentLastBaseUpdate = workInProgress.call(
+                  updateEventTime,
+                  currentLastBaseUpdate,
+                  pendingQueue
+                );
                 break a;
-              case 2:
-                hasForceUpdate = !0;
-            }
+              }
+              currentLastBaseUpdate = workInProgress;
+              break a;
+            case 3:
+              workInProgress.effectTag =
+                (workInProgress.effectTag & -4097) | 64;
+            case 0:
+              workInProgress = update.payload;
+              pendingQueue =
+                "function" === typeof workInProgress
+                  ? workInProgress.call(
+                      updateEventTime,
+                      currentLastBaseUpdate,
+                      pendingQueue
+                    )
+                  : workInProgress;
+              if (null === pendingQueue || void 0 === pendingQueue) break a;
+              currentLastBaseUpdate = Object.assign(
+                {},
+                currentLastBaseUpdate,
+                pendingQueue
+              );
+              break a;
+            case 2:
+              hasForceUpdate = !0;
           }
-          null !== update.callback &&
-            ((workInProgress$jscomp$0.effectTag |= 32),
-            (pendingQueue = queue.effects),
-            null === pendingQueue
-              ? (queue.effects = [update])
-              : pendingQueue.push(update));
         }
-        update = update.next;
-        if (null === update || update === baseFirst)
-          if (((pendingQueue = queue.shared.pending), null === pendingQueue))
-            break;
-          else
-            (update = baseQueue.next = pendingQueue.next),
-              (pendingQueue.next = baseFirst),
-              (queue.baseQueue = baseQueue = pendingQueue),
-              (queue.shared.pending = null);
-      } while (1);
-    }
-    null === newBaseQueueLast
-      ? (newBaseState = newState)
-      : (newBaseQueueLast.next = newBaseQueueFirst);
-    queue.baseState = newBaseState;
-    queue.baseQueue = newBaseQueueLast;
-    markUnprocessedUpdateTime(newExpirationTime);
-    workInProgress$jscomp$0.expirationTime = newExpirationTime;
-    workInProgress$jscomp$0.memoizedState = newState;
+        null !== firstBaseUpdate.callback &&
+          ((workInProgress$jscomp$0.effectTag |= 32),
+          (pendingQueue = queue.effects),
+          null === pendingQueue
+            ? (queue.effects = [firstBaseUpdate])
+            : pendingQueue.push(firstBaseUpdate));
+      } else
+        (updateEventTime = {
+          eventTime: updateEventTime,
+          lane: pendingQueue,
+          suspenseConfig: firstBaseUpdate.suspenseConfig,
+          tag: firstBaseUpdate.tag,
+          payload: firstBaseUpdate.payload,
+          callback: firstBaseUpdate.callback,
+          next: null
+        }),
+          null === current
+            ? ((firstPendingUpdate = current = updateEventTime),
+              (lastPendingUpdate = currentLastBaseUpdate))
+            : (current = current.next = updateEventTime),
+          (lastBaseUpdate |= pendingQueue);
+      firstBaseUpdate = firstBaseUpdate.next;
+      if (null === firstBaseUpdate)
+        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
+          break;
+        else
+          (firstBaseUpdate = pendingQueue.next),
+            (pendingQueue.next = null),
+            (queue.lastBaseUpdate = pendingQueue),
+            (queue.shared.pending = null);
+    } while (1);
+    null === current && (lastPendingUpdate = currentLastBaseUpdate);
+    queue.baseState = lastPendingUpdate;
+    queue.firstBaseUpdate = firstPendingUpdate;
+    queue.lastBaseUpdate = current;
+    workInProgressRootSkippedLanes |= lastBaseUpdate;
+    workInProgress$jscomp$0.lanes = lastBaseUpdate;
+    workInProgress$jscomp$0.memoizedState = currentLastBaseUpdate;
   }
 }
 function commitUpdateQueue(finishedWork, finishedQueue, instance) {
@@ -2152,54 +2471,54 @@ function applyDerivedStateFromProps(
       ? ctor
       : Object.assign({}, ctor, getDerivedStateFromProps);
   workInProgress.memoizedState = getDerivedStateFromProps;
-  0 === workInProgress.expirationTime &&
+  0 === workInProgress.lanes &&
     (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
 }
 var classComponentUpdater = {
   isMounted: function(component) {
-    return (component = component._reactInternalFiber)
+    return (component = component._reactInternals)
       ? getNearestMountedFiber(component) === component
       : !1;
   },
   enqueueSetState: function(inst, payload, callback) {
-    inst = inst._reactInternalFiber;
-    var currentTime = requestCurrentTimeForUpdate(),
-      suspenseConfig = ReactCurrentBatchConfig.suspense;
-    currentTime = computeExpirationForFiber(currentTime, inst, suspenseConfig);
-    suspenseConfig = createUpdate(currentTime, suspenseConfig);
+    inst = inst._reactInternals;
+    var eventTime = requestEventTime(),
+      suspenseConfig = ReactCurrentBatchConfig.suspense,
+      lane = requestUpdateLane(inst, suspenseConfig);
+    suspenseConfig = createUpdate(eventTime, lane, suspenseConfig);
     suspenseConfig.payload = payload;
     void 0 !== callback &&
       null !== callback &&
       (suspenseConfig.callback = callback);
     enqueueUpdate(inst, suspenseConfig);
-    scheduleWork(inst, currentTime);
+    scheduleUpdateOnFiber(inst, lane, eventTime);
   },
   enqueueReplaceState: function(inst, payload, callback) {
-    inst = inst._reactInternalFiber;
-    var currentTime = requestCurrentTimeForUpdate(),
-      suspenseConfig = ReactCurrentBatchConfig.suspense;
-    currentTime = computeExpirationForFiber(currentTime, inst, suspenseConfig);
-    suspenseConfig = createUpdate(currentTime, suspenseConfig);
+    inst = inst._reactInternals;
+    var eventTime = requestEventTime(),
+      suspenseConfig = ReactCurrentBatchConfig.suspense,
+      lane = requestUpdateLane(inst, suspenseConfig);
+    suspenseConfig = createUpdate(eventTime, lane, suspenseConfig);
     suspenseConfig.tag = 1;
     suspenseConfig.payload = payload;
     void 0 !== callback &&
       null !== callback &&
       (suspenseConfig.callback = callback);
     enqueueUpdate(inst, suspenseConfig);
-    scheduleWork(inst, currentTime);
+    scheduleUpdateOnFiber(inst, lane, eventTime);
   },
   enqueueForceUpdate: function(inst, callback) {
-    inst = inst._reactInternalFiber;
-    var currentTime = requestCurrentTimeForUpdate(),
-      suspenseConfig = ReactCurrentBatchConfig.suspense;
-    currentTime = computeExpirationForFiber(currentTime, inst, suspenseConfig);
-    suspenseConfig = createUpdate(currentTime, suspenseConfig);
+    inst = inst._reactInternals;
+    var eventTime = requestEventTime(),
+      suspenseConfig = ReactCurrentBatchConfig.suspense,
+      lane = requestUpdateLane(inst, suspenseConfig);
+    suspenseConfig = createUpdate(eventTime, lane, suspenseConfig);
     suspenseConfig.tag = 2;
     void 0 !== callback &&
       null !== callback &&
       (suspenseConfig.callback = callback);
     enqueueUpdate(inst, suspenseConfig);
-    scheduleWork(inst, currentTime);
+    scheduleUpdateOnFiber(inst, lane, eventTime);
   }
 };
 function checkShouldComponentUpdate(
@@ -2237,7 +2556,7 @@ function constructClassInstance(workInProgress, ctor, props) {
     null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
   ctor.updater = classComponentUpdater;
   workInProgress.stateNode = ctor;
-  ctor._reactInternalFiber = workInProgress;
+  ctor._reactInternals = workInProgress;
   isLegacyContextConsumer &&
     ((workInProgress = workInProgress.stateNode),
     (workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
@@ -2258,12 +2577,7 @@ function callComponentWillReceiveProps(
   instance.state !== workInProgress &&
     classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
 }
-function mountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
+function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   var instance = workInProgress.stateNode;
   instance.props = newProps;
   instance.state = workInProgress.memoizedState;
@@ -2276,7 +2590,7 @@ function mountClassInstance(
         ? previousContext
         : contextStackCursor.current),
       (instance.context = getMaskedContext(workInProgress, contextType)));
-  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
+  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
   instance.state = workInProgress.memoizedState;
   contextType = ctor.getDerivedStateFromProps;
   "function" === typeof contextType &&
@@ -2293,12 +2607,7 @@ function mountClassInstance(
       instance.UNSAFE_componentWillMount(),
     ctor !== instance.state &&
       classComponentUpdater.enqueueReplaceState(instance, instance.state, null),
-    processUpdateQueue(
-      workInProgress,
-      newProps,
-      instance,
-      renderExpirationTime
-    ),
+    processUpdateQueue(workInProgress, newProps, instance, renderLanes),
     (instance.state = workInProgress.memoizedState));
   "function" === typeof instance.componentDidMount &&
     (workInProgress.effectTag |= 4);
@@ -2362,7 +2671,7 @@ function throwOnInvalidObjectType(returnFiber, newChild) {
         ("[object Object]" === Object.prototype.toString.call(newChild)
           ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
           : newChild) +
-        ")."
+        "). If you meant to render a collection of children, use an array instead."
     );
 }
 function ChildReconciler(shouldTrackSideEffects) {
@@ -2418,14 +2727,10 @@ function ChildReconciler(shouldTrackSideEffects) {
       (newFiber.effectTag = 2);
     return newFiber;
   }
-  function updateTextNode(returnFiber, current, textContent, expirationTime) {
+  function updateTextNode(returnFiber, current, textContent, lanes) {
     if (null === current || 6 !== current.tag)
       return (
-        (current = createFiberFromText(
-          textContent,
-          returnFiber.mode,
-          expirationTime
-        )),
+        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
         (current.return = returnFiber),
         current
       );
@@ -2433,27 +2738,27 @@ function ChildReconciler(shouldTrackSideEffects) {
     current.return = returnFiber;
     return current;
   }
-  function updateElement(returnFiber, current, element, expirationTime) {
+  function updateElement(returnFiber, current, element, lanes) {
     if (null !== current && current.elementType === element.type)
       return (
-        (expirationTime = useFiber(current, element.props)),
-        (expirationTime.ref = coerceRef(returnFiber, current, element)),
-        (expirationTime.return = returnFiber),
-        expirationTime
+        (lanes = useFiber(current, element.props)),
+        (lanes.ref = coerceRef(returnFiber, current, element)),
+        (lanes.return = returnFiber),
+        lanes
       );
-    expirationTime = createFiberFromTypeAndProps(
+    lanes = createFiberFromTypeAndProps(
       element.type,
       element.key,
       element.props,
       null,
       returnFiber.mode,
-      expirationTime
+      lanes
     );
-    expirationTime.ref = coerceRef(returnFiber, current, element);
-    expirationTime.return = returnFiber;
-    return expirationTime;
+    lanes.ref = coerceRef(returnFiber, current, element);
+    lanes.return = returnFiber;
+    return lanes;
   }
-  function updatePortal(returnFiber, current, portal, expirationTime) {
+  function updatePortal(returnFiber, current, portal, lanes) {
     if (
       null === current ||
       4 !== current.tag ||
@@ -2461,11 +2766,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       current.stateNode.implementation !== portal.implementation
     )
       return (
-        (current = createFiberFromPortal(
-          portal,
-          returnFiber.mode,
-          expirationTime
-        )),
+        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
         (current.return = returnFiber),
         current
       );
@@ -2473,13 +2774,13 @@ function ChildReconciler(shouldTrackSideEffects) {
     current.return = returnFiber;
     return current;
   }
-  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
+  function updateFragment(returnFiber, current, fragment, lanes, key) {
     if (null === current || 7 !== current.tag)
       return (
         (current = createFiberFromFragment(
           fragment,
           returnFiber.mode,
-          expirationTime,
+          lanes,
           key
         )),
         (current.return = returnFiber),
@@ -2489,13 +2790,13 @@ function ChildReconciler(shouldTrackSideEffects) {
     current.return = returnFiber;
     return current;
   }
-  function createChild(returnFiber, newChild, expirationTime) {
+  function createChild(returnFiber, newChild, lanes) {
     if ("string" === typeof newChild || "number" === typeof newChild)
       return (
         (newChild = createFiberFromText(
           "" + newChild,
           returnFiber.mode,
-          expirationTime
+          lanes
         )),
         (newChild.return = returnFiber),
         newChild
@@ -2504,24 +2805,24 @@ function ChildReconciler(shouldTrackSideEffects) {
       switch (newChild.$$typeof) {
         case REACT_ELEMENT_TYPE:
           return (
-            (expirationTime = createFiberFromTypeAndProps(
+            (lanes = createFiberFromTypeAndProps(
               newChild.type,
               newChild.key,
               newChild.props,
               null,
               returnFiber.mode,
-              expirationTime
+              lanes
             )),
-            (expirationTime.ref = coerceRef(returnFiber, null, newChild)),
-            (expirationTime.return = returnFiber),
-            expirationTime
+            (lanes.ref = coerceRef(returnFiber, null, newChild)),
+            (lanes.return = returnFiber),
+            lanes
           );
         case REACT_PORTAL_TYPE:
           return (
             (newChild = createFiberFromPortal(
               newChild,
               returnFiber.mode,
-              expirationTime
+              lanes
             )),
             (newChild.return = returnFiber),
             newChild
@@ -2532,7 +2833,7 @@ function ChildReconciler(shouldTrackSideEffects) {
           (newChild = createFiberFromFragment(
             newChild,
             returnFiber.mode,
-            expirationTime,
+            lanes,
             null
           )),
           (newChild.return = returnFiber),
@@ -2542,12 +2843,12 @@ function ChildReconciler(shouldTrackSideEffects) {
     }
     return null;
   }
-  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
+  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
     var key = null !== oldFiber ? oldFiber.key : null;
     if ("string" === typeof newChild || "number" === typeof newChild)
       return null !== key
         ? null
-        : updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
+        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
     if ("object" === typeof newChild && null !== newChild) {
       switch (newChild.$$typeof) {
         case REACT_ELEMENT_TYPE:
@@ -2557,26 +2858,20 @@ function ChildReconciler(shouldTrackSideEffects) {
                   returnFiber,
                   oldFiber,
                   newChild.props.children,
-                  expirationTime,
+                  lanes,
                   key
                 )
-              : updateElement(returnFiber, oldFiber, newChild, expirationTime)
+              : updateElement(returnFiber, oldFiber, newChild, lanes)
             : null;
         case REACT_PORTAL_TYPE:
           return newChild.key === key
-            ? updatePortal(returnFiber, oldFiber, newChild, expirationTime)
+            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
             : null;
       }
       if (isArray(newChild) || getIteratorFn(newChild))
         return null !== key
           ? null
-          : updateFragment(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime,
-              null
-            );
+          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
       throwOnInvalidObjectType(returnFiber, newChild);
     }
     return null;
@@ -2586,17 +2881,12 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     newIdx,
     newChild,
-    expirationTime
+    lanes
   ) {
     if ("string" === typeof newChild || "number" === typeof newChild)
       return (
         (existingChildren = existingChildren.get(newIdx) || null),
-        updateTextNode(
-          returnFiber,
-          existingChildren,
-          "" + newChild,
-          expirationTime
-        )
+        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
       );
     if ("object" === typeof newChild && null !== newChild) {
       switch (newChild.$$typeof) {
@@ -2611,15 +2901,10 @@ function ChildReconciler(shouldTrackSideEffects) {
                   returnFiber,
                   existingChildren,
                   newChild.props.children,
-                  expirationTime,
+                  lanes,
                   newChild.key
                 )
-              : updateElement(
-                  returnFiber,
-                  existingChildren,
-                  newChild,
-                  expirationTime
-                )
+              : updateElement(returnFiber, existingChildren, newChild, lanes)
           );
         case REACT_PORTAL_TYPE:
           return (
@@ -2627,24 +2912,13 @@ function ChildReconciler(shouldTrackSideEffects) {
               existingChildren.get(
                 null === newChild.key ? newIdx : newChild.key
               ) || null),
-            updatePortal(
-              returnFiber,
-              existingChildren,
-              newChild,
-              expirationTime
-            )
+            updatePortal(returnFiber, existingChildren, newChild, lanes)
           );
       }
       if (isArray(newChild) || getIteratorFn(newChild))
         return (
           (existingChildren = existingChildren.get(newIdx) || null),
-          updateFragment(
-            returnFiber,
-            existingChildren,
-            newChild,
-            expirationTime,
-            null
-          )
+          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
         );
       throwOnInvalidObjectType(returnFiber, newChild);
     }
@@ -2654,7 +2928,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChildren,
-    expirationTime
+    lanes
   ) {
     for (
       var resultingFirstChild = null,
@@ -2672,7 +2946,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         oldFiber,
         newChildren[newIdx],
-        expirationTime
+        lanes
       );
       if (null === newFiber) {
         null === oldFiber && (oldFiber = nextOldFiber);
@@ -2695,11 +2969,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       );
     if (null === oldFiber) {
       for (; newIdx < newChildren.length; newIdx++)
-        (oldFiber = createChild(
-          returnFiber,
-          newChildren[newIdx],
-          expirationTime
-        )),
+        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
           null !== oldFiber &&
             ((currentFirstChild = placeChild(
               oldFiber,
@@ -2722,7 +2992,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         newIdx,
         newChildren[newIdx],
-        expirationTime
+        lanes
       )),
         null !== nextOldFiber &&
           (shouldTrackSideEffects &&
@@ -2749,7 +3019,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     returnFiber,
     currentFirstChild,
     newChildrenIterable,
-    expirationTime
+    lanes
   ) {
     var iteratorFn = getIteratorFn(newChildrenIterable);
     if ("function" !== typeof iteratorFn)
@@ -2771,12 +3041,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       oldFiber.index > newIdx
         ? ((nextOldFiber = oldFiber), (oldFiber = null))
         : (nextOldFiber = oldFiber.sibling);
-      var newFiber = updateSlot(
-        returnFiber,
-        oldFiber,
-        step.value,
-        expirationTime
-      );
+      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
       if (null === newFiber) {
         null === oldFiber && (oldFiber = nextOldFiber);
         break;
@@ -2796,7 +3061,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;
     if (null === oldFiber) {
       for (; !step.done; newIdx++, step = newChildrenIterable.next())
-        (step = createChild(returnFiber, step.value, expirationTime)),
+        (step = createChild(returnFiber, step.value, lanes)),
           null !== step &&
             ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
             null === previousNewFiber
@@ -2810,13 +3075,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       !step.done;
       newIdx++, step = newChildrenIterable.next()
     )
-      (step = updateFromMap(
-        oldFiber,
-        returnFiber,
-        newIdx,
-        step.value,
-        expirationTime
-      )),
+      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
         null !== step &&
           (shouldTrackSideEffects &&
             null !== step.alternate &&
@@ -2832,7 +3091,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       });
     return iteratorFn;
   }
-  return function(returnFiber, currentFirstChild, newChild, expirationTime) {
+  return function(returnFiber, currentFirstChild, newChild, lanes) {
     var isUnkeyedTopLevelFragment =
       "object" === typeof newChild &&
       null !== newChild &&
@@ -2898,26 +3157,26 @@ function ChildReconciler(shouldTrackSideEffects) {
               ? ((currentFirstChild = createFiberFromFragment(
                   newChild.props.children,
                   returnFiber.mode,
-                  expirationTime,
+                  lanes,
                   newChild.key
                 )),
                 (currentFirstChild.return = returnFiber),
                 (returnFiber = currentFirstChild))
-              : ((expirationTime = createFiberFromTypeAndProps(
+              : ((lanes = createFiberFromTypeAndProps(
                   newChild.type,
                   newChild.key,
                   newChild.props,
                   null,
                   returnFiber.mode,
-                  expirationTime
+                  lanes
                 )),
-                (expirationTime.ref = coerceRef(
+                (lanes.ref = coerceRef(
                   returnFiber,
                   currentFirstChild,
                   newChild
                 )),
-                (expirationTime.return = returnFiber),
-                (returnFiber = expirationTime));
+                (lanes.return = returnFiber),
+                (returnFiber = lanes));
           }
           return placeSingleChild(returnFiber);
         case REACT_PORTAL_TYPE:
@@ -2956,7 +3215,7 @@ function ChildReconciler(shouldTrackSideEffects) {
             currentFirstChild = createFiberFromPortal(
               newChild,
               returnFiber.mode,
-              expirationTime
+              lanes
             );
             currentFirstChild.return = returnFiber;
             returnFiber = currentFirstChild;
@@ -2975,7 +3234,7 @@ function ChildReconciler(shouldTrackSideEffects) {
             (currentFirstChild = createFiberFromText(
               newChild,
               returnFiber.mode,
-              expirationTime
+              lanes
             )),
             (currentFirstChild.return = returnFiber),
             (returnFiber = currentFirstChild)),
@@ -2986,14 +3245,14 @@ function ChildReconciler(shouldTrackSideEffects) {
         returnFiber,
         currentFirstChild,
         newChild,
-        expirationTime
+        lanes
       );
     if (getIteratorFn(newChild))
       return reconcileChildrenIterator(
         returnFiber,
         currentFirstChild,
         newChild,
-        expirationTime
+        lanes
       );
     isObject && throwOnInvalidObjectType(returnFiber, newChild);
     if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment)
@@ -3012,9 +3271,9 @@ function ChildReconciler(shouldTrackSideEffects) {
 var reconcileChildFibers = ChildReconciler(!0),
   mountChildFibers = ChildReconciler(!1),
   NO_CONTEXT = {},
-  contextStackCursor$1 = { current: NO_CONTEXT },
-  contextFiberStackCursor = { current: NO_CONTEXT },
-  rootInstanceStackCursor = { current: NO_CONTEXT };
+  contextStackCursor$1 = createCursor(NO_CONTEXT),
+  contextFiberStackCursor = createCursor(NO_CONTEXT),
+  rootInstanceStackCursor = createCursor(NO_CONTEXT);
 function requiredContext(c) {
   if (c === NO_CONTEXT)
     throw Error(
@@ -3037,26 +3296,26 @@ function popHostContainer() {
 function pushHostContext(fiber) {
   requiredContext(rootInstanceStackCursor.current);
   var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = fiber.type;
-  nextContext =
-    "AndroidTextInput" === nextContext ||
-    "RCTMultilineTextInputView" === nextContext ||
-    "RCTSinglelineTextInputView" === nextContext ||
-    "RCTText" === nextContext ||
-    "RCTVirtualText" === nextContext;
-  nextContext =
-    context.isInAParentText !== nextContext
-      ? { isInAParentText: nextContext }
+  var JSCompiler_inline_result = fiber.type;
+  JSCompiler_inline_result =
+    "AndroidTextInput" === JSCompiler_inline_result ||
+    "RCTMultilineTextInputView" === JSCompiler_inline_result ||
+    "RCTSinglelineTextInputView" === JSCompiler_inline_result ||
+    "RCTText" === JSCompiler_inline_result ||
+    "RCTVirtualText" === JSCompiler_inline_result;
+  JSCompiler_inline_result =
+    context.isInAParentText !== JSCompiler_inline_result
+      ? { isInAParentText: JSCompiler_inline_result }
       : context;
-  context !== nextContext &&
+  context !== JSCompiler_inline_result &&
     (push(contextFiberStackCursor, fiber),
-    push(contextStackCursor$1, nextContext));
+    push(contextStackCursor$1, JSCompiler_inline_result));
 }
 function popHostContext(fiber) {
   contextFiberStackCursor.current === fiber &&
     (pop(contextStackCursor$1), pop(contextFiberStackCursor));
 }
-var suspenseStackCursor = { current: 0 };
+var suspenseStackCursor = createCursor(0);
 function findFirstSuspended(row) {
   for (var node = row; null !== node; ) {
     if (13 === node.tag) {
@@ -3080,16 +3339,20 @@ function findFirstSuspended(row) {
   }
   return null;
 }
-function createDeprecatedResponderListener(responder, props) {
-  return { responder: responder, props: props };
+var workInProgressSources = [];
+function resetWorkInProgressVersions() {
+  for (var i = 0; i < workInProgressSources.length; i++)
+    workInProgressSources[i]._workInProgressVersionPrimary = null;
+  workInProgressSources.length = 0;
 }
-var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
+var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig,
-  renderExpirationTime = 0,
+  renderLanes = 0,
   currentlyRenderingFiber$1 = null,
   currentHook = null,
   workInProgressHook = null,
-  didScheduleRenderPhaseUpdate = !1;
+  didScheduleRenderPhaseUpdate = !1,
+  didScheduleRenderPhaseUpdateDuringThisPass = !1;
 function throwInvalidHookError() {
   throw Error(
     "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem."
@@ -3107,36 +3370,36 @@ function renderWithHooks(
   Component,
   props,
   secondArg,
-  nextRenderExpirationTime
+  nextRenderLanes
 ) {
-  renderExpirationTime = nextRenderExpirationTime;
+  renderLanes = nextRenderLanes;
   currentlyRenderingFiber$1 = workInProgress;
   workInProgress.memoizedState = null;
   workInProgress.updateQueue = null;
-  workInProgress.expirationTime = 0;
-  ReactCurrentDispatcher.current =
+  workInProgress.lanes = 0;
+  ReactCurrentDispatcher$1.current =
     null === current || null === current.memoizedState
       ? HooksDispatcherOnMount
       : HooksDispatcherOnUpdate;
   current = Component(props, secondArg);
-  if (workInProgress.expirationTime === renderExpirationTime) {
-    nextRenderExpirationTime = 0;
+  if (didScheduleRenderPhaseUpdateDuringThisPass) {
+    nextRenderLanes = 0;
     do {
-      workInProgress.expirationTime = 0;
-      if (!(25 > nextRenderExpirationTime))
+      didScheduleRenderPhaseUpdateDuringThisPass = !1;
+      if (!(25 > nextRenderLanes))
         throw Error(
           "Too many re-renders. React limits the number of renders to prevent an infinite loop."
         );
-      nextRenderExpirationTime += 1;
+      nextRenderLanes += 1;
       workInProgressHook = currentHook = null;
       workInProgress.updateQueue = null;
-      ReactCurrentDispatcher.current = HooksDispatcherOnRerender;
+      ReactCurrentDispatcher$1.current = HooksDispatcherOnRerender;
       current = Component(props, secondArg);
-    } while (workInProgress.expirationTime === renderExpirationTime);
+    } while (didScheduleRenderPhaseUpdateDuringThisPass);
   }
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
   workInProgress = null !== currentHook && null !== currentHook.next;
-  renderExpirationTime = 0;
+  renderLanes = 0;
   workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
   didScheduleRenderPhaseUpdate = !1;
   if (workInProgress)
@@ -3217,40 +3480,40 @@ function updateReducer(reducer) {
     var newBaseQueueLast = (baseFirst = pendingQueue = null),
       update = baseQueue;
     do {
-      var updateExpirationTime = update.expirationTime;
-      if (updateExpirationTime < renderExpirationTime) {
-        var clone = {
-          expirationTime: update.expirationTime,
-          suspenseConfig: update.suspenseConfig,
-          action: update.action,
-          eagerReducer: update.eagerReducer,
-          eagerState: update.eagerState,
-          next: null
-        };
-        null === newBaseQueueLast
-          ? ((baseFirst = newBaseQueueLast = clone), (pendingQueue = current))
-          : (newBaseQueueLast = newBaseQueueLast.next = clone);
-        updateExpirationTime > currentlyRenderingFiber$1.expirationTime &&
-          ((currentlyRenderingFiber$1.expirationTime = updateExpirationTime),
-          markUnprocessedUpdateTime(updateExpirationTime));
-      } else
-        null !== newBaseQueueLast &&
-          (newBaseQueueLast = newBaseQueueLast.next = {
-            expirationTime: 1073741823,
-            suspenseConfig: update.suspenseConfig,
+      var suspenseConfig = update.suspenseConfig,
+        updateLane = update.lane,
+        updateEventTime = update.eventTime;
+      (renderLanes & updateLane) === updateLane
+        ? (null !== newBaseQueueLast &&
+            (newBaseQueueLast = newBaseQueueLast.next = {
+              eventTime: updateEventTime,
+              lane: 0,
+              suspenseConfig: update.suspenseConfig,
+              action: update.action,
+              eagerReducer: update.eagerReducer,
+              eagerState: update.eagerState,
+              next: null
+            }),
+          markRenderEventTimeAndConfig(updateEventTime, suspenseConfig),
+          (current =
+            update.eagerReducer === reducer
+              ? update.eagerState
+              : reducer(current, update.action)))
+        : ((suspenseConfig = {
+            eventTime: updateEventTime,
+            lane: updateLane,
+            suspenseConfig: suspenseConfig,
             action: update.action,
             eagerReducer: update.eagerReducer,
             eagerState: update.eagerState,
             next: null
           }),
-          markRenderEventTimeAndConfig(
-            updateExpirationTime,
-            update.suspenseConfig
-          ),
-          (current =
-            update.eagerReducer === reducer
-              ? update.eagerState
-              : reducer(current, update.action));
+          null === newBaseQueueLast
+            ? ((baseFirst = newBaseQueueLast = suspenseConfig),
+              (pendingQueue = current))
+            : (newBaseQueueLast = newBaseQueueLast.next = suspenseConfig),
+          (currentlyRenderingFiber$1.lanes |= updateLane),
+          (workInProgressRootSkippedLanes |= updateLane));
       update = update.next;
     } while (null !== update && update !== baseQueue);
     null === newBaseQueueLast
@@ -3287,6 +3550,117 @@ function rerenderReducer(reducer) {
   }
   return [newState, dispatch];
 }
+function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
+  var getVersion = source._getVersion;
+  getVersion = getVersion(source._source);
+  var JSCompiler_inline_result = source._workInProgressVersionPrimary;
+  if (null !== JSCompiler_inline_result)
+    root = JSCompiler_inline_result === getVersion;
+  else if (
+    ((root = root.mutableReadLanes), (root = (renderLanes & root) === root))
+  )
+    (source._workInProgressVersionPrimary = getVersion),
+      workInProgressSources.push(source);
+  if (root) return getSnapshot(source._source);
+  workInProgressSources.push(source);
+  throw Error(
+    "Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue."
+  );
+}
+function useMutableSource(hook, source, getSnapshot, subscribe) {
+  var root = workInProgressRoot;
+  if (null === root)
+    throw Error(
+      "Expected a work-in-progress root. This is a bug in React. Please file an issue."
+    );
+  var getVersion = source._getVersion,
+    version = getVersion(source._source),
+    dispatcher = ReactCurrentDispatcher$1.current,
+    _dispatcher$useState = dispatcher.useState(function() {
+      return readFromUnsubcribedMutableSource(root, source, getSnapshot);
+    }),
+    setSnapshot = _dispatcher$useState[1],
+    snapshot = _dispatcher$useState[0];
+  _dispatcher$useState = workInProgressHook;
+  var memoizedState = hook.memoizedState,
+    refs = memoizedState.refs,
+    prevGetSnapshot = refs.getSnapshot,
+    prevSource = memoizedState.source;
+  memoizedState = memoizedState.subscribe;
+  var fiber = currentlyRenderingFiber$1;
+  hook.memoizedState = { refs: refs, source: source, subscribe: subscribe };
+  dispatcher.useEffect(
+    function() {
+      refs.getSnapshot = getSnapshot;
+      refs.setSnapshot = setSnapshot;
+      var maybeNewVersion = getVersion(source._source);
+      if (!objectIs(version, maybeNewVersion)) {
+        maybeNewVersion = getSnapshot(source._source);
+        objectIs(snapshot, maybeNewVersion) ||
+          (setSnapshot(maybeNewVersion),
+          (maybeNewVersion = requestUpdateLane(
+            fiber,
+            ReactCurrentBatchConfig.suspense
+          )),
+          (root.mutableReadLanes |= maybeNewVersion & root.pendingLanes));
+        maybeNewVersion = root.mutableReadLanes;
+        root.entangledLanes |= maybeNewVersion;
+        for (
+          var entanglements = root.entanglements, lanes = maybeNewVersion;
+          0 < lanes;
+
+        ) {
+          var index$14 = 31 - clz32(lanes),
+            lane = 1 << index$14;
+          entanglements[index$14] |= maybeNewVersion;
+          lanes &= ~lane;
+        }
+      }
+    },
+    [getSnapshot, source, subscribe]
+  );
+  dispatcher.useEffect(
+    function() {
+      return subscribe(source._source, function() {
+        var latestGetSnapshot = refs.getSnapshot,
+          latestSetSnapshot = refs.setSnapshot;
+        try {
+          latestSetSnapshot(latestGetSnapshot(source._source));
+          var lane = requestUpdateLane(fiber, ReactCurrentBatchConfig.suspense);
+          root.mutableReadLanes |= lane & root.pendingLanes;
+        } catch (error) {
+          latestSetSnapshot(function() {
+            throw error;
+          });
+        }
+      });
+    },
+    [source, subscribe]
+  );
+  (objectIs(prevGetSnapshot, getSnapshot) &&
+    objectIs(prevSource, source) &&
+    objectIs(memoizedState, subscribe)) ||
+    ((hook = {
+      pending: null,
+      dispatch: null,
+      lastRenderedReducer: basicStateReducer,
+      lastRenderedState: snapshot
+    }),
+    (hook.dispatch = setSnapshot = dispatchAction.bind(
+      null,
+      currentlyRenderingFiber$1,
+      hook
+    )),
+    (_dispatcher$useState.queue = hook),
+    (_dispatcher$useState.baseQueue = null),
+    (snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot)),
+    (_dispatcher$useState.memoizedState = _dispatcher$useState.baseState = snapshot));
+  return snapshot;
+}
+function updateMutableSource(source, getSnapshot, subscribe) {
+  var hook = updateWorkInProgressHook();
+  return useMutableSource(hook, source, getSnapshot, subscribe);
+}
 function mountState(initialState) {
   var hook = mountWorkInProgressHook();
   "function" === typeof initialState && (initialState = initialState());
@@ -3435,11 +3809,12 @@ function startTransition(setPending, config, callback) {
   });
 }
 function dispatchAction(fiber, queue, action) {
-  var currentTime = requestCurrentTimeForUpdate(),
-    suspenseConfig = ReactCurrentBatchConfig.suspense;
-  currentTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
+  var eventTime = requestEventTime(),
+    suspenseConfig = ReactCurrentBatchConfig.suspense,
+    lane = requestUpdateLane(fiber, suspenseConfig);
   suspenseConfig = {
-    expirationTime: currentTime,
+    eventTime: eventTime,
+    lane: lane,
     suspenseConfig: suspenseConfig,
     action: action,
     eagerReducer: null,
@@ -3456,13 +3831,11 @@ function dispatchAction(fiber, queue, action) {
     fiber === currentlyRenderingFiber$1 ||
     (null !== pending && pending === currentlyRenderingFiber$1)
   )
-    (didScheduleRenderPhaseUpdate = !0),
-      (suspenseConfig.expirationTime = renderExpirationTime),
-      (currentlyRenderingFiber$1.expirationTime = renderExpirationTime);
+    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
   else {
     if (
-      0 === fiber.expirationTime &&
-      (null === pending || 0 === pending.expirationTime) &&
+      0 === fiber.lanes &&
+      (null === pending || 0 === pending.lanes) &&
       ((pending = queue.lastRenderedReducer), null !== pending)
     )
       try {
@@ -3474,10 +3847,9 @@ function dispatchAction(fiber, queue, action) {
       } catch (error) {
       } finally {
       }
-    scheduleWork(fiber, currentTime);
+    scheduleUpdateOnFiber(fiber, lane, eventTime);
   }
 }
-function updateEventListener() {}
 var ContextOnlyDispatcher = {
     readContext: readContext,
     useCallback: throwInvalidHookError,
@@ -3490,10 +3862,11 @@ var ContextOnlyDispatcher = {
     useRef: throwInvalidHookError,
     useState: throwInvalidHookError,
     useDebugValue: throwInvalidHookError,
-    useResponder: throwInvalidHookError,
     useDeferredValue: throwInvalidHookError,
     useTransition: throwInvalidHookError,
-    useEvent: throwInvalidHookError
+    useMutableSource: throwInvalidHookError,
+    useOpaqueIdentifier: throwInvalidHookError,
+    unstable_isNewReconciler: !1
   },
   HooksDispatcherOnMount = {
     readContext: readContext,
@@ -3543,7 +3916,6 @@ var ContextOnlyDispatcher = {
     },
     useState: mountState,
     useDebugValue: mountDebugValue,
-    useResponder: createDeprecatedResponderListener,
     useDeferredValue: function(value, config) {
       var _mountState = mountState(value),
         prevValue = _mountState[0],
@@ -3575,7 +3947,19 @@ var ContextOnlyDispatcher = {
         isPending
       ];
     },
-    useEvent: function() {}
+    useMutableSource: function(source, getSnapshot, subscribe) {
+      var hook = mountWorkInProgressHook();
+      hook.memoizedState = {
+        refs: { getSnapshot: getSnapshot, setSnapshot: null },
+        source: source,
+        subscribe: subscribe
+      };
+      return useMutableSource(hook, source, getSnapshot, subscribe);
+    },
+    useOpaqueIdentifier: function() {
+      throw Error("Not yet implemented");
+    },
+    unstable_isNewReconciler: !1
   },
   HooksDispatcherOnUpdate = {
     readContext: readContext,
@@ -3591,7 +3975,6 @@ var ContextOnlyDispatcher = {
       return updateReducer(basicStateReducer);
     },
     useDebugValue: mountDebugValue,
-    useResponder: createDeprecatedResponderListener,
     useDeferredValue: function(value, config) {
       var _updateState = updateReducer(basicStateReducer),
         prevValue = _updateState[0],
@@ -3623,7 +4006,11 @@ var ContextOnlyDispatcher = {
         isPending
       ];
     },
-    useEvent: updateEventListener
+    useMutableSource: updateMutableSource,
+    useOpaqueIdentifier: function() {
+      return updateReducer(basicStateReducer)[0];
+    },
+    unstable_isNewReconciler: !1
   },
   HooksDispatcherOnRerender = {
     readContext: readContext,
@@ -3639,7 +4026,6 @@ var ContextOnlyDispatcher = {
       return rerenderReducer(basicStateReducer);
     },
     useDebugValue: mountDebugValue,
-    useResponder: createDeprecatedResponderListener,
     useDeferredValue: function(value, config) {
       var _rerenderState = rerenderReducer(basicStateReducer),
         prevValue = _rerenderState[0],
@@ -3671,29 +4057,23 @@ var ContextOnlyDispatcher = {
         isPending
       ];
     },
-    useEvent: updateEventListener
+    useMutableSource: updateMutableSource,
+    useOpaqueIdentifier: function() {
+      return rerenderReducer(basicStateReducer)[0];
+    },
+    unstable_isNewReconciler: !1
   },
   ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner,
   didReceiveUpdate = !1;
-function reconcileChildren(
-  current,
-  workInProgress,
-  nextChildren,
-  renderExpirationTime
-) {
+function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
   workInProgress.child =
     null === current
-      ? mountChildFibers(
-          workInProgress,
-          null,
-          nextChildren,
-          renderExpirationTime
-        )
+      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
       : reconcileChildFibers(
           workInProgress,
           current.child,
           nextChildren,
-          renderExpirationTime
+          renderLanes
         );
 }
 function updateForwardRef(
@@ -3701,33 +4081,28 @@ function updateForwardRef(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   Component = Component.render;
   var ref = workInProgress.ref;
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   nextProps = renderWithHooks(
     current,
     workInProgress,
     Component,
     nextProps,
     ref,
-    renderExpirationTime
+    renderLanes
   );
   if (null !== current && !didReceiveUpdate)
     return (
       (workInProgress.updateQueue = current.updateQueue),
       (workInProgress.effectTag &= -517),
-      current.expirationTime <= renderExpirationTime &&
-        (current.expirationTime = 0),
-      bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      )
+      (current.lanes &= ~renderLanes),
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
     );
   workInProgress.effectTag |= 1;
-  reconcileChildren(current, workInProgress, nextProps, renderExpirationTime);
+  reconcileChildren(current, workInProgress, nextProps, renderLanes);
   return workInProgress.child;
 }
 function updateMemoComponent(
@@ -3735,8 +4110,8 @@ function updateMemoComponent(
   workInProgress,
   Component,
   nextProps,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
   if (null === current) {
     var type = Component.type;
@@ -3755,8 +4130,8 @@ function updateMemoComponent(
           workInProgress,
           type,
           nextProps,
-          updateExpirationTime,
-          renderExpirationTime
+          updateLanes,
+          renderLanes
         )
       );
     current = createFiberFromTypeAndProps(
@@ -3765,7 +4140,7 @@ function updateMemoComponent(
       nextProps,
       null,
       workInProgress.mode,
-      renderExpirationTime
+      renderLanes
     );
     current.ref = workInProgress.ref;
     current.return = workInProgress;
@@ -3773,18 +4148,13 @@ function updateMemoComponent(
   }
   type = current.child;
   if (
-    updateExpirationTime < renderExpirationTime &&
-    ((updateExpirationTime = type.memoizedProps),
+    0 === (updateLanes & renderLanes) &&
+    ((updateLanes = type.memoizedProps),
     (Component = Component.compare),
     (Component = null !== Component ? Component : shallowEqual),
-    Component(updateExpirationTime, nextProps) &&
-      current.ref === workInProgress.ref)
+    Component(updateLanes, nextProps) && current.ref === workInProgress.ref)
   )
-    return bailoutOnAlreadyFinishedWork(
-      current,
-      workInProgress,
-      renderExpirationTime
-    );
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   workInProgress.effectTag |= 1;
   current = createWorkInProgress(type, nextProps);
   current.ref = workInProgress.ref;
@@ -3796,29 +4166,66 @@ function updateSimpleMemoComponent(
   workInProgress,
   Component,
   nextProps,
-  updateExpirationTime,
-  renderExpirationTime
+  updateLanes,
+  renderLanes
 ) {
-  return null !== current &&
+  if (
+    null !== current &&
     shallowEqual(current.memoizedProps, nextProps) &&
-    current.ref === workInProgress.ref &&
-    ((didReceiveUpdate = !1), updateExpirationTime < renderExpirationTime)
-    ? ((workInProgress.expirationTime = current.expirationTime),
-      bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      ))
-    : updateFunctionComponent(
-        current,
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
+    current.ref === workInProgress.ref
+  )
+    if (((didReceiveUpdate = !1), 0 !== (renderLanes & updateLanes)))
+      0 !== (current.effectTag & 16384) && (didReceiveUpdate = !0);
+    else
+      return (
+        (workInProgress.lanes = current.lanes),
+        bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
       );
-}
-function markRef(current, workInProgress) {
-  var ref = workInProgress.ref;
+  return updateFunctionComponent(
+    current,
+    workInProgress,
+    Component,
+    nextProps,
+    renderLanes
+  );
+}
+function updateOffscreenComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps,
+    nextChildren = nextProps.children,
+    prevState = null !== current ? current.memoizedState : null;
+  if (
+    "hidden" === nextProps.mode ||
+    "unstable-defer-without-hiding" === nextProps.mode
+  )
+    if (0 === (workInProgress.mode & 4))
+      (workInProgress.memoizedState = { baseLanes: 0 }),
+        pushRenderLanes(workInProgress, renderLanes);
+    else if (0 !== (renderLanes & 1073741824))
+      (workInProgress.memoizedState = { baseLanes: 0 }),
+        pushRenderLanes(
+          workInProgress,
+          null !== prevState ? prevState.baseLanes : renderLanes
+        );
+    else
+      return (
+        (current =
+          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes),
+        (workInProgress.lanes = workInProgress.childLanes = 1073741824),
+        (workInProgress.memoizedState = { baseLanes: current }),
+        pushRenderLanes(workInProgress, current),
+        null
+      );
+  else
+    null !== prevState
+      ? ((nextProps = prevState.baseLanes | renderLanes),
+        (workInProgress.memoizedState = null))
+      : (nextProps = renderLanes),
+      pushRenderLanes(workInProgress, nextProps);
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+  return workInProgress.child;
+}
+function markRef(current, workInProgress) {
+  var ref = workInProgress.ref;
   if (
     (null === current && null !== ref) ||
     (null !== current && current.ref !== ref)
@@ -3830,35 +4237,30 @@ function updateFunctionComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   var context = isContextProvider(Component)
     ? previousContext
     : contextStackCursor.current;
   context = getMaskedContext(workInProgress, context);
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   Component = renderWithHooks(
     current,
     workInProgress,
     Component,
     nextProps,
     context,
-    renderExpirationTime
+    renderLanes
   );
   if (null !== current && !didReceiveUpdate)
     return (
       (workInProgress.updateQueue = current.updateQueue),
       (workInProgress.effectTag &= -517),
-      current.expirationTime <= renderExpirationTime &&
-        (current.expirationTime = 0),
-      bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      )
+      (current.lanes &= ~renderLanes),
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
     );
   workInProgress.effectTag |= 1;
-  reconcileChildren(current, workInProgress, Component, renderExpirationTime);
+  reconcileChildren(current, workInProgress, Component, renderLanes);
   return workInProgress.child;
 }
 function updateClassComponent(
@@ -3866,25 +4268,20 @@ function updateClassComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderLanes
 ) {
   if (isContextProvider(Component)) {
     var hasContext = !0;
     pushContextProvider(workInProgress);
   } else hasContext = !1;
-  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToReadContext(workInProgress, renderLanes);
   if (null === workInProgress.stateNode)
     null !== current &&
       ((current.alternate = null),
       (workInProgress.alternate = null),
       (workInProgress.effectTag |= 2)),
       constructClassInstance(workInProgress, Component, nextProps),
-      mountClassInstance(
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
-      ),
+      mountClassInstance(workInProgress, Component, nextProps, renderLanes),
       (nextProps = !0);
   else if (null === current) {
     var instance = workInProgress.stateNode,
@@ -3915,12 +4312,7 @@ function updateClassComponent(
     hasForceUpdate = !1;
     var oldState = workInProgress.memoizedState;
     instance.state = oldState;
-    processUpdateQueue(
-      workInProgress,
-      nextProps,
-      instance,
-      renderExpirationTime
-    );
+    processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     oldContext = workInProgress.memoizedState;
     oldProps !== nextProps ||
     oldState !== oldContext ||
@@ -3965,117 +4357,111 @@ function updateClassComponent(
       : ("function" === typeof instance.componentDidMount &&
           (workInProgress.effectTag |= 4),
         (nextProps = !1));
-  } else
-    (instance = workInProgress.stateNode),
-      cloneUpdateQueue(current, workInProgress),
-      (oldProps = workInProgress.memoizedProps),
-      (instance.props =
-        workInProgress.type === workInProgress.elementType
-          ? oldProps
-          : resolveDefaultProps(workInProgress.type, oldProps)),
-      (oldContext = instance.context),
-      (contextType = Component.contextType),
-      "object" === typeof contextType && null !== contextType
-        ? (contextType = readContext(contextType))
-        : ((contextType = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (contextType = getMaskedContext(workInProgress, contextType))),
-      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
-      (hasNewLifecycles =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof instance.getSnapshotBeforeUpdate) ||
-        ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof instance.componentWillReceiveProps) ||
-        ((oldProps !== nextProps || oldContext !== contextType) &&
-          callComponentWillReceiveProps(
+  } else {
+    instance = workInProgress.stateNode;
+    cloneUpdateQueue(current, workInProgress);
+    oldProps = workInProgress.memoizedProps;
+    contextType =
+      workInProgress.type === workInProgress.elementType
+        ? oldProps
+        : resolveDefaultProps(workInProgress.type, oldProps);
+    instance.props = contextType;
+    hasNewLifecycles = workInProgress.pendingProps;
+    oldState = instance.context;
+    oldContext = Component.contextType;
+    "object" === typeof oldContext && null !== oldContext
+      ? (oldContext = readContext(oldContext))
+      : ((oldContext = isContextProvider(Component)
+          ? previousContext
+          : contextStackCursor.current),
+        (oldContext = getMaskedContext(workInProgress, oldContext)));
+    var getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;
+    (getDerivedStateFromProps =
+      "function" === typeof getDerivedStateFromProps$jscomp$0 ||
+      "function" === typeof instance.getSnapshotBeforeUpdate) ||
+      ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+        "function" !== typeof instance.componentWillReceiveProps) ||
+      ((oldProps !== hasNewLifecycles || oldState !== oldContext) &&
+        callComponentWillReceiveProps(
+          workInProgress,
+          instance,
+          nextProps,
+          oldContext
+        ));
+    hasForceUpdate = !1;
+    oldState = workInProgress.memoizedState;
+    instance.state = oldState;
+    processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
+    var newState = workInProgress.memoizedState;
+    oldProps !== hasNewLifecycles ||
+    oldState !== newState ||
+    didPerformWorkStackCursor.current ||
+    hasForceUpdate
+      ? ("function" === typeof getDerivedStateFromProps$jscomp$0 &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            getDerivedStateFromProps$jscomp$0,
+            nextProps
+          ),
+          (newState = workInProgress.memoizedState)),
+        (contextType =
+          hasForceUpdate ||
+          checkShouldComponentUpdate(
             workInProgress,
-            instance,
+            Component,
+            contextType,
             nextProps,
-            contextType
-          )),
-      (hasForceUpdate = !1),
-      (oldContext = workInProgress.memoizedState),
-      (instance.state = oldContext),
-      processUpdateQueue(
-        workInProgress,
-        nextProps,
-        instance,
-        renderExpirationTime
-      ),
-      (oldState = workInProgress.memoizedState),
-      oldProps !== nextProps ||
-      oldContext !== oldState ||
-      didPerformWorkStackCursor.current ||
-      hasForceUpdate
-        ? ("function" === typeof getDerivedStateFromProps &&
-            (applyDerivedStateFromProps(
-              workInProgress,
-              Component,
-              getDerivedStateFromProps,
-              nextProps
-            ),
-            (oldState = workInProgress.memoizedState)),
-          (getDerivedStateFromProps =
-            hasForceUpdate ||
-            checkShouldComponentUpdate(
-              workInProgress,
-              Component,
-              oldProps,
-              nextProps,
-              oldContext,
-              oldState,
-              contextType
-            ))
-            ? (hasNewLifecycles ||
-                ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
-                  "function" !== typeof instance.componentWillUpdate) ||
-                ("function" === typeof instance.componentWillUpdate &&
-                  instance.componentWillUpdate(
-                    nextProps,
-                    oldState,
-                    contextType
-                  ),
-                "function" === typeof instance.UNSAFE_componentWillUpdate &&
-                  instance.UNSAFE_componentWillUpdate(
-                    nextProps,
-                    oldState,
-                    contextType
-                  )),
-              "function" === typeof instance.componentDidUpdate &&
-                (workInProgress.effectTag |= 4),
-              "function" === typeof instance.getSnapshotBeforeUpdate &&
-                (workInProgress.effectTag |= 256))
-            : ("function" !== typeof instance.componentDidUpdate ||
-                (oldProps === current.memoizedProps &&
-                  oldContext === current.memoizedState) ||
-                (workInProgress.effectTag |= 4),
-              "function" !== typeof instance.getSnapshotBeforeUpdate ||
-                (oldProps === current.memoizedProps &&
-                  oldContext === current.memoizedState) ||
-                (workInProgress.effectTag |= 256),
-              (workInProgress.memoizedProps = nextProps),
-              (workInProgress.memoizedState = oldState)),
-          (instance.props = nextProps),
-          (instance.state = oldState),
-          (instance.context = contextType),
-          (nextProps = getDerivedStateFromProps))
-        : ("function" !== typeof instance.componentDidUpdate ||
-            (oldProps === current.memoizedProps &&
-              oldContext === current.memoizedState) ||
-            (workInProgress.effectTag |= 4),
-          "function" !== typeof instance.getSnapshotBeforeUpdate ||
-            (oldProps === current.memoizedProps &&
-              oldContext === current.memoizedState) ||
-            (workInProgress.effectTag |= 256),
-          (nextProps = !1));
+            oldState,
+            newState,
+            oldContext
+          ))
+          ? (getDerivedStateFromProps ||
+              ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
+                "function" !== typeof instance.componentWillUpdate) ||
+              ("function" === typeof instance.componentWillUpdate &&
+                instance.componentWillUpdate(nextProps, newState, oldContext),
+              "function" === typeof instance.UNSAFE_componentWillUpdate &&
+                instance.UNSAFE_componentWillUpdate(
+                  nextProps,
+                  newState,
+                  oldContext
+                )),
+            "function" === typeof instance.componentDidUpdate &&
+              (workInProgress.effectTag |= 4),
+            "function" === typeof instance.getSnapshotBeforeUpdate &&
+              (workInProgress.effectTag |= 256))
+          : ("function" !== typeof instance.componentDidUpdate ||
+              (oldProps === current.memoizedProps &&
+                oldState === current.memoizedState) ||
+              (workInProgress.effectTag |= 4),
+            "function" !== typeof instance.getSnapshotBeforeUpdate ||
+              (oldProps === current.memoizedProps &&
+                oldState === current.memoizedState) ||
+              (workInProgress.effectTag |= 256),
+            (workInProgress.memoizedProps = nextProps),
+            (workInProgress.memoizedState = newState)),
+        (instance.props = nextProps),
+        (instance.state = newState),
+        (instance.context = oldContext),
+        (nextProps = contextType))
+      : ("function" !== typeof instance.componentDidUpdate ||
+          (oldProps === current.memoizedProps &&
+            oldState === current.memoizedState) ||
+          (workInProgress.effectTag |= 4),
+        "function" !== typeof instance.getSnapshotBeforeUpdate ||
+          (oldProps === current.memoizedProps &&
+            oldState === current.memoizedState) ||
+          (workInProgress.effectTag |= 256),
+        (nextProps = !1));
+  }
   return finishClassComponent(
     current,
     workInProgress,
     Component,
     nextProps,
     hasContext,
-    renderExpirationTime
+    renderLanes
   );
 }
 function finishClassComponent(
@@ -4084,18 +4470,14 @@ function finishClassComponent(
   Component,
   shouldUpdate,
   hasContext,
-  renderExpirationTime
+  renderLanes
 ) {
   markRef(current, workInProgress);
   var didCaptureError = 0 !== (workInProgress.effectTag & 64);
   if (!shouldUpdate && !didCaptureError)
     return (
       hasContext && invalidateContextProvider(workInProgress, Component, !1),
-      bailoutOnAlreadyFinishedWork(
-        current,
-        workInProgress,
-        renderExpirationTime
-      )
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
     );
   shouldUpdate = workInProgress.stateNode;
   ReactCurrentOwner$1.current = workInProgress;
@@ -4109,20 +4491,15 @@ function finishClassComponent(
         workInProgress,
         current.child,
         null,
-        renderExpirationTime
+        renderLanes
       )),
       (workInProgress.child = reconcileChildFibers(
         workInProgress,
         null,
         nextChildren,
-        renderExpirationTime
+        renderLanes
       )))
-    : reconcileChildren(
-        current,
-        workInProgress,
-        nextChildren,
-        renderExpirationTime
-      );
+    : reconcileChildren(current, workInProgress, nextChildren, renderLanes);
   workInProgress.memoizedState = shouldUpdate.state;
   hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
@@ -4139,155 +4516,186 @@ function pushHostRootContext(workInProgress) {
       pushTopLevelContextObject(workInProgress, root.context, !1);
   pushHostContainer(workInProgress, root.containerInfo);
 }
-var SUSPENDED_MARKER = { dehydrated: null, retryTime: 0 };
-function updateSuspenseComponent(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
-  var mode = workInProgress.mode,
-    nextProps = workInProgress.pendingProps,
+var SUSPENDED_MARKER = { dehydrated: null, retryLane: 0 };
+function updateSuspenseComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps,
     suspenseContext = suspenseStackCursor.current,
-    nextDidTimeout = !1,
+    showFallback = !1,
     JSCompiler_temp;
   (JSCompiler_temp = 0 !== (workInProgress.effectTag & 64)) ||
     (JSCompiler_temp =
-      0 !== (suspenseContext & 2) &&
-      (null === current || null !== current.memoizedState));
+      null !== current && null === current.memoizedState
+        ? !1
+        : 0 !== (suspenseContext & 2));
   JSCompiler_temp
-    ? ((nextDidTimeout = !0), (workInProgress.effectTag &= -65))
+    ? ((showFallback = !0), (workInProgress.effectTag &= -65))
     : (null !== current && null === current.memoizedState) ||
       void 0 === nextProps.fallback ||
       !0 === nextProps.unstable_avoidThisFallback ||
       (suspenseContext |= 1);
   push(suspenseStackCursor, suspenseContext & 1);
   if (null === current) {
-    if (nextDidTimeout) {
-      nextDidTimeout = nextProps.fallback;
-      nextProps = createFiberFromFragment(null, mode, 0, null);
-      nextProps.return = workInProgress;
-      if (0 === (workInProgress.mode & 2))
-        for (
-          current =
-            null !== workInProgress.memoizedState
-              ? workInProgress.child.child
-              : workInProgress.child,
-            nextProps.child = current;
-          null !== current;
-
-        )
-          (current.return = nextProps), (current = current.sibling);
-      renderExpirationTime = createFiberFromFragment(
-        nextDidTimeout,
-        mode,
-        renderExpirationTime,
-        null
+    if (showFallback)
+      return (
+        (current = nextProps.fallback),
+        (suspenseContext = workInProgress.mode),
+        (showFallback = workInProgress.child),
+        (nextProps = { mode: "hidden", children: nextProps.children }),
+        0 === (suspenseContext & 2) && null !== showFallback
+          ? ((showFallback.childLanes = 0),
+            (showFallback.pendingProps = nextProps))
+          : (showFallback = createFiberFromOffscreen(
+              nextProps,
+              suspenseContext,
+              0,
+              null
+            )),
+        (current = createFiberFromFragment(
+          current,
+          suspenseContext,
+          renderLanes,
+          null
+        )),
+        (showFallback.return = workInProgress),
+        (current.return = workInProgress),
+        (showFallback.sibling = current),
+        (workInProgress.child = showFallback),
+        (workInProgress.child.memoizedState = { baseLanes: renderLanes }),
+        (workInProgress.memoizedState = SUSPENDED_MARKER),
+        current
       );
-      renderExpirationTime.return = workInProgress;
-      nextProps.sibling = renderExpirationTime;
-      workInProgress.memoizedState = SUSPENDED_MARKER;
-      workInProgress.child = nextProps;
-      return renderExpirationTime;
-    }
-    mode = nextProps.children;
-    workInProgress.memoizedState = null;
-    return (workInProgress.child = mountChildFibers(
-      workInProgress,
-      null,
-      mode,
-      renderExpirationTime
-    ));
+    renderLanes = createFiberFromOffscreen(
+      { mode: "visible", children: nextProps.children },
+      workInProgress.mode,
+      renderLanes,
+      null
+    );
+    renderLanes.return = workInProgress;
+    return (workInProgress.child = renderLanes);
   }
   if (null !== current.memoizedState) {
-    current = current.child;
-    mode = current.sibling;
-    if (nextDidTimeout) {
-      nextProps = nextProps.fallback;
-      renderExpirationTime = createWorkInProgress(
-        current,
-        current.pendingProps
+    if (showFallback)
+      return (
+        (nextProps = updateSuspenseFallbackChildren(
+          current,
+          workInProgress,
+          nextProps.children,
+          nextProps.fallback,
+          renderLanes
+        )),
+        (suspenseContext = workInProgress.child),
+        (showFallback = current.child.memoizedState),
+        (suspenseContext.memoizedState =
+          null === showFallback
+            ? { baseLanes: renderLanes }
+            : { baseLanes: showFallback.baseLanes | renderLanes }),
+        (suspenseContext.childLanes = current.childLanes & ~renderLanes),
+        (workInProgress.memoizedState = SUSPENDED_MARKER),
+        nextProps
       );
-      renderExpirationTime.return = workInProgress;
-      if (
-        0 === (workInProgress.mode & 2) &&
-        ((nextDidTimeout =
-          null !== workInProgress.memoizedState
-            ? workInProgress.child.child
-            : workInProgress.child),
-        nextDidTimeout !== current.child)
-      )
-        for (
-          renderExpirationTime.child = nextDidTimeout;
-          null !== nextDidTimeout;
-
-        )
-          (nextDidTimeout.return = renderExpirationTime),
-            (nextDidTimeout = nextDidTimeout.sibling);
-      mode = createWorkInProgress(mode, nextProps);
-      mode.return = workInProgress;
-      renderExpirationTime.sibling = mode;
-      renderExpirationTime.childExpirationTime = 0;
-      workInProgress.memoizedState = SUSPENDED_MARKER;
-      workInProgress.child = renderExpirationTime;
-      return mode;
-    }
-    renderExpirationTime = reconcileChildFibers(
+    renderLanes = updateSuspensePrimaryChildren(
+      current,
       workInProgress,
-      current.child,
       nextProps.children,
-      renderExpirationTime
+      renderLanes
     );
     workInProgress.memoizedState = null;
-    return (workInProgress.child = renderExpirationTime);
+    return renderLanes;
   }
-  current = current.child;
-  if (nextDidTimeout) {
-    nextDidTimeout = nextProps.fallback;
-    nextProps = createFiberFromFragment(null, mode, 0, null);
-    nextProps.return = workInProgress;
-    nextProps.child = current;
-    null !== current && (current.return = nextProps);
-    if (0 === (workInProgress.mode & 2))
-      for (
-        current =
-          null !== workInProgress.memoizedState
-            ? workInProgress.child.child
-            : workInProgress.child,
-          nextProps.child = current;
-        null !== current;
-
-      )
-        (current.return = nextProps), (current = current.sibling);
-    renderExpirationTime = createFiberFromFragment(
-      nextDidTimeout,
-      mode,
-      renderExpirationTime,
-      null
+  if (showFallback)
+    return (
+      (nextProps = updateSuspenseFallbackChildren(
+        current,
+        workInProgress,
+        nextProps.children,
+        nextProps.fallback,
+        renderLanes
+      )),
+      (suspenseContext = workInProgress.child),
+      (showFallback = current.child.memoizedState),
+      (suspenseContext.memoizedState =
+        null === showFallback
+          ? { baseLanes: renderLanes }
+          : { baseLanes: showFallback.baseLanes | renderLanes }),
+      (suspenseContext.childLanes = current.childLanes & ~renderLanes),
+      (workInProgress.memoizedState = SUSPENDED_MARKER),
+      nextProps
     );
-    renderExpirationTime.return = workInProgress;
-    nextProps.sibling = renderExpirationTime;
-    renderExpirationTime.effectTag |= 2;
-    nextProps.childExpirationTime = 0;
-    workInProgress.memoizedState = SUSPENDED_MARKER;
-    workInProgress.child = nextProps;
-    return renderExpirationTime;
-  }
-  workInProgress.memoizedState = null;
-  return (workInProgress.child = reconcileChildFibers(
-    workInProgress,
+  renderLanes = updateSuspensePrimaryChildren(
     current,
+    workInProgress,
     nextProps.children,
-    renderExpirationTime
-  ));
+    renderLanes
+  );
+  workInProgress.memoizedState = null;
+  return renderLanes;
 }
-function scheduleWorkOnFiber(fiber, renderExpirationTime) {
-  fiber.expirationTime < renderExpirationTime &&
-    (fiber.expirationTime = renderExpirationTime);
+function updateSuspensePrimaryChildren(
+  current,
+  workInProgress,
+  primaryChildren,
+  renderLanes
+) {
+  var currentPrimaryChildFragment = current.child;
+  current = currentPrimaryChildFragment.sibling;
+  primaryChildren = createWorkInProgress(currentPrimaryChildFragment, {
+    mode: "visible",
+    children: primaryChildren
+  });
+  0 === (workInProgress.mode & 2) && (primaryChildren.lanes = renderLanes);
+  primaryChildren.return = workInProgress;
+  primaryChildren.sibling = null;
+  null !== current &&
+    ((current.nextEffect = null),
+    (current.effectTag = 8),
+    (workInProgress.firstEffect = workInProgress.lastEffect = current));
+  return (workInProgress.child = primaryChildren);
+}
+function updateSuspenseFallbackChildren(
+  current,
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode,
+    currentPrimaryChildFragment = current.child;
+  current = currentPrimaryChildFragment.sibling;
+  var primaryChildProps = { mode: "hidden", children: primaryChildren };
+  0 === (mode & 2) && workInProgress.child !== currentPrimaryChildFragment
+    ? ((primaryChildren = workInProgress.child),
+      (primaryChildren.childLanes = 0),
+      (primaryChildren.pendingProps = primaryChildProps),
+      (currentPrimaryChildFragment = primaryChildren.lastEffect),
+      null !== currentPrimaryChildFragment
+        ? ((workInProgress.firstEffect = primaryChildren.firstEffect),
+          (workInProgress.lastEffect = currentPrimaryChildFragment),
+          (currentPrimaryChildFragment.nextEffect = null))
+        : (workInProgress.firstEffect = workInProgress.lastEffect = null))
+    : (primaryChildren = createWorkInProgress(
+        currentPrimaryChildFragment,
+        primaryChildProps
+      ));
+  null !== current
+    ? (fallbackChildren = createWorkInProgress(current, fallbackChildren))
+    : ((fallbackChildren = createFiberFromFragment(
+        fallbackChildren,
+        mode,
+        renderLanes,
+        null
+      )),
+      (fallbackChildren.effectTag |= 2));
+  fallbackChildren.return = workInProgress;
+  primaryChildren.return = workInProgress;
+  primaryChildren.sibling = fallbackChildren;
+  workInProgress.child = primaryChildren;
+  return fallbackChildren;
+}
+function scheduleWorkOnFiber(fiber, renderLanes) {
+  fiber.lanes |= renderLanes;
   var alternate = fiber.alternate;
-  null !== alternate &&
-    alternate.expirationTime < renderExpirationTime &&
-    (alternate.expirationTime = renderExpirationTime);
-  scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
+  null !== alternate && (alternate.lanes |= renderLanes);
+  scheduleWorkOnParentPath(fiber.return, renderLanes);
 }
 function initSuspenseListRenderState(
   workInProgress,
@@ -4318,20 +4726,11 @@ function initSuspenseListRenderState(
       (renderState.tailMode = tailMode),
       (renderState.lastEffect = lastEffectBeforeRendering));
 }
-function updateSuspenseListComponent(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
+function updateSuspenseListComponent(current, workInProgress, renderLanes) {
   var nextProps = workInProgress.pendingProps,
     revealOrder = nextProps.revealOrder,
     tailMode = nextProps.tail;
-  reconcileChildren(
-    current,
-    workInProgress,
-    nextProps.children,
-    renderExpirationTime
-  );
+  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
   nextProps = suspenseStackCursor.current;
   if (0 !== (nextProps & 2))
     (nextProps = (nextProps & 1) | 2), (workInProgress.effectTag |= 64);
@@ -4340,9 +4739,8 @@ function updateSuspenseListComponent(
       a: for (current = workInProgress.child; null !== current; ) {
         if (13 === current.tag)
           null !== current.memoizedState &&
-            scheduleWorkOnFiber(current, renderExpirationTime);
-        else if (19 === current.tag)
-          scheduleWorkOnFiber(current, renderExpirationTime);
+            scheduleWorkOnFiber(current, renderLanes);
+        else if (19 === current.tag) scheduleWorkOnFiber(current, renderLanes);
         else if (null !== current.child) {
           current.child.return = current;
           current = current.child;
@@ -4364,30 +4762,29 @@ function updateSuspenseListComponent(
   else
     switch (revealOrder) {
       case "forwards":
-        renderExpirationTime = workInProgress.child;
-        for (revealOrder = null; null !== renderExpirationTime; )
-          (current = renderExpirationTime.alternate),
+        renderLanes = workInProgress.child;
+        for (revealOrder = null; null !== renderLanes; )
+          (current = renderLanes.alternate),
             null !== current &&
               null === findFirstSuspended(current) &&
-              (revealOrder = renderExpirationTime),
-            (renderExpirationTime = renderExpirationTime.sibling);
-        renderExpirationTime = revealOrder;
-        null === renderExpirationTime
+              (revealOrder = renderLanes),
+            (renderLanes = renderLanes.sibling);
+        renderLanes = revealOrder;
+        null === renderLanes
           ? ((revealOrder = workInProgress.child),
             (workInProgress.child = null))
-          : ((revealOrder = renderExpirationTime.sibling),
-            (renderExpirationTime.sibling = null));
+          : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
         initSuspenseListRenderState(
           workInProgress,
           !1,
           revealOrder,
-          renderExpirationTime,
+          renderLanes,
           tailMode,
           workInProgress.lastEffect
         );
         break;
       case "backwards":
-        renderExpirationTime = null;
+        renderLanes = null;
         revealOrder = workInProgress.child;
         for (workInProgress.child = null; null !== revealOrder; ) {
           current = revealOrder.alternate;
@@ -4396,14 +4793,14 @@ function updateSuspenseListComponent(
             break;
           }
           current = revealOrder.sibling;
-          revealOrder.sibling = renderExpirationTime;
-          renderExpirationTime = revealOrder;
+          revealOrder.sibling = renderLanes;
+          renderLanes = revealOrder;
           revealOrder = current;
         }
         initSuspenseListRenderState(
           workInProgress,
           !0,
-          renderExpirationTime,
+          renderLanes,
           null,
           tailMode,
           workInProgress.lastEffect
@@ -4424,35 +4821,28 @@ function updateSuspenseListComponent(
     }
   return workInProgress.child;
 }
-function bailoutOnAlreadyFinishedWork(
-  current,
-  workInProgress,
-  renderExpirationTime
-) {
+function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
   null !== current && (workInProgress.dependencies = current.dependencies);
-  var updateExpirationTime = workInProgress.expirationTime;
-  0 !== updateExpirationTime && markUnprocessedUpdateTime(updateExpirationTime);
-  if (workInProgress.childExpirationTime < renderExpirationTime) return null;
-  if (null !== current && workInProgress.child !== current.child)
-    throw Error("Resuming work not yet implemented.");
-  if (null !== workInProgress.child) {
-    current = workInProgress.child;
-    renderExpirationTime = createWorkInProgress(current, current.pendingProps);
-    workInProgress.child = renderExpirationTime;
-    for (
-      renderExpirationTime.return = workInProgress;
-      null !== current.sibling;
-
-    )
-      (current = current.sibling),
-        (renderExpirationTime = renderExpirationTime.sibling = createWorkInProgress(
-          current,
-          current.pendingProps
-        )),
-        (renderExpirationTime.return = workInProgress);
-    renderExpirationTime.sibling = null;
+  workInProgressRootSkippedLanes |= workInProgress.lanes;
+  if (0 !== (renderLanes & workInProgress.childLanes)) {
+    if (null !== current && workInProgress.child !== current.child)
+      throw Error("Resuming work not yet implemented.");
+    if (null !== workInProgress.child) {
+      current = workInProgress.child;
+      renderLanes = createWorkInProgress(current, current.pendingProps);
+      workInProgress.child = renderLanes;
+      for (renderLanes.return = workInProgress; null !== current.sibling; )
+        (current = current.sibling),
+          (renderLanes = renderLanes.sibling = createWorkInProgress(
+            current,
+            current.pendingProps
+          )),
+          (renderLanes.return = workInProgress);
+      renderLanes.sibling = null;
+    }
+    return workInProgress.child;
   }
-  return workInProgress.child;
+  return null;
 }
 var appendAllChildren,
   updateHostContainer,
@@ -4499,17 +4889,17 @@ function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
       break;
     case "collapsed":
       lastTailNode = renderState.tail;
-      for (var _lastTailNode = null; null !== lastTailNode; )
-        null !== lastTailNode.alternate && (_lastTailNode = lastTailNode),
+      for (var lastTailNode$64 = null; null !== lastTailNode; )
+        null !== lastTailNode.alternate && (lastTailNode$64 = lastTailNode),
           (lastTailNode = lastTailNode.sibling);
-      null === _lastTailNode
+      null === lastTailNode$64
         ? hasRenderedATailFallback || null === renderState.tail
           ? (renderState.tail = null)
           : (renderState.tail.sibling = null)
-        : (_lastTailNode.sibling = null);
+        : (lastTailNode$64.sibling = null);
   }
 }
-function completeWork(current, workInProgress, renderExpirationTime) {
+function completeWork(current, workInProgress, renderLanes) {
   var newProps = workInProgress.pendingProps;
   switch (workInProgress.tag) {
     case 2:
@@ -4530,10 +4920,14 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         popHostContainer(),
         pop(didPerformWorkStackCursor),
         pop(contextStackCursor),
-        (current = workInProgress.stateNode),
-        current.pendingContext &&
-          ((current.context = current.pendingContext),
-          (current.pendingContext = null)),
+        resetWorkInProgressVersions(),
+        (newProps = workInProgress.stateNode),
+        newProps.pendingContext &&
+          ((newProps.context = newProps.pendingContext),
+          (newProps.pendingContext = null)),
+        (null !== current && null !== current.child) ||
+          newProps.hydrate ||
+          (workInProgress.effectTag |= 256),
         updateHostContainer(workInProgress),
         null
       );
@@ -4542,12 +4936,12 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       var rootContainerInstance = requiredContext(
         rootInstanceStackCursor.current
       );
-      renderExpirationTime = workInProgress.type;
+      renderLanes = workInProgress.type;
       if (null !== current && null != workInProgress.stateNode)
         updateHostComponent$1(
           current,
           workInProgress,
-          renderExpirationTime,
+          renderLanes,
           newProps,
           rootContainerInstance
         ),
@@ -4563,22 +4957,22 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         }
         requiredContext(contextStackCursor$1.current);
         current = allocateTag();
-        renderExpirationTime = getViewConfigForType(renderExpirationTime);
+        renderLanes = getViewConfigForType(renderLanes);
         var updatePayload = diffProperties(
           null,
           emptyObject,
           newProps,
-          renderExpirationTime.validAttributes
+          renderLanes.validAttributes
         );
         ReactNativePrivateInterface.UIManager.createView(
           current,
-          renderExpirationTime.uiViewClassName,
+          renderLanes.uiViewClassName,
           rootContainerInstance,
           updatePayload
         );
         rootContainerInstance = new ReactNativeFiberHostComponent(
           current,
-          renderExpirationTime,
+          renderLanes,
           workInProgress
         );
         instanceCache.set(current, workInProgress);
@@ -4623,49 +5017,32 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       pop(suspenseStackCursor);
       newProps = workInProgress.memoizedState;
       if (0 !== (workInProgress.effectTag & 64))
-        return (
-          (workInProgress.expirationTime = renderExpirationTime), workInProgress
-        );
+        return (workInProgress.lanes = renderLanes), workInProgress;
       newProps = null !== newProps;
       rootContainerInstance = !1;
       null !== current &&
-        ((renderExpirationTime = current.memoizedState),
-        (rootContainerInstance = null !== renderExpirationTime),
-        newProps ||
-          null === renderExpirationTime ||
-          ((renderExpirationTime = current.child.sibling),
-          null !== renderExpirationTime &&
-            ((updatePayload = workInProgress.firstEffect),
-            null !== updatePayload
-              ? ((workInProgress.firstEffect = renderExpirationTime),
-                (renderExpirationTime.nextEffect = updatePayload))
-              : ((workInProgress.firstEffect = workInProgress.lastEffect = renderExpirationTime),
-                (renderExpirationTime.nextEffect = null)),
-            (renderExpirationTime.effectTag = 8))));
+        (rootContainerInstance = null !== current.memoizedState);
       if (newProps && !rootContainerInstance && 0 !== (workInProgress.mode & 2))
         if (
           (null === current &&
             !0 !== workInProgress.memoizedProps.unstable_avoidThisFallback) ||
           0 !== (suspenseStackCursor.current & 1)
         )
-          workInProgressRootExitStatus === RootIncomplete &&
-            (workInProgressRootExitStatus = RootSuspended);
+          0 === workInProgressRootExitStatus &&
+            (workInProgressRootExitStatus = 3);
         else {
           if (
-            workInProgressRootExitStatus === RootIncomplete ||
-            workInProgressRootExitStatus === RootSuspended
+            0 === workInProgressRootExitStatus ||
+            3 === workInProgressRootExitStatus
           )
-            workInProgressRootExitStatus = RootSuspendedWithDelay;
-          0 !== workInProgressRootNextUnprocessedUpdateTime &&
-            null !== workInProgressRoot &&
-            (markRootSuspendedAtTime(
+            workInProgressRootExitStatus = 4;
+          null === workInProgressRoot ||
+            (0 === (workInProgressRootSkippedLanes & 134217727) &&
+              0 === (workInProgressRootUpdatedLanes & 134217727)) ||
+            markRootSuspended$1(
               workInProgressRoot,
-              renderExpirationTime$1
-            ),
-            markRootUpdatedAtTime(
-              workInProgressRoot,
-              workInProgressRootNextUnprocessedUpdateTime
-            ));
+              workInProgressRootRenderLanes
+            );
         }
       if (newProps || rootContainerInstance) workInProgress.effectTag |= 4;
       return null;
@@ -4685,7 +5062,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         if (rootContainerInstance) cutOffTailIfNeeded(newProps, !1);
         else {
           if (
-            workInProgressRootExitStatus !== RootIncomplete ||
+            0 !== workInProgressRootExitStatus ||
             (null !== current && 0 !== (current.effectTag & 64))
           )
             for (current = workInProgress.child; null !== current; ) {
@@ -4700,27 +5077,27 @@ function completeWork(current, workInProgress, renderExpirationTime) {
                 null === newProps.lastEffect &&
                   (workInProgress.firstEffect = null);
                 workInProgress.lastEffect = newProps.lastEffect;
-                current = renderExpirationTime;
+                current = renderLanes;
                 for (newProps = workInProgress.child; null !== newProps; )
                   (rootContainerInstance = newProps),
-                    (renderExpirationTime = current),
+                    (renderLanes = current),
                     (rootContainerInstance.effectTag &= 2),
                     (rootContainerInstance.nextEffect = null),
                     (rootContainerInstance.firstEffect = null),
                     (rootContainerInstance.lastEffect = null),
                     (updatePayload = rootContainerInstance.alternate),
                     null === updatePayload
-                      ? ((rootContainerInstance.childExpirationTime = 0),
-                        (rootContainerInstance.expirationTime = renderExpirationTime),
+                      ? ((rootContainerInstance.childLanes = 0),
+                        (rootContainerInstance.lanes = renderLanes),
                         (rootContainerInstance.child = null),
                         (rootContainerInstance.memoizedProps = null),
                         (rootContainerInstance.memoizedState = null),
                         (rootContainerInstance.updateQueue = null),
-                        (rootContainerInstance.dependencies = null))
-                      : ((rootContainerInstance.childExpirationTime =
-                          updatePayload.childExpirationTime),
-                        (rootContainerInstance.expirationTime =
-                          updatePayload.expirationTime),
+                        (rootContainerInstance.dependencies = null),
+                        (rootContainerInstance.stateNode = null))
+                      : ((rootContainerInstance.childLanes =
+                          updatePayload.childLanes),
+                        (rootContainerInstance.lanes = updatePayload.lanes),
                         (rootContainerInstance.child = updatePayload.child),
                         (rootContainerInstance.memoizedProps =
                           updatePayload.memoizedProps),
@@ -4728,15 +5105,14 @@ function completeWork(current, workInProgress, renderExpirationTime) {
                           updatePayload.memoizedState),
                         (rootContainerInstance.updateQueue =
                           updatePayload.updateQueue),
-                        (renderExpirationTime = updatePayload.dependencies),
+                        (rootContainerInstance.type = updatePayload.type),
+                        (renderLanes = updatePayload.dependencies),
                         (rootContainerInstance.dependencies =
-                          null === renderExpirationTime
+                          null === renderLanes
                             ? null
                             : {
-                                expirationTime:
-                                  renderExpirationTime.expirationTime,
-                                firstContext: renderExpirationTime.firstContext,
-                                responders: renderExpirationTime.responders
+                                lanes: renderLanes.lanes,
+                                firstContext: renderLanes.firstContext
                               })),
                     (newProps = newProps.sibling);
                 push(
@@ -4773,12 +5149,11 @@ function completeWork(current, workInProgress, renderExpirationTime) {
               );
           } else
             2 * now() - newProps.renderingStartTime > newProps.tailExpiration &&
-              1 < renderExpirationTime &&
+              1073741824 !== renderLanes &&
               ((workInProgress.effectTag |= 64),
               (rootContainerInstance = !0),
               cutOffTailIfNeeded(newProps, !1),
-              (workInProgress.expirationTime = workInProgress.childExpirationTime =
-                renderExpirationTime - 1));
+              (workInProgress.lanes = renderLanes));
         newProps.isBackwards
           ? ((updatePayload.sibling = workInProgress.child),
             (workInProgress.child = updatePayload))
@@ -4806,6 +5181,17 @@ function completeWork(current, workInProgress, renderExpirationTime) {
           ),
           current)
         : null;
+    case 23:
+    case 24:
+      return (
+        popRenderLanes(),
+        null !== current &&
+          (null !== current.memoizedState) !==
+            (null !== workInProgress.memoizedState) &&
+          "unstable-defer-without-hiding" !== newProps.mode &&
+          (workInProgress.effectTag |= 4),
+        null
+      );
   }
   throw Error(
     "Unknown unit of work tag (" +
@@ -4826,6 +5212,7 @@ function unwindWork(workInProgress) {
       popHostContainer();
       pop(didPerformWorkStackCursor);
       pop(contextStackCursor);
+      resetWorkInProgressVersions();
       effectTag = workInProgress.effectTag;
       if (0 !== (effectTag & 64))
         throw Error(
@@ -4850,6 +5237,9 @@ function unwindWork(workInProgress) {
       return popHostContainer(), null;
     case 10:
       return popProvider(workInProgress), null;
+    case 23:
+    case 24:
+      return popRenderLanes(), null;
     default:
       return null;
   }
@@ -4868,51 +5258,61 @@ if (
   throw Error(
     "Expected ReactFiberErrorDialog.showErrorDialog to be a function."
   );
-function logCapturedError(capturedError) {
-  !1 !==
-    ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog(
-      capturedError
-    ) && console.error(capturedError.error);
-}
-var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
-function logError(boundary, errorInfo) {
-  var source = errorInfo.source,
-    stack = errorInfo.stack;
-  null === stack &&
-    null !== source &&
-    (stack = getStackByFiberInDevAndProd(source));
-  errorInfo = {
-    componentName: null !== source ? getComponentName(source.type) : null,
-    componentStack: null !== stack ? stack : "",
-    error: errorInfo.value,
-    errorBoundary: null,
-    errorBoundaryName: null,
-    errorBoundaryFound: !1,
-    willRetry: !1
-  };
-  null !== boundary &&
-    1 === boundary.tag &&
-    ((errorInfo.errorBoundary = boundary.stateNode),
-    (errorInfo.errorBoundaryName = getComponentName(boundary.type)),
-    (errorInfo.errorBoundaryFound = !0),
-    (errorInfo.willRetry = !0));
+function logCapturedError(boundary, errorInfo) {
   try {
-    logCapturedError(errorInfo);
+    !1 !==
+      ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog({
+        componentStack: null !== errorInfo.stack ? errorInfo.stack : "",
+        error: errorInfo.value,
+        errorBoundary:
+          null !== boundary && 1 === boundary.tag ? boundary.stateNode : null
+      }) && console.error(errorInfo.value);
   } catch (e) {
     setTimeout(function() {
       throw e;
     });
   }
 }
-function safelyCallComponentWillUnmount(current, instance) {
-  try {
-    (instance.props = current.memoizedProps),
-      (instance.state = current.memoizedState),
-      instance.componentWillUnmount();
-  } catch (unmountError) {
-    captureCommitPhaseError(current, unmountError);
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
+function createRootErrorUpdate(fiber, errorInfo, lane) {
+  lane = createUpdate(-1, lane, null);
+  lane.tag = 3;
+  lane.payload = { element: null };
+  var error = errorInfo.value;
+  lane.callback = function() {
+    hasUncaughtError || ((hasUncaughtError = !0), (firstUncaughtError = error));
+    logCapturedError(fiber, errorInfo);
+  };
+  return lane;
+}
+function createClassErrorUpdate(fiber, errorInfo, lane) {
+  lane = createUpdate(-1, lane, null);
+  lane.tag = 3;
+  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+  if ("function" === typeof getDerivedStateFromError) {
+    var error = errorInfo.value;
+    lane.payload = function() {
+      logCapturedError(fiber, errorInfo);
+      return getDerivedStateFromError(error);
+    };
   }
+  var inst = fiber.stateNode;
+  null !== inst &&
+    "function" === typeof inst.componentDidCatch &&
+    (lane.callback = function() {
+      "function" !== typeof getDerivedStateFromError &&
+        (null === legacyErrorBoundariesThatAlreadyFailed
+          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
+          : legacyErrorBoundariesThatAlreadyFailed.add(this),
+        logCapturedError(fiber, errorInfo));
+      var stack = errorInfo.stack;
+      this.componentDidCatch(errorInfo.value, {
+        componentStack: null !== stack ? stack : ""
+      });
+    });
+  return lane;
 }
+var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
 function safelyDetachRef(current) {
   var ref = current.ref;
   if (null !== ref)
@@ -4946,6 +5346,7 @@ function commitBeforeMutationLifeCycles(current, finishedWork) {
       }
       return;
     case 3:
+      return;
     case 5:
     case 6:
     case 4:
@@ -4956,58 +5357,57 @@ function commitBeforeMutationLifeCycles(current, finishedWork) {
     "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
   );
 }
-function commitHookEffectListUnmount(tag, finishedWork) {
-  finishedWork = finishedWork.updateQueue;
-  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
-  if (null !== finishedWork) {
-    var effect = (finishedWork = finishedWork.next);
-    do {
-      if ((effect.tag & tag) === tag) {
-        var destroy = effect.destroy;
-        effect.destroy = void 0;
-        void 0 !== destroy && destroy();
-      }
-      effect = effect.next;
-    } while (effect !== finishedWork);
-  }
-}
-function commitHookEffectListMount(tag, finishedWork) {
-  finishedWork = finishedWork.updateQueue;
-  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
-  if (null !== finishedWork) {
-    var effect = (finishedWork = finishedWork.next);
-    do {
-      if ((effect.tag & tag) === tag) {
-        var create = effect.create;
-        effect.destroy = create();
-      }
-      effect = effect.next;
-    } while (effect !== finishedWork);
-  }
-}
 function commitLifeCycles(finishedRoot, current, finishedWork) {
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 15:
     case 22:
-      commitHookEffectListMount(3, finishedWork);
+      current = finishedWork.updateQueue;
+      current = null !== current ? current.lastEffect : null;
+      if (null !== current) {
+        finishedRoot = current = current.next;
+        do {
+          if (3 === (finishedRoot.tag & 3)) {
+            var create$81 = finishedRoot.create;
+            finishedRoot.destroy = create$81();
+          }
+          finishedRoot = finishedRoot.next;
+        } while (finishedRoot !== current);
+      }
+      current = finishedWork.updateQueue;
+      current = null !== current ? current.lastEffect : null;
+      if (null !== current) {
+        finishedRoot = current = current.next;
+        do {
+          var _effect = finishedRoot;
+          create$81 = _effect.next;
+          _effect = _effect.tag;
+          0 !== (_effect & 4) &&
+            0 !== (_effect & 1) &&
+            (enqueuePendingPassiveHookEffectUnmount(finishedWork, finishedRoot),
+            enqueuePendingPassiveHookEffectMount(finishedWork, finishedRoot));
+          finishedRoot = create$81;
+        } while (finishedRoot !== current);
+      }
       return;
     case 1:
       finishedRoot = finishedWork.stateNode;
-      if (finishedWork.effectTag & 4)
-        if (null === current) finishedRoot.componentDidMount();
-        else {
-          var prevProps =
-            finishedWork.elementType === finishedWork.type
-              ? current.memoizedProps
-              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
-          finishedRoot.componentDidUpdate(
-            prevProps,
-            current.memoizedState,
-            finishedRoot.__reactInternalSnapshotBeforeUpdate
-          );
-        }
+      finishedWork.effectTag & 4 &&
+        (null === current
+          ? finishedRoot.componentDidMount()
+          : ((create$81 =
+              finishedWork.elementType === finishedWork.type
+                ? current.memoizedProps
+                : resolveDefaultProps(
+                    finishedWork.type,
+                    current.memoizedProps
+                  )),
+            finishedRoot.componentDidUpdate(
+              create$81,
+              current.memoizedState,
+              finishedRoot.__reactInternalSnapshotBeforeUpdate
+            )));
       current = finishedWork.updateQueue;
       null !== current &&
         commitUpdateQueue(finishedWork, current, finishedRoot);
@@ -5041,78 +5441,138 @@ function commitLifeCycles(finishedRoot, current, finishedWork) {
     case 17:
     case 20:
     case 21:
+    case 23:
+    case 24:
       return;
   }
   throw Error(
     "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
   );
 }
-function commitUnmount(finishedRoot, current$jscomp$0, renderPriorityLevel) {
-  "function" === typeof onCommitFiberUnmount &&
-    onCommitFiberUnmount(current$jscomp$0);
-  switch (current$jscomp$0.tag) {
+function hideOrUnhideAllChildren(finishedWork, isHidden) {
+  for (var node = finishedWork; ; ) {
+    if (5 === node.tag) {
+      var instance = node.stateNode;
+      if (isHidden) {
+        var viewConfig = instance.viewConfig;
+        var updatePayload = diffProperties(
+          null,
+          emptyObject,
+          { style: { display: "none" } },
+          viewConfig.validAttributes
+        );
+        ReactNativePrivateInterface.UIManager.updateView(
+          instance._nativeTag,
+          viewConfig.uiViewClassName,
+          updatePayload
+        );
+      } else {
+        instance = node.stateNode;
+        updatePayload = node.memoizedProps;
+        viewConfig = instance.viewConfig;
+        var prevProps = Object.assign({}, updatePayload, {
+          style: [updatePayload.style, { display: "none" }]
+        });
+        updatePayload = diffProperties(
+          null,
+          prevProps,
+          updatePayload,
+          viewConfig.validAttributes
+        );
+        ReactNativePrivateInterface.UIManager.updateView(
+          instance._nativeTag,
+          viewConfig.uiViewClassName,
+          updatePayload
+        );
+      }
+    } else {
+      if (6 === node.tag) throw Error("Not yet implemented.");
+      if (
+        ((23 !== node.tag && 24 !== node.tag) ||
+          null === node.memoizedState ||
+          node === finishedWork) &&
+        null !== node.child
+      ) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+    }
+    if (node === finishedWork) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === finishedWork) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+}
+function commitUnmount(finishedRoot, current) {
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, current);
+    } catch (err) {}
+  switch (current.tag) {
     case 0:
     case 11:
     case 14:
     case 15:
     case 22:
-      finishedRoot = current$jscomp$0.updateQueue;
+      finishedRoot = current.updateQueue;
       if (
         null !== finishedRoot &&
         ((finishedRoot = finishedRoot.lastEffect), null !== finishedRoot)
       ) {
-        var firstEffect = finishedRoot.next;
-        runWithPriority(
-          97 < renderPriorityLevel ? 97 : renderPriorityLevel,
-          function() {
-            var effect = firstEffect;
-            do {
-              var _destroy = effect.destroy;
-              if (void 0 !== _destroy) {
-                var current = current$jscomp$0;
-                try {
-                  _destroy();
-                } catch (error) {
-                  captureCommitPhaseError(current, error);
-                }
+        var effect = (finishedRoot = finishedRoot.next);
+        do {
+          var _effect2 = effect,
+            destroy = _effect2.destroy;
+          _effect2 = _effect2.tag;
+          if (void 0 !== destroy)
+            if (0 !== (_effect2 & 4))
+              enqueuePendingPassiveHookEffectUnmount(current, effect);
+            else {
+              _effect2 = current;
+              try {
+                destroy();
+              } catch (error) {
+                captureCommitPhaseError(_effect2, error);
               }
-              effect = effect.next;
-            } while (effect !== firstEffect);
-          }
-        );
+            }
+          effect = effect.next;
+        } while (effect !== finishedRoot);
       }
       break;
     case 1:
-      safelyDetachRef(current$jscomp$0);
-      renderPriorityLevel = current$jscomp$0.stateNode;
-      "function" === typeof renderPriorityLevel.componentWillUnmount &&
-        safelyCallComponentWillUnmount(current$jscomp$0, renderPriorityLevel);
+      safelyDetachRef(current);
+      finishedRoot = current.stateNode;
+      if ("function" === typeof finishedRoot.componentWillUnmount)
+        try {
+          (finishedRoot.props = current.memoizedProps),
+            (finishedRoot.state = current.memoizedState),
+            finishedRoot.componentWillUnmount();
+        } catch (unmountError) {
+          captureCommitPhaseError(current, unmountError);
+        }
       break;
     case 5:
-      safelyDetachRef(current$jscomp$0);
+      safelyDetachRef(current);
       break;
     case 4:
-      unmountHostComponents(
-        finishedRoot,
-        current$jscomp$0,
-        renderPriorityLevel
-      );
+      unmountHostComponents(finishedRoot, current);
   }
 }
-function detachFiber(current) {
-  var alternate = current.alternate;
-  current.return = null;
-  current.child = null;
-  current.memoizedState = null;
-  current.updateQueue = null;
-  current.dependencies = null;
-  current.alternate = null;
-  current.firstEffect = null;
-  current.lastEffect = null;
-  current.pendingProps = null;
-  current.memoizedProps = null;
-  current.stateNode = null;
-  null !== alternate && detachFiber(alternate);
+function detachFiberMutation(fiber) {
+  fiber.alternate = null;
+  fiber.child = null;
+  fiber.dependencies = null;
+  fiber.firstEffect = null;
+  fiber.lastEffect = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.return = null;
+  fiber.updateQueue = null;
 }
 function isHostParent(fiber) {
   return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
@@ -5120,16 +5580,14 @@ function isHostParent(fiber) {
 function commitPlacement(finishedWork) {
   a: {
     for (var parent = finishedWork.return; null !== parent; ) {
-      if (isHostParent(parent)) {
-        var parentFiber = parent;
-        break a;
-      }
+      if (isHostParent(parent)) break a;
       parent = parent.return;
     }
     throw Error(
       "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
     );
   }
+  var parentFiber = parent;
   parent = parentFiber.stateNode;
   switch (parentFiber.tag) {
     case 5:
@@ -5264,11 +5722,7 @@ function insertOrAppendPlacementNode(node, before, parent) {
     )
       insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
 }
-function unmountHostComponents(
-  finishedRoot$jscomp$0,
-  current,
-  renderPriorityLevel$jscomp$0
-) {
+function unmountHostComponents(finishedRoot$jscomp$0, current) {
   for (
     var node = current,
       currentParentIsValid = !1,
@@ -5306,13 +5760,12 @@ function unmountHostComponents(
       a: for (
         var finishedRoot = finishedRoot$jscomp$0,
           root = node,
-          renderPriorityLevel = renderPriorityLevel$jscomp$0,
           node$jscomp$0 = root;
         ;
 
       )
         if (
-          (commitUnmount(finishedRoot, node$jscomp$0, renderPriorityLevel),
+          (commitUnmount(finishedRoot, node$jscomp$0),
           null !== node$jscomp$0.child && 4 !== node$jscomp$0.tag)
         )
           (node$jscomp$0.child.return = node$jscomp$0),
@@ -5339,18 +5792,18 @@ function unmountHostComponents(
             [0]
           ))
         : ((finishedRoot = currentParent),
-          (renderPriorityLevel = node.stateNode),
-          recursivelyUncacheFiberNode(renderPriorityLevel),
+          (node$jscomp$0 = node.stateNode),
+          recursivelyUncacheFiberNode(node$jscomp$0),
           (root = finishedRoot._children),
-          (renderPriorityLevel = root.indexOf(renderPriorityLevel)),
-          root.splice(renderPriorityLevel, 1),
+          (node$jscomp$0 = root.indexOf(node$jscomp$0)),
+          root.splice(node$jscomp$0, 1),
           ReactNativePrivateInterface.UIManager.manageChildren(
             finishedRoot._nativeTag,
             [],
             [],
             [],
             [],
-            [renderPriorityLevel]
+            [node$jscomp$0]
           ));
     } else if (4 === node.tag) {
       if (null !== node.child) {
@@ -5361,8 +5814,7 @@ function unmountHostComponents(
         continue;
       }
     } else if (
-      (commitUnmount(finishedRoot$jscomp$0, node, renderPriorityLevel$jscomp$0),
-      null !== node.child)
+      (commitUnmount(finishedRoot$jscomp$0, node), null !== node.child)
     ) {
       node.child.return = node;
       node = node.child;
@@ -5385,31 +5837,42 @@ function commitWork(current, finishedWork) {
     case 14:
     case 15:
     case 22:
-      commitHookEffectListUnmount(3, finishedWork);
+      var updateQueue = finishedWork.updateQueue;
+      updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
+      if (null !== updateQueue) {
+        var effect = (updateQueue = updateQueue.next);
+        do
+          3 === (effect.tag & 3) &&
+            ((finishedWork = effect.destroy),
+            (effect.destroy = void 0),
+            void 0 !== finishedWork && finishedWork()),
+            (effect = effect.next);
+        while (effect !== updateQueue);
+      }
       return;
     case 1:
       return;
     case 5:
-      var instance = finishedWork.stateNode;
-      if (null != instance) {
-        var newProps = finishedWork.memoizedProps;
-        current = null !== current ? current.memoizedProps : newProps;
+      updateQueue = finishedWork.stateNode;
+      if (null != updateQueue) {
+        effect = finishedWork.memoizedProps;
+        current = null !== current ? current.memoizedProps : effect;
         var updatePayload = finishedWork.updateQueue;
         finishedWork.updateQueue = null;
         null !== updatePayload &&
-          ((finishedWork = instance.viewConfig),
-          instanceProps.set(instance._nativeTag, newProps),
-          (newProps = diffProperties(
+          ((finishedWork = updateQueue.viewConfig),
+          instanceProps.set(updateQueue._nativeTag, effect),
+          (effect = diffProperties(
             null,
             current,
-            newProps,
+            effect,
             finishedWork.validAttributes
           )),
-          null != newProps &&
+          null != effect &&
             ReactNativePrivateInterface.UIManager.updateView(
-              instance._nativeTag,
+              updateQueue._nativeTag,
               finishedWork.uiViewClassName,
-              newProps
+              effect
             ));
       }
       return;
@@ -5429,72 +5892,9 @@ function commitWork(current, finishedWork) {
     case 12:
       return;
     case 13:
-      instance = finishedWork;
-      null === finishedWork.memoizedState
-        ? (newProps = !1)
-        : ((newProps = !0),
-          (instance = finishedWork.child),
-          (globalMostRecentFallbackTime = now()));
-      if (null !== instance)
-        a: for (current = instance; ; ) {
-          if (5 === current.tag)
-            if (((updatePayload = current.stateNode), newProps)) {
-              var viewConfig = updatePayload.viewConfig;
-              var updatePayload$jscomp$0 = diffProperties(
-                null,
-                emptyObject,
-                { style: { display: "none" } },
-                viewConfig.validAttributes
-              );
-              ReactNativePrivateInterface.UIManager.updateView(
-                updatePayload._nativeTag,
-                viewConfig.uiViewClassName,
-                updatePayload$jscomp$0
-              );
-            } else {
-              updatePayload = current.stateNode;
-              updatePayload$jscomp$0 = current.memoizedProps;
-              viewConfig = updatePayload.viewConfig;
-              var prevProps = Object.assign({}, updatePayload$jscomp$0, {
-                style: [updatePayload$jscomp$0.style, { display: "none" }]
-              });
-              updatePayload$jscomp$0 = diffProperties(
-                null,
-                prevProps,
-                updatePayload$jscomp$0,
-                viewConfig.validAttributes
-              );
-              ReactNativePrivateInterface.UIManager.updateView(
-                updatePayload._nativeTag,
-                viewConfig.uiViewClassName,
-                updatePayload$jscomp$0
-              );
-            }
-          else {
-            if (6 === current.tag) throw Error("Not yet implemented.");
-            if (
-              13 === current.tag &&
-              null !== current.memoizedState &&
-              null === current.memoizedState.dehydrated
-            ) {
-              updatePayload = current.child.sibling;
-              updatePayload.return = current;
-              current = updatePayload;
-              continue;
-            } else if (null !== current.child) {
-              current.child.return = current;
-              current = current.child;
-              continue;
-            }
-          }
-          if (current === instance) break;
-          for (; null === current.sibling; ) {
-            if (null === current.return || current.return === instance) break a;
-            current = current.return;
-          }
-          current.sibling.return = current.return;
-          current = current.sibling;
-        }
+      null !== finishedWork.memoizedState &&
+        ((globalMostRecentFallbackTime = now()),
+        hideOrUnhideAllChildren(finishedWork.child, !0));
       attachSuspenseRetryListeners(finishedWork);
       return;
     case 19:
@@ -5502,90 +5902,59 @@ function commitWork(current, finishedWork) {
       return;
     case 17:
       return;
+    case 23:
+    case 24:
+      hideOrUnhideAllChildren(
+        finishedWork,
+        null !== finishedWork.memoizedState
+      );
+      return;
   }
   throw Error(
     "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
   );
 }
 function attachSuspenseRetryListeners(finishedWork) {
-  var thenables = finishedWork.updateQueue;
-  if (null !== thenables) {
+  var wakeables = finishedWork.updateQueue;
+  if (null !== wakeables) {
     finishedWork.updateQueue = null;
     var retryCache = finishedWork.stateNode;
     null === retryCache &&
       (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
-    thenables.forEach(function(thenable) {
-      var retry = resolveRetryThenable.bind(null, finishedWork, thenable);
-      retryCache.has(thenable) ||
-        (retryCache.add(thenable), thenable.then(retry, retry));
+    wakeables.forEach(function(wakeable) {
+      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+      retryCache.has(wakeable) ||
+        (retryCache.add(wakeable), wakeable.then(retry, retry));
     });
   }
 }
-var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
-function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
-  expirationTime = createUpdate(expirationTime, null);
-  expirationTime.tag = 3;
-  expirationTime.payload = { element: null };
-  var error = errorInfo.value;
-  expirationTime.callback = function() {
-    hasUncaughtError || ((hasUncaughtError = !0), (firstUncaughtError = error));
-    logError(fiber, errorInfo);
-  };
-  return expirationTime;
-}
-function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
-  expirationTime = createUpdate(expirationTime, null);
-  expirationTime.tag = 3;
-  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
-  if ("function" === typeof getDerivedStateFromError) {
-    var error = errorInfo.value;
-    expirationTime.payload = function() {
-      logError(fiber, errorInfo);
-      return getDerivedStateFromError(error);
-    };
-  }
-  var inst = fiber.stateNode;
-  null !== inst &&
-    "function" === typeof inst.componentDidCatch &&
-    (expirationTime.callback = function() {
-      "function" !== typeof getDerivedStateFromError &&
-        (null === legacyErrorBoundariesThatAlreadyFailed
-          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
-          : legacyErrorBoundariesThatAlreadyFailed.add(this),
-        logError(fiber, errorInfo));
-      var stack = errorInfo.stack;
-      this.componentDidCatch(errorInfo.value, {
-        componentStack: null !== stack ? stack : ""
-      });
-    });
-  return expirationTime;
+function isSuspenseBoundaryBeingHidden(current, finishedWork) {
+  return null !== current &&
+    ((current = current.memoizedState),
+    null === current || null !== current.dehydrated)
+    ? ((finishedWork = finishedWork.memoizedState),
+      null !== finishedWork && null === finishedWork.dehydrated)
+    : !1;
 }
 var ceil = Math.ceil,
-  ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
+  ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
-  NoContext = 0,
-  LegacyUnbatchedContext = 8,
-  RenderContext = 16,
-  CommitContext = 32,
-  RootIncomplete = 0,
-  RootFatalErrored = 1,
-  RootErrored = 2,
-  RootSuspended = 3,
-  RootSuspendedWithDelay = 4,
-  RootCompleted = 5,
-  executionContext = NoContext,
+  executionContext = 0,
   workInProgressRoot = null,
   workInProgress = null,
-  renderExpirationTime$1 = 0,
-  workInProgressRootExitStatus = RootIncomplete,
+  workInProgressRootRenderLanes = 0,
+  subtreeRenderLanes = 0,
+  subtreeRenderLanesCursor = createCursor(0),
+  workInProgressRootExitStatus = 0,
   workInProgressRootFatalError = null,
-  workInProgressRootLatestProcessedExpirationTime = 1073741823,
-  workInProgressRootLatestSuspenseTimeout = 1073741823,
+  workInProgressRootLatestSuspenseTimeout = -1,
   workInProgressRootCanSuspendUsingConfig = null,
-  workInProgressRootNextUnprocessedUpdateTime = 0,
-  workInProgressRootHasPendingPing = !1,
+  workInProgressRootIncludedLanes = 0,
+  workInProgressRootSkippedLanes = 0,
+  workInProgressRootUpdatedLanes = 0,
+  workInProgressRootPingedLanes = 0,
+  mostRecentlyUpdatedRoot = null,
   globalMostRecentFallbackTime = 0,
-  FALLBACK_THROTTLE_MS = 500,
   nextEffect = null,
   hasUncaughtError = !1,
   firstUncaughtError = null,
@@ -5593,205 +5962,200 @@ var ceil = Math.ceil,
   rootDoesHavePassiveEffects = !1,
   rootWithPendingPassiveEffects = null,
   pendingPassiveEffectsRenderPriority = 90,
+  pendingPassiveHookEffectsMount = [],
+  pendingPassiveHookEffectsUnmount = [],
   rootsWithPendingDiscreteUpdates = null,
   nestedUpdateCount = 0,
   rootWithNestedUpdates = null,
-  currentEventTime = 0;
-function requestCurrentTimeForUpdate() {
-  return (executionContext & (RenderContext | CommitContext)) !== NoContext
-    ? 1073741821 - ((now() / 10) | 0)
-    : 0 !== currentEventTime
+  currentEventTime = -1,
+  currentEventWipLanes = 0,
+  currentEventPendingLanes = 0,
+  focusedInstanceHandle = null,
+  shouldFireAfterActiveInstanceBlur = !1;
+function requestEventTime() {
+  return 0 !== (executionContext & 48)
+    ? now()
+    : -1 !== currentEventTime
     ? currentEventTime
-    : (currentEventTime = 1073741821 - ((now() / 10) | 0));
+    : (currentEventTime = now());
 }
-function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {
+function requestUpdateLane(fiber, suspenseConfig) {
   fiber = fiber.mode;
-  if (0 === (fiber & 2)) return 1073741823;
-  var priorityLevel = getCurrentPriorityLevel();
-  if (0 === (fiber & 4)) return 99 === priorityLevel ? 1073741823 : 1073741822;
-  if ((executionContext & RenderContext) !== NoContext)
-    return renderExpirationTime$1;
-  if (null !== suspenseConfig)
-    currentTime =
-      1073741821 -
-      25 *
-        ((((1073741821 -
-          currentTime +
-          (suspenseConfig.timeoutMs | 0 || 5e3) / 10) /
-          25) |
-          0) +
-          1);
-  else
-    switch (priorityLevel) {
-      case 99:
-        currentTime = 1073741823;
-        break;
-      case 98:
-        currentTime =
-          1073741821 - 10 * ((((1073741821 - currentTime + 15) / 10) | 0) + 1);
-        break;
-      case 97:
-      case 96:
-        currentTime =
-          1073741821 - 25 * ((((1073741821 - currentTime + 500) / 25) | 0) + 1);
-        break;
-      case 95:
-        currentTime = 2;
-        break;
-      default:
-        throw Error("Expected a valid priority level");
-    }
-  null !== workInProgressRoot &&
-    currentTime === renderExpirationTime$1 &&
-    --currentTime;
-  return currentTime;
-}
-function scheduleWork(fiber, expirationTime) {
+  if (0 === (fiber & 2)) return 1;
+  if (0 === (fiber & 4)) return 99 === getCurrentPriorityLevel() ? 1 : 2;
+  0 === currentEventWipLanes &&
+    (currentEventWipLanes = workInProgressRootIncludedLanes);
+  if (null !== suspenseConfig) {
+    suspenseConfig = suspenseConfig.timeoutMs;
+    fiber = void 0 === suspenseConfig || 1e4 > (suspenseConfig | 0) ? 8 : 6;
+    0 !== currentEventPendingLanes &&
+      (currentEventPendingLanes =
+        null !== mostRecentlyUpdatedRoot
+          ? mostRecentlyUpdatedRoot.pendingLanes
+          : 0);
+    suspenseConfig = currentEventWipLanes;
+    var pendingLanes = currentEventPendingLanes;
+    if (8 === fiber)
+      (fiber = pickArbitraryLane(122880 & ~pendingLanes)),
+        0 === fiber &&
+          ((fiber = pickArbitraryLane(122880 & ~suspenseConfig)),
+          0 === fiber && (fiber = 8192)),
+        (suspenseConfig = fiber);
+    else if (6 === fiber)
+      (fiber = pickArbitraryLane(3932160 & ~pendingLanes)),
+        0 === fiber &&
+          ((fiber = pickArbitraryLane(3932160 & ~suspenseConfig)),
+          0 === fiber && (fiber = 262144)),
+        (suspenseConfig = fiber);
+    else
+      throw Error(
+        "Invalid transition priority: " + fiber + ". This is a bug in React."
+      );
+    return suspenseConfig;
+  }
+  suspenseConfig = getCurrentPriorityLevel();
+  0 !== (executionContext & 4) && 98 === suspenseConfig
+    ? (suspenseConfig = findUpdateLane(14, currentEventWipLanes))
+    : ((suspenseConfig = schedulerPriorityToLanePriority(suspenseConfig)),
+      (suspenseConfig = findUpdateLane(suspenseConfig, currentEventWipLanes)));
+  return suspenseConfig;
+}
+function scheduleUpdateOnFiber(fiber, lane, eventTime) {
   if (50 < nestedUpdateCount)
     throw ((nestedUpdateCount = 0),
-    (rootWithNestedUpdates = null),
-    Error(
-      "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
-    ));
-  fiber = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
-  if (null !== fiber) {
-    var priorityLevel = getCurrentPriorityLevel();
-    1073741823 === expirationTime
-      ? (executionContext & LegacyUnbatchedContext) !== NoContext &&
-        (executionContext & (RenderContext | CommitContext)) === NoContext
-        ? performSyncWorkOnRoot(fiber)
-        : (ensureRootIsScheduled(fiber),
-          executionContext === NoContext && flushSyncCallbackQueue())
-      : ensureRootIsScheduled(fiber);
-    (executionContext & 4) === NoContext ||
-      (98 !== priorityLevel && 99 !== priorityLevel) ||
-      (null === rootsWithPendingDiscreteUpdates
-        ? (rootsWithPendingDiscreteUpdates = new Map([[fiber, expirationTime]]))
-        : ((priorityLevel = rootsWithPendingDiscreteUpdates.get(fiber)),
-          (void 0 === priorityLevel || priorityLevel > expirationTime) &&
-            rootsWithPendingDiscreteUpdates.set(fiber, expirationTime)));
-  }
-}
-function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
-  fiber.expirationTime < expirationTime &&
-    (fiber.expirationTime = expirationTime);
-  var alternate = fiber.alternate;
-  null !== alternate &&
-    alternate.expirationTime < expirationTime &&
-    (alternate.expirationTime = expirationTime);
-  var node = fiber.return,
-    root = null;
-  if (null === node && 3 === fiber.tag) root = fiber.stateNode;
-  else
-    for (; null !== node; ) {
-      alternate = node.alternate;
-      node.childExpirationTime < expirationTime &&
-        (node.childExpirationTime = expirationTime);
-      null !== alternate &&
-        alternate.childExpirationTime < expirationTime &&
-        (alternate.childExpirationTime = expirationTime);
-      if (null === node.return && 3 === node.tag) {
-        root = node.stateNode;
-        break;
+    (rootWithNestedUpdates = null),
+    Error(
+      "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
+    ));
+  fiber = markUpdateLaneFromFiberToRoot(fiber, lane);
+  if (null === fiber) return null;
+  markRootUpdated(fiber, lane, eventTime);
+  fiber === workInProgressRoot &&
+    ((workInProgressRootUpdatedLanes |= lane),
+    4 === workInProgressRootExitStatus &&
+      markRootSuspended$1(fiber, workInProgressRootRenderLanes));
+  var priorityLevel = getCurrentPriorityLevel();
+  1 === lane
+    ? 0 !== (executionContext & 8) && 0 === (executionContext & 48)
+      ? performSyncWorkOnRoot(fiber)
+      : (ensureRootIsScheduled(fiber, eventTime),
+        0 === executionContext && flushSyncCallbackQueue())
+    : (0 === (executionContext & 4) ||
+        (98 !== priorityLevel && 99 !== priorityLevel) ||
+        (null === rootsWithPendingDiscreteUpdates
+          ? (rootsWithPendingDiscreteUpdates = new Set([fiber]))
+          : rootsWithPendingDiscreteUpdates.add(fiber)),
+      ensureRootIsScheduled(fiber, eventTime));
+  mostRecentlyUpdatedRoot = fiber;
+}
+function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
+  sourceFiber.lanes |= lane;
+  var alternate = sourceFiber.alternate;
+  null !== alternate && (alternate.lanes |= lane);
+  alternate = sourceFiber;
+  for (sourceFiber = sourceFiber.return; null !== sourceFiber; )
+    (sourceFiber.childLanes |= lane),
+      (alternate = sourceFiber.alternate),
+      null !== alternate && (alternate.childLanes |= lane),
+      (alternate = sourceFiber),
+      (sourceFiber = sourceFiber.return);
+  return 3 === alternate.tag ? alternate.stateNode : null;
+}
+function ensureRootIsScheduled(root, currentTime) {
+  for (
+    var existingCallbackNode = root.callbackNode,
+      suspendedLanes = root.suspendedLanes,
+      pingedLanes = root.pingedLanes,
+      expirationTimes = root.expirationTimes,
+      lanes = root.pendingLanes;
+    0 < lanes;
+
+  ) {
+    var index$7 = 31 - clz32(lanes),
+      lane = 1 << index$7,
+      expirationTime = expirationTimes[index$7];
+    if (-1 === expirationTime) {
+      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) {
+        expirationTime = currentTime;
+        getHighestPriorityLanes(lane);
+        var priority = return_highestLanePriority;
+        expirationTimes[index$7] =
+          12 <= priority
+            ? expirationTime + 1e3
+            : 6 <= priority
+            ? expirationTime + 5e3
+            : -1;
       }
-      node = node.return;
-    }
-  null !== root &&
-    (workInProgressRoot === root &&
-      (markUnprocessedUpdateTime(expirationTime),
-      workInProgressRootExitStatus === RootSuspendedWithDelay &&
-        markRootSuspendedAtTime(root, renderExpirationTime$1)),
-    markRootUpdatedAtTime(root, expirationTime));
-  return root;
-}
-function getNextRootExpirationTimeToWorkOn(root) {
-  var lastExpiredTime = root.lastExpiredTime;
-  if (0 !== lastExpiredTime) return lastExpiredTime;
-  lastExpiredTime = root.firstPendingTime;
-  if (!isRootSuspendedAtTime(root, lastExpiredTime)) return lastExpiredTime;
-  var lastPingedTime = root.lastPingedTime;
-  root = root.nextKnownPendingLevel;
-  root = lastPingedTime > root ? lastPingedTime : root;
-  return 2 >= root && lastExpiredTime !== root ? 0 : root;
-}
-function ensureRootIsScheduled(root) {
-  if (0 !== root.lastExpiredTime)
-    (root.callbackExpirationTime = 1073741823),
-      (root.callbackPriority = 99),
-      (root.callbackNode = scheduleSyncCallback(
-        performSyncWorkOnRoot.bind(null, root)
-      ));
+    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
+    lanes &= ~lane;
+  }
+  suspendedLanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
+  );
+  currentTime = return_highestLanePriority;
+  if (0 === suspendedLanes)
+    null !== existingCallbackNode &&
+      (existingCallbackNode !== fakeCallbackNode &&
+        Scheduler_cancelCallback(existingCallbackNode),
+      (root.callbackNode = null),
+      (root.callbackPriority = 0));
   else {
-    var expirationTime = getNextRootExpirationTimeToWorkOn(root),
-      existingCallbackNode = root.callbackNode;
-    if (0 === expirationTime)
-      null !== existingCallbackNode &&
-        ((root.callbackNode = null),
-        (root.callbackExpirationTime = 0),
-        (root.callbackPriority = 90));
-    else {
-      var priorityLevel = requestCurrentTimeForUpdate();
-      1073741823 === expirationTime
-        ? (priorityLevel = 99)
-        : 1 === expirationTime || 2 === expirationTime
-        ? (priorityLevel = 95)
-        : ((priorityLevel =
-            10 * (1073741821 - expirationTime) -
-            10 * (1073741821 - priorityLevel)),
-          (priorityLevel =
-            0 >= priorityLevel
-              ? 99
-              : 250 >= priorityLevel
-              ? 98
-              : 5250 >= priorityLevel
-              ? 97
-              : 95));
-      if (null !== existingCallbackNode) {
-        var existingCallbackPriority = root.callbackPriority;
-        if (
-          root.callbackExpirationTime === expirationTime &&
-          existingCallbackPriority >= priorityLevel
-        )
-          return;
-        existingCallbackNode !== fakeCallbackNode &&
-          Scheduler_cancelCallback(existingCallbackNode);
-      }
-      root.callbackExpirationTime = expirationTime;
-      root.callbackPriority = priorityLevel;
-      expirationTime =
-        1073741823 === expirationTime
-          ? scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root))
-          : scheduleCallback(
-              priorityLevel,
-              performConcurrentWorkOnRoot.bind(null, root),
-              { timeout: 10 * (1073741821 - expirationTime) - now() }
-            );
-      root.callbackNode = expirationTime;
+    if (null !== existingCallbackNode) {
+      if (root.callbackPriority === currentTime) return;
+      existingCallbackNode !== fakeCallbackNode &&
+        Scheduler_cancelCallback(existingCallbackNode);
     }
+    17 === currentTime
+      ? ((existingCallbackNode = performSyncWorkOnRoot.bind(null, root)),
+        null === syncQueue
+          ? ((syncQueue = [existingCallbackNode]),
+            (immediateQueueCallbackNode = Scheduler_scheduleCallback(
+              Scheduler_ImmediatePriority,
+              flushSyncCallbackQueueImpl
+            )))
+          : syncQueue.push(existingCallbackNode),
+        (existingCallbackNode = fakeCallbackNode))
+      : 16 === currentTime
+      ? (existingCallbackNode = scheduleCallback(
+          99,
+          performSyncWorkOnRoot.bind(null, root)
+        ))
+      : ((existingCallbackNode = lanePriorityToSchedulerPriority(currentTime)),
+        (existingCallbackNode = scheduleCallback(
+          existingCallbackNode,
+          performConcurrentWorkOnRoot.bind(null, root)
+        )));
+    root.callbackPriority = currentTime;
+    root.callbackNode = existingCallbackNode;
   }
 }
 function performConcurrentWorkOnRoot(root, didTimeout) {
-  currentEventTime = 0;
-  if (didTimeout) {
-    didTimeout = requestCurrentTimeForUpdate();
-    var lastExpiredTime = root.lastExpiredTime;
-    if (0 === lastExpiredTime || lastExpiredTime > didTimeout)
-      root.lastExpiredTime = didTimeout;
-    ensureRootIsScheduled(root);
-    return null;
-  }
-  lastExpiredTime = getNextRootExpirationTimeToWorkOn(root);
-  if (0 === lastExpiredTime) return null;
-  didTimeout = root.callbackNode;
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+  currentEventTime = -1;
+  currentEventPendingLanes = currentEventWipLanes = 0;
+  if (0 !== (executionContext & 48))
     throw Error("Should not already be working.");
-  flushPassiveEffects();
-  var expirationTime = lastExpiredTime;
-  var exitStatus = executionContext;
-  executionContext |= RenderContext;
+  var originalCallbackNode = root.callbackNode;
+  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
+    return null;
+  var lanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
+  );
+  if (0 === lanes) return null;
+  if (didTimeout)
+    return (
+      (root.expiredLanes |= lanes & root.pendingLanes),
+      ensureRootIsScheduled(root, now()),
+      null
+    );
+  didTimeout = lanes;
+  var prevExecutionContext = executionContext;
+  executionContext |= 16;
   var prevDispatcher = pushDispatcher();
-  (root === workInProgressRoot && expirationTime === renderExpirationTime$1) ||
-    prepareFreshStack(root, expirationTime);
+  (workInProgressRoot === root &&
+    workInProgressRootRenderLanes === didTimeout) ||
+    prepareFreshStack(root, didTimeout);
   do
     try {
       workLoopConcurrent();
@@ -5801,156 +6165,120 @@ function performConcurrentWorkOnRoot(root, didTimeout) {
     }
   while (1);
   resetContextDependencies();
-  ReactCurrentDispatcher$1.current = prevDispatcher;
-  executionContext = exitStatus;
+  ReactCurrentDispatcher$2.current = prevDispatcher;
+  executionContext = prevExecutionContext;
   null !== workInProgress
-    ? (exitStatus = RootIncomplete)
+    ? (didTimeout = 0)
     : ((workInProgressRoot = null),
-      (exitStatus = workInProgressRootExitStatus));
-  if (exitStatus !== RootIncomplete) {
-    exitStatus === RootErrored &&
-      ((lastExpiredTime = 2 < lastExpiredTime ? 2 : lastExpiredTime),
-      (exitStatus = renderRootSync(root, lastExpiredTime)));
-    if (exitStatus === RootFatalErrored)
-      throw ((didTimeout = workInProgressRootFatalError),
-      prepareFreshStack(root, lastExpiredTime),
-      markRootSuspendedAtTime(root, lastExpiredTime),
-      ensureRootIsScheduled(root),
-      didTimeout);
-    expirationTime = root.finishedWork = root.current.alternate;
-    root.finishedExpirationTime = lastExpiredTime;
-    switch (exitStatus) {
-      case RootIncomplete:
-      case RootFatalErrored:
+      (workInProgressRootRenderLanes = 0),
+      (didTimeout = workInProgressRootExitStatus));
+  if (0 !== (workInProgressRootIncludedLanes & workInProgressRootUpdatedLanes))
+    prepareFreshStack(root, 0);
+  else if (0 !== didTimeout) {
+    2 === didTimeout &&
+      ((executionContext |= 64),
+      root.hydrate && (root.hydrate = !1),
+      (lanes = getLanesToRetrySynchronouslyOnError(root)),
+      0 !== lanes && (didTimeout = renderRootSync(root, lanes)));
+    if (1 === didTimeout)
+      throw ((originalCallbackNode = workInProgressRootFatalError),
+      prepareFreshStack(root, 0),
+      markRootSuspended$1(root, lanes),
+      ensureRootIsScheduled(root, now()),
+      originalCallbackNode);
+    root.finishedWork = root.current.alternate;
+    root.finishedLanes = lanes;
+    switch (didTimeout) {
+      case 0:
+      case 1:
         throw Error("Root did not complete. This is a bug in React.");
-      case RootErrored:
+      case 2:
         commitRoot(root);
         break;
-      case RootSuspended:
-        markRootSuspendedAtTime(root, lastExpiredTime);
-        exitStatus = root.lastSuspendedTime;
-        lastExpiredTime === exitStatus &&
-          (root.nextKnownPendingLevel = getRemainingExpirationTime(
-            expirationTime
-          ));
+      case 3:
+        markRootSuspended$1(root, lanes);
         if (
-          1073741823 === workInProgressRootLatestProcessedExpirationTime &&
-          ((expirationTime =
-            globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now()),
-          10 < expirationTime)
+          (lanes & 62914560) === lanes &&
+          ((didTimeout = globalMostRecentFallbackTime + 500 - now()),
+          10 < didTimeout)
         ) {
-          if (
-            workInProgressRootHasPendingPing &&
-            ((prevDispatcher = root.lastPingedTime),
-            0 === prevDispatcher || prevDispatcher >= lastExpiredTime)
-          ) {
-            root.lastPingedTime = lastExpiredTime;
-            prepareFreshStack(root, lastExpiredTime);
-            break;
-          }
-          prevDispatcher = getNextRootExpirationTimeToWorkOn(root);
-          if (0 !== prevDispatcher && prevDispatcher !== lastExpiredTime) break;
-          if (0 !== exitStatus && exitStatus !== lastExpiredTime) {
-            root.lastPingedTime = exitStatus;
+          if (0 !== getNextLanes(root, 0)) break;
+          prevExecutionContext = root.suspendedLanes;
+          if ((prevExecutionContext & lanes) !== lanes) {
+            requestEventTime();
+            root.pingedLanes |= root.suspendedLanes & prevExecutionContext;
             break;
           }
           root.timeoutHandle = scheduleTimeout(
             commitRoot.bind(null, root),
-            expirationTime
+            didTimeout
           );
           break;
         }
         commitRoot(root);
         break;
-      case RootSuspendedWithDelay:
-        markRootSuspendedAtTime(root, lastExpiredTime);
-        exitStatus = root.lastSuspendedTime;
-        lastExpiredTime === exitStatus &&
-          (root.nextKnownPendingLevel = getRemainingExpirationTime(
-            expirationTime
-          ));
-        if (
-          workInProgressRootHasPendingPing &&
-          ((expirationTime = root.lastPingedTime),
-          0 === expirationTime || expirationTime >= lastExpiredTime)
-        ) {
-          root.lastPingedTime = lastExpiredTime;
-          prepareFreshStack(root, lastExpiredTime);
-          break;
-        }
-        expirationTime = getNextRootExpirationTimeToWorkOn(root);
-        if (0 !== expirationTime && expirationTime !== lastExpiredTime) break;
-        if (0 !== exitStatus && exitStatus !== lastExpiredTime) {
-          root.lastPingedTime = exitStatus;
+      case 4:
+        markRootSuspended$1(root, lanes);
+        if (0 !== getNextLanes(root, 0)) break;
+        didTimeout = root.suspendedLanes;
+        if ((didTimeout & lanes) !== lanes) {
+          requestEventTime();
+          root.pingedLanes |= root.suspendedLanes & didTimeout;
           break;
         }
-        1073741823 !== workInProgressRootLatestSuspenseTimeout
-          ? (expirationTime =
-              10 * (1073741821 - workInProgressRootLatestSuspenseTimeout) -
-              now())
-          : 1073741823 === workInProgressRootLatestProcessedExpirationTime
-          ? (expirationTime = 0)
-          : ((expirationTime =
-              10 *
-                (1073741821 - workInProgressRootLatestProcessedExpirationTime) -
-              5e3),
-            (exitStatus = now()),
-            (lastExpiredTime =
-              10 * (1073741821 - lastExpiredTime) - exitStatus),
-            (expirationTime = exitStatus - expirationTime),
-            0 > expirationTime && (expirationTime = 0),
-            (expirationTime =
-              (120 > expirationTime
+        lanes = getMostRecentEventTime(root, lanes);
+        -1 !== workInProgressRootLatestSuspenseTimeout
+          ? (lanes = workInProgressRootLatestSuspenseTimeout - now())
+          : -1 === lanes
+          ? (lanes = 0)
+          : ((lanes = now() - lanes),
+            (lanes =
+              (120 > lanes
                 ? 120
-                : 480 > expirationTime
+                : 480 > lanes
                 ? 480
-                : 1080 > expirationTime
+                : 1080 > lanes
                 ? 1080
-                : 1920 > expirationTime
+                : 1920 > lanes
                 ? 1920
-                : 3e3 > expirationTime
+                : 3e3 > lanes
                 ? 3e3
-                : 4320 > expirationTime
+                : 4320 > lanes
                 ? 4320
-                : 1960 * ceil(expirationTime / 1960)) - expirationTime),
-            lastExpiredTime < expirationTime &&
-              (expirationTime = lastExpiredTime));
-        if (10 < expirationTime) {
+                : 1960 * ceil(lanes / 1960)) - lanes));
+        if (10 < lanes) {
           root.timeoutHandle = scheduleTimeout(
             commitRoot.bind(null, root),
-            expirationTime
+            lanes
           );
           break;
         }
         commitRoot(root);
         break;
-      case RootCompleted:
+      case 5:
+        prevDispatcher = getMostRecentEventTime(root, lanes);
         if (
-          1073741823 !== workInProgressRootLatestProcessedExpirationTime &&
-          null !== workInProgressRootCanSuspendUsingConfig
-        ) {
-          prevDispatcher = workInProgressRootLatestProcessedExpirationTime;
-          var suspenseConfig = workInProgressRootCanSuspendUsingConfig;
-          expirationTime = suspenseConfig.busyMinDurationMs | 0;
-          0 >= expirationTime
-            ? (expirationTime = 0)
-            : ((exitStatus = suspenseConfig.busyDelayMs | 0),
-              (prevDispatcher =
-                now() -
-                (10 * (1073741821 - prevDispatcher) -
-                  (suspenseConfig.timeoutMs | 0 || 5e3))),
-              (expirationTime =
-                prevDispatcher <= exitStatus
+          -1 !== prevDispatcher &&
+          null !== workInProgressRootCanSuspendUsingConfig &&
+          ((didTimeout =
+            workInProgressRootCanSuspendUsingConfig.busyMinDurationMs | 0),
+          0 >= didTimeout
+            ? (didTimeout = 0)
+            : ((prevExecutionContext =
+                workInProgressRootCanSuspendUsingConfig.busyDelayMs | 0),
+              (prevDispatcher = now() - prevDispatcher),
+              (didTimeout =
+                prevDispatcher <= prevExecutionContext
                   ? 0
-                  : exitStatus + expirationTime - prevDispatcher));
-          if (10 < expirationTime) {
-            markRootSuspendedAtTime(root, lastExpiredTime);
-            root.timeoutHandle = scheduleTimeout(
-              commitRoot.bind(null, root),
-              expirationTime
-            );
-            break;
-          }
+                  : prevExecutionContext + didTimeout - prevDispatcher)),
+          10 < didTimeout)
+        ) {
+          markRootSuspended$1(root, lanes);
+          root.timeoutHandle = scheduleTimeout(
+            commitRoot.bind(null, root),
+            didTimeout
+          );
+          break;
         }
         commitRoot(root);
         break;
@@ -5958,42 +6286,68 @@ function performConcurrentWorkOnRoot(root, didTimeout) {
         throw Error("Unknown root exit status.");
     }
   }
-  ensureRootIsScheduled(root);
-  return root.callbackNode === didTimeout
+  ensureRootIsScheduled(root, now());
+  return root.callbackNode === originalCallbackNode
     ? performConcurrentWorkOnRoot.bind(null, root)
     : null;
 }
+function markRootSuspended$1(root, suspendedLanes) {
+  suspendedLanes &= ~workInProgressRootPingedLanes;
+  suspendedLanes &= ~workInProgressRootUpdatedLanes;
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+  for (root = root.expirationTimes; 0 < suspendedLanes; ) {
+    var index$12 = 31 - clz32(suspendedLanes),
+      lane = 1 << index$12;
+    root[index$12] = -1;
+    suspendedLanes &= ~lane;
+  }
+}
 function performSyncWorkOnRoot(root) {
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+  if (0 !== (executionContext & 48))
     throw Error("Should not already be working.");
   flushPassiveEffects();
-  var lastExpiredTime = root.lastExpiredTime;
-  lastExpiredTime =
-    0 !== lastExpiredTime
-      ? root === workInProgressRoot && renderExpirationTime$1 >= lastExpiredTime
-        ? renderExpirationTime$1
-        : lastExpiredTime
-      : 1073741823;
-  var exitStatus = renderRootSync(root, lastExpiredTime);
+  if (
+    root === workInProgressRoot &&
+    0 !== (root.expiredLanes & workInProgressRootRenderLanes)
+  ) {
+    var lanes = workInProgressRootRenderLanes;
+    var exitStatus = renderRootSync(root, lanes);
+    0 !== (workInProgressRootIncludedLanes & workInProgressRootUpdatedLanes) &&
+      ((lanes = getNextLanes(root, lanes)),
+      (exitStatus = renderRootSync(root, lanes)));
+  } else
+    (lanes = getNextLanes(root, 0)), (exitStatus = renderRootSync(root, lanes));
   0 !== root.tag &&
-    exitStatus === RootErrored &&
-    ((lastExpiredTime = 2 < lastExpiredTime ? 2 : lastExpiredTime),
-    (exitStatus = renderRootSync(root, lastExpiredTime)));
-  if (exitStatus === RootFatalErrored)
+    2 === exitStatus &&
+    ((executionContext |= 64),
+    root.hydrate && (root.hydrate = !1),
+    (lanes = getLanesToRetrySynchronouslyOnError(root)),
+    0 !== lanes && (exitStatus = renderRootSync(root, lanes)));
+  if (1 === exitStatus)
     throw ((exitStatus = workInProgressRootFatalError),
-    prepareFreshStack(root, lastExpiredTime),
-    markRootSuspendedAtTime(root, lastExpiredTime),
-    ensureRootIsScheduled(root),
+    prepareFreshStack(root, 0),
+    markRootSuspended$1(root, lanes),
+    ensureRootIsScheduled(root, now()),
     exitStatus);
   root.finishedWork = root.current.alternate;
-  root.finishedExpirationTime = lastExpiredTime;
+  root.finishedLanes = lanes;
   commitRoot(root);
-  ensureRootIsScheduled(root);
+  ensureRootIsScheduled(root, now());
   return null;
 }
-function prepareFreshStack(root, expirationTime) {
+function pushRenderLanes(fiber, lanes) {
+  push(subtreeRenderLanesCursor, subtreeRenderLanes);
+  subtreeRenderLanes |= lanes;
+  workInProgressRootIncludedLanes |= lanes;
+}
+function popRenderLanes() {
+  subtreeRenderLanes = subtreeRenderLanesCursor.current;
+  pop(subtreeRenderLanesCursor);
+}
+function prepareFreshStack(root, lanes) {
   root.finishedWork = null;
-  root.finishedExpirationTime = 0;
+  root.finishedLanes = 0;
   var timeoutHandle = root.timeoutHandle;
   -1 !== timeoutHandle &&
     ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
@@ -6011,6 +6365,7 @@ function prepareFreshStack(root, expirationTime) {
           popHostContainer();
           pop(didPerformWorkStackCursor);
           pop(contextStackCursor);
+          resetWorkInProgressVersions();
           break;
         case 5:
           popHostContext(interruptedWork);
@@ -6026,25 +6381,29 @@ function prepareFreshStack(root, expirationTime) {
           break;
         case 10:
           popProvider(interruptedWork);
+          break;
+        case 23:
+        case 24:
+          popRenderLanes();
       }
       timeoutHandle = timeoutHandle.return;
     }
   workInProgressRoot = root;
   workInProgress = createWorkInProgress(root.current, null);
-  renderExpirationTime$1 = expirationTime;
-  workInProgressRootExitStatus = RootIncomplete;
+  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
+  workInProgressRootExitStatus = 0;
   workInProgressRootFatalError = null;
-  workInProgressRootLatestSuspenseTimeout = workInProgressRootLatestProcessedExpirationTime = 1073741823;
+  workInProgressRootLatestSuspenseTimeout = -1;
   workInProgressRootCanSuspendUsingConfig = null;
-  workInProgressRootNextUnprocessedUpdateTime = 0;
-  workInProgressRootHasPendingPing = !1;
+  workInProgressRootPingedLanes = workInProgressRootUpdatedLanes = workInProgressRootSkippedLanes = 0;
 }
 function handleError(root$jscomp$0, thrownValue) {
   do {
+    var erroredWork = workInProgress;
     try {
       resetContextDependencies();
-      ReactCurrentDispatcher.current = ContextOnlyDispatcher;
-      if (didScheduleRenderPhaseUpdate)
+      ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+      if (didScheduleRenderPhaseUpdate) {
         for (
           var hook = currentlyRenderingFiber$1.memoizedState;
           null !== hook;
@@ -6054,21 +6413,24 @@ function handleError(root$jscomp$0, thrownValue) {
           null !== queue && (queue.pending = null);
           hook = hook.next;
         }
-      renderExpirationTime = 0;
+        didScheduleRenderPhaseUpdate = !1;
+      }
+      renderLanes = 0;
       workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
-      didScheduleRenderPhaseUpdate = !1;
-      if (null === workInProgress || null === workInProgress.return)
-        return (
-          (workInProgressRootExitStatus = RootFatalErrored),
-          (workInProgressRootFatalError = thrownValue),
-          (workInProgress = null)
-        );
+      didScheduleRenderPhaseUpdateDuringThisPass = !1;
+      ReactCurrentOwner$2.current = null;
+      if (null === erroredWork || null === erroredWork.return) {
+        workInProgressRootExitStatus = 1;
+        workInProgressRootFatalError = thrownValue;
+        workInProgress = null;
+        break;
+      }
       a: {
         var root = root$jscomp$0,
-          returnFiber = workInProgress.return,
-          sourceFiber = workInProgress,
+          returnFiber = erroredWork.return,
+          sourceFiber = erroredWork,
           value = thrownValue;
-        thrownValue = renderExpirationTime$1;
+        thrownValue = workInProgressRootRenderLanes;
         sourceFiber.effectTag |= 2048;
         sourceFiber.firstEffect = sourceFiber.lastEffect = null;
         if (
@@ -6076,27 +6438,27 @@ function handleError(root$jscomp$0, thrownValue) {
           "object" === typeof value &&
           "function" === typeof value.then
         ) {
-          var thenable = value;
+          var wakeable = value;
           if (0 === (sourceFiber.mode & 2)) {
             var currentSource = sourceFiber.alternate;
             currentSource
               ? ((sourceFiber.updateQueue = currentSource.updateQueue),
                 (sourceFiber.memoizedState = currentSource.memoizedState),
-                (sourceFiber.expirationTime = currentSource.expirationTime))
+                (sourceFiber.lanes = currentSource.lanes))
               : ((sourceFiber.updateQueue = null),
                 (sourceFiber.memoizedState = null));
           }
           var hasInvisibleParentBoundary =
               0 !== (suspenseStackCursor.current & 1),
-            _workInProgress = returnFiber;
+            workInProgress$76 = returnFiber;
           do {
             var JSCompiler_temp;
-            if ((JSCompiler_temp = 13 === _workInProgress.tag)) {
-              var nextState = _workInProgress.memoizedState;
+            if ((JSCompiler_temp = 13 === workInProgress$76.tag)) {
+              var nextState = workInProgress$76.memoizedState;
               if (null !== nextState)
                 JSCompiler_temp = null !== nextState.dehydrated ? !0 : !1;
               else {
-                var props = _workInProgress.memoizedProps;
+                var props = workInProgress$76.memoizedProps;
                 JSCompiler_temp =
                   void 0 === props.fallback
                     ? !1
@@ -6108,23 +6470,24 @@ function handleError(root$jscomp$0, thrownValue) {
               }
             }
             if (JSCompiler_temp) {
-              var thenables = _workInProgress.updateQueue;
-              if (null === thenables) {
+              var wakeables = workInProgress$76.updateQueue;
+              if (null === wakeables) {
                 var updateQueue = new Set();
-                updateQueue.add(thenable);
-                _workInProgress.updateQueue = updateQueue;
-              } else thenables.add(thenable);
-              if (0 === (_workInProgress.mode & 2)) {
-                _workInProgress.effectTag |= 64;
+                updateQueue.add(wakeable);
+                workInProgress$76.updateQueue = updateQueue;
+              } else wakeables.add(wakeable);
+              if (0 === (workInProgress$76.mode & 2)) {
+                workInProgress$76.effectTag |= 64;
+                sourceFiber.effectTag |= 16384;
                 sourceFiber.effectTag &= -2981;
                 if (1 === sourceFiber.tag)
                   if (null === sourceFiber.alternate) sourceFiber.tag = 17;
                   else {
-                    var update = createUpdate(1073741823, null);
+                    var update = createUpdate(-1, 1, null);
                     update.tag = 2;
                     enqueueUpdate(sourceFiber, update);
                   }
-                sourceFiber.expirationTime = 1073741823;
+                sourceFiber.lanes |= 1;
                 break a;
               }
               value = void 0;
@@ -6133,108 +6496,105 @@ function handleError(root$jscomp$0, thrownValue) {
               null === pingCache
                 ? ((pingCache = root.pingCache = new PossiblyWeakMap()),
                   (value = new Set()),
-                  pingCache.set(thenable, value))
-                : ((value = pingCache.get(thenable)),
+                  pingCache.set(wakeable, value))
+                : ((value = pingCache.get(wakeable)),
                   void 0 === value &&
-                    ((value = new Set()), pingCache.set(thenable, value)));
+                    ((value = new Set()), pingCache.set(wakeable, value)));
               if (!value.has(sourceFiber)) {
                 value.add(sourceFiber);
                 var ping = pingSuspendedRoot.bind(
                   null,
                   root,
-                  thenable,
+                  wakeable,
                   sourceFiber
                 );
-                thenable.then(ping, ping);
+                wakeable.then(ping, ping);
               }
-              _workInProgress.effectTag |= 4096;
-              _workInProgress.expirationTime = thrownValue;
+              workInProgress$76.effectTag |= 4096;
+              workInProgress$76.lanes = thrownValue;
               break a;
             }
-            _workInProgress = _workInProgress.return;
-          } while (null !== _workInProgress);
+            workInProgress$76 = workInProgress$76.return;
+          } while (null !== workInProgress$76);
           value = Error(
             (getComponentName(sourceFiber.type) || "A React component") +
-              " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." +
-              getStackByFiberInDevAndProd(sourceFiber)
+              " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."
           );
         }
-        workInProgressRootExitStatus !== RootCompleted &&
-          (workInProgressRootExitStatus = RootErrored);
+        5 !== workInProgressRootExitStatus &&
+          (workInProgressRootExitStatus = 2);
         value = createCapturedValue(value, sourceFiber);
-        _workInProgress = returnFiber;
+        workInProgress$76 = returnFiber;
         do {
-          switch (_workInProgress.tag) {
+          switch (workInProgress$76.tag) {
             case 3:
-              thenable = value;
-              _workInProgress.effectTag |= 4096;
-              _workInProgress.expirationTime = thrownValue;
-              var _update = createRootErrorUpdate(
-                _workInProgress,
-                thenable,
+              root = value;
+              workInProgress$76.effectTag |= 4096;
+              thrownValue &= -thrownValue;
+              workInProgress$76.lanes |= thrownValue;
+              var update$77 = createRootErrorUpdate(
+                workInProgress$76,
+                root,
                 thrownValue
               );
-              enqueueCapturedUpdate(_workInProgress, _update);
+              enqueueCapturedUpdate(workInProgress$76, update$77);
               break a;
             case 1:
-              thenable = value;
-              var ctor = _workInProgress.type,
-                instance = _workInProgress.stateNode;
+              root = value;
+              var ctor = workInProgress$76.type,
+                instance = workInProgress$76.stateNode;
               if (
-                0 === (_workInProgress.effectTag & 64) &&
+                0 === (workInProgress$76.effectTag & 64) &&
                 ("function" === typeof ctor.getDerivedStateFromError ||
                   (null !== instance &&
                     "function" === typeof instance.componentDidCatch &&
                     (null === legacyErrorBoundariesThatAlreadyFailed ||
                       !legacyErrorBoundariesThatAlreadyFailed.has(instance))))
               ) {
-                _workInProgress.effectTag |= 4096;
-                _workInProgress.expirationTime = thrownValue;
-                var _update2 = createClassErrorUpdate(
-                  _workInProgress,
-                  thenable,
+                workInProgress$76.effectTag |= 4096;
+                thrownValue &= -thrownValue;
+                workInProgress$76.lanes |= thrownValue;
+                var update$80 = createClassErrorUpdate(
+                  workInProgress$76,
+                  root,
                   thrownValue
                 );
-                enqueueCapturedUpdate(_workInProgress, _update2);
+                enqueueCapturedUpdate(workInProgress$76, update$80);
                 break a;
               }
           }
-          _workInProgress = _workInProgress.return;
-        } while (null !== _workInProgress);
+          workInProgress$76 = workInProgress$76.return;
+        } while (null !== workInProgress$76);
       }
-      workInProgress = completeUnitOfWork(workInProgress);
+      completeUnitOfWork(erroredWork);
     } catch (yetAnotherThrownValue) {
       thrownValue = yetAnotherThrownValue;
+      workInProgress === erroredWork &&
+        null !== erroredWork &&
+        (workInProgress = erroredWork = erroredWork.return);
       continue;
     }
     break;
   } while (1);
 }
 function pushDispatcher() {
-  var prevDispatcher = ReactCurrentDispatcher$1.current;
-  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+  var prevDispatcher = ReactCurrentDispatcher$2.current;
+  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
   return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
 }
-function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {
-  expirationTime < workInProgressRootLatestProcessedExpirationTime &&
-    2 < expirationTime &&
-    (workInProgressRootLatestProcessedExpirationTime = expirationTime);
+function markRenderEventTimeAndConfig(eventTime, suspenseConfig) {
   null !== suspenseConfig &&
-    expirationTime < workInProgressRootLatestSuspenseTimeout &&
-    2 < expirationTime &&
-    ((workInProgressRootLatestSuspenseTimeout = expirationTime),
-    (workInProgressRootCanSuspendUsingConfig = suspenseConfig));
-}
-function markUnprocessedUpdateTime(expirationTime) {
-  expirationTime > workInProgressRootNextUnprocessedUpdateTime &&
-    (workInProgressRootNextUnprocessedUpdateTime = expirationTime);
+    ((eventTime += suspenseConfig.timeoutMs | 0 || 5e3),
+    eventTime > workInProgressRootLatestSuspenseTimeout &&
+      ((workInProgressRootLatestSuspenseTimeout = eventTime),
+      (workInProgressRootCanSuspendUsingConfig = suspenseConfig)));
 }
-function renderRootSync(root, expirationTime) {
+function renderRootSync(root, lanes) {
   var prevExecutionContext = executionContext;
-  executionContext |= RenderContext;
+  executionContext |= 16;
   var prevDispatcher = pushDispatcher();
-  (root === workInProgressRoot && expirationTime === renderExpirationTime$1) ||
-    prepareFreshStack(root, expirationTime);
+  (workInProgressRoot === root && workInProgressRootRenderLanes === lanes) ||
+    prepareFreshStack(root, lanes);
   do
     try {
       workLoopSync();
@@ -6245,142 +6605,144 @@ function renderRootSync(root, expirationTime) {
   while (1);
   resetContextDependencies();
   executionContext = prevExecutionContext;
-  ReactCurrentDispatcher$1.current = prevDispatcher;
+  ReactCurrentDispatcher$2.current = prevDispatcher;
   if (null !== workInProgress)
     throw Error(
       "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
     );
   workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
   return workInProgressRootExitStatus;
 }
 function workLoopSync() {
-  for (; null !== workInProgress; )
-    workInProgress = performUnitOfWork(workInProgress);
+  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
 }
 function workLoopConcurrent() {
-  for (; null !== workInProgress && !shouldYield(); )
-    workInProgress = performUnitOfWork(workInProgress);
+  for (; null !== workInProgress && !Scheduler_shouldYield(); )
+    performUnitOfWork(workInProgress);
 }
 function performUnitOfWork(unitOfWork) {
-  var next = beginWork$1(
-    unitOfWork.alternate,
-    unitOfWork,
-    renderExpirationTime$1
-  );
+  var next = beginWork$1(unitOfWork.alternate, unitOfWork, subtreeRenderLanes);
   unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === next && (next = completeUnitOfWork(unitOfWork));
+  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
   ReactCurrentOwner$2.current = null;
-  return next;
 }
 function completeUnitOfWork(unitOfWork) {
-  workInProgress = unitOfWork;
+  var completedWork = unitOfWork;
   do {
-    var current = workInProgress.alternate;
-    unitOfWork = workInProgress.return;
-    if (0 === (workInProgress.effectTag & 2048)) {
-      current = completeWork(current, workInProgress, renderExpirationTime$1);
+    var current = completedWork.alternate;
+    unitOfWork = completedWork.return;
+    if (0 === (completedWork.effectTag & 2048)) {
+      current = completeWork(current, completedWork, subtreeRenderLanes);
+      if (null !== current) {
+        workInProgress = current;
+        return;
+      }
+      current = completedWork;
       if (
-        1 === renderExpirationTime$1 ||
-        1 !== workInProgress.childExpirationTime
+        (24 !== current.tag && 23 !== current.tag) ||
+        null === current.memoizedState ||
+        0 !== (subtreeRenderLanes & 1073741824) ||
+        0 === (current.mode & 4)
       ) {
-        for (
-          var newChildExpirationTime = 0, _child = workInProgress.child;
-          null !== _child;
-
-        ) {
-          var _childUpdateExpirationTime = _child.expirationTime,
-            _childChildExpirationTime = _child.childExpirationTime;
-          _childUpdateExpirationTime > newChildExpirationTime &&
-            (newChildExpirationTime = _childUpdateExpirationTime);
-          _childChildExpirationTime > newChildExpirationTime &&
-            (newChildExpirationTime = _childChildExpirationTime);
-          _child = _child.sibling;
-        }
-        workInProgress.childExpirationTime = newChildExpirationTime;
+        for (var newChildLanes = 0, child = current.child; null !== child; )
+          (newChildLanes |= child.lanes | child.childLanes),
+            (child = child.sibling);
+        current.childLanes = newChildLanes;
       }
-      if (null !== current) return current;
       null !== unitOfWork &&
         0 === (unitOfWork.effectTag & 2048) &&
         (null === unitOfWork.firstEffect &&
-          (unitOfWork.firstEffect = workInProgress.firstEffect),
-        null !== workInProgress.lastEffect &&
+          (unitOfWork.firstEffect = completedWork.firstEffect),
+        null !== completedWork.lastEffect &&
           (null !== unitOfWork.lastEffect &&
-            (unitOfWork.lastEffect.nextEffect = workInProgress.firstEffect),
-          (unitOfWork.lastEffect = workInProgress.lastEffect)),
-        1 < workInProgress.effectTag &&
+            (unitOfWork.lastEffect.nextEffect = completedWork.firstEffect),
+          (unitOfWork.lastEffect = completedWork.lastEffect)),
+        1 < completedWork.effectTag &&
           (null !== unitOfWork.lastEffect
-            ? (unitOfWork.lastEffect.nextEffect = workInProgress)
-            : (unitOfWork.firstEffect = workInProgress),
-          (unitOfWork.lastEffect = workInProgress)));
+            ? (unitOfWork.lastEffect.nextEffect = completedWork)
+            : (unitOfWork.firstEffect = completedWork),
+          (unitOfWork.lastEffect = completedWork)));
     } else {
-      current = unwindWork(workInProgress);
-      if (null !== current) return (current.effectTag &= 2047), current;
+      current = unwindWork(completedWork);
+      if (null !== current) {
+        current.effectTag &= 2047;
+        workInProgress = current;
+        return;
+      }
       null !== unitOfWork &&
         ((unitOfWork.firstEffect = unitOfWork.lastEffect = null),
         (unitOfWork.effectTag |= 2048));
     }
-    current = workInProgress.sibling;
-    if (null !== current) return current;
-    workInProgress = unitOfWork;
-  } while (null !== workInProgress);
-  workInProgressRootExitStatus === RootIncomplete &&
-    (workInProgressRootExitStatus = RootCompleted);
-  return null;
-}
-function getRemainingExpirationTime(fiber) {
-  var updateExpirationTime = fiber.expirationTime;
-  fiber = fiber.childExpirationTime;
-  return updateExpirationTime > fiber ? updateExpirationTime : fiber;
+    completedWork = completedWork.sibling;
+    if (null !== completedWork) {
+      workInProgress = completedWork;
+      return;
+    }
+    workInProgress = completedWork = unitOfWork;
+  } while (null !== completedWork);
+  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
 }
 function commitRoot(root) {
   var renderPriorityLevel = getCurrentPriorityLevel();
   runWithPriority(99, commitRootImpl.bind(null, root, renderPriorityLevel));
   return null;
 }
-function commitRootImpl(root$jscomp$0, renderPriorityLevel$jscomp$0) {
+function commitRootImpl(root, renderPriorityLevel) {
   do flushPassiveEffects();
   while (null !== rootWithPendingPassiveEffects);
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+  if (0 !== (executionContext & 48))
     throw Error("Should not already be working.");
-  var finishedWork = root$jscomp$0.finishedWork,
-    expirationTime = root$jscomp$0.finishedExpirationTime;
+  var finishedWork = root.finishedWork;
   if (null === finishedWork) return null;
-  root$jscomp$0.finishedWork = null;
-  root$jscomp$0.finishedExpirationTime = 0;
-  if (finishedWork === root$jscomp$0.current)
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  if (finishedWork === root.current)
     throw Error(
       "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
     );
-  root$jscomp$0.callbackNode = null;
-  root$jscomp$0.callbackExpirationTime = 0;
-  root$jscomp$0.callbackPriority = 90;
-  root$jscomp$0.nextKnownPendingLevel = 0;
-  var remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(
-    finishedWork
-  );
-  root$jscomp$0.firstPendingTime = remainingExpirationTimeBeforeCommit;
-  expirationTime <= root$jscomp$0.lastSuspendedTime
-    ? (root$jscomp$0.firstSuspendedTime = root$jscomp$0.lastSuspendedTime = root$jscomp$0.nextKnownPendingLevel = 0)
-    : expirationTime <= root$jscomp$0.firstSuspendedTime &&
-      (root$jscomp$0.firstSuspendedTime = expirationTime - 1);
-  expirationTime <= root$jscomp$0.lastPingedTime &&
-    (root$jscomp$0.lastPingedTime = 0);
-  expirationTime <= root$jscomp$0.lastExpiredTime &&
-    (root$jscomp$0.lastExpiredTime = 0);
-  root$jscomp$0 === workInProgressRoot &&
+  root.callbackNode = null;
+  var remainingLanes = finishedWork.lanes | finishedWork.childLanes,
+    remainingLanes$jscomp$0 = remainingLanes,
+    noLongerPendingLanes = root.pendingLanes & ~remainingLanes$jscomp$0;
+  root.pendingLanes = remainingLanes$jscomp$0;
+  root.suspendedLanes = 0;
+  root.pingedLanes = 0;
+  root.expiredLanes &= remainingLanes$jscomp$0;
+  root.mutableReadLanes &= remainingLanes$jscomp$0;
+  root.entangledLanes &= remainingLanes$jscomp$0;
+  remainingLanes$jscomp$0 = root.entanglements;
+  for (
+    var eventTimes = root.eventTimes, expirationTimes = root.expirationTimes;
+    0 < noLongerPendingLanes;
+
+  ) {
+    var index$13 = 31 - clz32(noLongerPendingLanes),
+      lane = 1 << index$13;
+    remainingLanes$jscomp$0[index$13] = 0;
+    eventTimes[index$13] = -1;
+    expirationTimes[index$13] = -1;
+    noLongerPendingLanes &= ~lane;
+  }
+  null !== rootsWithPendingDiscreteUpdates &&
+    0 === (remainingLanes & 24) &&
+    rootsWithPendingDiscreteUpdates.has(root) &&
+    rootsWithPendingDiscreteUpdates.delete(root);
+  root === workInProgressRoot &&
     ((workInProgress = workInProgressRoot = null),
-    (renderExpirationTime$1 = 0));
+    (workInProgressRootRenderLanes = 0));
   1 < finishedWork.effectTag
     ? null !== finishedWork.lastEffect
       ? ((finishedWork.lastEffect.nextEffect = finishedWork),
-        (remainingExpirationTimeBeforeCommit = finishedWork.firstEffect))
-      : (remainingExpirationTimeBeforeCommit = finishedWork)
-    : (remainingExpirationTimeBeforeCommit = finishedWork.firstEffect);
-  if (null !== remainingExpirationTimeBeforeCommit) {
-    var prevExecutionContext = executionContext;
-    executionContext |= CommitContext;
-    ReactCurrentOwner$2.current = null;
-    nextEffect = remainingExpirationTimeBeforeCommit;
+        (remainingLanes = finishedWork.firstEffect))
+      : (remainingLanes = finishedWork)
+    : (remainingLanes = finishedWork.firstEffect);
+  if (null !== remainingLanes) {
+    remainingLanes$jscomp$0 = executionContext;
+    executionContext |= 32;
+    focusedInstanceHandle = ReactCurrentOwner$2.current = null;
+    shouldFireAfterActiveInstanceBlur = !1;
+    nextEffect = remainingLanes;
     do
       try {
         commitBeforeMutationEffects();
@@ -6390,15 +6752,11 @@ function commitRootImpl(root$jscomp$0, renderPriorityLevel$jscomp$0) {
         nextEffect = nextEffect.nextEffect;
       }
     while (null !== nextEffect);
-    nextEffect = remainingExpirationTimeBeforeCommit;
+    focusedInstanceHandle = null;
+    nextEffect = remainingLanes;
     do
       try {
-        for (
-          var root = root$jscomp$0,
-            renderPriorityLevel = renderPriorityLevel$jscomp$0;
-          null !== nextEffect;
-
-        ) {
+        for (eventTimes = root; null !== nextEffect; ) {
           var effectTag = nextEffect.effectTag;
           if (effectTag & 128) {
             var current = nextEffect.alternate;
@@ -6431,27 +6789,25 @@ function commitRootImpl(root$jscomp$0, renderPriorityLevel$jscomp$0) {
               commitWork(nextEffect.alternate, nextEffect);
               break;
             case 8:
-              var current$jscomp$0 = nextEffect;
-              unmountHostComponents(
-                root,
-                current$jscomp$0,
-                renderPriorityLevel
-              );
-              detachFiber(current$jscomp$0);
+              expirationTimes = nextEffect;
+              unmountHostComponents(eventTimes, expirationTimes);
+              var alternate = expirationTimes.alternate;
+              detachFiberMutation(expirationTimes);
+              null !== alternate && detachFiberMutation(alternate);
           }
           nextEffect = nextEffect.nextEffect;
         }
-      } catch (error) {
+      } catch (error$93) {
         if (null === nextEffect) throw Error("Should be working on an effect.");
-        captureCommitPhaseError(nextEffect, error);
+        captureCommitPhaseError(nextEffect, error$93);
         nextEffect = nextEffect.nextEffect;
       }
     while (null !== nextEffect);
-    root$jscomp$0.current = finishedWork;
-    nextEffect = remainingExpirationTimeBeforeCommit;
+    root.current = finishedWork;
+    nextEffect = remainingLanes;
     do
       try {
-        for (effectTag = root$jscomp$0; null !== nextEffect; ) {
+        for (effectTag = root; null !== nextEffect; ) {
           var effectTag$jscomp$0 = nextEffect.effectTag;
           effectTag$jscomp$0 & 36 &&
             commitLifeCycles(effectTag, nextEffect.alternate, nextEffect);
@@ -6474,54 +6830,71 @@ function commitRootImpl(root$jscomp$0, renderPriorityLevel$jscomp$0) {
           }
           nextEffect = nextEffect.nextEffect;
         }
-      } catch (error) {
+      } catch (error$94) {
         if (null === nextEffect) throw Error("Should be working on an effect.");
-        captureCommitPhaseError(nextEffect, error);
+        captureCommitPhaseError(nextEffect, error$94);
         nextEffect = nextEffect.nextEffect;
       }
     while (null !== nextEffect);
     nextEffect = null;
     requestPaint();
-    executionContext = prevExecutionContext;
-  } else root$jscomp$0.current = finishedWork;
+    executionContext = remainingLanes$jscomp$0;
+  } else root.current = finishedWork;
   if (rootDoesHavePassiveEffects)
     (rootDoesHavePassiveEffects = !1),
-      (rootWithPendingPassiveEffects = root$jscomp$0),
-      (pendingPassiveEffectsRenderPriority = renderPriorityLevel$jscomp$0);
+      (rootWithPendingPassiveEffects = root),
+      (pendingPassiveEffectsRenderPriority = renderPriorityLevel);
   else
-    for (
-      nextEffect = remainingExpirationTimeBeforeCommit;
-      null !== nextEffect;
-
-    )
-      (renderPriorityLevel$jscomp$0 = nextEffect.nextEffect),
+    for (nextEffect = remainingLanes; null !== nextEffect; )
+      (renderPriorityLevel = nextEffect.nextEffect),
         (nextEffect.nextEffect = null),
-        (nextEffect = renderPriorityLevel$jscomp$0);
-  renderPriorityLevel$jscomp$0 = root$jscomp$0.firstPendingTime;
-  0 === renderPriorityLevel$jscomp$0 &&
-    (legacyErrorBoundariesThatAlreadyFailed = null);
-  1073741823 === renderPriorityLevel$jscomp$0
-    ? root$jscomp$0 === rootWithNestedUpdates
+        nextEffect.effectTag & 8 &&
+          ((effectTag$jscomp$0 = nextEffect),
+          (effectTag$jscomp$0.sibling = null),
+          (effectTag$jscomp$0.stateNode = null)),
+        (nextEffect = renderPriorityLevel);
+  remainingLanes = root.pendingLanes;
+  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
+  1 === remainingLanes
+    ? root === rootWithNestedUpdates
       ? nestedUpdateCount++
-      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root$jscomp$0))
+      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
     : (nestedUpdateCount = 0);
-  "function" === typeof onCommitFiberRoot &&
-    onCommitFiberRoot(finishedWork.stateNode, expirationTime);
-  ensureRootIsScheduled(root$jscomp$0);
+  finishedWork = finishedWork.stateNode;
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
+    try {
+      injectedHook.onCommitFiberRoot(
+        rendererID,
+        finishedWork,
+        void 0,
+        64 === (finishedWork.current.effectTag & 64)
+      );
+    } catch (err) {}
+  ensureRootIsScheduled(root, now());
   if (hasUncaughtError)
     throw ((hasUncaughtError = !1),
-    (root$jscomp$0 = firstUncaughtError),
+    (root = firstUncaughtError),
     (firstUncaughtError = null),
-    root$jscomp$0);
-  if ((executionContext & LegacyUnbatchedContext) !== NoContext) return null;
+    root);
+  if (0 !== (executionContext & 8)) return null;
   flushSyncCallbackQueue();
   return null;
 }
 function commitBeforeMutationEffects() {
   for (; null !== nextEffect; ) {
+    var current = nextEffect.alternate;
+    shouldFireAfterActiveInstanceBlur ||
+      null === focusedInstanceHandle ||
+      (0 !== (nextEffect.effectTag & 8)
+        ? doesFiberContain(nextEffect, focusedInstanceHandle) &&
+          (shouldFireAfterActiveInstanceBlur = !0)
+        : 13 === nextEffect.tag &&
+          isSuspenseBoundaryBeingHidden(current, nextEffect) &&
+          doesFiberContain(nextEffect, focusedInstanceHandle) &&
+          (shouldFireAfterActiveInstanceBlur = !0));
     var effectTag = nextEffect.effectTag;
     0 !== (effectTag & 256) &&
-      commitBeforeMutationLifeCycles(nextEffect.alternate, nextEffect);
+      commitBeforeMutationLifeCycles(current, nextEffect);
     0 === (effectTag & 512) ||
       rootDoesHavePassiveEffects ||
       ((rootDoesHavePassiveEffects = !0),
@@ -6539,47 +6912,84 @@ function flushPassiveEffects() {
         ? 97
         : pendingPassiveEffectsRenderPriority;
     pendingPassiveEffectsRenderPriority = 90;
+    schedulerPriorityToLanePriority(priorityLevel);
     return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
   }
+  return !1;
+}
+function enqueuePendingPassiveHookEffectMount(fiber, effect) {
+  pendingPassiveHookEffectsMount.push(effect, fiber);
+  rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(97, function() {
+      flushPassiveEffects();
+      return null;
+    }));
+}
+function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
+  pendingPassiveHookEffectsUnmount.push(effect, fiber);
+  rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(97, function() {
+      flushPassiveEffects();
+      return null;
+    }));
 }
 function flushPassiveEffectsImpl() {
   if (null === rootWithPendingPassiveEffects) return !1;
   var root = rootWithPendingPassiveEffects;
   rootWithPendingPassiveEffects = null;
-  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+  if (0 !== (executionContext & 48))
     throw Error("Cannot flush passive effects while already rendering.");
   var prevExecutionContext = executionContext;
-  executionContext |= CommitContext;
-  for (root = root.current.firstEffect; null !== root; ) {
+  executionContext |= 32;
+  var unmountEffects = pendingPassiveHookEffectsUnmount;
+  pendingPassiveHookEffectsUnmount = [];
+  for (var i = 0; i < unmountEffects.length; i += 2) {
+    var effect$99 = unmountEffects[i],
+      fiber = unmountEffects[i + 1],
+      destroy = effect$99.destroy;
+    effect$99.destroy = void 0;
+    if ("function" === typeof destroy)
+      try {
+        destroy();
+      } catch (error) {
+        if (null === fiber) throw Error("Should be working on an effect.");
+        captureCommitPhaseError(fiber, error);
+      }
+  }
+  unmountEffects = pendingPassiveHookEffectsMount;
+  pendingPassiveHookEffectsMount = [];
+  for (i = 0; i < unmountEffects.length; i += 2) {
+    effect$99 = unmountEffects[i];
+    fiber = unmountEffects[i + 1];
     try {
-      var finishedWork = root;
-      if (0 !== (finishedWork.effectTag & 512))
-        switch (finishedWork.tag) {
-          case 0:
-          case 11:
-          case 15:
-          case 22:
-            commitHookEffectListUnmount(5, finishedWork),
-              commitHookEffectListMount(5, finishedWork);
-        }
-    } catch (error) {
-      if (null === root) throw Error("Should be working on an effect.");
-      captureCommitPhaseError(root, error);
+      var create$103 = effect$99.create;
+      effect$99.destroy = create$103();
+    } catch (error$104) {
+      if (null === fiber) throw Error("Should be working on an effect.");
+      captureCommitPhaseError(fiber, error$104);
     }
-    finishedWork = root.nextEffect;
-    root.nextEffect = null;
-    root = finishedWork;
   }
+  for (create$103 = root.current.firstEffect; null !== create$103; )
+    (root = create$103.nextEffect),
+      (create$103.nextEffect = null),
+      create$103.effectTag & 8 &&
+        ((create$103.sibling = null), (create$103.stateNode = null)),
+      (create$103 = root);
   executionContext = prevExecutionContext;
   flushSyncCallbackQueue();
   return !0;
 }
 function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
   sourceFiber = createCapturedValue(error, sourceFiber);
-  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 1073741823);
+  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 1);
   enqueueUpdate(rootFiber, sourceFiber);
-  rootFiber = markUpdateTimeFromFiberToRoot(rootFiber, 1073741823);
-  null !== rootFiber && ensureRootIsScheduled(rootFiber);
+  sourceFiber = requestEventTime();
+  rootFiber = markUpdateLaneFromFiberToRoot(rootFiber, 1);
+  null !== rootFiber &&
+    (markRootUpdated(rootFiber, 1, sourceFiber),
+    ensureRootIsScheduled(rootFiber, sourceFiber));
 }
 function captureCommitPhaseError(sourceFiber, error) {
   if (3 === sourceFiber.tag)
@@ -6598,143 +7008,156 @@ function captureCommitPhaseError(sourceFiber, error) {
               !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
         ) {
           sourceFiber = createCapturedValue(error, sourceFiber);
-          sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1073741823);
+          sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1);
           enqueueUpdate(fiber, sourceFiber);
-          fiber = markUpdateTimeFromFiberToRoot(fiber, 1073741823);
-          null !== fiber && ensureRootIsScheduled(fiber);
+          sourceFiber = requestEventTime();
+          fiber = markUpdateLaneFromFiberToRoot(fiber, 1);
+          null !== fiber &&
+            (markRootUpdated(fiber, 1, sourceFiber),
+            ensureRootIsScheduled(fiber, sourceFiber));
           break;
         }
       }
       fiber = fiber.return;
     }
 }
-function pingSuspendedRoot(root, thenable, suspendedTime) {
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
   var pingCache = root.pingCache;
-  null !== pingCache && pingCache.delete(thenable);
-  workInProgressRoot === root && renderExpirationTime$1 === suspendedTime
-    ? workInProgressRootExitStatus === RootSuspendedWithDelay ||
-      (workInProgressRootExitStatus === RootSuspended &&
-        1073741823 === workInProgressRootLatestProcessedExpirationTime &&
-        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
-      ? prepareFreshStack(root, renderExpirationTime$1)
-      : (workInProgressRootHasPendingPing = !0)
-    : isRootSuspendedAtTime(root, suspendedTime) &&
-      ((thenable = root.lastPingedTime),
-      (0 !== thenable && thenable < suspendedTime) ||
-        ((root.lastPingedTime = suspendedTime), ensureRootIsScheduled(root)));
-}
-function resolveRetryThenable(boundaryFiber, thenable) {
+  null !== pingCache && pingCache.delete(wakeable);
+  wakeable = requestEventTime();
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+  workInProgressRoot === root &&
+    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
+    (4 === workInProgressRootExitStatus ||
+    (3 === workInProgressRootExitStatus &&
+      (workInProgressRootRenderLanes & 62914560) ===
+        workInProgressRootRenderLanes &&
+      500 > now() - globalMostRecentFallbackTime)
+      ? prepareFreshStack(root, 0)
+      : (workInProgressRootPingedLanes |= pingedLanes));
+  ensureRootIsScheduled(root, wakeable);
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
   var retryCache = boundaryFiber.stateNode;
-  null !== retryCache && retryCache.delete(thenable);
-  thenable = 0;
-  0 === thenable &&
-    ((thenable = requestCurrentTimeForUpdate()),
-    (thenable = computeExpirationForFiber(thenable, boundaryFiber, null)));
-  boundaryFiber = markUpdateTimeFromFiberToRoot(boundaryFiber, thenable);
-  null !== boundaryFiber && ensureRootIsScheduled(boundaryFiber);
+  null !== retryCache && retryCache.delete(wakeable);
+  wakeable = 0;
+  0 === wakeable &&
+    ((wakeable = boundaryFiber.mode),
+    0 === (wakeable & 2)
+      ? (wakeable = 1)
+      : 0 === (wakeable & 4)
+      ? (wakeable = 99 === getCurrentPriorityLevel() ? 1 : 2)
+      : (0 === currentEventWipLanes &&
+          (currentEventWipLanes = workInProgressRootIncludedLanes),
+        (wakeable = getHighestPriorityLane(62914560 & ~currentEventWipLanes)),
+        0 === wakeable && (wakeable = 4194304)));
+  retryCache = requestEventTime();
+  boundaryFiber = markUpdateLaneFromFiberToRoot(boundaryFiber, wakeable);
+  null !== boundaryFiber &&
+    (markRootUpdated(boundaryFiber, wakeable, retryCache),
+    ensureRootIsScheduled(boundaryFiber, retryCache));
 }
 var beginWork$1;
-beginWork$1 = function(current, workInProgress, renderExpirationTime) {
-  var updateExpirationTime = workInProgress.expirationTime;
+beginWork$1 = function(current, workInProgress, renderLanes) {
+  var updateLanes = workInProgress.lanes;
   if (null !== current)
     if (
       current.memoizedProps !== workInProgress.pendingProps ||
       didPerformWorkStackCursor.current
     )
       didReceiveUpdate = !0;
+    else if (0 !== (renderLanes & updateLanes))
+      didReceiveUpdate = 0 !== (current.effectTag & 16384) ? !0 : !1;
     else {
-      if (updateExpirationTime < renderExpirationTime) {
-        didReceiveUpdate = !1;
-        switch (workInProgress.tag) {
-          case 3:
-            pushHostRootContext(workInProgress);
-            break;
-          case 5:
-            pushHostContext(workInProgress);
-            break;
-          case 1:
-            isContextProvider(workInProgress.type) &&
-              pushContextProvider(workInProgress);
-            break;
-          case 4:
-            pushHostContainer(
+      didReceiveUpdate = !1;
+      switch (workInProgress.tag) {
+        case 3:
+          pushHostRootContext(workInProgress);
+          break;
+        case 5:
+          pushHostContext(workInProgress);
+          break;
+        case 1:
+          isContextProvider(workInProgress.type) &&
+            pushContextProvider(workInProgress);
+          break;
+        case 4:
+          pushHostContainer(
+            workInProgress,
+            workInProgress.stateNode.containerInfo
+          );
+          break;
+        case 10:
+          updateLanes = workInProgress.memoizedProps.value;
+          var context = workInProgress.type._context;
+          push(valueCursor, context._currentValue);
+          context._currentValue = updateLanes;
+          break;
+        case 13:
+          if (null !== workInProgress.memoizedState) {
+            if (0 !== (renderLanes & workInProgress.child.childLanes))
+              return updateSuspenseComponent(
+                current,
+                workInProgress,
+                renderLanes
+              );
+            push(suspenseStackCursor, suspenseStackCursor.current & 1);
+            workInProgress = bailoutOnAlreadyFinishedWork(
+              current,
               workInProgress,
-              workInProgress.stateNode.containerInfo
+              renderLanes
             );
-            break;
-          case 10:
-            updateExpirationTime = workInProgress.memoizedProps.value;
-            var context = workInProgress.type._context;
-            push(valueCursor, context._currentValue);
-            context._currentValue = updateExpirationTime;
-            break;
-          case 13:
-            if (null !== workInProgress.memoizedState) {
-              updateExpirationTime = workInProgress.child.childExpirationTime;
-              if (
-                0 !== updateExpirationTime &&
-                updateExpirationTime >= renderExpirationTime
-              )
-                return updateSuspenseComponent(
-                  current,
-                  workInProgress,
-                  renderExpirationTime
-                );
-              push(suspenseStackCursor, suspenseStackCursor.current & 1);
-              workInProgress = bailoutOnAlreadyFinishedWork(
+            return null !== workInProgress ? workInProgress.sibling : null;
+          }
+          push(suspenseStackCursor, suspenseStackCursor.current & 1);
+          break;
+        case 19:
+          updateLanes = 0 !== (renderLanes & workInProgress.childLanes);
+          if (0 !== (current.effectTag & 64)) {
+            if (updateLanes)
+              return updateSuspenseListComponent(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
-              return null !== workInProgress ? workInProgress.sibling : null;
-            }
-            push(suspenseStackCursor, suspenseStackCursor.current & 1);
-            break;
-          case 19:
-            updateExpirationTime =
-              workInProgress.childExpirationTime >= renderExpirationTime;
-            if (0 !== (current.effectTag & 64)) {
-              if (updateExpirationTime)
-                return updateSuspenseListComponent(
-                  current,
-                  workInProgress,
-                  renderExpirationTime
-                );
-              workInProgress.effectTag |= 64;
-            }
-            context = workInProgress.memoizedState;
-            null !== context &&
-              ((context.rendering = null), (context.tail = null));
-            push(suspenseStackCursor, suspenseStackCursor.current);
-            if (!updateExpirationTime) return null;
-        }
-        return bailoutOnAlreadyFinishedWork(
-          current,
-          workInProgress,
-          renderExpirationTime
-        );
+            workInProgress.effectTag |= 64;
+          }
+          context = workInProgress.memoizedState;
+          null !== context &&
+            ((context.rendering = null),
+            (context.tail = null),
+            (context.lastEffect = null));
+          push(suspenseStackCursor, suspenseStackCursor.current);
+          if (updateLanes) break;
+          else return null;
+        case 23:
+        case 24:
+          return (
+            (workInProgress.lanes = 0),
+            updateOffscreenComponent(current, workInProgress, renderLanes)
+          );
       }
-      didReceiveUpdate = !1;
+      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
     }
   else didReceiveUpdate = !1;
-  workInProgress.expirationTime = 0;
+  workInProgress.lanes = 0;
   switch (workInProgress.tag) {
     case 2:
-      updateExpirationTime = workInProgress.type;
+      updateLanes = workInProgress.type;
       null !== current &&
         ((current.alternate = null),
         (workInProgress.alternate = null),
         (workInProgress.effectTag |= 2));
       current = workInProgress.pendingProps;
       context = getMaskedContext(workInProgress, contextStackCursor.current);
-      prepareToReadContext(workInProgress, renderExpirationTime);
+      prepareToReadContext(workInProgress, renderLanes);
       context = renderWithHooks(
         null,
         workInProgress,
-        updateExpirationTime,
+        updateLanes,
         current,
         context,
-        renderExpirationTime
+        renderLanes
       );
       workInProgress.effectTag |= 1;
       if (
@@ -6746,7 +7169,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
         workInProgress.tag = 1;
         workInProgress.memoizedState = null;
         workInProgress.updateQueue = null;
-        if (isContextProvider(updateExpirationTime)) {
+        if (isContextProvider(updateLanes)) {
           var hasContext = !0;
           pushContextProvider(workInProgress);
         } else hasContext = !1;
@@ -6755,53 +7178,41 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
             ? context.state
             : null;
         initializeUpdateQueue(workInProgress);
-        var getDerivedStateFromProps =
-          updateExpirationTime.getDerivedStateFromProps;
+        var getDerivedStateFromProps = updateLanes.getDerivedStateFromProps;
         "function" === typeof getDerivedStateFromProps &&
           applyDerivedStateFromProps(
             workInProgress,
-            updateExpirationTime,
+            updateLanes,
             getDerivedStateFromProps,
             current
           );
         context.updater = classComponentUpdater;
         workInProgress.stateNode = context;
-        context._reactInternalFiber = workInProgress;
-        mountClassInstance(
-          workInProgress,
-          updateExpirationTime,
-          current,
-          renderExpirationTime
-        );
+        context._reactInternals = workInProgress;
+        mountClassInstance(workInProgress, updateLanes, current, renderLanes);
         workInProgress = finishClassComponent(
           null,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           !0,
           hasContext,
-          renderExpirationTime
+          renderLanes
         );
       } else
         (workInProgress.tag = 0),
-          reconcileChildren(
-            null,
-            workInProgress,
-            context,
-            renderExpirationTime
-          ),
+          reconcileChildren(null, workInProgress, context, renderLanes),
           (workInProgress = workInProgress.child);
       return workInProgress;
     case 16:
+      context = workInProgress.elementType;
       a: {
-        context = workInProgress.elementType;
         null !== current &&
           ((current.alternate = null),
           (workInProgress.alternate = null),
           (workInProgress.effectTag |= 2));
         current = workInProgress.pendingProps;
-        initializeLazyComponentType(context);
-        if (1 !== context._status) throw context._result;
-        context = context._result;
+        hasContext = context._init;
+        context = hasContext(context._payload);
         workInProgress.type = context;
         hasContext = workInProgress.tag = resolveLazyComponentTag(context);
         current = resolveDefaultProps(context, current);
@@ -6812,7 +7223,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress,
               context,
               current,
-              renderExpirationTime
+              renderLanes
             );
             break a;
           case 1:
@@ -6821,7 +7232,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress,
               context,
               current,
-              renderExpirationTime
+              renderLanes
             );
             break a;
           case 11:
@@ -6830,7 +7241,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress,
               context,
               current,
-              renderExpirationTime
+              renderLanes
             );
             break a;
           case 14:
@@ -6839,8 +7250,8 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress,
               context,
               resolveDefaultProps(context.type, current),
-              updateExpirationTime,
-              renderExpirationTime
+              updateLanes,
+              renderLanes
             );
             break a;
         }
@@ -6853,126 +7264,106 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
       return workInProgress;
     case 0:
       return (
-        (updateExpirationTime = workInProgress.type),
+        (updateLanes = workInProgress.type),
         (context = workInProgress.pendingProps),
         (context =
-          workInProgress.elementType === updateExpirationTime
+          workInProgress.elementType === updateLanes
             ? context
-            : resolveDefaultProps(updateExpirationTime, context)),
+            : resolveDefaultProps(updateLanes, context)),
         updateFunctionComponent(
           current,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           context,
-          renderExpirationTime
+          renderLanes
         )
       );
     case 1:
       return (
-        (updateExpirationTime = workInProgress.type),
+        (updateLanes = workInProgress.type),
         (context = workInProgress.pendingProps),
         (context =
-          workInProgress.elementType === updateExpirationTime
+          workInProgress.elementType === updateLanes
             ? context
-            : resolveDefaultProps(updateExpirationTime, context)),
+            : resolveDefaultProps(updateLanes, context)),
         updateClassComponent(
           current,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           context,
-          renderExpirationTime
+          renderLanes
         )
       );
     case 3:
       pushHostRootContext(workInProgress);
-      updateExpirationTime = workInProgress.updateQueue;
-      if (null === current || null === updateExpirationTime)
+      updateLanes = workInProgress.updateQueue;
+      if (null === current || null === updateLanes)
         throw Error(
           "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."
         );
-      updateExpirationTime = workInProgress.pendingProps;
+      updateLanes = workInProgress.pendingProps;
       context = workInProgress.memoizedState;
       context = null !== context ? context.element : null;
       cloneUpdateQueue(current, workInProgress);
-      processUpdateQueue(
-        workInProgress,
-        updateExpirationTime,
-        null,
-        renderExpirationTime
-      );
-      updateExpirationTime = workInProgress.memoizedState.element;
-      updateExpirationTime === context
+      processUpdateQueue(workInProgress, updateLanes, null, renderLanes);
+      updateLanes = workInProgress.memoizedState.element;
+      updateLanes === context
         ? (workInProgress = bailoutOnAlreadyFinishedWork(
             current,
             workInProgress,
-            renderExpirationTime
+            renderLanes
           ))
-        : (reconcileChildren(
-            current,
-            workInProgress,
-            updateExpirationTime,
-            renderExpirationTime
-          ),
+        : (reconcileChildren(current, workInProgress, updateLanes, renderLanes),
           (workInProgress = workInProgress.child));
       return workInProgress;
     case 5:
       return (
         pushHostContext(workInProgress),
-        (updateExpirationTime = workInProgress.pendingProps.children),
+        (updateLanes = workInProgress.pendingProps.children),
         markRef(current, workInProgress),
-        reconcileChildren(
-          current,
-          workInProgress,
-          updateExpirationTime,
-          renderExpirationTime
-        ),
-        (workInProgress = workInProgress.child),
-        workInProgress
+        reconcileChildren(current, workInProgress, updateLanes, renderLanes),
+        workInProgress.child
       );
     case 6:
       return null;
     case 13:
-      return updateSuspenseComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
     case 4:
       return (
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         ),
-        (updateExpirationTime = workInProgress.pendingProps),
+        (updateLanes = workInProgress.pendingProps),
         null === current
           ? (workInProgress.child = reconcileChildFibers(
               workInProgress,
               null,
-              updateExpirationTime,
-              renderExpirationTime
+              updateLanes,
+              renderLanes
             ))
           : reconcileChildren(
               current,
               workInProgress,
-              updateExpirationTime,
-              renderExpirationTime
+              updateLanes,
+              renderLanes
             ),
         workInProgress.child
       );
     case 11:
       return (
-        (updateExpirationTime = workInProgress.type),
+        (updateLanes = workInProgress.type),
         (context = workInProgress.pendingProps),
         (context =
-          workInProgress.elementType === updateExpirationTime
+          workInProgress.elementType === updateLanes
             ? context
-            : resolveDefaultProps(updateExpirationTime, context)),
+            : resolveDefaultProps(updateLanes, context)),
         updateForwardRef(
           current,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           context,
-          renderExpirationTime
+          renderLanes
         )
       );
     case 7:
@@ -6981,7 +7372,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           current,
           workInProgress,
           workInProgress.pendingProps,
-          renderExpirationTime
+          renderLanes
         ),
         workInProgress.child
       );
@@ -6991,7 +7382,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           current,
           workInProgress,
           workInProgress.pendingProps.children,
-          renderExpirationTime
+          renderLanes
         ),
         workInProgress.child
       );
@@ -7001,13 +7392,13 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           current,
           workInProgress,
           workInProgress.pendingProps.children,
-          renderExpirationTime
+          renderLanes
         ),
         workInProgress.child
       );
     case 10:
       a: {
-        updateExpirationTime = workInProgress.type._context;
+        updateLanes = workInProgress.type._context;
         context = workInProgress.pendingProps;
         getDerivedStateFromProps = workInProgress.memoizedProps;
         hasContext = context.value;
@@ -7019,9 +7410,8 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
             ((context$jscomp$0 = getDerivedStateFromProps.value),
             (hasContext = objectIs(context$jscomp$0, hasContext)
               ? 0
-              : ("function" ===
-                typeof updateExpirationTime._calculateChangedBits
-                  ? updateExpirationTime._calculateChangedBits(
+              : ("function" === typeof updateLanes._calculateChangedBits
+                  ? updateLanes._calculateChangedBits(
                       context$jscomp$0,
                       hasContext
                     )
@@ -7035,7 +7425,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
               workInProgress = bailoutOnAlreadyFinishedWork(
                 current,
                 workInProgress,
-                renderExpirationTime
+                renderLanes
               );
               break a;
             }
@@ -7056,25 +7446,25 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
 
                 ) {
                   if (
-                    dependency.context === updateExpirationTime &&
+                    dependency.context === updateLanes &&
                     0 !== (dependency.observedBits & hasContext)
                   ) {
                     1 === context$jscomp$0.tag &&
-                      ((dependency = createUpdate(renderExpirationTime, null)),
+                      ((dependency = createUpdate(
+                        -1,
+                        renderLanes & -renderLanes,
+                        null
+                      )),
                       (dependency.tag = 2),
                       enqueueUpdate(context$jscomp$0, dependency));
-                    context$jscomp$0.expirationTime < renderExpirationTime &&
-                      (context$jscomp$0.expirationTime = renderExpirationTime);
+                    context$jscomp$0.lanes |= renderLanes;
                     dependency = context$jscomp$0.alternate;
-                    null !== dependency &&
-                      dependency.expirationTime < renderExpirationTime &&
-                      (dependency.expirationTime = renderExpirationTime);
+                    null !== dependency && (dependency.lanes |= renderLanes);
                     scheduleWorkOnParentPath(
                       context$jscomp$0.return,
-                      renderExpirationTime
+                      renderLanes
                     );
-                    list.expirationTime < renderExpirationTime &&
-                      (list.expirationTime = renderExpirationTime);
+                    list.lanes |= renderLanes;
                     break;
                   }
                   dependency = dependency.next;
@@ -7112,7 +7502,7 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           current,
           workInProgress,
           context.children,
-          renderExpirationTime
+          renderLanes
         );
         workInProgress = workInProgress.child;
       }
@@ -7121,17 +7511,12 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
       return (
         (context = workInProgress.type),
         (hasContext = workInProgress.pendingProps),
-        (updateExpirationTime = hasContext.children),
-        prepareToReadContext(workInProgress, renderExpirationTime),
+        (updateLanes = hasContext.children),
+        prepareToReadContext(workInProgress, renderLanes),
         (context = readContext(context, hasContext.unstable_observedBits)),
-        (updateExpirationTime = updateExpirationTime(context)),
+        (updateLanes = updateLanes(context)),
         (workInProgress.effectTag |= 1),
-        reconcileChildren(
-          current,
-          workInProgress,
-          updateExpirationTime,
-          renderExpirationTime
-        ),
+        reconcileChildren(current, workInProgress, updateLanes, renderLanes),
         workInProgress.child
       );
     case 14:
@@ -7147,8 +7532,8 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
           workInProgress,
           context,
           hasContext,
-          updateExpirationTime,
-          renderExpirationTime
+          updateLanes,
+          renderLanes
         )
       );
     case 15:
@@ -7157,48 +7542,43 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
         workInProgress,
         workInProgress.type,
         workInProgress.pendingProps,
-        updateExpirationTime,
-        renderExpirationTime
+        updateLanes,
+        renderLanes
       );
     case 17:
       return (
-        (updateExpirationTime = workInProgress.type),
+        (updateLanes = workInProgress.type),
         (context = workInProgress.pendingProps),
         (context =
-          workInProgress.elementType === updateExpirationTime
+          workInProgress.elementType === updateLanes
             ? context
-            : resolveDefaultProps(updateExpirationTime, context)),
+            : resolveDefaultProps(updateLanes, context)),
         null !== current &&
           ((current.alternate = null),
           (workInProgress.alternate = null),
           (workInProgress.effectTag |= 2)),
         (workInProgress.tag = 1),
-        isContextProvider(updateExpirationTime)
+        isContextProvider(updateLanes)
           ? ((current = !0), pushContextProvider(workInProgress))
           : (current = !1),
-        prepareToReadContext(workInProgress, renderExpirationTime),
-        constructClassInstance(workInProgress, updateExpirationTime, context),
-        mountClassInstance(
-          workInProgress,
-          updateExpirationTime,
-          context,
-          renderExpirationTime
-        ),
+        prepareToReadContext(workInProgress, renderLanes),
+        constructClassInstance(workInProgress, updateLanes, context),
+        mountClassInstance(workInProgress, updateLanes, context, renderLanes),
         finishClassComponent(
           null,
           workInProgress,
-          updateExpirationTime,
+          updateLanes,
           !0,
           current,
-          renderExpirationTime
+          renderLanes
         )
       );
     case 19:
-      return updateSuspenseListComponent(
-        current,
-        workInProgress,
-        renderExpirationTime
-      );
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+    case 23:
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
+    case 24:
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
   }
   throw Error(
     "Unknown unit of work tag (" +
@@ -7206,32 +7586,6 @@ beginWork$1 = function(current, workInProgress, renderExpirationTime) {
       "). This error is likely caused by a bug in React. Please file an issue."
   );
 };
-var onCommitFiberRoot = null,
-  onCommitFiberUnmount = null;
-function injectInternals(internals) {
-  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
-  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
-  if (hook.isDisabled || !hook.supportsFiber) return !0;
-  try {
-    var rendererID = hook.inject(internals);
-    onCommitFiberRoot = function(root) {
-      try {
-        hook.onCommitFiberRoot(
-          rendererID,
-          root,
-          void 0,
-          64 === (root.current.effectTag & 64)
-        );
-      } catch (err) {}
-    };
-    onCommitFiberUnmount = function(fiber) {
-      try {
-        hook.onCommitFiberUnmount(rendererID, fiber);
-      } catch (err) {}
-    };
-  } catch (err) {}
-  return !0;
-}
 function FiberNode(tag, pendingProps, key, mode) {
   this.tag = tag;
   this.key = key;
@@ -7243,9 +7597,12 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.mode = mode;
   this.effectTag = 0;
   this.lastEffect = this.firstEffect = this.nextEffect = null;
-  this.childExpirationTime = this.expirationTime = 0;
+  this.childLanes = this.lanes = 0;
   this.alternate = null;
 }
+function createFiber(tag, pendingProps, key, mode) {
+  return new FiberNode(tag, pendingProps, key, mode);
+}
 function shouldConstruct(Component) {
   Component = Component.prototype;
   return !(!Component || !Component.isReactComponent);
@@ -7263,7 +7620,7 @@ function resolveLazyComponentTag(Component) {
 function createWorkInProgress(current, pendingProps) {
   var workInProgress = current.alternate;
   null === workInProgress
-    ? ((workInProgress = new FiberNode(
+    ? ((workInProgress = createFiber(
         current.tag,
         pendingProps,
         current.key,
@@ -7275,12 +7632,13 @@ function createWorkInProgress(current, pendingProps) {
       (workInProgress.alternate = current),
       (current.alternate = workInProgress))
     : ((workInProgress.pendingProps = pendingProps),
+      (workInProgress.type = current.type),
       (workInProgress.effectTag = 0),
       (workInProgress.nextEffect = null),
       (workInProgress.firstEffect = null),
       (workInProgress.lastEffect = null));
-  workInProgress.childExpirationTime = current.childExpirationTime;
-  workInProgress.expirationTime = current.expirationTime;
+  workInProgress.childLanes = current.childLanes;
+  workInProgress.lanes = current.lanes;
   workInProgress.child = current.child;
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
@@ -7289,11 +7647,7 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.dependencies =
     null === pendingProps
       ? null
-      : {
-          expirationTime: pendingProps.expirationTime,
-          firstContext: pendingProps.firstContext,
-          responders: pendingProps.responders
-        };
+      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
   workInProgress.sibling = current.sibling;
   workInProgress.index = current.index;
   workInProgress.ref = current.ref;
@@ -7305,7 +7659,7 @@ function createFiberFromTypeAndProps(
   pendingProps,
   owner,
   mode,
-  expirationTime
+  lanes
 ) {
   var fiberTag = 2;
   owner = type;
@@ -7314,15 +7668,10 @@ function createFiberFromTypeAndProps(
   else
     a: switch (type) {
       case REACT_FRAGMENT_TYPE:
-        return createFiberFromFragment(
-          pendingProps.children,
-          mode,
-          expirationTime,
-          key
-        );
-      case REACT_CONCURRENT_MODE_TYPE:
+        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
+      case REACT_DEBUG_TRACING_MODE_TYPE:
         fiberTag = 8;
-        mode |= 7;
+        mode |= 16;
         break;
       case REACT_STRICT_MODE_TYPE:
         fiberTag = 8;
@@ -7330,25 +7679,34 @@ function createFiberFromTypeAndProps(
         break;
       case REACT_PROFILER_TYPE:
         return (
-          (type = new FiberNode(12, pendingProps, key, mode | 8)),
+          (type = createFiber(12, pendingProps, key, mode | 8)),
           (type.elementType = REACT_PROFILER_TYPE),
           (type.type = REACT_PROFILER_TYPE),
-          (type.expirationTime = expirationTime),
+          (type.lanes = lanes),
           type
         );
       case REACT_SUSPENSE_TYPE:
         return (
-          (type = new FiberNode(13, pendingProps, key, mode)),
+          (type = createFiber(13, pendingProps, key, mode)),
           (type.type = REACT_SUSPENSE_TYPE),
           (type.elementType = REACT_SUSPENSE_TYPE),
-          (type.expirationTime = expirationTime),
+          (type.lanes = lanes),
           type
         );
       case REACT_SUSPENSE_LIST_TYPE:
         return (
-          (type = new FiberNode(19, pendingProps, key, mode)),
+          (type = createFiber(19, pendingProps, key, mode)),
           (type.elementType = REACT_SUSPENSE_LIST_TYPE),
-          (type.expirationTime = expirationTime),
+          (type.lanes = lanes),
+          type
+        );
+      case REACT_OFFSCREEN_TYPE:
+        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+      case REACT_LEGACY_HIDDEN_TYPE:
+        return (
+          (type = createFiber(24, pendingProps, key, mode)),
+          (type.elementType = REACT_LEGACY_HIDDEN_TYPE),
+          (type.lanes = lanes),
           type
         );
       default:
@@ -7380,30 +7738,36 @@ function createFiberFromTypeAndProps(
             "."
         );
     }
-  key = new FiberNode(fiberTag, pendingProps, key, mode);
+  key = createFiber(fiberTag, pendingProps, key, mode);
   key.elementType = type;
   key.type = owner;
-  key.expirationTime = expirationTime;
+  key.lanes = lanes;
   return key;
 }
-function createFiberFromFragment(elements, mode, expirationTime, key) {
-  elements = new FiberNode(7, elements, key, mode);
-  elements.expirationTime = expirationTime;
+function createFiberFromFragment(elements, mode, lanes, key) {
+  elements = createFiber(7, elements, key, mode);
+  elements.lanes = lanes;
   return elements;
 }
-function createFiberFromText(content, mode, expirationTime) {
-  content = new FiberNode(6, content, null, mode);
-  content.expirationTime = expirationTime;
+function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
+  pendingProps = createFiber(23, pendingProps, key, mode);
+  pendingProps.elementType = REACT_OFFSCREEN_TYPE;
+  pendingProps.lanes = lanes;
+  return pendingProps;
+}
+function createFiberFromText(content, mode, lanes) {
+  content = createFiber(6, content, null, mode);
+  content.lanes = lanes;
   return content;
 }
-function createFiberFromPortal(portal, mode, expirationTime) {
-  mode = new FiberNode(
+function createFiberFromPortal(portal, mode, lanes) {
+  mode = createFiber(
     4,
     null !== portal.children ? portal.children : [],
     portal.key,
     mode
   );
-  mode.expirationTime = expirationTime;
+  mode.lanes = lanes;
   mode.stateNode = {
     containerInfo: portal.containerInfo,
     pendingChildren: null,
@@ -7413,51 +7777,31 @@ function createFiberFromPortal(portal, mode, expirationTime) {
 }
 function FiberRootNode(containerInfo, tag, hydrate) {
   this.tag = tag;
-  this.current = null;
   this.containerInfo = containerInfo;
-  this.pingCache = this.pendingChildren = null;
-  this.finishedExpirationTime = 0;
-  this.finishedWork = null;
+  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
   this.timeoutHandle = -1;
   this.pendingContext = this.context = null;
   this.hydrate = hydrate;
   this.callbackNode = null;
-  this.callbackPriority = 90;
-  this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
-}
-function isRootSuspendedAtTime(root, expirationTime) {
-  var firstSuspendedTime = root.firstSuspendedTime;
-  root = root.lastSuspendedTime;
-  return (
-    0 !== firstSuspendedTime &&
-    firstSuspendedTime >= expirationTime &&
-    root <= expirationTime
-  );
+  this.callbackPriority = 0;
+  this.eventTimes = Array(31).fill(0);
+  this.expirationTimes = Array(31).fill(-1);
+  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
+  this.entanglements = Array(31).fill(0);
 }
-function markRootSuspendedAtTime(root, expirationTime) {
-  var firstSuspendedTime = root.firstSuspendedTime,
-    lastSuspendedTime = root.lastSuspendedTime;
-  firstSuspendedTime < expirationTime &&
-    (root.firstSuspendedTime = expirationTime);
-  if (lastSuspendedTime > expirationTime || 0 === firstSuspendedTime)
-    root.lastSuspendedTime = expirationTime;
-  expirationTime <= root.lastPingedTime && (root.lastPingedTime = 0);
-  expirationTime <= root.lastExpiredTime && (root.lastExpiredTime = 0);
-}
-function markRootUpdatedAtTime(root, expirationTime) {
-  expirationTime > root.firstPendingTime &&
-    (root.firstPendingTime = expirationTime);
-  var firstSuspendedTime = root.firstSuspendedTime;
-  0 !== firstSuspendedTime &&
-    (expirationTime >= firstSuspendedTime
-      ? (root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = 0)
-      : expirationTime >= root.lastSuspendedTime &&
-        (root.lastSuspendedTime = expirationTime + 1),
-    expirationTime > root.nextKnownPendingLevel &&
-      (root.nextKnownPendingLevel = expirationTime));
+function createPortal(children, containerInfo, implementation) {
+  var key =
+    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
+  return {
+    $$typeof: REACT_PORTAL_TYPE,
+    key: null == key ? null : "" + key,
+    children: children,
+    containerInfo: containerInfo,
+    implementation: implementation
+  };
 }
 function findHostInstance(component) {
-  var fiber = component._reactInternalFiber;
+  var fiber = component._reactInternals;
   if (void 0 === fiber) {
     if ("function" === typeof component.render)
       throw Error("Unable to find node on an unmounted component.");
@@ -7471,11 +7815,11 @@ function findHostInstance(component) {
 }
 function updateContainer(element, container, parentComponent, callback) {
   var current = container.current,
-    currentTime = requestCurrentTimeForUpdate(),
-    suspenseConfig = ReactCurrentBatchConfig.suspense;
-  currentTime = computeExpirationForFiber(currentTime, current, suspenseConfig);
+    eventTime = requestEventTime(),
+    suspenseConfig = ReactCurrentBatchConfig.suspense,
+    lane = requestUpdateLane(current, suspenseConfig);
   a: if (parentComponent) {
-    parentComponent = parentComponent._reactInternalFiber;
+    parentComponent = parentComponent._reactInternals;
     b: {
       if (
         getNearestMountedFiber(parentComponent) !== parentComponent ||
@@ -7484,22 +7828,23 @@ function updateContainer(element, container, parentComponent, callback) {
         throw Error(
           "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
         );
-      var parentContext = parentComponent;
+      var JSCompiler_inline_result = parentComponent;
       do {
-        switch (parentContext.tag) {
+        switch (JSCompiler_inline_result.tag) {
           case 3:
-            parentContext = parentContext.stateNode.context;
+            JSCompiler_inline_result =
+              JSCompiler_inline_result.stateNode.context;
             break b;
           case 1:
-            if (isContextProvider(parentContext.type)) {
-              parentContext =
-                parentContext.stateNode
+            if (isContextProvider(JSCompiler_inline_result.type)) {
+              JSCompiler_inline_result =
+                JSCompiler_inline_result.stateNode
                   .__reactInternalMemoizedMergedChildContext;
               break b;
             }
         }
-        parentContext = parentContext.return;
-      } while (null !== parentContext);
+        JSCompiler_inline_result = JSCompiler_inline_result.return;
+      } while (null !== JSCompiler_inline_result);
       throw Error(
         "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
       );
@@ -7510,34 +7855,26 @@ function updateContainer(element, container, parentComponent, callback) {
         parentComponent = processChildContext(
           parentComponent,
           Component,
-          parentContext
+          JSCompiler_inline_result
         );
         break a;
       }
     }
-    parentComponent = parentContext;
+    parentComponent = JSCompiler_inline_result;
   } else parentComponent = emptyContextObject;
   null === container.context
     ? (container.context = parentComponent)
     : (container.pendingContext = parentComponent);
-  container = createUpdate(currentTime, suspenseConfig);
+  container = createUpdate(eventTime, lane, suspenseConfig);
   container.payload = { element: element };
   callback = void 0 === callback ? null : callback;
   null !== callback && (container.callback = callback);
   enqueueUpdate(current, container);
-  scheduleWork(current, currentTime);
-  return currentTime;
+  scheduleUpdateOnFiber(current, lane, eventTime);
+  return lane;
 }
-function createPortal(children, containerInfo, implementation) {
-  var key =
-    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
-  return {
-    $$typeof: REACT_PORTAL_TYPE,
-    key: null == key ? null : "" + key,
-    children: children,
-    containerInfo: containerInfo,
-    implementation: implementation
-  };
+function emptyFindFiberByHostInstance() {
+  return null;
 }
 function findNodeHandle(componentOrHandle) {
   if (null == componentOrHandle) return null;
@@ -7566,53 +7903,64 @@ batchedUpdatesImpl = function(fn, a) {
     return fn(a);
   } finally {
     (executionContext = prevExecutionContext),
-      executionContext === NoContext && flushSyncCallbackQueue();
+      0 === executionContext && flushSyncCallbackQueue();
   }
 };
-var roots = new Map();
-(function(devToolsConfig) {
-  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
-  return injectInternals({
-    bundleType: devToolsConfig.bundleType,
-    version: devToolsConfig.version,
-    rendererPackageName: devToolsConfig.rendererPackageName,
-    rendererConfig: devToolsConfig.rendererConfig,
-    overrideHookState: null,
-    overrideProps: null,
-    setSuspenseHandler: null,
-    scheduleUpdate: null,
-    currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
-    findHostInstanceByFiber: function(fiber) {
-      fiber = findCurrentHostFiber(fiber);
-      return null === fiber ? null : fiber.stateNode;
-    },
-    findFiberByHostInstance: function(instance) {
-      return findFiberByHostInstance ? findFiberByHostInstance(instance) : null;
-    },
-    findHostInstancesForRefresh: null,
-    scheduleRefresh: null,
-    scheduleRoot: null,
-    setRefreshHandler: null,
-    getCurrentFiber: null
-  });
-})({
-  findFiberByHostInstance: getInstanceFromTag,
-  bundleType: 0,
-  version: "16.13.0",
-  rendererPackageName: "react-native-renderer",
-  rendererConfig: {
-    getInspectorDataForViewTag: function() {
-      throw Error(
-        "getInspectorDataForViewTag() is not available in production"
-      );
-    },
-    getInspectorDataForViewAtPoint: function() {
-      throw Error(
-        "getInspectorDataForViewAtPoint() is not available in production."
-      );
-    }.bind(null, findNodeHandle)
-  }
-});
+var roots = new Map(),
+  devToolsConfig$jscomp$inline_934 = {
+    findFiberByHostInstance: getInstanceFromTag,
+    bundleType: 0,
+    version: "17.0.0-alpha.0",
+    rendererPackageName: "react-native-renderer",
+    rendererConfig: {
+      getInspectorDataForViewTag: function() {
+        throw Error(
+          "getInspectorDataForViewTag() is not available in production"
+        );
+      },
+      getInspectorDataForViewAtPoint: function() {
+        throw Error(
+          "getInspectorDataForViewAtPoint() is not available in production."
+        );
+      }.bind(null, findNodeHandle)
+    }
+  };
+var internals$jscomp$inline_1135 = {
+  bundleType: devToolsConfig$jscomp$inline_934.bundleType,
+  version: devToolsConfig$jscomp$inline_934.version,
+  rendererPackageName: devToolsConfig$jscomp$inline_934.rendererPackageName,
+  rendererConfig: devToolsConfig$jscomp$inline_934.rendererConfig,
+  overrideHookState: null,
+  overrideProps: null,
+  setSuspenseHandler: null,
+  scheduleUpdate: null,
+  currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
+  findHostInstanceByFiber: function(fiber) {
+    fiber = findCurrentHostFiber(fiber);
+    return null === fiber ? null : fiber.stateNode;
+  },
+  findFiberByHostInstance:
+    devToolsConfig$jscomp$inline_934.findFiberByHostInstance ||
+    emptyFindFiberByHostInstance,
+  findHostInstancesForRefresh: null,
+  scheduleRefresh: null,
+  scheduleRoot: null,
+  setRefreshHandler: null,
+  getCurrentFiber: null
+};
+if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
+  var hook$jscomp$inline_1136 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  if (
+    !hook$jscomp$inline_1136.isDisabled &&
+    hook$jscomp$inline_1136.supportsFiber
+  )
+    try {
+      (rendererID = hook$jscomp$inline_1136.inject(
+        internals$jscomp$inline_1135
+      )),
+        (injectedHook = hook$jscomp$inline_1136);
+    } catch (err) {}
+}
 exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {
   computeComponentStackForErrorReporting: function(reactTag) {
     return (reactTag = getInstanceFromTag(reactTag))
@@ -7659,7 +8007,7 @@ exports.render = function(element, containerTag, callback) {
   var root = roots.get(containerTag);
   if (!root) {
     root = new FiberRootNode(containerTag, 0, !1);
-    var uninitializedFiber = new FiberNode(3, null, null, 0);
+    var uninitializedFiber = createFiber(3, null, null, 0);
     root.current = uninitializedFiber;
     uninitializedFiber.stateNode = root;
     initializeUpdateQueue(uninitializedFiber);
diff --git a/node_modules/react-native/scripts/.packager.env b/node_modules/react-native/scripts/.packager.env
new file mode 100644
index 0000000..361f5fb
--- /dev/null
+++ b/node_modules/react-native/scripts/.packager.env
@@ -0,0 +1 @@
+export RCT_METRO_PORT=8081
